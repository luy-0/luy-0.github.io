<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>(ﾟ∀。)</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-08T08:14:52.196Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LUY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java拾遗之基本类库</title>
    <link href="http://yoursite.com/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%BA%93/"/>
    <id>http://yoursite.com/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%BA%93/</id>
    <published>2020-10-08T08:14:15.000Z</published>
    <updated>2020-10-08T08:14:52.196Z</updated>
    
    <content type="html"><![CDATA[<p>第七章 Java基础类库<br>本节应当配备Java Document使用.<br>在线网址: <a href="https://docs.oracle.com/en/java/javase/index.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/index.html</a><br>下载地址: <a href="https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline" target="_blank" rel="noopener">https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline</a></p><ul><li>系统类System</li><li>字符串: String, StringBuffer, StringBuilder</li><li>Math类</li><li>Data与Calendar</li><li>正则表达式</li><li>日志</li></ul><a id="more"></a><h2 id="7-1-与用户交互"><a href="#7-1-与用户交互" class="headerlink" title="7.1 与用户交互"></a>7.1 与用户交互</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><ul><li>main函数的方法签名: <code>public static void main(String[] args){...}</code></li><li>main函数需要暴露给JVM调用,因此使用public修饰;</li><li>main函数在调用时直接通过主类静态调用,因此使用static修饰;</li><li>main函数没有返回值</li><li>main函数的参数可以在运行时指定.例如 <code>java ArgsTest hello world</code> 这里args数组为{“hello”,”world”}</li></ul><h3 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h3><ul><li>Scanner是一种基于正则表达式的文本扫描器. </li><li>hasNextXXX();</li><li>nextXXX();</li></ul><h2 id="7-2-系统交互"><a href="#7-2-系统交互" class="headerlink" title="7.2 系统交互"></a>7.2 系统交互</h2><ul><li>通过C语言实现Java的native方法: <a href="https://blog.csdn.net/hjh_walker/article/details/52439149" target="_blank" rel="noopener">https://blog.csdn.net/hjh_walker/article/details/52439149</a></li><li>可以通过System类访问操作系统的信息</li><li>可以通过Runtime类访问运行环境(JVM)的相关信息.</li><li>还可以通过Runtime类的静态方法exec()新建进程运行操作系统的命令.</li></ul><h2 id="7-3-常用类"><a href="#7-3-常用类" class="headerlink" title="7.3 常用类"></a>7.3 常用类</h2><ul><li>Object类是所有类,数组,枚举类的父类.Object提供了一些静态方法.(所有类都可以使用)</li><li>equals(Object obj); 判断对象是否相等. 这里判断是否是同一个对象(也就是针对地址的判断)</li><li>protected void finalize(); 垃圾回收器调用该方法来回收对象</li><li>getClass(); 返回对象的运行时类</li><li>int hashCode();默认情况下是根据对象的地址计算.但大多数类都重写了该方法.</li><li>toString();默认情况下返回 “类名+@+hashCode” 的值,往往需要对其重写.</li><li>protected clone();会返回一个当前对象的副本.这个方法只能被子类重写或调用.这种克隆更快,但是是浅克隆.</li><li><p>浅克隆:引用类型变量只复制地址; 深克隆:引用类型变量指向的对象也会被复制 参考:<a href="https://segmentfault.com/a/1190000022552883" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022552883</a></p></li><li><p>Java7 新增了一系列工具类.它们大多是空指针安全的.</p></li><li>这些工具类大多以”s”结尾.例如 <code>Objects</code>,<code>Arrays</code></li></ul><h2 id="7-4-字符串操作"><a href="#7-4-字符串操作" class="headerlink" title="7.4 字符串操作"></a>7.4 字符串操作</h2><ul><li>Java中的String是不可变的,直到对象被销毁.</li><li>StringBuffer 是一个字符序列可变的字符串.在操作完该字符序列后使用toSting()将其转换为String对象</li><li>StringBuilder 也代表可变字符串对象. 但Buffer是线程安全的,而Builder是非安全的. 因此Builder的性能更高.</li><li>charAt(); 用于读取字符串的下标.string 的其他方法不列出</li><li>StringBuilder 的常用方法: append(),insert(),delete(),reverse(),length(),capacity()</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第七章 Java基础类库&lt;br&gt;本节应当配备Java Document使用.&lt;br&gt;在线网址: &lt;a href=&quot;https://docs.oracle.com/en/java/javase/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.oracle.com/en/java/javase/index.html&lt;/a&gt;&lt;br&gt;下载地址: &lt;a href=&quot;https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统类System&lt;/li&gt;
&lt;li&gt;字符串: String, StringBuffer, StringBuilder&lt;/li&gt;
&lt;li&gt;Math类&lt;/li&gt;
&lt;li&gt;Data与Calendar&lt;/li&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;li&gt;日志&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/"/>
    
      <category term="Java拾遗" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/Java%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java拾遗之面向对象</title>
    <link href="http://yoursite.com/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-10-08T06:51:34.516Z</published>
    <updated>2020-10-08T07:00:20.145Z</updated>
    
    <content type="html"><![CDATA[<p>又开的新坑~ 目标是把平日里关于Java的学习到的碎片化知识先记录下来, 待日后回顾.</p><p>希望以后会回顾(逃)</p><p>目前在学习的是李刚老师的 <a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂JAVA讲义 (第四版)</a> </p><a id="more"></a><h2 id="第六章：面向对象（下）"><a href="#第六章：面向对象（下）" class="headerlink" title="第六章：面向对象（下）"></a>第六章：面向对象（下）</h2><ul><li>包装类：将基本类型封装成对象使用</li><li>final关键词</li><li>abstract：抽象类</li><li>interface：接口</li></ul><h3 id="6-1-包装类"><a href="#6-1-包装类" class="headerlink" title="6.1 包装类"></a>6.1 包装类</h3><ul><li>自动装箱/拆箱：基本类型与包装类型的直接转换</li><li>包装类的两类静态方法，用于操作string与类型的装换</li></ul><blockquote><p>parseXXX(string str);    将string类型转为XXX类型.例如<code>int a = parseInt(&quot;123&quot;);</code><br>valueOf(string str); 作用同上</p></blockquote><ul><li>String 包装类中也有将其他类型的转为string类的valueOf函数.例如<code>string a = String.valueOf(123.4);</code></li><li>或者可以直接 <code>string a = 123.4 + &quot;&quot; ;</code></li></ul><hr><ul><li>包装类是引用类型,但是直接与基本类型比较时会自动比较其值;但是两个包装类比较时依旧比较引用的对象是否是一个</li><li>不应当对两个装箱后的包装类比较.Integer包装类在初始化时会初始化-128~127的数组.所有被包装的,值在这个范围内的Integer对象指向的是堆中的同一个.但是不在这个范围内的对象指向的不是用一个对象.因此:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D; 2;</span><br><span class="line">Integer b &#x3D; 2;</span><br><span class="line">&#x2F;*这里a&#x3D;&#x3D;b,因为作为引用类型的变量,他们指向堆中的同一个地址(即Integer类被初始化时创建的那个数组)*&#x2F;</span><br><span class="line">Integer A &#x3D; 128;</span><br><span class="line">Integer B &#x3D; 128;</span><br><span class="line">&#x2F;*这里A!&#x3D;B,因为这是新创建的两个不同指向的引用类型的变量,尽管他们指向的地址所储存的值是一样的*&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>这么设置的原因是为了提前针对小值的Integer包装类对象进行缓存,提高性能</p></li><li><p>Java7 对所有的包装类提供了专门用于比较的静态方法compare.例如:<code>Integer.compare()</code>    //TODO:存疑:这个方法是用来比较基本类还是包装类的?还是说可以混合比较?</p></li><li>Java7对Character,Java8对包装类功能增强.</li></ul><hr><h3 id="6-2处理Object"><a href="#6-2处理Object" class="headerlink" title="6.2处理Object"></a>6.2处理Object</h3><ul><li><p>所有类都是Object类的子类</p></li><li><p>Object类中有toString()方法.他会在对象被打印时自动调用.用于自我描述,例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object p;</span><br><span class="line">&#x2F;*以下3行是等价的*&#x2F;</span><br><span class="line">System.out.println(p);</span><br><span class="line">System.out.println(p.toString());</span><br><span class="line">System.out.println(p + &quot;&quot;);</span><br></pre></td></tr></table></figure></li><li><p>基础的toString() 会返回 “类名+@+hashCode” 的值,可以并往往需要对其重写.通常会返回成类似”Apple[color=red,weight=5.6]”的字符串</p></li></ul><hr><ul><li><p>对于基本类型可以使用==进行相等判断,但是引用类型变量必须要指向相同地址时才会返回true.因此Object类提供了静态方法Object.equal(Object obj)</p></li><li><p>默认的equal方法依旧只比较该变量的地址(也就是和==一个效果),因此我们往往也会重写equal方法.该方法需要满足:自反性,对称性,传递性,一致性</p></li><li><p>JVM常量池保证相同的字符串直接量只有一个.</p></li></ul><h3 id="6-3-类成员与static"><a href="#6-3-类成员与static" class="headerlink" title="6.3 类成员与static"></a>6.3 类成员与static</h3><ul><li><p>类成员属于整个类,而非某个对象.被static修饰的就是类成员.</p></li><li><p>当类第一次被使用时,类成员(包括类变量与类方法)被加载,直到类不被使用而被垃圾回收.</p></li><li><p>可以通过类或类的实例对象来访问类成员,但这不代表类成员属于该实例对象.</p></li><li><p>静态初始化块也是类成员的一种, 一般是在类被初始化时执行该块.</p></li><li><p>类成员不能访问实例成员</p></li></ul><hr><ul><li>如果某种类仅允许拥有一个实例,它被称为单例(Singleton)</li><li>该类的构造器被修饰为private</li><li>该类需要提供一个静态方法来产生第一个实例(并且,如果以前产生过实例则返回先前产生的实例)</li><li>需要一个private static 的类变量储存曾经创建的实例(如果有)</li></ul><hr><h3 id="6-4-final"><a href="#6-4-final" class="headerlink" title="6.4 final"></a>6.4 final</h3><ul><li>被final修饰的变量不可被重新赋值.</li><li>final可以修饰成员变量(包括类变量与实例变量),也可以修饰局部变量.这两者有些许不同.</li></ul><h4 id="final修饰成员变量"><a href="#final修饰成员变量" class="headerlink" title="final修饰成员变量"></a>final修饰成员变量</h4><ul><li><p>final修饰类变量: 必需在静态初始化块,或声明类变量时指定初始值.且只能在二处之一指定初始值.</p></li><li><p>final修饰实例变量: 必需在非静态初始化块,或声明实例变量时, 或构造器中指定初始值.且只能在三处之一指定初始值.</p></li></ul><h4 id="final修饰局部变量"><a href="#final修饰局部变量" class="headerlink" title="final修饰局部变量"></a>final修饰局部变量</h4><ul><li><p>final修饰的局部变量可以在声明时不指定初始值.如果没有指定,则可以在后续代码中进行赋值,但只能赋值一次.</p></li><li><p>形参可以被final修饰,那么在函数体中该参数不能被赋值.</p></li><li><p>引用变量可以被final修饰,但是锁定的是该引用类型变量所指向的地址.引用的对象的成员变量的值依旧可以被改变.</p></li><li><p>一个在定义时就指定了初始值的final变量如果在编译时就可以确定初始值,那么它将起到类似宏替换的效果.</p></li></ul><h4 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h4><ul><li>被final修饰的方法无法被子类重写.例如Object类中的 getClass() 方法.</li><li>比较: 被private修饰的方法无法被子类访问; 另外注意区分重写与重载的区别.</li><li>被final和private同时修饰的方法可以在子类中被 “重写”. 但实质上是子类的新方法.并非真正意义上的重写.</li></ul><h4 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h4><ul><li>被final修饰的类无法有子类. 例如java.lang.Math类. </li><li>当子类继承父类时可以访问父类的内部数据,甚至可以重写父类方法.因此需要对该父类限制继承.</li></ul><h4 id="不可变类-immutable"><a href="#不可变类-immutable" class="headerlink" title="不可变类(immutable)"></a>不可变类(immutable)</h4><ul><li>创建出的该类的实例的实例变量是不可改变的.例如8个包装类以及java.lang.String类</li><li><p>TODO:自建不可变类的注意事项</p></li><li><p>由于被final修饰的引用变量依旧是可以改变的.因此直接包括引用变量的不可变类并不是真正的不可变. 可以在涉及到相关操作时创建新的匿名类来规避.</p></li></ul><h3 id="6-5-抽象类与abstract"><a href="#6-5-抽象类与abstract" class="headerlink" title="6.5 抽象类与abstract"></a>6.5 抽象类与abstract</h3><ul><li><p>抽象类必须使用abstract修饰.抽象方法也必须使用abstract修饰,并且不能有方法体.</p></li><li><p>抽象类中未必包括抽象方法.但包括抽象方法的类必须是抽象类.</p></li><li><p>抽象类不能有实体.不能被实例化.可以有构造器但不能被直接构造.(构造器用于被子类重写).</p></li><li><p>其子类需要实现父类的所有抽象类.否则,子类也是一个抽象类.</p></li><li><p>被abstract修饰的类只能被继承,而被final修饰的类不能被继承.因此这两个修饰符不能同时使用.</p></li><li><p>被abstract修饰的方法只能子类实现,而被static修饰的方法只能被该类调用.因此这两个修饰符不能同时修饰方法.但是可以同时修饰部类.</p></li></ul><p>TODO:接口</p><h3 id="6-9-枚举"><a href="#6-9-枚举" class="headerlink" title="6.9 枚举"></a>6.9 枚举</h3><ul><li><p>枚举是一种特殊的类.使用enum进行修饰.(该关键词与class,interface等价).一个java源文件只能有一个被public修饰的enum类.</p></li><li><p>枚举类默认继承java.lang.Enum类(而非Object类).因此枚举类不能显式继承其他父类.Enum提供了一些接口.</p></li><li><p>非抽象的enum类默认使用final修饰,因此不能派生子类.</p></li><li><p>枚举类的构造器只能使用private修饰.</p></li><li><p>枚举类的所有实例必须在第一行显式列出.</p></li><li><p>Enum 类中提供的一些接口:</p><ol><li>int compareTo(E o):用于与相同枚举类型的对象进行比较排序.若该对象位于o之后返回正整数,反之返回负整数或0.</li><li>String name() 与 String toString():都可以返回当前实例的名称.习惯上使用后者.</li><li>int ordinal(): 返回当前枚举实例的索引值(从0开始)</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又开的新坑~ 目标是把平日里关于Java的学习到的碎片化知识先记录下来, 待日后回顾.&lt;/p&gt;
&lt;p&gt;希望以后会回顾(逃)&lt;/p&gt;
&lt;p&gt;目前在学习的是李刚老师的 &lt;a href=&quot;https://book.douban.com/subject/3246499/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;疯狂JAVA讲义 (第四版)&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/"/>
    
      <category term="Java拾遗" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/Java%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之二刷子午</title>
    <link href="http://yoursite.com/2020/09/27/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E4%BA%8C%E5%88%B7%E5%AD%90%E5%8D%88/"/>
    <id>http://yoursite.com/2020/09/27/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E4%BA%8C%E5%88%B7%E5%AD%90%E5%8D%88/</id>
    <published>2020-09-27T15:36:42.000Z</published>
    <updated>2020-09-28T07:46:35.659Z</updated>
    
    <content type="html"><![CDATA[<p>2020年9月26日</p><p>子午口-荔枝驿-金仙观-小土地梁-原返</p><a id="more"></a><p>由于我坚持不懈地在朋友圈更新徒步动态, 终于有同学跑过来私聊说想试一试户外了~ 正好本周的打卡山是难度较大的冰晶顶, 自觉水平不够, 就带着N同学一起去了超简单线:子午峪. 子午是我疫情返校后的第一座山, (可以参看8月5日的游记), 对新手非常友好了~</p><h2 id="新队友"><a href="#新队友" class="headerlink" title="新队友"></a>新队友</h2><p>让我惊讶的是居然在队伍里偶遇到西电的本科生. 是一位17级的大四学长, 在此之前我几乎没有碰到过玩户外的其他本科生欸. 事后发现跃跃学长真是dalao哈哈哈. 这个一会再说</p><p>集合点是陕师大门口. 副领队是一只看上去好小的政法小姐姐 , 居然也是大三. 虽说明明也是户外新人怎么就成领队了呢(狗头</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E9%87%91%E4%BB%99%E8%A7%82.jpg" alt=""></p><p>主领队是西电的研究生非鱼. 很皮很欠揍. 提前就约好了一起腐败哈哈哈</p><p>除此之外还有个巨巨巨巨佬Black, 是交大的研究生. 越野老驴, 体能贼强, 回去路上给我们看之前反穿鳌太, 一日太白的照片, 实在是太好看了. 高强度徒步. 除此之外科研生活也两开花, 大佬果然做什么事情都是大佬.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E7%8E%AF%E4%BF%9D.jpg" alt=""></p><h2 id="徒步"><a href="#徒步" class="headerlink" title="徒步"></a>徒步</h2><p>一路上倒是没什么值得记录的, 跟散步一样慢悠悠晃了过来, 没啥景色.</p><p>倒是有队员拍到了山羊的照片,可惜我没看到.还有第一次来的时候见到的猫猫, 两个月不见又胖了一圈</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E7%8C%AB%E5%92%AA.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%F0%9F%90%8F.jpg" alt=""></p><p>有段路满地都是野板栗壳, 都是先前的徒步队留下来的, 我们瞪大了眼睛也找不到一个完整的, 不过回来路上看见别的驴友拎着一大袋子板栗回去, 估计是进山进的更深一些.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E6%9D%BF%E6%A0%97%28%E5%B0%8F%29.jpg" alt=""></p><h2 id="腐败"><a href="#腐败" class="headerlink" title="腐败"></a>腐败</h2><p>那这种轻装休闲线嘛~ 肯定是主要出来腐败的. 提前准备好了海底捞底料, 火腿, 肉肠, 鸡胸肉, 方便面. 甚至还在乐购买了包牛肉卷(容易化, 下次别带了). 其他人也带了两袋子菜蔬, 火锅丸子, 爆浆蛋糕, 鸭脖鸭架, 炒货等待…非鱼还带的一口大锅! 第一次吃这么丰盛的火锅哈哈哈. 最后煮了一盆肉,一盆菜,一盆方便面. 到最后都九个人都没能吃完!!</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E7%81%AB%E9%94%85.jpg" alt=""></p><p>跃跃原来是厨神, 油炸火腿肠(虽然不好吃), 番茄汤底方便面, 最后甚至掏出了一套茶具开始喝茶! 真的绝了~~</p><p>回去路上又临时起意去约饭, 居然还是去的自助~! 感觉这一趟下来胖好多哈哈哈</p><p>但是自助真好吃</p><blockquote><p>还记得去年说, 旅游的意义之一是简单更多的人更广的世界，现在觉得这句话更加正确。</p><p>拘泥于固有的生活节奏的人是井底之蛙，是动了奶酪而不自知的老鼠。</p><p>遇到了交大大佬black，体能好 徒步越野的老驴，文理双修，博闻强识 科研生活两开花<br>遇到了同龄的政法小姐姐，虽然也在迷茫但是很努力在提升自己<br>遇到大一届的学长，在毕业和求职之间忙里偷闲<br>遇到78年高考的大叔，交大毕业，扬州工作，还能跟我们唠的开心</p><p>缘分这种事啊，不迈出第一步就永远也碰不见</p></blockquote><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E5%90%88%E7%85%A7.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年9月26日&lt;/p&gt;
&lt;p&gt;子午口-荔枝驿-金仙观-小土地梁-原返&lt;/p&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之雨中紫阁</title>
    <link href="http://yoursite.com/2020/09/22/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E9%9B%A8%E4%B8%AD%E7%B4%AB%E9%98%81/"/>
    <id>http://yoursite.com/2020/09/22/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E9%9B%A8%E4%B8%AD%E7%B4%AB%E9%98%81/</id>
    <published>2020-09-22T15:35:30.000Z</published>
    <updated>2020-09-28T07:46:43.096Z</updated>
    
    <content type="html"><![CDATA[<p>2020年月日</p><h1 id="在这里简要概括路线"><a href="#在这里简要概括路线" class="headerlink" title="在这里简要概括路线"></a>在这里简要概括路线</h1><a id="more"></a><ul><li>山与水    | 游记<ul><li>不积硅步 | 徒步系列</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年月日&lt;/p&gt;
&lt;h1 id=&quot;在这里简要概括路线&quot;&gt;&lt;a href=&quot;#在这里简要概括路线&quot; class=&quot;headerlink&quot; title=&quot;在这里简要概括路线&quot;&gt;&lt;/a&gt;在这里简要概括路线&lt;/h1&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭##可选" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD-%E5%8F%AF%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统之一_引言</title>
    <link href="http://yoursite.com/2020/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80_%E5%BC%95%E8%A8%80/"/>
    <id>http://yoursite.com/2020/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80_%E5%BC%95%E8%A8%80/</id>
    <published>2020-09-10T11:15:14.000Z</published>
    <updated>2020-09-10T15:49:45.023Z</updated>
    
    <content type="html"><![CDATA[<p>勤能补拙是良训, 一分辛苦一分才.</p><ol><li>系列介绍</li><li>数据库的定义与目标</li><li>数据视图</li><li>数据库语言</li><li>关系数据库</li><li>数据库的设计</li><li>存储与查询</li></ol><a id="more"></a><h1 id="系列介绍"><a href="#系列介绍" class="headerlink" title="系列介绍"></a>系列介绍</h1><p>没错又开新系列了~~ 这次还是以学校开设的 &lt;&lt;数据库系统概念&gt;&gt; 课程为进度安排, 使用教材为机械工业出版社的 <a href="https://book.douban.com/subject/10548379/" target="_blank" rel="noopener">数据库系统概念</a> 黑皮书.</p><p>文章不会针对某一知识点具体展开叙述, 更多地是作为知识点的列举, 以便于日后回顾.</p><p>文章中也可能会穿插部分与期末考试强相关的信息.</p><h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><h2 id="数据库的定义与目标"><a href="#数据库的定义与目标" class="headerlink" title="数据库的定义与目标"></a>数据库的定义与目标</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>数据库管理系统 (Data Base-Management System, DBMS)</strong>由一个<u>互相关联的数据的集合</u>和一组<u>用以访问这些数据的程序(接口)组成</u></p><p>A database-management system (DBMS) is a collection of interrelated data and a set of programs to access those data.</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li><p>DBMS的主要目标</p><p>to provide a way to <em>store and retrieve</em> database information that is both <strong>convenient</strong> and <strong>efﬁcient</strong></p></li><li><p>对数据的管理, 要求有一下几方面:</p><ul><li>信息体的<u>存储结构的定义</u></li><li>信息<u>操作机制的提供</u></li><li>信息<u>安全性</u>保证</li><li>信息共享时带来的冲突</li></ul></li></ul><p>在历史上，数据的管理经历了人工管理-文件系统管理-数据库管理的阶段。文件处理系统的主要弊端有：</p><ol><li>数据的冗余和不一致（data redundancy and inconsistency）</li><li>数据访问困难(difficulty in accessing data)</li></ol><p>需要解决的问题：</p><ol><li>数据孤立(data isolation) </li><li>完整性问题(integrity problem)</li><li>原子性问题(atomicity problem)</li><li>并发访问(concurrent-access anomaly)</li><li>安全性(security problem) </li></ol><h2 id="数据视图"><a href="#数据视图" class="headerlink" title="数据视图"></a>数据视图</h2><p>数据库系统包括：</p><ul><li>一组互相关联的数据</li><li>一组使用户便于读写的程序（接口）</li></ul><p>数据库系统提供了数据的抽象视图</p><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><ul><li>物理层：最低层次的抽象，描述了数据是如何存储的</li><li>逻辑层：描述了系统中存储了什么数据，以及数据之间的关系。面向数据库管理员</li><li><p>视图层：最高层次的抽象，仅仅描述数据库的某个部分。同一个数据库可能拥有多种视图层</p><h3 id="实例与模式"><a href="#实例与模式" class="headerlink" title="实例与模式"></a>实例与模式</h3></li><li>实例：数据库在某一时刻存储在数据库中的信息的集合。</li><li>模式：数据库的总体设计方式</li></ul><p>任意时刻的实例都是该模式的具体，模式是实例的抽象。<br>根据不同的抽象层次模式又分为：</p><ul><li>物理模式：描述了数据库在物理层上的设计抽象模式</li><li>逻辑模式：描述了数据库在逻辑层上的设计抽象模式</li><li><p>子模式：描述了数据库在视图层上的设计抽象模式</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型是一类概念的集合，这些概念描述了数据，数据联系，数据语义以及一致性约束。<br>常见的数据模型：</p></li></ul><ol><li>关系模型</li><li>实体-联系模型</li><li>基于对象数据模型</li><li><p>半结构化数据模型</p><h2 id="数据库语言"><a href="#数据库语言" class="headerlink" title="数据库语言"></a>数据库语言</h2><p>数据库语言分为数据定义语言（DDL）和数据操纵语言（DML）。<br>这两种并非对立的语言，而是同一门数据库语言的两部分。</p><h4 id="数据操纵语言DML"><a href="#数据操纵语言DML" class="headerlink" title="数据操纵语言DML"></a>数据操纵语言DML</h4><p>使用户能够访问或操作数据，包括以下访问类型：</p></li><li>Create 插入新的数据</li><li>Retrieve 从存储在数据库中的信息进行检索</li><li>Update 更新已有的数据</li><li>Delete 删除数据</li></ol><p>有两类基本的数据操纵语言：</p><ol><li>过程化DML ，需要用户指定需要的数据并且如何获得数据</li><li>声明式DML，仅需要指定需要的数据，不需要指明如何获得</li></ol><p>查询（Query）语言本义是特指DML中的检索语句，现在常作为DML的同义词。</p><h4 id="数据定义语言DDL"><a href="#数据定义语言DDL" class="headerlink" title="数据定义语言DDL"></a>数据定义语言DDL</h4><p>DDL不直接操作数据，而是对数据库模式进行设计的一种语言。数据库中的数值必须满足某些一致性约束，DDL正是指定这些约束的工具。DDL可用于：</p><ul><li>域约束</li><li>参照完整性</li><li>断言</li><li>授权</li></ul><p>DDL编写的结果储存在在数据字典中，数据字典中储存的内容被称作元数据。元数据是关于数据的数据，规定了表中数据应当符合的模式。（大概）</p><h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><p>关系型数据库基于关系模型，使用表来展示数据及数据间的联系。关系型数据库是目前最广泛使用的数据库，我们将在接下来几章详细讲解。</p><p>关系型数据库（例如SQL）常常无法用于复杂的计算，因此往往需要宿主语言（Java，C++）。数据库语言提供了一系列接口给宿主语言。</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><ol><li><p>确定用户的数据需求</p></li><li><p>概念设计</p><p>选择合适的数据模型并使用该模型将需求转化为一个数据库的概念模式</p></li><li><p>逻辑设计阶段</p><p>将高层的概念模式映射到实现数据模型上</p></li><li><p>物理设计阶段</p></li></ol><h3 id="实体-关系模型"><a href="#实体-关系模型" class="headerlink" title="实体-关系模型"></a>实体-关系模型</h3><p>实体-联系(E-R)数据模型使用一组称作实体的基本对象，以及这些对象间的联系。</p><p><strong>实体</strong> (entity) 是现实世界中可区别于其他对象的一件“事情”或一个“物体”。例如，每个人是一个实体，每个银行账户也是一个实体。实体通过<strong>属性</strong>(attribute)集合来描述</p><p><strong>联系</strong>(relationship)是几个实体之间的关联。同一类型的所有实体的集合称作实体集(entity set),同一类型的所有联系的集合称作联系集 (relationship set) </p><p>数据库的总体逻辑结构(模式)可以用实体-联系图(entity-relationship diagram, E-R图)进行图形化表示。最常用的方法之一是采用统一建模语言(Unified Modeling Language, UML) </p><ul><li>实体集用矩形框表示，实体名在头部，属性名列在下面。</li><li>联系集用连接一对相关的实体集的菱形表示，联系名放在菱形内部。</li></ul><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p>设计关系数据库所用到的另外一种方法是通常被称为<strong>规范化</strong>的过程。它的目标是生成一个关系模式集合，使我们存储信息时没有不必要的冗余，同时又能很轻易地检索数据。这种方法是设计一种符合适当的<strong>范式</strong>(normal form)的模式</p><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值(null) 表示这个值不存在(或者未知)，未知值可能是 缺失(该值确实存在，但我们没有得到它)或不知道(我们不知道该值是否存在)。空值很难处理，所以最好不要用它。</p><h2 id="存储与查询"><a href="#存储与查询" class="headerlink" title="存储与查询"></a>存储与查询</h2><h3 id="存储管理器"><a href="#存储管理器" class="headerlink" title="存储管理器"></a>存储管理器</h3><p><strong>存储管理器</strong>是数据库系统中负责在数据库中<u>存储的低层数据与应用程序</u>以及<u>向系统提交的查询之间提供接口</u>的部件。存储管理器负责与<strong>文件管理器</strong>进行交互。存储管理器将各种DML语句翻译为底层文件系统命令,并存储在磁盘中。存储管理器负责数据库中数据的<u><em>存储、检索和更新</em></u>。 </p><p>存储管理部件包括：</p><ul><li><p>权限及完整性管理器(authorization and integrity manager)</p><p>它<u>检测是否满足完整性约束</u>，并检查试图访问数据的用户的权限。</p></li><li><p>事务管理器(transaction manager)</p><p>它保证即使发生了故障，数据库也<u>保持在一致的(正确的)状态</u>，并保证并发<u>事务的执行不发生冲突</u>。 </p></li><li><p>文件管理器(file manager)</p><p>它管理磁盘存储空间的分配，管理用于表示磁盘上所存储信息的数据结构。</p></li><li><p>缓冲区管理器(buffer manager)</p><p>它负责将数据从磁盘上取到内存中来，并决定哪些数据应被缓冲存储在内存中。</p></li></ul><p>存储管理器实现了几种<strong><u>数据结构</u></strong>，作为系统物理实现的一部分：</p><ul><li><p>数据文件(data files)</p><p>存储数据库自身。</p></li><li><p>数据字典(data dictionary)</p><p>存储关于数据库结构的元数据，尤其是数据库模式。</p></li><li><p>索引(index)</p><p>提供对数据项的快速访问。和书中的索引一样，数据库索引提供了指向包含特定值的数据的指针。</p></li></ul><h3 id="查询处理器"><a href="#查询处理器" class="headerlink" title="查询处理器"></a>查询处理器</h3><ul><li>DDL 解释器(DDL interpreter),它解释DDL语句并将这些定义记录在数据字典中。 </li><li>DML解释器(DML compiler),将查询语言中的DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令。</li></ul><p>DML编译器还进行查询优化(query optimization),也就是从几种选择中选出代价最小的一种。 </p><ul><li>查询执行引擎(query evaluation engine),执行由DML编译器产生的低级指令。 </li></ul><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p><strong>事务</strong> (transaction): 是数据库应用中完成单一逻辑功能的操作集合。每一个事务是一个既具原子性又具一致性的单元</p><blockquote><p>例如: 资金转账这一逻辑单元由两个基本操作组成: 其中一个系(A系)的账户进行取出操作，而另一个系(B系)的账户进行存入操作。显然，这两个操作必 须保证要么都发生要么都不发生。也就是说，资金转账必须完成或根本不发生。这种要么完成要么不 发生的要求称为<strong>原子性(atomicity)</strong> </p><p>除此以外，资金转账还必须保持数据库的一致性。也就是说，A 和B的余额之和应该是保持不变的。这种正确性的要求称作<strong>一致性(consistency)</strong> .最后，当资金转账 成功结束后，即使发生系统故障，账户A和账户B的余额也应该保持转账成功结束后的新值。这种保持的要求称作<strong>持久性(durability)</strong>。</p></blockquote><p>原子性和持久性的保证是数据库系统自身的职责，确切地说，是恢复管理器(recovery manager)的职责。为了保证原子性，失败的事务必须对数据库状态不产生任何影响。因此，数据库必须被恢复到该失败事务开始执行以前的状态, 即<strong>故障恢复(failure recovery)</strong></p><p>最后，当多个事务同时对数据库进行更新时，即使每个单独的事务都是正确的，数据的一致性也可能被破坏。<strong>并发控制管理器(concurrency-control manager)</strong>控制并发事务间的相互影响，保证数据库一 致性。</p><p>并发控制管理器和恢复管理器 都属于 <strong>事务管理器(transaction manager)</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;勤能补拙是良训, 一分辛苦一分才.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系列介绍&lt;/li&gt;
&lt;li&gt;数据库的定义与目标&lt;/li&gt;
&lt;li&gt;数据视图&lt;/li&gt;
&lt;li&gt;数据库语言&lt;/li&gt;
&lt;li&gt;关系数据库&lt;/li&gt;
&lt;li&gt;数据库的设计&lt;/li&gt;
&lt;li&gt;存储与查询&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="数据库系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之太兴山</title>
    <link href="http://yoursite.com/2020/09/02/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%A4%AA%E5%85%B4%E5%B1%B1/"/>
    <id>http://yoursite.com/2020/09/02/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%A4%AA%E5%85%B4%E5%B1%B1/</id>
    <published>2020-09-02T15:34:09.000Z</published>
    <updated>2020-09-28T07:47:00.820Z</updated>
    
    <content type="html"><![CDATA[<p>2020年月日</p><h1 id="在这里简要概括路线"><a href="#在这里简要概括路线" class="headerlink" title="在这里简要概括路线"></a>在这里简要概括路线</h1><a id="more"></a><ul><li>山与水    | 游记<ul><li>不积硅步 | 徒步系列</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年月日&lt;/p&gt;
&lt;h1 id=&quot;在这里简要概括路线&quot;&gt;&lt;a href=&quot;#在这里简要概括路线&quot; class=&quot;headerlink&quot; title=&quot;在这里简要概括路线&quot;&gt;&lt;/a&gt;在这里简要概括路线&lt;/h1&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭##可选" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD-%E5%8F%AF%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题流水账2020-08</title>
    <link href="http://yoursite.com/2020/09/01/LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-08/"/>
    <id>http://yoursite.com/2020/09/01/LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-08/</id>
    <published>2020-09-01T13:21:59.000Z</published>
    <updated>2020-09-01T13:27:42.865Z</updated>
    
    <content type="html"><![CDATA[<p>Week 4 ✔</p><p>Week 5 ✘ ​</p><a id="more"></a><p>2020年8月22日 “再度”开始刷力扣</p><p>既然决定不读研就好好刷题学工程吧</p><p>每周七题以上. 如果遇到考试周等特别情况可以提前一周完成任务, 不得向后拖延.</p><h2 id="2020年8月22日-week4"><a href="#2020年8月22日-week4" class="headerlink" title="2020年8月22日-week4"></a>2020年8月22日-week4</h2><p>主题: 链表</p><h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="[237] 删除链表中的节点"></a>[237] 删除链表中的节点</h3><p>简单题</p><p>复习单链表</p><h4 id="删除当前节点"><a href="#删除当前节点" class="headerlink" title="删除当前节点"></a>删除当前节点</h4><p>传入参数仅为要删除的节点, (保证不是最后一个节点, 保证链表有两个及以上节点)</p><p>最初的思路自然是<strong>将前驱节点的指针指向后继节点</strong>, 但是无法取得前驱节点.</p><p>正确的思路: <strong>将本节点赋值为后继节点, 并删去后继节点.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="[19] 删除链表的倒数第N个节点"></a>[19] 删除链表的倒数第N个节点</h3><p>中等题</p><p>学习了链表的两个常用技巧: 快慢双指针, 哑节点</p><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a><strong>双指针</strong></h4><p>比较慢的做法是遍历两遍, 一次获取链表长度L, 一次删去倒数第几个数</p><p>可以设置两个指针, 快指针先走n步, 然后快慢指针一起走, 这样快指针到尾的时候慢指针正好到了倒数第n个</p><h4 id="哑节点"><a href="#哑节点" class="headerlink" title="哑节点"></a><strong>哑节点</strong></h4><p>其实就是数据结构课上那个首结点还是什么来着的, 就那个实际第一个节点的前面一个没有数据仅为了引导链表的节点. 加入这玩意可以简化链表操作.</p><blockquote><p>但是当我面对操作<strong>头节点</strong>的问题时，代码就无法通过测试了。<br>例如：我们一共有<strong>四个节点</strong>，需要删除<strong>倒数第四个</strong>节点。<br>因为当我们删除了头节点的时候，我们用什么来返回链表呢？</p></blockquote><h2 id="2020年8月31日-week5"><a href="#2020年8月31日-week5" class="headerlink" title="2020年8月31日-week5"></a>2020年8月31日-week5</h2><p>主题:链表</p><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="[206]反转链表"></a>[206]反转链表</h3><p>简单题</p><p>使用了三种方法解决: 完全地反向构建一个新链表; 原地迭代反转链表; 原地递归反转链表.</p><p>反向复制: 从头到尾地遍历, 每次复制遍历到的节点, 并将该节点的指向为刚才复制的节点.</p><p>原地迭代: 将本节点的指向从后节点指向前节点, 注意储存后节点和本节点的地址</p><p>递归反转: 假设后半段已经复制好了.还是不太能理得清楚. <a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/" target="_blank" rel="noopener">链接</a></p><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="[21] 合并两个有序链表"></a>[21] 合并两个有序链表</h3><p>简单题</p><p>两种: 迭代比较/递归合并</p><p>迭代比较: 双指针, 指向的小的那个并入结果链表(注: 不需要实际复制一遍链表, 只要使用指针即可)</p><p>递归比较: 每次小的指向合并后半部分的返回结果</p><p>注意: 两个链表为空/有一个为空的情况, 只需要两次判断即可</p><h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="[234] 回文链表"></a>[234] 回文链表</h3><p>简单</p><p>On遍历, 将链表的数据储存在数组中, 从前从后比较</p><p>进阶: 时间On 空间O1, 将后半部分链表翻转, 然后双指针比较(未完成)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Week 4 ✔&lt;/p&gt;
&lt;p&gt;Week 5 ✘ ​&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="屠龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/"/>
    
      <category term="算法与刷题" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%B7%E9%A2%98/"/>
    
      <category term="力扣刷题流水账" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>软件工程之敏捷方法综述:XP与Scrum</title>
    <link href="http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0-XP%E4%B8%8EScrum/"/>
    <id>http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0-XP%E4%B8%8EScrum/</id>
    <published>2020-08-21T08:13:58.000Z</published>
    <updated>2020-08-21T08:16:34.378Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了敏捷方法中的极限编程与Scrum，就二者的相似与区别、各自在实践中的优劣势进行了论述分析。并根据相关资料整理得出其在国内应用的现状，进一步分析其背后的原因，并加以展望未来的发展可能性。</p><p>关键词：敏捷开发，极限编程，Scrum，系统开发方法，软件工程</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>极限编程与 Scrum方法概述<ol><li>什么是极限编程<ol><li>极限编程的简述</li><li>极限编程的目的</li><li>极限编程的12条军规</li><li>极限编程的4个价值</li></ol></li><li>什么是Scrum？<ol><li>Scrum的简述与流程</li><li>Scrum中的三大角色</li></ol></li></ol></li><li>二者的比较分析<ol><li>Xp与scrum的主要异同</li><li>二者的区别<ol><li>迭代长度的不同</li><li>是否允许修改需求</li><li>User Story是否严格按照优先级别来实现</li><li>是否采用严格的工程方法保证进度或者质量</li></ol></li><li>Xp与 Scrum在生产实践中的优劣</li></ol></li><li>国内应用现状</li><li>小结</li></ol><hr><h2 id="一、极限编程与Scrum方法概述"><a href="#一、极限编程与Scrum方法概述" class="headerlink" title="一、极限编程与Scrum方法概述"></a>一、极限编程与Scrum方法概述</h2><h3 id="什么是极限编程（Extreme-Programming，XP）？"><a href="#什么是极限编程（Extreme-Programming，XP）？" class="headerlink" title="什么是极限编程（Extreme Programming，XP）？"></a>什么是极限编程（Extreme Programming，XP）？</h3><h4 id="极限编程的简述"><a href="#极限编程的简述" class="headerlink" title="极限编程的简述"></a>极限编程的简述</h4><p>极限编程是一种软件工程方法学，并且是敏捷软件开发中应用最为广泛和最富有成效的几种方法学之一。相对于传统的软件开发方法学，它更加强调字开发过程中软件需求的不断变化性，认为这种变化是及其正常且不可避免的。正因为如此，极限编程非常注重对于变化的适应，而不是对变化的规避或预测。</p><h4 id="极限编程的目的"><a href="#极限编程的目的" class="headerlink" title="极限编程的目的"></a>极限编程的目的</h4><p>极限编程的主要目标在于<strong>降低因需求变更而带来的成本</strong>。</p><p>在传统系统开发方法中，系统需求在开始阶段后在之后的开发过程中保持不变的。这意味着项目在进入后期阶段时出现的需求变更将导致开发成本急速增加。</p><p>极限编程通过引入基本价值、原则、方法等概念来达到降低变更成本的目的。一个应用了极限编程方法的系统开发项目在应对需求变更时将显得更为灵活。</p><h4 id="极限编程的12条军规"><a href="#极限编程的12条军规" class="headerlink" title="极限编程的12条军规"></a>极限编程的12条军规</h4><p>短交付周期    计划游戏    结对编程    可持续的节奏    </p><p>代码集体所有    编码规范    简单设计    测试驱动开发    </p><p>重构    系统隐喻    持续集成    现场客户</p><h4 id="极限编程的4个价值"><a href="#极限编程的4个价值" class="headerlink" title="极限编程的4个价值"></a>极限编程的4个价值</h4><h5 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h5><p>是在开发小组的成员之间迅速构建与传播制度上的认识的一种方法。极限编程支持设计、抽象、还有用户-程序员间交流的简单化，鼓励经常性的口头交流与回馈。</p><h5 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h5><p>鼓励从最简单的解决方式入手，再通过不断重构达到更好的结果。它只关注于对当前的需求来进行设计、编码。为了将来不确定的需求进行设计以及编码意味着在不必要的方面浪费资源。</p><p>而且设计与代码上的简化可以提高交流的质量。</p><h5 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h5><p>XP团队重视反馈，反馈越快越好。</p><ol><li>来自系统的反馈：通过编写单元测试，程序员能够很直观的得到经过修改后系统的状态。</li><li>来自客户的反馈：功能性测试是由客户还有测试人员来编写的。他们能由此得知当前系统的状态。</li><li>来自小组的反馈：当客户带着新需求来参加项目计划会议时，小组可以直接对于实现新需求所需要的时间进行评估然后反馈给客户。</li></ol><h5 id="勇气"><a href="#勇气" class="headerlink" title="勇气"></a>勇气</h5><p>勇气是软件开发中的一个重要价值，因为它需要勇气来坦率真诚地面对客户，它需要勇气来识别我们自己，我们的团队和我们的组织的缺点，并努力改善这些缺点。</p><h3 id="什么是Scrum？"><a href="#什么是Scrum？" class="headerlink" title="什么是Scrum？"></a>什么是Scrum？</h3><h4 id="Scrum-的简述与流程"><a href="#Scrum-的简述与流程" class="headerlink" title="Scrum 的简述与流程"></a>Scrum 的简述与流程</h4><p>Scrum 是用于开发、交付和持续支持复杂产品的一个框架，是一个增量的、迭代的开发过程。</p><p>在这个框架中，整个开发过程由若干个短的迭代周期（Sprint）组成，每个Sprint的建议长度是一至四周。</p><p>在Scrum中，使用按照商业价值排序的需求列表（Backlog）来管理产品的需求。Scrum团队总是先开发对客户具有较高价值的需求。</p><p>在每一个Sprint计划会议上，将高优先级的需求经过讨论、分析得到相应的任务列表，称它为Sprint backlog。每个成员根据Sprint Backlog再细化成更小的任务。</p><p>在一次迭代环节中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须汇报你昨天完成了什么、承诺你今天要完成什么，以及遇到不能解决的问题。最后要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）</p><p>在每个迭代结束时，Scrum团队将召开  Sprint Retrospective Meeting（回顾会议），总结并讨论改进的地方，放入下一轮Sprint的产品需求中；并递交潜在可交付的产品增量（Increment）</p><h4 id="Scrum中的三大角色"><a href="#Scrum中的三大角色" class="headerlink" title="Scrum中的三大角色"></a>Scrum中的三大角色</h4><h5 id="产品负责人（Product-Owner）"><a href="#产品负责人（Product-Owner）" class="headerlink" title="产品负责人（Product Owner）"></a>产品负责人（Product Owner）</h5><p>主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。</p><h5 id="流程管理员（Scrum-Master）"><a href="#流程管理员（Scrum-Master）" class="headerlink" title="流程管理员（Scrum Master）"></a>流程管理员（Scrum Master）</h5><p>主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。</p><h5 id="开发团队（Scrum-Team）"><a href="#开发团队（Scrum-Team）" class="headerlink" title="开发团队（Scrum Team）"></a>开发团队（Scrum Team）</h5><p>主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。</p><h2 id="二、二者的比较分析"><a href="#二、二者的比较分析" class="headerlink" title="二、二者的比较分析"></a>二、二者的比较分析</h2><h3 id="XP与Scrum的主要异同"><a href="#XP与Scrum的主要异同" class="headerlink" title="XP与Scrum的主要异同"></a>XP与Scrum的主要异同</h3><h4 id="二者的相同"><a href="#二者的相同" class="headerlink" title="二者的相同"></a>二者的相同</h4><p>同属于敏捷开发，都是为了在不确定或混乱的环境中取得项目的成功。</p><p>最终目的相同：都是为了迭代出更好的产品交付给用户。</p><h4 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h4><h5 id="迭代长度的不同"><a href="#迭代长度的不同" class="headerlink" title="迭代长度的不同"></a>迭代长度的不同</h5><p>XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周</p><h5 id="是否允许修改需求"><a href="#是否允许修改需求" class="headerlink" title="是否允许修改需求"></a>是否允许修改需求</h5><p>XP在一个迭代中，如果一个User Story还没有实现， 则可以考虑用另外的需求将其替换， 替换的原则是需求实现的时间量是相等的。</p><p> 而Scrum是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来。</p><h5 id="User-Story是否严格按照优先级别来实现"><a href="#User-Story是否严格按照优先级别来实现" class="headerlink" title="User Story是否严格按照优先级别来实现"></a>User Story是否严格按照优先级别来实现</h5><p>XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活， 可以不按照优先级别来做。</p><h5 id="是否采用严格的工程方法保证进度或者质量"><a href="#是否采用严格的工程方法保证进度或者质量" class="headerlink" title="是否采用严格的工程方法保证进度或者质量"></a>是否采用严格的工程方法保证进度或者质量</h5><p>Scrum没有对软件的整个实施过程定义任何方法。要求开发者自觉保证产品的生产。</p><p>但XP对整个流程方法定义非常严格，规定需要采用TDD, 自动测试， 结对编程，简单设计，重构等约束团队的行为。</p><h3 id="XP与Scrum在生产实践中的优劣"><a href="#XP与Scrum在生产实践中的优劣" class="headerlink" title="XP与Scrum在生产实践中的优劣"></a>XP与Scrum在生产实践中的优劣</h3><p>Scrum的出现实践比极限开发更早。scrum被定义为一个“框架”，提供了宏观上的概念及方法论——鸡类人员、猪类人员、计划会议、每日站立会议、验收会议和回顾会议等等。但是没有提出对于细节的控制与要求（这在前面的区别也有论述），这导致了Scrum更多的是作为一种实践思想与范本，而不是生产过程中的标准。此外，这也导致了Scrum在实际运用中质量的良莠不齐。</p><p>极限开发的出现晚于Scrum ，其中也鲜明地带有或多或少的Scrum烙印。Xp是由“价值观”“原则”和“实践”组成，其中的理念（价值观与）是统筹Xp所有方法的核心。但是在实际的生产实践中，Xp大量的实践约束带来了相当大的成本。无论是人员成本较高的结对编程，还是技术门槛较高的TDD，都给Xp带来了实现的困难。这也导致了在生产实践中，Xp很少会作为一套“完整的流程”，而更多地作为生产中的建议而部分采纳。</p><p>当然，实践中更多地是采用两种多种不同的方法之长进行混合开发。</p><h2 id="三、国内应用现状"><a href="#三、国内应用现状" class="headerlink" title="三、国内应用现状"></a>三、国内应用现状</h2><p>Scrum作为从国外引进的系统开发的技术。在国内的实践并不顺利。酷壳站长陈皓曾经编译过一篇《为什么Scrum不行？》，其中提到了9个Scrum不行的理由。如下：</p><blockquote><p><strong>Reason 1:</strong> Scrum的基石是相信人。创造一个安全的环境，这样每个人都能相互学习，相互直言。但是，这是不行的，这世上有很多人并不关心这些，而且政治和竞争到处都是，办公室里无小事，你和别人交心，你相信他们，最终受伤的你自己。你真的以为那里有空间让你可以去犯错，去冒险吗？</p><p><strong>Reason 2:</strong> Scrum认为只要给员工足够多的自由员工就能做得最好。这该死的理论是基于什么玩意？不可能，人的天性是懒惰的，他们才不会把事做好的，他们只会做相应报酬的工作量，还可能基本甚至达不到其相应的报酬，大多数人都在混日子。尤其是和经理比起来，谁不想能尽快地成为经理或Team leader啊，因为那样他们就可以即不干活，又挣得多。另外，你给他们自由，你就会发现，他们会只会做他们感兴趣的事，要么聊QQ，要么打游戏，看闲书，反正不干正事。直到你催了，他们才动一动。</p><p><strong>Reason 3:</strong> 因为前面的原因，所以，我们仍然要把一个PM放在Scrum团队的上面做管理，这样才会有产出。于是，PM给团队分配任何，管得细枝末节，事无巨细，天天让你做进度汇报，等等。直至把团队拖垮。</p><p><strong>Reason 4:</strong>Scrum只不过是一个流程。这世上有太多的流程，尤其是那那些执行CMMI的公司。几乎所有玩CMMI流程的公司，你都能看到的是员工都是那一副副难看的脸。所以，Scrum的流程同样会这样。因为这些都不是开发团队自发出来的，而是上面管你喜欢不喜欢按给你的。Scrum根本不可能增进你的软件质量和技术，只能是优秀的人才才可能！使用Scrum的公司都是些吝啬鬼，他们不愿花大钱招优秀的人，他们妄图使用Scrum这种东西让现有的这些廉价劳动力发挥更大的生产效率，Scrum成了push程序员最有用的工具。</p><p><strong>Reason 5:</strong>Scrum delivers ‘business value’。不是这样的，实际上，Scrum不可能。这有很多原因。真正了解业务的那帮人根本不可能加入项目团队，那些人谁TMD愿意和苦逼的技术人员加班啊。 那些人喜欢和我们的用户吃吃喝喝，花天酒地的，根本不会和你们那些奇怪的东西（如：backlog）或是那堆ugly的内向古怪的技术人员打交道，更别说什么技术了。所以，你的团队就像一个客服团队或救火队一样疲于奔命。</p><p><strong>Reason 6:</strong> 一个敏捷的团队应该是持续进步的。这就是为什么Scrum总是在问什么干得好，什么需要改进，并定义行动方案。你真的以为员工想进步吗？让他们不得不去想想自己和团队怎么进步，然后他们还不得不去执行行动方案。别天真了，人的天性是不喜欢改变的，人的天性是习惯于一些按部就搬的事，也许那样做令人讨厌，但是人家还是能干点东西出来。如果你逼着人家改变，你就是在压迫人家，人家自然会反抗。</p><p><strong>Reason 7:</strong>Product Owner专注于 ‘what’ 和 ‘why’ 的问题，开发团队决定 ‘how’。很不错的分工，于是可以造就一个即高速有重质量的团队。然而，这根本不行。你的Product Owner马上就想要这个功能，他才不管你的软件开发的技术难题，人家只要快，要你meet deadline，要你给我们重要的客户做出承诺。另外，你千万不要以为你们可以轰走这个初级的product owner，因为他的后台是直接汇报到高层管理。你作为一个程序员可能只是其个小部门的一个小喽啰，或者只是外包公司，你觉得可能吗？你觉得建立信任可能吗？</p><p><strong>Reason 8:</strong> 软件质量和生产率成正比。也就是说，质量越高，生产率越高。如果质量不高，你开发效率就会低下，但是谁管呢？我们朝九晚五的上班，质量好了也是做8小时，质量差了也是做8小时，无所为嘛。另外，我们的project manager (或者是Scrum master!) 总是会批评我们没有按计划完成。所以，这根本不可能。</p><p><strong>Reason 9:</strong> “是的，如果我们只做需要的功能，那么我们就会最低的成本，对吗？”，为什么这世上总是会有这些幼稚的人？这种事怎么可能啊。很多很多的银行或保险公司的项目在你还没有启动项目前就谈好了一个价格（可能还会有回扣），为了打单子，销售什么都干得出来，让你去做项目是因为你是廉价劳动力，而且，他们会不断地加需求，因为软件合同谈好的价格时候，连需求都没有，你去做了才有，还是模糊和不确定或根本就是错的，然后需求是越来越多，越改越多。等你精疲力尽的时候，你才意识到，销售早就把你卖了。</p></blockquote><p>这九点抨击了<strong>Scrum方法体系中过度的理想化，构建了一个平等、高效、友善的类乌托邦式的开发团队</strong>。而作者指出这一理想环境是很难在现实中遇到的，无论是开发团队成员拒绝不断积极地改进重构；还是项目负责人只是追求开发结果；还是业务人员不愿与团队交流…这些都是在社会语境下会存在的实际问题。</p><p>我认为国内对于Scrum方法运用的屡屡碰壁也由此的一部分原因。姑且假设Scrum方法是高效的，但是在我国生产环境及行业背景下却很难将这一高效的特性发挥出来（甚至有可能更加低效）。我国的互联网行业普遍存在高级程序员稀缺、低级程序员泛滥的问题。对于某一出现的问题，可能大部分开发者不适沟通与解决。<strong>Scrum更加适合于一帮资深程序员组成的team，每个人都是牛人，每个人都有激情干活</strong>。在国内大家只是干活拿工资，没什么激情，不适合Scrum。</p><p>极限编程在实践落地中的现状与问题已经在前述优劣处提过，在于<strong>过于复杂的实践带来了更高的成本</strong>。结伴开发。每周40工时等一设想几乎不可能在国内互联网公司（尤其是各中小型公司）推广，更多的公司和PM选择借鉴其中的一部分作为项目开发的“建议”。而Xp中的 <strong>价值观 和原则 更是不被互联网公司重视</strong>，可能在互联网及迅速发展的大背景下，更多的公司热衷于能直接带来红利的狼性文化，而不是沟通、简答、反馈和勇气。</p><p>尽管如此，我们依旧发现<strong>国内的生产实践中存在不少实践成功的事例</strong>。早在2008年，在 google 的 Agile China 讨论组中出现了一系列的帖子讨论Scrum ，内容涉及对Scrum 的理解、CSM 的接受程度及其在国内的实施效果等方面。从这些讨论的字里行间不难看出，业内人员已对“敏捷”有了更深入的思考，而不再是最初的模仿。发展至今，也许以Xp和Scrum为代表的敏捷开发早已深入人心，但是其<strong>在具体实践中的细节仍然需要国内互联网从业者们根据国情进行不断的取舍、优化与迭代。</strong></p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><ol><li>极限编程和Scrum作为21世纪兴起的敏捷开发的代表性方法论，各具特性又互相影响。Scrum更多提供了框架供开发团队参考和自我完善。而极限编程作为一整个价值观、原则与实践，为开发的各项环节确定了可供使用的标准。</li><li>二者思想相近、内容相异，彼此在兴起与发展过程中互相融合补充。也在十数年的实践中体现了各自的优劣性与适用场景。</li><li>目前大多数公司采用以Scrum为框架，Xp中借鉴部分的实践方法进行开发。</li><li>国内目前对于二者的应用并不顺利，在引进这两种高效开发方法的同属遇到了很多我国特定的社会与技术问题有待解决。也许未来随着我国互联网产业的进一步成熟，会在此为框架基础上形成一套适合我国国情的中国特色敏捷开发方法体系。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>什么是敏捷    <a href="http://www.scrumcn.com/agile/scrum-knowledge-libray/agile101.html" target="_blank" rel="noopener">http://www.scrumcn.com/agile/scrum-knowledge-libray/agile101.html</a></li><li>什么是SCRUM    <a href="http://www.scrumcn.com/agile/xp.html" target="_blank" rel="noopener">http://www.scrumcn.com/agile/xp.html</a></li><li>什么是极限编程    <a href="http://www.scrumcn.com/agile/scrum-knowledge-library/scrum.html" target="_blank" rel="noopener">http://www.scrumcn.com/agile/scrum-knowledge-library/scrum.html</a></li><li>xp和scrum在实战中的应用问题    <a href="https://www.cnblogs.com/cly84920/archive/2012/12/26/4426470.html" target="_blank" rel="noopener">https://www.cnblogs.com/cly84920/archive/2012/12/26/4426470.html</a></li><li>敏捷方法之极限编程(XP)和 Scrum区别    <a href="https://www.cnblogs.com/dekevin/p/5613664.html" target="_blank" rel="noopener">https://www.cnblogs.com/dekevin/p/5613664.html</a>)</li><li>运用Scrum做项目管理真实案例    <a href="https://blog.csdn.net/lackin/article/details/7265992" target="_blank" rel="noopener">https://blog.csdn.net/lackin/article/details/7265992</a></li><li>Scrum 在中国——企业实施情况调查实录   <a href="https://www.infoq.cn/article/scrum_china_2008_investigate" target="_blank" rel="noopener">https://www.infoq.cn/article/scrum_china_2008_investigate</a></li><li>凤翼天翔——Scrum 在 Yahoo! 中的成功应用    <a href="https://www.infoq.cn/article/2008/03/Scrum-Adoption-in-Yahoo/" target="_blank" rel="noopener">https://www.infoq.cn/article/2008/03/Scrum-Adoption-in-Yahoo/</a></li><li>国人眼中的 Scrum    <a href="https://www.infoq.cn/article/2008/03/Scrum-Perspective-in-China" target="_blank" rel="noopener">https://www.infoq.cn/article/2008/03/Scrum-Perspective-in-China</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了敏捷方法中的极限编程与Scrum，就二者的相似与区别、各自在实践中的优劣势进行了论述分析。并根据相关资料整理得出其在国内应用的现状，进一步分析其背后的原因，并加以展望未来的发展可能性。&lt;/p&gt;
&lt;p&gt;关键词：敏捷开发，极限编程，Scrum，系统开发方法，软件工程&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="软件工程概论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="敏捷开发" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>软件工程概论之过程模型</title>
    <link href="http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-08-21T08:07:53.000Z</published>
    <updated>2020-08-21T08:12:33.255Z</updated>
    
    <content type="html"><![CDATA[<ol><li>过程</li><li>软件过程模型<ol><li>瀑布模型    Waterfall model </li><li>V-模型  V model </li><li>原型模型 Prototyping model </li><li>阶段性开发：增量与迭代  Phased development:  increments and iteration </li><li>螺旋模型  Spiral model </li><li>敏捷开发 Agile methods</li></ol></li></ol><p><em>之前随便记的,千万别用来备考期末</em></p><a id="more"></a><h1 id="软件工程概论-第二章-过程模型与生命周期"><a href="#软件工程概论-第二章-过程模型与生命周期" class="headerlink" title="软件工程概论  第二章  过程模型与生命周期"></a>软件工程概论  第二章  过程模型与生命周期</h1><h2 id="2-1-过程-Meaning-of-Process"><a href="#2-1-过程-Meaning-of-Process" class="headerlink" title="2.1 过程     Meaning of  Process"></a>2.1 过程     Meaning of  Process</h2><p>软件开发不等于写课后题</p><ol><li>实际软件大而复杂</li><li>多人协作，需要及时沟通及对工程的共同理解</li></ol><h3 id="什么是过程？"><a href="#什么是过程？" class="headerlink" title="什么是过程？"></a>什么是过程？</h3><p> A process defines <strong>who</strong> is doing <strong>what, when</strong> and <strong>how</strong>, in order to reach a certain <strong>goal</strong>.</p><p>一组任务的集合。具体是包括：</p><ul><li>分工及workflow：谁去干什么？先干什么？后干什么？</li><li>产品：不止是最终交付的软件，还包括在过程中的某一环节生产出的各种文档、手册、代码etc</li><li>里程碑 Mailstones：如何标志一个环节结束？</li><li>。。。</li></ul><h3 id="使用过程的重要性"><a href="#使用过程的重要性" class="headerlink" title="使用过程的重要性"></a>使用过程的重要性</h3><ol><li>确保生产过程的一致性，以及对项目的整体结构的把握</li><li>指导如何理解项目、控制环节、检查成果。并改善上述活动</li><li>对同一类型（模型） 的生产过程积攒经验，并在下次处理同类问题时应用</li></ol><h3 id="综上，搭建过程模型的理由："><a href="#综上，搭建过程模型的理由：" class="headerlink" title="综上，搭建过程模型的理由："></a>综上，搭建过程模型的理由：</h3><ol><li>确保所有人对该项目有一个统一普遍的理解；</li><li>To find inconsistencies, redundancies, omissions （？？？）</li><li>确定合适的活动来实现其中每个阶段目标，并在时候对其进行评估；</li><li>对特定的、同类型的工程总结普遍的开发规律，并在日后开发时加以运用。</li></ol><h3 id="定义软件过程"><a href="#定义软件过程" class="headerlink" title="定义软件过程"></a>定义软件过程</h3><p>谁做什么，when，how，并且最终达到什么标准</p><p>生命周期是什么</p><p>图：软件开发中的多种阶段</p><h2 id="2-2-过程模型举例"><a href="#2-2-过程模型举例" class="headerlink" title="2.2 过程模型举例"></a>2.2 过程模型举例</h2><h3 id="2-2-1瀑布模型"><a href="#2-2-1瀑布模型" class="headerlink" title="2.2.1瀑布模型"></a>2.2.1瀑布模型</h3><p>严格地串行化过程。</p><ol><li>需求分析完全结束后，生成需求文档作为里程碑。</li><li>在需求文档基础上开始系统设计，生成功能分析表。</li><li>在功能分析表基础上开始程序设计，生成…….</li><li>…….编程</li><li>…….单元测试、集成测试</li><li>…….系统测试</li><li>…….验收测试 &amp; 交付</li><li>……维护与保养</li></ol><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583564856014.png" alt="瀑布模型"></p><h4 id="瀑布模型的特点"><a href="#瀑布模型的特点" class="headerlink" title="瀑布模型的特点"></a>瀑布模型的特点</h4><p>模型易于理解；后续环节完全基于上游环节；每一步严格地具有输入输出的产品/文档；对不同阶段的开发者定义为不同的角色。</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583637124830.png" alt="1583637124830"></p><h4 id="瀑布模型的问题"><a href="#瀑布模型的问题" class="headerlink" title="瀑布模型的问题"></a>瀑布模型的问题</h4><p>要求每一步都需要完全正确。该模型难以回溯至上层环节。</p><p>Where the waterfall model works fine?</p><ul><li>既定的程序和技术</li><li>不需要太多的需求变化</li><li>•组织良好、角色明确的项目</li><li>“可重复”项目</li><li>时间与资金预算充足的大型项目</li></ul><h3 id="2-2-2-原型模型-Prototyping"><a href="#2-2-2-原型模型-Prototyping" class="headerlink" title="2.2.2 原型模型 Prototyping"></a>2.2.2 原型模型 Prototyping</h3><p>迅速建造一个可以运行的软件原型 ，以便理解和澄清问题，使开发人员与用户达成共识，最终在确定的客户需求基础上开发客户满意的软件产品。在需求分析阶段对软件的需求进行初步而非完全的分析和定义，由用户提出修改和细节，最终再进行实现。<img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583637791886.png" alt="1583637791886"></p><h3 id="2-2-3-V-模型-V-mode"><a href="#2-2-3-V-模型-V-mode" class="headerlink" title="2.2.3 V-模型     V-mode"></a>2.2.3 V-模型     V-mode</h3><p>为了解决开发出的软件质量不高问题</p><p>核心：通过设置多次测试来保证软件的质量</p><p>单元测试、集成测试、系统测试、验收测试</p><p>每一步测试不通过时可以向上回溯。</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583567021149.png" alt="1583567021149"></p><h3 id="2-2-4-阶段性开发-Phased-development"><a href="#2-2-4-阶段性开发-Phased-development" class="headerlink" title="2.2.4 阶段性开发    Phased development:"></a>2.2.4 阶段性开发    Phased development:</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>将整体的任务分解成多个小阶段，从而将工作量化简、并减少错误。</p><h4 id="递增开发，increments"><a href="#递增开发，increments" class="headerlink" title="递增开发，increments"></a>递增开发，increments</h4><p>由某一子系统开始开发，在每次版本更新时逐渐新增功能。</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583567710642.png" alt="1583567710642"></p><h4 id="迭代开发，-iterations"><a href="#迭代开发，-iterations" class="headerlink" title="迭代开发， iterations"></a>迭代开发， iterations</h4><p>由整个系统的测试版开始开发，每次更新完善其中的部分模块</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583567758762.png" alt="1583567758762"></p><h4 id="阶段性开发的优点"><a href="#阶段性开发的优点" class="headerlink" title="阶段性开发的优点"></a>阶段性开发的优点</h4><ul><li>产品可以提前发布，即使功能缺失或不完善</li><li>可以为以前从未提供过的功能提前创建市场</li><li>频繁的发布可以让开发人员快速、全面地解决未预料到的问题</li><li>开发团队可以通过不同的发布专注于不同的专业领域</li></ul><h3 id="2-2-5-螺旋开发-Spiral-model"><a href="#2-2-5-螺旋开发-Spiral-model" class="headerlink" title="2.2.5 螺旋开发    Spiral model"></a>2.2.5 螺旋开发    Spiral model</h3><ul><li>引入风险控制</li><li>开发呈现出围绕以下四个维度的螺旋式开发<ol><li>计划</li><li>定义目标、备选方案及限制</li><li>评估备选方案以及风险</li><li>开发与测试</li></ol></li></ul><p>特点：将与代码相关的内容压缩，大部分内容在开发研究</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583568162769.png" alt="1583568162769"></p><h3 id="2-2-6-混合开发-Hybrid-process-models"><a href="#2-2-6-混合开发-Hybrid-process-models" class="headerlink" title="2.2.6 混合开发 Hybrid process models"></a>2.2.6 混合开发 Hybrid process models</h3><p>过程模型有其优劣点与适用场景，不能一概而论。</p><p>下图为不同年代使用的不同开发模型，可见历史上所出现的所有软件工程模型都没有消亡过。（包括最初的瀑布模型）所以断言某一种模型比另外一种好是不可取的。事实上在实际工程项目中，各模型常常混合使用。</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583638636203.png" alt="1583638636203"></p><h3 id="2-2-7-敏捷开发-Agile-methods"><a href="#2-2-7-敏捷开发-Agile-methods" class="headerlink" title="2.2.7 敏捷开发 Agile methods"></a>2.2.7 敏捷开发 Agile methods</h3><p>2001年敏捷宣言 Agile manifesto</p><blockquote><ul><li>重视<strong>个人和交互</strong>，而不是过程和工具。</li></ul><p>value individuals and interactions over processes and tools</p><ul><li>更愿意花时间在<strong>生产工作软件</strong>上，而不是在生产全面的文档上</li></ul><p>invest time in producing working software rather than in producing comprehensive documentation</p><ul><li>专注于<strong>客户协作</strong>而不是合同谈判，从而使客户参与开发过程的关键方面</li></ul><p>focus on customer collaboration rather than contrast negotiation</p><ul><li>专注于<strong>响应变化</strong>而不是先制定计划然后再执行，因为无法事先预料所有情况</li></ul><p>concentrate on responding to change rather than on creating a plan and then following it</p></blockquote><p>敏捷开发包括多种方法体系，这里主要介绍两种：Extreme programming和S</p><h4 id="2-2-7-1-极限编程-Extreme-programming（简称XP）"><a href="#2-2-7-1-极限编程-Extreme-programming（简称XP）" class="headerlink" title="2.2.7.1 极限编程 Extreme programming（简称XP）"></a>2.2.7.1 极限编程 Extreme programming（简称XP）</h4><p>四大基本特征：</p><ol><li><p>Communication</p><p>所有成员要及时沟通。</p></li><li><p>Simplify</p><p>以用户要求为最高标准，不要画蛇添足；越复杂越易错。</p></li><li><p>Courage</p><p>承担责任。所有成员都有权修改任何代码（并承担所有责任）</p></li><li><p>Feedback</p><p>反馈。不断地与客户反馈，并保证反馈的问题被跟踪、完善、解决。</p></li></ol><h4 id="2-2-7-2-Scrum"><a href="#2-2-7-2-Scrum" class="headerlink" title="2.2.7.2 Scrum"></a>2.2.7.2 Scrum</h4><p>Scrum是一个包括了一系列的实践和预定义角色的过程骨架。</p><p>在每一次冲刺（一个15到30 天周期），开发团队创建可用的软件的一个增量。每一个冲刺所要实现的特性来自产品订单（product backlog，产品目标）哪些订单项（目标项目）会被加入一次冲刺，由冲刺计划会议决定。 </p><p>在会议中，产品负责人告诉开发团队他需要完成产品订单中的哪些订单项。开发团队决定在下一次冲刺中他们能够承诺完成多少订单项。 在冲刺的过程中，没有人能够变更冲刺订单（sprint backlog），即使用户需求发生了变化（称为“冻结”）。</p><p>在冲刺中，每一天都会举行项目状况会议，被称为“scrum”或“每日站立会议”。不论团队规模大小，会议被限制在15分钟。所有出席者都应站立或喝咖啡。（有助于保持会议简短）会议应在固定地点和每天的同一时间举行。在会议上，每个团队成员需要回答三个问题：</p><p>你完成了哪些工作？以后你打算做什么？完成你的目标是否存在什么障碍？</p><p>每一个冲刺完成后，都会举行一次冲刺回顾会议，在会议上所有团队成员都要反思这个冲刺。举行冲刺回顾会议是为了进行持续过程改进。会议的时间限制在4小时。</p><p>、</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;软件过程模型&lt;ol&gt;
&lt;li&gt;瀑布模型    Waterfall model &lt;/li&gt;
&lt;li&gt;V-模型  V model &lt;/li&gt;
&lt;li&gt;原型模型 Prototyping model &lt;/li&gt;
&lt;li&gt;阶段性开发：增量与迭代  Phased development:  increments and iteration &lt;/li&gt;
&lt;li&gt;螺旋模型  Spiral model &lt;/li&gt;
&lt;li&gt;敏捷开发 Agile methods&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;之前随便记的,千万别用来备考期末&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="软件工程概论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件工程概论之期末补天笔记</title>
    <link href="http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E6%9C%9F%E6%9C%AB%E8%A1%A5%E5%A4%A9%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E6%9C%9F%E6%9C%AB%E8%A1%A5%E5%A4%A9%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-21T08:06:48.000Z</published>
    <updated>2020-08-21T08:21:58.769Z</updated>
    
    <content type="html"><![CDATA[<p>综述了学校软件工程概论课程的常考知识点(中英对照), 不保证考点完全覆盖.</p><p>推荐<a href="https://blog.csdn.net/sandalphon4869/category_9045731.html" target="_blank" rel="noopener">一位学长的博客</a>, 建议搭配打印店往年题食用, 效果奇佳.</p><p>西电无纸化之软件工程分群:929629717</p><a id="more"></a><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="定义-软件"><a href="#定义-软件" class="headerlink" title="定义: 软件"></a>定义: <strong>软件</strong></h3><p><em>必考</em></p><p>软件是文档、指令、数据结构的集合</p><ul><li><strong>Documents</strong> that describe the operation and use of the programs.<br>文档描述了程序的操作(operation)和使用(use)。</li><li><strong>Instructions</strong> (computer programs) that when executed provide desired function and performance;<br>指令在执行时提供了所需的功能(function)和性能(performance)。</li><li><strong>Data</strong> <strong>structures</strong> that enable the programs to adequately manipulate information;<br>数据结构使程序能够充分地操作信息(information)。</li></ul><h3 id="软件的3个特性"><a href="#软件的3个特性" class="headerlink" title="软件的3个特性"></a><strong>软件的3个特性</strong></h3><p><em>理解</em></p><ol><li>Software is developed or engineered, it is not manufactured in the classical sense.<br>软件是开发或工程的，而不是传统意义上的制造.</li><li>Software doesn’t “wear out”, but it does deteriorate.<br>软件不会“磨损”，但会恶化。</li><li>Most software is custom-built, rather than being assembled from existing component.<br>大多数软件都是定制的，而不是由现有组件组装而成.</li></ol><h3 id="定义-软件工程"><a href="#定义-软件工程" class="headerlink" title="定义: 软件工程 "></a>定义: <strong>软件工程 </strong></h3><p><em>必考</em></p><p>The application of a <strong>systematic</strong> , <strong>disciplined</strong>, <strong>measure-able</strong> approach to the <strong>development</strong>, <strong>operation</strong>, and <strong>maintenance</strong> of software. That is, the application of engineering to software.</p><p>软件工程是将系统的(systematic)、规范的(disciplined)、可度量的(measurable)方法应用于软件的开发(development)、运行(operation)和维护(maintenance)的过程，即将工程化应用于软件中。</p><h3 id="软件涉及到的人员"><a href="#软件涉及到的人员" class="headerlink" title="软件涉及到的人员"></a>软件涉及到的人员</h3><ul><li>consumer   需求提出者</li><li>developer   开发人员</li><li>user   软件的实际使用者</li></ul><h3 id="质量指标"><a href="#质量指标" class="headerlink" title="质量指标"></a>质量指标</h3><p> <em>理解</em></p><ol><li><p>The Quality of the Product,  <strong>McCall</strong></p><p>度量<strong>软件质量</strong>的指标模型</p></li><li><p>The Quality of the Process,  <strong>CMM</strong> (Capability Maturity Mode)</p><p>度量<strong>过程质量</strong>的指标模型</p></li><li><p>The Quality in the Context of the Business Environment, <strong>ROI</strong></p><p>度量<strong>商业价值</strong>的指标模型</p></li></ol><h2 id="第二章-过程"><a href="#第二章-过程" class="headerlink" title="第二章 过程"></a>第二章 过程</h2><h3 id="定义-过程-process"><a href="#定义-过程-process" class="headerlink" title="定义: 过程 process"></a>定义: <strong>过程 process</strong></h3><p><em>必考</em></p><p>process：</p><ul><li>A series of <strong>ordered steps</strong> involving <u><strong>activities</strong>, <strong>constraints</strong>, and <strong>resources</strong></u> that <strong><u>produce an intended output</u></strong> of some kind.</li><li>一系列涉及活动、约束和资源的步骤，这些步骤会产生某种预期的输出。</li></ul><h3 id="Characteristics-of-process"><a href="#Characteristics-of-process" class="headerlink" title="Characteristics of process"></a>Characteristics of process</h3><p><em>了解</em></p><ol><li>过程描述了所有主要的过程活动。<pre><code>   The process describes all the major  process activities.</code></pre></li><li>这个过程使用资源，但受到一系列限制，并生产中间产品和最终产品。<pre><code>   The process uses the resources, subject to a set of constraints, and produces intermediate and final products.</code></pre></li><li>过程可能由以某种方式链接的子过程组成。<pre><code>     The process may be composed of sub-processes that that linked in some way。</code></pre></li><li>每个过程活动都有进入和退出标准，因此我们知道活动开始和结束的时间。<pre><code>   Each process activity has entry and exit criteria, so that we know when the activity begins and ends .</code></pre></li><li>活动按顺序组织，因此一个活动相对于另一个活动的执行时间很清楚。<pre><code>     The activities are organized in a sequence, so that it is clear when one activity is performed relative to the other activity .</code></pre></li><li>每个过程都有一组指导原则来解释每个活动的目标。<pre><code>     Every process has a set of guiding principles that explain the goals of each activity。</code></pre></li><li>约束或控制可以应用于活动、资源或产品<pre><code>   Constraints  or controls may apply to an activity, resource, or product。</code></pre></li></ol><h3 id="定义-生命周期-Life-cycle"><a href="#定义-生命周期-Life-cycle" class="headerlink" title="定义: 生命周期 Life cycle"></a>定义: <strong>生命周期 Life cycle</strong></h3><p><em>必考</em></p><ul><li>当过程涉及到建设某些产品，我们有时把过程称为生命周期。</li><li>when the process involves the building of some product, we sometimes refer to the process as a life cycle.</li><li>The life cycle of a software product include <strong>conception</strong>(概念化)，<strong>implementation</strong>(实现)，<strong>delivery</strong>(交付)，<strong>use</strong>, <strong>maintenance</strong>.(维护)</li></ul><h3 id="定义-模型"><a href="#定义-模型" class="headerlink" title="定义: 模型"></a>定义: 模型</h3><p>  <em>了解</em></p><ul><li>一个过程可以用多种方法来描述，使用文字、图片或组合</li></ul><p>A process can be described in a variety of ways, using text, pictures or a combination.</p><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a><strong>瀑布模型</strong></h4><p><em>必考(步骤与优缺点)</em></p><h4 id="Step-8"><a href="#Step-8" class="headerlink" title="Step (8)"></a>Step (8)</h4><ol><li>Requirements Analysis 需求分析</li><li>System Design 系统设计</li><li>Program Design 程序设计</li><li>Coding 编程</li><li>Unit &amp; Integration Test 单元&amp;集成测试</li><li>System Test 系统测试</li><li>Acceptance Test 验收测试</li><li>Operation &amp; Maintenance 使用与维护</li></ol><p>特点</p><ol><li><p>One of the first process development models </p><p>是第一个被提出的开发模型之一</p></li><li><p>Works for well understood problems with minimal or no changes in the requirements</p><p>仅需极少的需求或没有任何变化即可解决众所周知的问题</p></li><li><p>It presents a very high-level view of the development process开发过程的顶层理解</p></li><li><p>and sequence of process activities 过程活动的顺序</p></li><li><p>Each major phase is marked by milestones and deliverables  每个主要阶段都具有里程碑和可交付成果</p></li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>The waterfall model can be very useful in <u>helping developers lay out what they need to do</u>.</p><p>在帮助开发人员规划他们需要做的事情时非常有用</p></li><li><p>Its simplicity makes it <u>easy to explain to customers</u> who are not familiar with software development.</p><p>它的简单性使得向不熟悉软件开发的客户解释它很容易</p></li><li><p>It <u>makes explicit which intermediate products are necessary</u> in order to begin the next stage of development.</p><p>它明确了哪些中间产品是必要的，以便开始下一阶段的开发。</p></li><li><p>Many other,more complex models are really just embellishments of waterfall,incorporating feedback loops and extra activities. </p><p>许多其他更复杂的模型实际上只是瀑布的点缀</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>Provides no guidance how to handle changes to products and activities during development (<u>assumes requirements can be frozen</u>)</p><p>没有提供有关如何在开发过程中处理产品和活动更改的指导（假设要求可以冻结）</p></li><li><p>Views software development as manufacturing process rather than as creative process</p><p>将软件开发视为制造过程而非创意过程</p></li><li><p>There is <u>no iterative activities</u> that lead to creating a final Product</p><p>没有迭代活动可以创建最终产品</p></li><li><p>Long wait before a final product</p><p>长时间等待最终产品</p></li></ul><h2 id="第三章-项目管理"><a href="#第三章-项目管理" class="headerlink" title="第三章 项目管理"></a>第三章 项目管理</h2><h3 id="定义-进度-Schedule"><a href="#定义-进度-Schedule" class="headerlink" title="定义: 进度 Schedule"></a>定义: 进度 Schedule</h3><ul><li>A project schedule describes the software development cycle for a particular project by enumerating the phases or stages of the project and breaking each into discrete tasks or activities to be done.</li><li>项目进度通过列举项目的时期或阶段，并将每个阶段分解为待完成的离散任务或活动来描述特定项目的软件开发周期。</li><li>The schedule is a <strong>timeline</strong> that shows when activities will begin and end,and when the related development products while be ready.</li><li>进度是显示活动开始和结束的时间线，以及相关开发产品准备就绪的时间线</li></ul><h3 id="定义-活动"><a href="#定义-活动" class="headerlink" title="定义: 活动"></a>定义: <strong>活动</strong></h3><ul><li>An activity is a <u>part of the project that takes place over a period of time</u>.</li><li>活动是在一段时间内发生的项目的一部分</li></ul><h3 id="定义-里程碑-Milestone"><a href="#定义-里程碑-Milestone" class="headerlink" title="定义: 里程碑 Milestone"></a>定义: <strong>里程碑</strong> Milestone</h3><ul><li>A milestone is <strong><u>the completion of an activity</u></strong>，<strong><u>a particular point in time</u></strong>.</li><li>里程碑是一个活动的完成，一个特定的时间点。</li></ul><h3 id="WBS"><a href="#WBS" class="headerlink" title="WBS"></a>WBS</h3><ul><li>工作分解结构(WBS)将项目描述为一组离散的工作片段。</li><li>work breakdown structure depicts the project as a set of discrete pieces of work.<ul><li>Precursor is an event or set of events that must occur before the activity can begin.<br>前驱是在活动开始之前必须发生的一个或一组事件。</li><li>Due date is the date by which the activity must be completed,frequently determined by contractual deadlines.<br>截止时间是活动必须完成的日期，通常由合同期限决定。</li><li>Duration is length of time needed to complete an activity。<br>工期是完成一项活动所需的时间长度。</li><li>Endpoint is usually a milestone or deliverable<br>终点是里程碑或可交付件。</li></ul></li></ul><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><ul><li>The critical path is the one for which the slack at every node is zero.</li><li>关键路径是每个节点的松弛度为零的路径。</li></ul><p>从活动图找出关键路径!!! 书后两条练习题 ⭐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于活动A_B,P-A-B-S 表示前驱活动P_A,后继活动B_S</span></span><br><span class="line"><span class="comment">//活动A_B可能有不止一个前驱/后继, 此时用Pi_A,B_Si表示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> time_point int<span class="comment">//时刻</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> time_period int<span class="comment">//时间段</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> START 1<span class="comment">//开始时间=1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END END<span class="comment">//结束时间END</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回活动A_B的前驱活动数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回活动A_B的后继活动数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">time_period <span class="title">T</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回活动A_B需要的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">time_point <span class="title">EST</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    time_point re;</span><br><span class="line">    <span class="keyword">int</span> preNum = pre(A_B);</span><br><span class="line">    <span class="keyword">if</span>(preNum == <span class="number">0</span>)</span><br><span class="line">        re = START;</span><br><span class="line">    <span class="keyword">if</span>(preNum == <span class="number">1</span>)</span><br><span class="line">        re = EST(P_A) + T(P_A);</span><br><span class="line">    <span class="keyword">if</span>(preNum &gt; <span class="number">1</span>)</span><br><span class="line">        re = <span class="built_in">max</span>(EST(Pi_A) + T(Pi_A));</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">time_point <span class="title">LST</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    time_point re;</span><br><span class="line">    <span class="keyword">int</span> subNum = sub(A_B);</span><br><span class="line">    <span class="keyword">if</span>(subNum == <span class="number">0</span>)</span><br><span class="line">        re = END - T(A_B);</span><br><span class="line">    <span class="keyword">if</span>(subNum == <span class="number">1</span>)</span><br><span class="line">        re = LST(B_S) - T(A_B);</span><br><span class="line">    <span class="keyword">if</span>(subNum &gt; <span class="number">1</span>)</span><br><span class="line">        re = <span class="built_in">min</span>(LST(B_Si) - T(A_B));</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四章-需求分析"><a href="#第四章-需求分析" class="headerlink" title="第四章 需求分析"></a>第四章 需求分析</h2><h3 id="定义-需求"><a href="#定义-需求" class="headerlink" title="定义: 需求"></a>定义: 需求</h3><ul><li><p>An <strong>Expression</strong> of desired <strong>Behavior</strong></p><p>期望行为的一种表达。</p></li></ul><p>四种需求</p><ul><li><p>functional requirement : 功能性需求</p><p>describes required behavior in terms of required activities</p></li><li><p>nonfunctional requirement (quality function) 非功能性需求(质量需求)</p><p>describes some quality characteristic that the software must possess.</p></li><li><p>design constraint 设计约束</p><p>a design decision,such as choice of platform.</p></li><li><p>process constraint 过程约束</p><p>a restriction on the techniques or resources that can be used to build the system.</p></li></ul><h3 id="ERD（实体关系图）"><a href="#ERD（实体关系图）" class="headerlink" title="ERD（实体关系图）"></a>ERD（实体关系图）</h3><ul><li><p>entity-relationship diagram (ERD): </p><p>is a popular graphical notational paradigm.</p></li><li><p>三要素</p><ul><li>An entity, epicted as a rectangle, represents a collection of  <pre><code>real-world objects that have common properties and behaviors.</code></pre></li><li>A relationship, depicted as an edge between two entities, with diamond<pre><code>in the middle  of the edge specifying the type of relationship.</code></pre></li><li>An attribute, an annotation(注释) on an entity that describes data or <pre><code>properties associated with the entity.</code></pre></li></ul></li></ul><h3 id="DFD-Data-Flow-Diagram数据流图"><a href="#DFD-Data-Flow-Diagram数据流图" class="headerlink" title="DFD Data Flow Diagram数据流图"></a>DFD Data Flow Diagram数据流图</h3><p>Process, data flow, data store, actors </p><h3 id="UCD-（用例图）"><a href="#UCD-（用例图）" class="headerlink" title="UCD （用例图）"></a>UCD （用例图）</h3><ul><li>概念: use-case diagram(UCD) is similar to a top-level data-flow diagram that depicts observable,user-initiated functionality in terms of interactions between the system and its environment.用例图(UCD)类似于顶级数据流图，根据系统和环境之间的交互描述可观察的、用户发起的功能。</li><li>用处: <u>用于表示需求, 不是设计</u></li><li>怎么画?<ul><li>边界</li><li>case</li></ul></li></ul><h3 id="两种文档-区别作用"><a href="#两种文档-区别作用" class="headerlink" title="两种文档 (区别作用)"></a>两种文档 (区别作用)</h3><ul><li><p>require <strong><u>definition</u></strong> 需求分析说明书 For <strong>Customer</strong></p><p>一般是对某个市场或者是客户群来讲的，类似于调研报告，重点是体现出产品要满足哪些功能，哪些是重点、热点。</p></li><li><p>require <strong><u>specificatiuon</u></strong> 需求规格说明书 For <strong>Developer</strong></p><p>是从业务规则讲起的，细一点偏向于软件的概要设计。是从开发、测试的角度去讲产品功能，里面要包含原型界面、业务接口、活动图等 </p></li></ul><h2 id="第五章-体系结构"><a href="#第五章-体系结构" class="headerlink" title="第五章 体系结构"></a>第五章 体系结构</h2><h3 id="定义-设计"><a href="#定义-设计" class="headerlink" title="定义: 设计"></a>定义: 设计</h3><ul><li>Design is the creative process of figuring out how to implement all of the customer’s requirements; </li><li>the resulting plan is also called the design.</li><li>设计是找出如何实现客户所有要求的创造性过程;</li><li>最终的方案也称为设计。</li></ul><h3 id="体系结构三要素-3C-⭐"><a href="#体系结构三要素-3C-⭐" class="headerlink" title="体系结构三要素(3C)⭐"></a>体系结构三要素(3C)⭐</h3><p>软件体系结构={构件，连接件，约束}</p><ul><li>component(构件): 可以是一组代码，如程序模块，也可以是一个独立运行的程序，如数据库服务器。</li><li>connector(连接件):可以是过程调用，管道，远程调用等，用于表示构建之间的相互作用。</li><li>constraint(约束)：对象的连接规则。</li></ul><p>分解</p><p>自顶向下</p><p>合成</p><h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><p>概念! </p><ul><li>管道过滤器 <strong>Piper-and-Filter</strong><ul><li>管道是干什么的? 过滤器是什么?</li><li>Transmit data form one filter to then next</li><li>MIS system of XIDIAN University 西电迎新系统</li></ul></li><li>客户服务器 <strong>Client-Server</strong><ul><li>Most transaction processing system(事务处理系统)    Eg. Bank System</li></ul></li><li>…</li></ul><h2 id="第六章-模块设计"><a href="#第六章-模块设计" class="headerlink" title="第六章 模块设计"></a>第六章 模块设计</h2><p>什么是模块化?</p><ul><li>Modularity, also called separation of concerns, is the principle of keeping separate the various unrelated aspects of a system, so that each aspect can be studied in isolation. </li><li>不相关的方面的相互独立</li></ul><p>什么是独立性? Independence?   Separation of Concern</p><h3 id="Coupling-六耦合"><a href="#Coupling-六耦合" class="headerlink" title="Coupling 六耦合"></a>Coupling 六耦合</h3><ul><li>非直接耦合 Uncoupled</li><li>数据耦合 Data</li><li>标记耦合 Stamp</li><li>控制耦合 Control</li><li>公共耦合 Common</li><li>内容耦合 Content</li></ul><h3 id="Concerns-七内聚"><a href="#Concerns-七内聚" class="headerlink" title="Concerns  七内聚"></a>Concerns  七内聚</h3><ul><li>偶然内聚 Coincidence</li><li>逻辑内聚 Logic</li><li>时间内聚 Temporal</li><li>过程内聚 Procedural</li><li>通信内聚 Communicational</li><li>功能内聚 Functional</li><li>(信息内聚) Information</li></ul><p>耦合与内聚 各考一个(判断是什么类型的耦合\内聚)</p><h2 id="第七章-编程"><a href="#第七章-编程" class="headerlink" title="第七章 编程"></a>第七章 编程</h2><h3 id="程序三要素"><a href="#程序三要素" class="headerlink" title="程序三要素"></a>程序三要素</h3><ul><li>控制结构 Control Structural</li><li>算法 Algorithm</li><li>数据结构 Data Structure</li></ul><h3 id="注释-Head-comment-Block"><a href="#注释-Head-comment-Block" class="headerlink" title="注释: Head_comment_Block"></a>注释: Head_comment_Block</h3><p>里面有什么东西(7个)</p><ol><li>Program SCAN</li><li>Programmer</li><li>Calling sequence</li><li>Version</li><li>Revision</li><li>Purpose</li><li>Data structure</li><li>Algorithm</li></ol><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>内部 Internal documentation</p><ul><li>Head Comment Block</li><li>Other Program Comment</li><li>Meaningful Variable Names and Statement Labels</li><li>Formatting to Enhance Understanding</li></ul><p>外部 External documentation</p><ul><li>describing the problem</li><li>describing the algorithm</li><li>describing the data</li></ul><p>各包括什么content</p><h2 id="第八章-单元测试-⭐"><a href="#第八章-单元测试-⭐" class="headerlink" title="第八章 单元测试 ⭐"></a>第八章 单元测试 ⭐</h2><p>测试方法</p><p>测试用例: </p><ul><li>A test point or test case is <u>a particular choice of <strong>input data</strong></u> to be used in test a program.</li><li>测试点或测试用例是用于测试程序的输入数据的特定选择</li></ul><p>覆盖  由方法选数据</p><p>黑盒白盒: 各测试什么(功能/结构)</p><ul><li>We view the test object form the outside as a <u>closed or black box</u> whose contents are unknown, our testing <strong>feeds inputs to the closed box and notes what output is produced.</strong><br>我们从外部将测试对象视为一个关闭的或内容未知的黑盒，我们的测试将输入输入到关闭的盒子中，并记录产生了什么输出。</li><li>We view the test object as an <u>open</u> <u>box and or white box</u>, we can use the <strong>structure</strong> of the test object to test in different way.<br>我们将测试对象看作是一个开放的盒子或者白盒子，我们可以使用测试对象的结构以不同的方式进行测试。</li></ul><p>路径测试———-给程序, 画流程图,画控制图; 给图, 找测试路径</p><h2 id="第九章-系统测试"><a href="#第九章-系统测试" class="headerlink" title="第九章 系统测试"></a>第九章 系统测试</h2><p>Rush Time 高峰时间</p><p>概念: 前五个</p><ul><li>压力 Stress Test</li><li>容量 Volume Test</li><li>配置 Configuration Test</li><li>Compatibility Test</li><li>Regression Test</li><li>…</li></ul><h2 id="第十章-系统交付"><a href="#第十章-系统交付" class="headerlink" title="第十章 系统交付"></a>第十章 系统交付</h2><p>概念</p><ul><li><p>R 可靠性</p><p>The software reliability is a <strong>possibility</strong> of the system will <strong>operate without failure</strong> under a given conditions and a given time interval.<br>软件可靠性是指系统在给定条件和给定时间间隔下无故障运行的可能性。</p></li><li><p>A 可用性</p><p>The software availability is the <strong>probability</strong> that a system <strong>is operating successfully</strong> according to specification at a given point of time.</p></li><li><p>M 可维护性</p><p>The software maintainability is the probability that , for a given condition of use, a maintenance activity <strong>can be carried out</strong> within stated time interval and using stated procedures and resources.</p><p>给定的使用条件下，可以在规定的时间间隔内并使用规定的过程和资源进行维护活动的可能性。</p></li><li><p>PPT原话!!!!</p></li></ul><h2 id="第十一章-系统维护"><a href="#第十一章-系统维护" class="headerlink" title="第十一章 系统维护"></a>第十一章 系统维护</h2><p>维护的定义</p><p>Any work done to change the system after it is in operation is considered to be maintenance.<br>在系统运行后为改变系统所做的任何工作都被认为是维护。</p><p>四类维护: 判断是什么样的维护…</p><ol><li>Corrective Maintenance     ：Bug 改正性维护</li><li>Adaptive Maintenance    ：Table-Driven Design 适应性维护</li><li>Perfective Maintenance    : DB Upgrade to New Version 完善性维护</li><li>Preventive Maintenance    : Printer Driver: Print-line 预防性维护</li></ol><h2 id="彩蛋-2020年软工概论考题回忆版"><a href="#彩蛋-2020年软工概论考题回忆版" class="headerlink" title="彩蛋: 2020年软工概论考题回忆版"></a>彩蛋: 2020年软工概论考题回忆版</h2><p>题型:选择*15+判断*10+简答*5+大题*3</p><p>选择判断基本全是课后题里面的原句扣关键字</p><p>20年简答:<br>简述瀑布模型及优缺点<br>ERD三要素及功能<br>简述pip and filter的功能<br>简述Head block comment包括的内容<br>简述corrective maintenance</p><p>20年大题:<br>Critical Path<br>Branch Test<br>Logic Flow-&gt;possible path</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;综述了学校软件工程概论课程的常考知识点(中英对照), 不保证考点完全覆盖.&lt;/p&gt;
&lt;p&gt;推荐&lt;a href=&quot;https://blog.csdn.net/sandalphon4869/category_9045731.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一位学长的博客&lt;/a&gt;, 建议搭配打印店往年题食用, 效果奇佳.&lt;/p&gt;
&lt;p&gt;西电无纸化之软件工程分群:929629717&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="软件工程概论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之概述</title>
    <link href="http://yoursite.com/2020/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%A6%82%E8%BF%B0/</id>
    <published>2020-08-14T07:45:25.000Z</published>
    <updated>2020-08-16T07:57:23.751Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统 系列文章链接🔗</p><p>操作系统之概述:</p><ol><li>OS 定义</li><li>OS 历史</li><li>OS 分类</li><li>计算机底层硬件一览</li><li>OS 中的基本概念</li><li>系统调用</li><li>OS 结构</li></ol><a id="more"></a><h1 id="操作系统-系列文章链接🔗"><a href="#操作系统-系列文章链接🔗" class="headerlink" title="操作系统 系列文章链接🔗"></a>操作系统 系列文章链接🔗</h1><ol><li>操作系统之概述 (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol><h1 id="操作系统之概述"><a href="#操作系统之概述" class="headerlink" title="操作系统之概述"></a>操作系统之概述</h1><p>本章将涉及: </p><ol><li>OS 定义</li><li>OS 历史</li><li>OS 分类</li><li>计算机底层硬件一览</li><li>OS 中的基本概念</li><li>系统调用</li><li>OS 结构</li></ol><p><em>本部分基础概念较多, 仅为应付考试, 中英混杂且不做过多解释.  <del>背就完事了</del></em> </p><h2 id="OS定义"><a href="#OS定义" class="headerlink" title="OS定义"></a>OS定义</h2><h3 id="计算机系统的组成部分"><a href="#计算机系统的组成部分" class="headerlink" title="计算机系统的组成部分"></a>计算机系统的组成部分</h3><p>A computer system consists of </p><ol><li>硬件 Hardware </li><li>系统程序 system programs</li><li>应用程序 application programs</li></ol><h3 id="操作系统扮演的角色"><a href="#操作系统扮演的角色" class="headerlink" title="操作系统扮演的角色"></a>操作系统扮演的角色</h3><ol><li>an extended machine (对于用户: 让用户更好地使用机器, 是硬件的包装接口) </li><li>a resource manager (对于机器: 告知机器如何分配硬件资源, 是用户的命令代理执行者, 也是资源的分配者)</li></ol><p>是 an intermediary(中间调解人) between a user of a computer and the computer hardware.</p><h3 id="Operating-system-goals"><a href="#Operating-system-goals" class="headerlink" title="Operating system goals"></a>Operating system goals</h3><ol><li>Execute user programs and make solving user problems <strong>easier</strong>. <strong>简单</strong></li><li>Make the computer system <strong>convenient</strong> to use. <strong>易用</strong></li><li>Use the computer hardware in an <strong>efficient</strong> manner. <strong>高效</strong></li><li>Permit effective development, testing, and introduction of new system functions without interfering with service. （<strong>易于扩充</strong>）</li></ol><h3 id="一些正确叙述"><a href="#一些正确叙述" class="headerlink" title="一些正确叙述"></a>一些正确叙述</h3><ul><li><p><strong>Resource allocator</strong> – manages and allocates resources. </p></li><li><p><strong>Control program</strong> – controls the execution of user programs and operations of I/O devices .</p></li><li><p><strong>Kernel</strong> – the one program running at all times (all else being application programs).</p><p>OS 是唯一运行在内核态的程序, 并且是全程运行, 并且先于其他程序运行</p></li><li><p>OS 与用户交互的界面: <strong>Shell</strong> : 文本交互; <strong>GUI</strong> : 图像交互</p></li><li><p>内核态中, OS对所有的硬件具有完全的访问权, 可以执行任何对于硬件的指令. 而用户级程序只能使用机器指令中的子集</p></li></ul><h2 id="OS历史"><a href="#OS历史" class="headerlink" title="OS历史"></a>OS历史</h2><p>根据计算机本身的发展而发展</p><ul><li><p>真空管, 穿孔卡</p></li><li><p>晶体管, 批处理程序</p></li><li><p>集成电路, 多道程序Multiprogramming        </p><p>多道程序: 在计算机中同时存放多个作业( 但不一定是绝对意义上的 <strong>同时</strong> 运行 详细请参看进程一章)</p></li><li><p>个人计算机</p></li><li><p>手持计算机</p></li></ul><h2 id="OS分类"><a href="#OS分类" class="headerlink" title="OS分类"></a>OS分类</h2><ul><li> Mainframe operating systems （大型机OS）</li><li> Server operating systems （服务器OS） </li><li> Multiprocessor operating systems （多处理机OS） </li><li> Personal computer operating systems （个人计算机OS）</li><li> Real-time operating systems （实时 OS） <ul><li>硬实时: <ul><li>辅助储存空间有限或不存在, 所有数据只在寄存器或只读存储器ROM中保存</li><li>例如: 导弹制动系统</li><li>由于不存在任何辅助储存空间, 因此与分时系统是冲突的</li></ul></li><li>软实时: <ul><li>部分关键实时任务的优先级高于其他任务，并保留该优先级直到完成为止</li><li>例如:  industrial control or robotics 以及 applications (多媒体 VR等) requiring  advanced operating system features.</li></ul></li></ul></li><li> Embedded operating systems （嵌入式OS）</li><li> Smart card operating systems （智能卡OS)</li></ul><h2 id="计算机底层硬件"><a href="#计算机底层硬件" class="headerlink" title="计算机底层硬件"></a>计算机底层硬件</h2><p>计算机包括这些硬件组成部分</p><ol><li>CPU </li><li>Main Memory</li><li>IO Module</li><li>System Bus</li><li>…</li></ol><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/toplevel.png" alt=""></p><h3 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h3><p>从内存中提取指令并执行它们。 </p><ul><li>每个CPU都有一组可以执行的特定指令 称为该CPU的指令集( 例如8086指令集)</li><li>因为访问内存以获取指令或数据字比执行一条指令要花费更长的时间，所以所有CPU都在其中包含一些寄存器来保存键变量和临时结果。</li></ul><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><ul><li>中断是CPU 在工作中的必要操作, 能够使工作更加高效</li><li>An interruption of the normal sequence of execution  </li><li>例如等待IO的过程中执行别的进程, 在IO结束时产生中断回到原进程继续执行</li><li>运行 - 中断 - 恢复 - 运行</li><li>中断分类<ul><li>程序中断<ul><li>运算溢出</li><li>除零</li><li>页面失效</li><li>执行非法指令</li></ul></li><li>时钟中断<ul><li>程序片使用完毕</li></ul></li><li>IO 中断</li><li>硬件错误</li></ul></li></ul><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><h4 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/cache.png" alt=""></p><ul><li>每一级都是下一级的内容的子集</li><li>从上到下: 更大 更慢 更便宜</li></ul><p>详见内存管理章节</p><h4 id="DMA-直接存储器存取"><a href="#DMA-直接存储器存取" class="headerlink" title="DMA 直接存储器存取"></a>DMA 直接存储器存取</h4><p>Transfers a block of data directly to or from memory</p><p>可以在不经有CPU的情况下直接访问Data Bus, 用于进一步简化CPU等待时间</p><h4 id="基址-限址-MMU"><a href="#基址-限址-MMU" class="headerlink" title="基址 限址 MMU"></a>基址 限址 MMU</h4><ul><li>Base register and limit register 基址寄存器和限界寄存器</li><li>MMU (Memory Management Unit) 内存管理单元</li></ul><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>IO设备实际上包括(控制器与设备本身) A controller and the device itself. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/device.png" alt=""></p><p>IO中断</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/io.png" alt=""></p><ul><li>(a) Steps in starting an I/O device and getting interrupt 设备如何发起中断 </li><li>(b) How the CPU is interrupted 中央处理器如何处理中断</li></ul><p>总线</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/bus.png" alt=""></p><h2 id="OS概念"><a href="#OS概念" class="headerlink" title="OS概念"></a>OS概念</h2><h3 id="程序管理相关"><a href="#程序管理相关" class="headerlink" title="程序管理相关"></a>程序管理相关</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li>Process: a program in execution.</li></ul><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><ul><li>Address space: a list of memory locations from some minimum to some maximum, which the process can read and write.</li></ul><h4 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h4><ul><li>Process table: where all the information about each process is stored in.</li></ul><h4 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h4><ul><li>process tree </li></ul><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul><li>process is divided into threads that can run simultaneously </li><li>线程 Thread : <ul><li>CPU可分配的最基本单元</li><li>能够执行与中断</li></ul></li></ul><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><ul><li>Inter-process communication<ul><li>Related processes that are cooperating to get some job done often need to communicate with one another and synchronize their activities.</li><li>为了完成某项工作而进行协作的相关流程通常需要彼此通信并同步其活动。</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>Deadlock: when two or more processes are interacting, they can sometimes get themselves into a stalemate (僵持) situation they cannot get out of.</li></ul><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ul><li>Pipe: a sort of pseudofile that used to connect two processes.</li></ul><h3 id="文件管理相关"><a href="#文件管理相关" class="headerlink" title="文件管理相关"></a>文件管理相关</h3><h4 id="设备无关性"><a href="#设备无关性" class="headerlink" title="设备无关性"></a>设备无关性</h4><p>操作系统的主要功能是隐藏磁盘和其他IO设备的特性，并为程序员提供一个与设备无关的文件的漂亮，简洁的抽象模型。<strong>设备无关性</strong> : device-independent</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li>Director: A place to keep files, a way of grouping files together. System calls are then needed to create and remove directories. </li></ul><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul><li><p>File system: Calls are also provided to put an existing file in a directory, and to remove a file from a directory. Directory entries may be either files or other directories.</p></li><li><p>挂载mount</p></li></ul><h3 id="架构相关"><a href="#架构相关" class="headerlink" title="架构相关"></a>架构相关</h3><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><ul><li>Microkernel architecture （微内核结构）</li><li>assigns only a few essential functions to the kernel 只分配了最基本功能<ul><li>➢ address space </li><li>➢ inter-process communication (IPC)</li><li>➢ basic scheduling</li></ul></li></ul><h4 id="对称多处理"><a href="#对称多处理" class="headerlink" title="对称多处理"></a>对称多处理</h4><ul><li>Symmetric multiprocessing（对称多处理） <ul><li>there are multiple processors 多个处理器</li><li>these processors share same main memory and I/O facilities   共享主存与IO设备</li><li>All processors can perform the same functions  所有处理器可执行相同的功能</li></ul></li></ul><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><ul><li>Distributed operating systems（分布）<ul><li>provides the illusion of a single main memory and single secondary memory space 虽然是分布式但是给人感觉像是单个主存单个辅助存储空间的错觉</li><li>used for distributed file system 常用于分布式文件系统</li></ul></li></ul><h4 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h4><ul><li>Object-oriented design（面向对象设计） <ul><li>used for adding modular extensions to a small kernel  用于向小内核添加模块化扩展</li><li>enables programmers to customize an operating system without disrupting system integrity 使程序员能够自定义操作系统，而不会破坏系统完整性</li></ul></li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="系统调用的流程"><a href="#系统调用的流程" class="headerlink" title="系统调用的流程"></a>系统调用的流程</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/sys%20call.png" alt=""></p><p>系统调用需要11步来实现</p><p>以 <code>read (fd, buffer, nbytes)</code> 为例; 从 <code>fd</code> 文件向<code>buffer</code> 缓冲区中读入 <code>nbytes</code> 内容</p><ol><li>用户程序:  保存 <code>nbytes</code> 参数</li><li>用户程序:  保存 缓冲区地址 参数</li><li>用户程序:  保存 文件 参数</li><li>用户程序:  调用库函数中的代码</li><li>库程序:      将相关代码存入寄存器</li><li>陷入内核, 此时CPU的使用权转移至内核态</li><li>处理指令</li><li>读取数据</li><li>返回库程序</li><li>返回用户程序</li><li>用户程序:  SP++ 执行下一条指令</li></ol><h3 id="常见的系统调用"><a href="#常见的系统调用" class="headerlink" title="常见的系统调用"></a>常见的系统调用</h3><h4 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/unix1.png" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/unix2.png" alt=""></p><h4 id="Win32"><a href="#Win32" class="headerlink" title="Win32"></a>Win32</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/win32.png" alt=""></p><h2 id="OS结构"><a href="#OS结构" class="headerlink" title="OS结构"></a>OS结构</h2><h3 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h3><ul><li>Monolithic system (单体系统): The structure is that there is <strong>no structure</strong>. </li><li>The OS is written as a collection of procedures, each of which can call any of the other ones whenever it needs to.操作系统是作为过程的集合编写的，每个过程都可以在需要时调用任何其他过程。</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/mono.png" alt=""></p><h3 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h3><ul><li>Layered system (分层系统): Organize the OS as a hierarchy of layers, each one constructed upon the one below it 层次结构，每个层次结构都基于其下一层</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/layer.png" alt=""></p><h3 id="微内核系统"><a href="#微内核系统" class="headerlink" title="微内核系统"></a>微内核系统</h3><ul><li>Microkernels (微内核结构): Put as little as possible in kernel model</li></ul><h3 id="Client-Server-Model"><a href="#Client-Server-Model" class="headerlink" title="Client-Server Model"></a>Client-Server Model</h3><ul><li>现代OS的趋势是: 采用<strong>将代码进一步移到更高层</strong>的想法，并尽可能<strong>从内核模式中删除</strong>，从而保留最小的微内核。</li><li>The client-server model, all the kernel does is handle the communication between clients and servers. 内核只负责处理客户端和服务器之间的通信。</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/CS%20Model.png" alt=""></p><h3 id="虚拟系统"><a href="#虚拟系统" class="headerlink" title="虚拟系统"></a>虚拟系统</h3><ul><li>Virtual Machines (虚拟机): 系统的核心被称为 <strong>虚拟机监视器</strong> virtual machine monitor直接运行在硬件层, 并且向下一层提供多个虚拟的机器</li><li>下图仅为虚拟化的一种实现方式, 详见多处理器系统章节</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E8%99%9A%E6%8B%9F%E5%8C%961.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统 系列文章链接🔗&lt;/p&gt;
&lt;p&gt;操作系统之概述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OS 定义&lt;/li&gt;
&lt;li&gt;OS 历史&lt;/li&gt;
&lt;li&gt;OS 分类&lt;/li&gt;
&lt;li&gt;计算机底层硬件一览&lt;/li&gt;
&lt;li&gt;OS 中的基本概念&lt;/li&gt;
&lt;li&gt;系统调用&lt;/li&gt;
&lt;li&gt;OS 结构&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之安全</title>
    <link href="http://yoursite.com/2020/08/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2020/08/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%AE%89%E5%85%A8/</id>
    <published>2020-08-11T06:42:28.000Z</published>
    <updated>2020-08-15T11:05:03.963Z</updated>
    
    <content type="html"><![CDATA[<p>本章将涉及:</p><ol><li>安全与威胁</li><li>简易密码学(真的很简易!)</li><li>用户认证</li><li>系统受到的攻击<ol><li>来自内部</li><li>来自外部</li></ol></li><li>保护机制</li><li>信任系统</li><li>OS安全</li></ol><p><em>本文匆匆赶制, 内容粗糙简陋</em></p><a id="more"></a><h2 id="安全与威胁"><a href="#安全与威胁" class="headerlink" title="安全与威胁"></a>安全与威胁</h2><div class="table-container"><table><thead><tr><th>Goal</th><th>Threat</th></tr></thead><tbody><tr><td>Data confidentiality 数据机密性</td><td>Exposure of data 数据泄露</td></tr><tr><td>Data integrity           数据完整性</td><td>Tampering with data 数据篡改</td></tr><tr><td>System available     系统可用性</td><td>Denial of service      拒绝服务</td></tr></tbody></table></div><p>首先保护数据的机密性, 防止数据泄露.   需要保证数据不被外界所知.</p><p>其次要保证数据的完整性, 防止数据被破坏.  不能被外界破坏.</p><p>最后要保证系统的可用性, 防止系统拒绝服务. 例如DoS攻击等</p><p>入侵者 intruder or sometimes 敌人 adversary<br>a) Passive intruders(被动入侵者)- to read files they are not authorized to<br>read<br>b) Active intruders(主动入侵者)- to make unauthorized changes to data</p><p>常见的安全入侵场景有:</p><ol><li>Casual prying (窥探) by nontechnical users     被非专业使用者随意窥探</li><li>Snooping by insiders  被内部人员窥视</li><li>Determined attempt to make money  为了利益</li><li>Commercial or military espionage   商业或军事间谍</li></ol><p>常见的数据丢失场景有:</p><ol><li><p>天灾</p><p>fires, floods, wars</p></li><li><p>软硬件错误</p><p>CPU malfunction, bad disk, program bugs </p></li><li><p>人为错误</p><p>data entry, wrong tape mounted</p><hr></li></ol><h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h2><p><em><u>了解即可</u></em></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>斯巴达将军</li><li>戚继光: 反切注音法</li><li>周恩来: 豪密</li><li>菲利普与玛丽女王</li><li>一战: 齐默尔曼电报</li><li>二战: Enigma密码机, 图灵</li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul><li>? - 1949 古典密码<ul><li>密码学还不是科学, 而是艺术</li><li>数据的安全<strong>基于算法的保密</strong></li><li>一般的加密方法是<strong>替换</strong></li><li>单表替换密码(凯撒密码), 多表替换密码(Playfair密码, Hill密码) , 转轮密码(Enigma)</li></ul></li><li>1949 - 1975 复杂计算的密码<ul><li>由于算力提升使得复杂计算的密码称为可能</li><li>1949年,香农发表了&lt;&lt;保密系统的信息理论&gt;&gt;(The Communication Theory of Secrecy Systems), 它证明了密码编码 学是如何置于坚实的数学基础之上的，从此密码学发展成为 一个专门学科。——标志性事件 </li><li>数据的安全<strong>基于密钥</strong>而不是算法的保密</li></ul></li><li>1975 - 公钥密码<ul><li>公钥密码学成为主要研究方向 </li><li><strong>公钥密码</strong>使得发送端和接收端<strong>无密钥传输的保密通信</strong>成为可能</li></ul></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><ul><li>传统密码/常规密码/私钥密码/单钥密码 conventional / private-key / single-key</li><li>发送方和接收方共享一个共同的密钥</li><li>20世纪70年代以前私钥密码是唯一类型 </li><li>至今仍广泛应用</li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ul><li>公钥/双钥/非对称密码都是指使用两个密钥: <ul><li>公钥：可以对任何人公开的密钥，用于加密消息或 验证签名。 </li><li>私钥：只能由接收者私存，用于解密消息或签名。 </li></ul></li><li>非对称 <ul><li>用于加密消息或验证签名的人不能进行消息的加密或消息的签名。</li></ul></li></ul><hr><h2 id="用户认证⭐"><a href="#用户认证⭐" class="headerlink" title="用户认证⭐"></a>用户认证⭐</h2><p>Authentication<br>user authentication（用户验证） crackers（骇客）</p><p>认证必须要能够标识使用者的身份</p><p>用户认证应当在使用系统之前完成</p><p>三种认证方式</p><ol><li><p>Something the user knows</p><p>密码, 口令</p></li><li><p>Something the user has</p><p>钥匙, 芯片, 动态密码, 验证码</p></li><li><p>Something the user is</p><p>指纹, 虹膜</p></li></ol><blockquote><p>UNIX 安全系统会对输入的密码进行<strong>加盐</strong>(Salt), 即将每一个口令同一个叫做盐（Salt）的n位随机数相关联。无论何时口令改变，这个随机数就改变。将口令和随机数连接起来，一同加密，加密后的结果存放进口令文件。</p><p>One-Time passwords 对于函数 y=f(x) 已知y求x的难度远大于已知x求y的难度. </p></blockquote><h3 id="一些用户认证时的对策"><a href="#一些用户认证时的对策" class="headerlink" title="一些用户认证时的对策"></a>一些用户认证时的对策</h3><ul><li>Limiting times when someone can log in    限制登录时间</li><li>Automatic callback at number prespecified   自动回调 (例如判断密码是否太过简单)</li><li>Limited number of login tries   限制尝试的登录次数</li><li>A database of all logins    记录所有尝试登录的数据</li><li>Simple login name/password as a trap  使用简单的密码作为陷阱 (假装登陆成功)</li><li>security personnel notified when attacker bites 当检测到攻击者时通知安全人员</li></ul><hr><h2 id="系统受到的攻击"><a href="#系统受到的攻击" class="headerlink" title="系统受到的攻击"></a>系统受到的攻击</h2><h3 id="Insider-Attacks-内部攻击"><a href="#Insider-Attacks-内部攻击" class="headerlink" title="Insider Attacks 内部攻击"></a>Insider Attacks 内部攻击</h3><h4 id="Logic-Bombs"><a href="#Logic-Bombs" class="headerlink" title="Logic Bombs"></a>Logic Bombs</h4><p>（逻辑炸弹）由一些公司的编程人员或使用这些受保护的计算机、编制核心软件的员工实施.秘密的嵌在产品的操作系统中的代码，特定情况下爆炸</p><h4 id="Trap-Doors"><a href="#Trap-Doors" class="headerlink" title="Trap Doors"></a>Trap Doors</h4><p>（后门）系统程序员跳过正常的认证过程并插入一段代码造成<br>的。代码审查 code review</p><h4 id="Login-Spoofing"><a href="#Login-Spoofing" class="headerlink" title="Login Spoofing"></a>Login Spoofing</h4><p>（登录欺骗）假冒的登录屏幕</p><h4 id="Trojan-Horses"><a href="#Trojan-Horses" class="headerlink" title="Trojan Horses"></a>Trojan Horses</h4><p>特洛伊木马 诱导用户运行攻击代码</p><h4 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h4><p>缓冲区溢出攻击</p><h3 id="Outside-Attacks-外部攻击"><a href="#Outside-Attacks-外部攻击" class="headerlink" title="Outside Attacks 外部攻击"></a>Outside Attacks 外部攻击</h3><h4 id="Virus"><a href="#Virus" class="headerlink" title="Virus"></a>Virus</h4><p>病毒: 不断地复制自身并传播</p><h4 id="Morris-Worm"><a href="#Morris-Worm" class="headerlink" title="Morris Worm"></a>Morris Worm</h4><p>蠕虫: 先潜伏自己的存在, 直到传播到一定规模后再爆发</p><p>(zero-day Attack</p><p>Zombie</p><p>…</p><h2 id="系统设计的原则"><a href="#系统设计的原则" class="headerlink" title="系统设计的原则"></a>系统设计的原则</h2><ol><li>System design should be public </li><li>Default should be no access </li><li>Check for current authority </li><li>Give each process least privilege possible </li><li>Protection mechanism should be 保护机制应当<ul><li>simple 简单</li><li>uniform  统一</li><li>in lowest layers of system  处于系统底层</li></ul></li><li>Scheme should be psychologically acceptable</li></ol><h2 id="保护机制-⭐"><a href="#保护机制-⭐" class="headerlink" title="保护机制 ⭐"></a>保护机制 ⭐</h2><h3 id="Protection-Domains"><a href="#Protection-Domains" class="headerlink" title="Protection Domains"></a>Protection Domains</h3><p>注: 下文中提到的 <em>用户</em> 也可能指进程</p><p>保护域</p><p>a domain is a set of （object， right） pairs. Each pair specifies an object and some<br>subset of the operations that can be performed. A right means permission to perform one of the operations.<br>一对对象权限的组合，每对组合指定一个对象和一些可在上面运行的操作子集指对某个操作的执行许可.</p><p>人话: 一张表, 记录了所有的文件和每个用户允许对文件进行的操作</p><p>缺点: 太大</p><h3 id="Access-Control-Lists-ACL"><a href="#Access-Control-Lists-ACL" class="headerlink" title="Access Control Lists , ACL"></a>Access Control Lists , ACL</h3><p>访问控制列表</p><p>每个对象的有序列表里包含了所有可访问对象的域以及这些域如何访问这些对象的方法</p><p>人话: 由于文件多而域少, 因此在每个文件处记录哪些域能进行什么操作. 将保护域按文件分解</p><h3 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h3><p>权能字</p><p>使用按行存储时，与每个进程关联的是可访问的对象列表，以及每个对象上叫做权能字列表，每个单独的项目叫做权能字</p><p>人话: 每个用户自己储存对每个文件能进行什么操作, 将保护域按用户分解</p><p>因此要防止权能字被用户自己篡改(三种方法)</p><ol><li>First way, require a tagged architecture </li><li>Second way, keep the C-list inside the OS </li><li>Third way, keep the C-list in user space, but manage the capabilities cryptographically</li></ol><h2 id="可信任系统"><a href="#可信任系统" class="headerlink" title="可信任系统"></a>可信任系统</h2><p>完全可信任的系统是否存在?</p><p>可信任系统的核心是 <strong>可信计算基Trusted Computing Base, TCB</strong></p><p>TCB 是一种机制, 保护所有敏感操作; (例如切换进程, 进程创建, 内存映射管理等) 任何试图访问这些操作的进程必须通过可信计算基的安全审查, 称为 reference monitor (访问监视器)</p><blockquote><p>All system calls go through the reference monitor for security checking</p></blockquote><p>TCB可以通过硬件, 软件, 固件的形式实现, 它只是个机制. </p><p>一旦可信计算机基的某个构件出现程序错误或者安全隐患，就对整个系统的安全造成危害。 与之相反，如果除可信计算基之外的系统的其他部分出现问题，也只是泄漏了系统安全策略赋予它们的相关权限而已，这些权限一般都是比较低的。</p><p>现代操作系统努力降低TCB的大小，使得对其代码库彻底的检查成为可能.</p><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>操作系统之安全  (本文)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将涉及:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安全与威胁&lt;/li&gt;
&lt;li&gt;简易密码学(真的很简易!)&lt;/li&gt;
&lt;li&gt;用户认证&lt;/li&gt;
&lt;li&gt;系统受到的攻击&lt;ol&gt;
&lt;li&gt;来自内部&lt;/li&gt;
&lt;li&gt;来自外部&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;保护机制&lt;/li&gt;
&lt;li&gt;信任系统&lt;/li&gt;
&lt;li&gt;OS安全&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;本文匆匆赶制, 内容粗糙简陋&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之多处理器系统</title>
    <link href="http://yoursite.com/2020/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-08-08T14:59:29.000Z</published>
    <updated>2020-08-15T11:04:34.529Z</updated>
    
    <content type="html"><![CDATA[<p>本章将会涉及:</p><ol><li>多处理器系统</li><li>多计算机系统</li><li>虚拟化</li><li>分布式</li></ol><a id="more"></a><p>对更快的计算是推动计算机进步的动力. 除了从技术层面上突破(如优化芯片) , 人们还设计了这些系统来提高计算水平. </p><ol><li><p>计算机并行处理, 主要体现在同一个计算机中存在多个处理器 , 这些处理器 <u>共享内存模块</u> (share memory model ). 称为 <strong>多处理器系统</strong> (<strong>Multiprocessors</strong>)</p><blockquote><p>注意与 <strong>多核</strong> 的区别</p><p>多处理器指: 在一个机器中有多个处理器;</p><p>多核: 在一个处理器中有多个处理芯片</p></blockquote></li><li><p>多个计算机相互协作. 表现为不同的计算机通过 <u>消息传递</u> 的而协作.(紧耦合)  称为 <strong>多计算机系统</strong> (<strong>Multicomputers</strong> )</p></li><li><p>多个计算机互相协作. 表现为通过 <u>广域分布式系统</u> (指网络) 协作. (松耦合) 称为 <strong>分布式系统</strong> (<strong>Distributed systems</strong>)</p></li></ol><p><img src='https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%89%E7%A7%8D%E6%8A%80%E6%9C%AF.png' height = '500' width = '1300'></img></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E6%AF%94%E8%BE%83.png" alt=""></p><p>除此之外本章还会涉及到 <strong>虚拟化技术</strong> (Virtualization ).</p><h2 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h2><p>在一个计算机系统内部，两个以上的CPU共享对一个公共RAM都拥有的完全访问权限. 根据不同CPU读写速度的不同又分为</p><ol><li><p>UMA ( Uniform Memory Access ， 统一内存访问)</p><p>每个存储器字的读出速度是一样快的。 </p><p>主要有三种硬件实现</p><ol><li>Bus-Based Architectures 总线结构</li><li>Crossbar Switches  交叉开关</li><li>Multistage Switching Networks  多级交换网络</li></ol></li><li><p>NUMA ( Nonuniform Memory Access， 非统一内存 访问 )</p><p>存储器访问时间取决于相对于处理器的存储器位置.</p><p>访问远程存储器的速度比本地存储器慢</p></li></ol><h3 id="UMA-的硬件实现"><a href="#UMA-的硬件实现" class="headerlink" title="UMA 的硬件实现"></a>UMA 的硬件实现</h3><p><em><u>了解</u></em></p><h4 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h4><p>字面意思, 每个CPU通过总线与内存交互. 又可分为三种:</p><ol><li>不带独立cache</li><li>拥有独立cache</li><li>拥有独立cache和私有内存</li></ol><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%89%E7%A7%8D%E6%80%BB%E7%BA%BF.png" alt=""></p><p>问题: CPU会争夺总线的使用权, 引起<strong>竞争</strong>.</p><h4 id="交叉开关"><a href="#交叉开关" class="headerlink" title="交叉开关"></a>交叉开关</h4><p>对于 $n$ 个CPU 构建 $n\times n$ 的交叉开关网络. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%BA%A4%E5%8F%89%E5%BC%80%E5%85%B3.png" alt=""></p><p>优点: 绝对不会竞争或阻塞</p><p>缺点: 开销过大</p><h4 id="多级交换网络"><a href="#多级交换网络" class="headerlink" title="多级交换网络"></a>多级交换网络</h4><p>使用 2*2 的交换机来构建多级交换网络.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E5%A4%9A%E7%BA%A7%E4%BA%A4%E6%8D%A2.png" alt=""></p><p>上图是三级交换网络, 对于 $n$ 个CPU, 仅需要 $3\times \frac n 2$ 个交换机. 同时每个线路的可通达度大幅提高了.</p><h3 id="OS-划分类型"><a href="#OS-划分类型" class="headerlink" title="OS 划分类型"></a>OS 划分类型</h3><h4 id="类型１-每个CPU都有自己的OS"><a href="#类型１-每个CPU都有自己的OS" class="headerlink" title="类型１: 每个CPU都有自己的OS"></a>类型１: 每个CPU都有自己的OS</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E7%8B%AC%E8%87%AA1.png" alt=""></p><ul><li>内存划分为n个部分</li><li>为每个CPU分配自己的专用内存和操作系统的专用副本</li><li>OS每个操作系统都有自己的表，不共享进程；<br>没有共享页面</li></ul><h4 id="类型2-主从处理器"><a href="#类型2-主从处理器" class="headerlink" title="类型2: 主从处理器"></a>类型2: 主从处理器</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%BB%E4%BB%8E2.png" alt=""></p><ul><li>OS及其表的一个副本位于CPU1上</li><li>所有系统调用都重定向到CPU1进行处理</li><li>缺点: 如果从处理器过多, 主处理器的性能将成为系统的瓶颈</li></ul><h4 id="类型3-对称处理器"><a href="#类型3-对称处理器" class="headerlink" title="类型3: 对称处理器"></a>类型3: 对称处理器</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E5%AF%B9%E7%A7%B03.png" alt=""></p><ul><li>内存中只有一个OS副本，但是任何CPU都可以运行它</li><li>使用互斥量(锁)保证只有一个处理器在使用OS </li></ul><h3 id="处理器的调度"><a href="#处理器的调度" class="headerlink" title="处理器的调度"></a>处理器的调度</h3><h4 id="分时调度-Timesharing"><a href="#分时调度-Timesharing" class="headerlink" title="分时调度 Timesharing"></a>分时调度 Timesharing</h4><p>Using a single data structure for scheduling a multiprocessor</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/time.png" alt=""></p><h4 id="分空间调度-Space-sharing"><a href="#分空间调度-Space-sharing" class="headerlink" title="分空间调度 Space sharing"></a>分空间调度 Space sharing</h4><p>multiple threads at same time across multiple CPUs</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/space.png" alt=""></p><h4 id="Gang-Scheduling-（-群调度-）"><a href="#Gang-Scheduling-（-群调度-）" class="headerlink" title="Gang Scheduling （ 群调度 ）"></a>Gang Scheduling （ 群调度 ）</h4><ol><li>Groups of related threads scheduled as a unit (a gang)</li><li>All members of gang run simultaneously （ 同时 ） on different timeshared CPUs </li><li>All gang members start and end time slices together</li></ol><p><em>其他的应该不是重点</em></p><hr><h2 id="多计算机系统"><a href="#多计算机系统" class="headerlink" title="多计算机系统"></a>多计算机系统</h2><p>一言以蔽之: <u>不共享内存的紧密耦合CPU</u></p><p>又称为cluster computers (群集计算机) , clusters of workstations (群集工作站,COW)</p><p>每个CPU的内存连接在自己的CPU上并且不会被其他CPU访问到. </p><p><em>本节不是重点</em></p><h3 id="互联拓扑结构"><a href="#互联拓扑结构" class="headerlink" title="互联拓扑结构"></a>互联拓扑结构</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%BA%92%E8%81%94%E6%8B%93%E6%89%91.png" alt=""></p><p>星型; 环型; 网格; 双环; 立方; 超立方</p><h3 id="存储转发分组交换"><a href="#存储转发分组交换" class="headerlink" title="存储转发分组交换"></a><strong>存储转发分组交换</strong></h3><h3 id="其他链接方式"><a href="#其他链接方式" class="headerlink" title="其他链接方式"></a><strong>其他链接方式</strong></h3><p>电路交换</p><p>虫孔路由</p><p>…</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><ul><li>根据计算能力的需要，可能需要在多台刀片服务器上部署 应用，即分布式应用部署。</li><li>为了在这个分布式计算环境上，给最终用户一个集成的开 发环境，让用户感觉是在一台计算机上进行编程一样，底 层多台刀片服务器之间需要使用远程过程调用RPC。</li><li>选型RPC 框架时，主要考虑三个关键方面：传输协议与数 据类型（JSON、XML 等），数据的存储、传输效率，服 务器端对数据的请求方式。</li></ul><hr><h2 id="虚拟化⭐"><a href="#虚拟化⭐" class="headerlink" title="虚拟化⭐"></a>虚拟化⭐</h2><p>虚拟机技术，通常简称为 <strong>虚拟化</strong> virtualization 。<br>该技术允许一台计算机托管多个虚拟机，每个虚拟机可能运行不同的操作系统。</p><p>优点:</p><ul><li>一个虚拟机的故障不会自动导致其他任何故障。 </li><li>拥有更少的物理机可以节省硬件成本并占用更少的空间</li><li>检查点和迁移虚拟机比普通的要容易得多</li><li>在不再受支持或无法在当前硬件上运行的操作系统上运行旧版应用程序</li><li>在软件开发时确保软件可以在不同的OS上运行。</li></ul><p><strong>Hypervisor</strong>, also called Virtual Machine Monitor (VMM, 虚拟机监视器)它是在硬件层之上，独立于操作系统的一层软件。创建虚拟化平台，OS实例运行在这个平台上，使得硬件可以被多个OS和应用共享.</p><p><em><u>搞清楚几种的区别</u></em></p><h3 id="Type-1-Hypervisor"><a href="#Type-1-Hypervisor" class="headerlink" title="Type 1 Hypervisor"></a>Type 1 Hypervisor</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E8%99%9A%E6%8B%9F%E5%8C%961.png" alt=""></p><ul><li>Hypervisor 直接运行在硬件之上, 其余的OS运行在Hypervisor 上.</li><li>但是OS都以为自己在内核上 (实际是用户态)</li><li>被称为 <strong>虚拟内核态</strong> (virtual kernel mode)</li><li>例如: Hyper-V, Xen, Vmware vSphere</li></ul><h3 id="Type-2-Hypervisors"><a href="#Type-2-Hypervisors" class="headerlink" title="Type 2 Hypervisors"></a>Type 2 Hypervisors</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E8%99%9A%E6%8B%9F%E5%8C%962.png" alt=""></p><ul><li>主OS运行在硬件上, Hypervisor 运行在主OS上, 其余OS 运行在Hypervisor 上.</li><li>当虚拟OS第一次启动时, Hypervisor 引导它们安装在虚拟磁盘上</li><li>例如:  Vmware worksation, Parallels, VM virtualBox</li></ul><h3 id="Paravirtualization-半虚拟化"><a href="#Paravirtualization-半虚拟化" class="headerlink" title="Paravirtualization  半虚拟化"></a>Paravirtualization  半虚拟化</h3><p>修改来宾操作系统的源代码，以便根本不执行敏感指令，而进行 <strong>hypervisor calls</strong>.</p><p>Hypervisor 定义接口，该接口由guest操作系统可以使用的一组过程调用组成（API）.</p><p>这种限制guest操作系统敏感操作的方式称为 <strong>半虚拟化</strong> (paravirtualized)</p><hr><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><em>不是重点</em></p><p>使用中间件技术实现一致性.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%AD%E9%97%B4%E4%BB%B6.png" alt=""></p><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>操作系统之多处理器系统 (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将会涉及:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多处理器系统&lt;/li&gt;
&lt;li&gt;多计算机系统&lt;/li&gt;
&lt;li&gt;虚拟化&lt;/li&gt;
&lt;li&gt;分布式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之文件系统</title>
    <link href="http://yoursite.com/2020/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-08-06T08:27:07.000Z</published>
    <updated>2020-08-15T11:05:18.531Z</updated>
    
    <content type="html"><![CDATA[<p>本章将会涉及:</p><ol><li>文件</li><li>目录</li><li>文件系统的实现</li></ol><a id="more"></a><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>在进程的运行过程中出现了以下需求: 1) 需要储存大量信息; 2)信息需要保存至进程结束后; 3) 多个进程需要同时对数据进行操作.</p><p>为了解决以上问题, 我们将信息存储在磁盘和其他外部介质中, 称之为 <strong>文件</strong>.</p><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>文件的命名要求因操作系统而已. </p><p>有的系统区分文件的大小写, 有的则不区分(MS-DOS).</p><p>许多OS使用字符<code>.</code>将文件名分成两部分, 后半部分称为 <strong>文件后缀名</strong>(file extension)</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E5%90%8E%E7%BC%80.png" alt=""></p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>文件有多种组成结构</p><ol><li>byte sequence  文件由字节序列组成 (UNIX和WIN都是如此)</li><li>record sequence 文件由记录片组成(早期插卡式系统)</li><li>tree 树型 文件是一层层地储存的</li></ol><h3 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h3><p>由使用用途</p><ul><li>系统文件</li><li>用户文件</li><li>库文件</li></ul><p>由数据形式</p><ul><li>源文件</li><li>目标文件</li><li>可执行文件</li></ul><p>由权限</p><ul><li>只可执行文件</li><li>只读</li><li>读写</li></ul><p>由逻辑结构</p><ul><li>结构化数据</li><li>非结构化数据</li></ul><p>由(在硬盘上储存的)物理结构</p><ul><li>顺序文件</li><li>连接文件</li><li>索引文件</li></ul><p>UNIX和WIN都有常规文件和目录文件</p><p>UNIX中还有 字符设备文件 和块设备文件, 进程文件(伪文件)等特殊文件.</p><h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><ul><li><p>顺序访问</p><p>只能从最开始访问</p><p>不能跳转</p></li><li><p>随机访问</p><p>以任意顺序访问</p></li></ul><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>文件包括很多属性,见图</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.png" alt=""></p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li>创建</li><li>删除</li><li>打开</li><li>关闭</li><li>读</li><li>写</li><li>追加</li><li>查找</li><li>访问属性</li><li>设定属性</li><li>重命名</li></ul><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="目录系统的种类"><a href="#目录系统的种类" class="headerlink" title="目录系统的种类"></a>目录系统的种类</h3><ul><li><p>单层析目录</p><p>ROOT 下直接跟随各种文件</p></li><li><p>双层次目录</p><p>ROOT 下由用户创建文件夹, 并在文件夹中储存文件</p></li><li><p>多层次目录</p><p>ROOT 下由用户创建文件夹, 并在文件夹中储存文件或文件夹</p></li></ul><h3 id="路径-⭐"><a href="#路径-⭐" class="headerlink" title="路径 ⭐"></a>路径 ⭐</h3><p>假设文件层次如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root:</span><br><span class="line">├─other1</span><br><span class="line">└─usr</span><br><span class="line">    ├─ast</span><br><span class="line">    │  ├─mailbox</span><br><span class="line">    │  ├─myInfo.txt</span><br><span class="line">    │  └─other3</span><br><span class="line">    └─other2</span><br></pre></td></tr></table></figure><p>假设当前位于<code>ast</code>目录</p><ul><li><p>Absolute path name </p><p>绝对路径(从根目录起) 前加 <code>/</code> </p><ul><li><code>/usr/ast/mailbox</code> (UNIX)   访问mailbox文件夹</li><li><code>/usr/ast/myInfo.txt</code> (UNIX)   访问myInfo.txt</li><li><code>\usr\ast\mailbox</code> (Win)    访问mailbox文件夹</li></ul></li><li><p>Relative path name</p><p>相对目录(从当前目录开始) </p><ul><li><code>mailbox</code>    访问mailbox文件夹</li><li><code>./myInfo.txt</code> 访问myInfo.txt</li></ul><p>如访问当前目录的可执行文件，如果用相对路径必须是 ./filename</p></li><li><p>Working directory ( current directory) </p><ul><li><code>/usr/ast</code> 表示当前目录</li></ul></li></ul><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><ul><li>Create</li><li>Delete</li><li>Opendir</li><li>Closedir</li><li>Readdir</li><li>Rename</li><li>Link(hard link/symbol link)</li><li>Unlink</li></ul><hr><h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><p>文件都是储存在磁盘上的. 大多数磁盘都分为一个或多个区(Partitions) ,  每个区都有自己的独立文件系统.</p><p>磁盘的0扇区被称为 <strong>主引导区</strong> <strong>MBR</strong> (Master Boot Record) , 用于引导计算机启动.</p><blockquote><p> Sector 0 of the disk is called MBR (Master Boot Record) and is used to boot the computer.</p></blockquote><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80.png" alt=""></p><ul><li>Partition table: 给出每个分区开始结束的地址信息gives the starting and ending addresses of each partition. </li><li>Boot block: locate the active partition </li><li>Superblock: magic number, number of blocks, … </li><li>Free space mgmt: 使用位图/链表储存文件的空余信息</li><li>i-nodes: an array of data structure, one per file. </li><li>后面的部分就是真正的文件和目录内容了</li></ul><h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><ul><li>顺序存放</li><li>链接存放</li><li>使用FAT在内存中链接存放 </li><li>I-Node ⭐</li></ul><h4 id="顺序存放"><a href="#顺序存放" class="headerlink" title="顺序存放"></a>顺序存放</h4><p>就是顺序存放.</p><p>优点:</p><ul><li>简单</li><li>读的性能非常高效</li></ul><p>缺点</p><ul><li>文件如果后续需要删除, 重写会造成大量碎片</li></ul><p>常用于后续不会再写入数据. 如CD</p><h4 id="链接存放"><a href="#链接存放" class="headerlink" title="链接存放"></a>链接存放</h4><p>每个文件都指明下一个文件的指针</p><p>缺点: 随机访问非常非常慢, 找一个文件要从头找</p><h4 id="使用FAT在内存中链接存放⭐"><a href="#使用FAT在内存中链接存放⭐" class="headerlink" title="使用FAT在内存中链接存放⭐"></a>使用FAT在内存中链接存放⭐</h4><p>将文件的链接关系放在一张表中, 称为 <strong>文件分配表</strong> (( File Allocation Table), FAT) </p><p>缺点: 需要将整个文件系统的表(通常很大)载入内存.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/FAT.png" alt=""></p><h4 id="I-Node-⭐"><a href="#I-Node-⭐" class="headerlink" title="I-Node ⭐"></a>I-Node ⭐</h4><p>给每个文件赋予一个相关联的数据结构, 称为 <strong>索引节点</strong>（I-Node , index-node），该数据结构列出了文件块的<strong>属性</strong>和<strong>磁盘地址</strong>。仅在访问本文件时, 才需要将节点载入内存.</p><p>也有可能储存文件的磁盘地址比较多, 可以再指向另外一个储存地址的地址</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/inode.png" alt=""></p><h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>目录系统的主要功能是<strong>将文件的ASCII名称映射到定位数据所需的信息</strong>上。</p><p>Windows 系统给每个条目都分配了定长的数据段, 来保存文件的属性. </p><p>UNIX 系统给每个条目分配一个I-node的引用</p><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>UNIX 提供共享文件的机制. 出现在多用户下.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6.png" alt=""></p><p>C的一个文件出现在B的目录下。B的目录与该共享的联系称为一个连接 LINK.</p><p>问题：若目录中包含磁盘地址，则连接文件时，C目录的磁盘地址复制到B目录<br>中，若B或C后又加内容，则新的数据块只会列入进行添加工作的目录中。</p><h4 id="hard-link"><a href="#hard-link" class="headerlink" title="hard link"></a><strong>hard link</strong></h4><p>（硬连接或者实际连接）</p><p>由于Linux里面每个文件都对应一个inode，而文件名是记录在目录的block里的，也就是说文件名和inode没有关系，这样就可以把多个文件名对应同一个inode，这就是hard link，简单的说：hard link只是在某个目录下新建一条文件名连接到某inode号码的关联记录而已。</p><p>缺点</p><ul><li>不能够跨文件系统地做硬连接</li><li>不能够连接到目录</li></ul><h4 id="symbolic-link"><a href="#symbolic-link" class="headerlink" title="symbolic link"></a><strong>symbolic link</strong></h4><p>软连接或者符号连接</p><p>软连接创建一个新的文件，有自己的inode和block，只是在block里记录的是到连接目标文件的指向，读取到这个指向记录以后，系统再从根目录一层层进到目标文件的block里把数据读出来</p><p>symbolic link有如下特点：</p><p>1.等于是文件的一个“快捷方式”，只起一个指向作用</p><p>2.是一个独立的新文件，对目标文件没有任何影响</p><p>3.目标文件一旦删除，软连接会打不开</p><p>两种连接方式都存在的问题: 查找文件时会将同一个文件重复查询.</p><h3 id="Linux虚拟文件系统VFS"><a href="#Linux虚拟文件系统VFS" class="headerlink" title="Linux虚拟文件系统VFS"></a>Linux虚拟文件系统VFS</h3><p> 整个 Linux 系统通过 Virtual Filesystem Switch 的核心功能去 读取 filesystem。整个 Linux 认识的 filesystem 都是 VFS 在 进行管理，使用者并不需要知道每个 partition 的 filesystem 是什么</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/VFS.png" alt=""></p><p><em><u>其他了解即可</u></em></p><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>操作系统之文件系统 (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将会涉及:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件&lt;/li&gt;
&lt;li&gt;目录&lt;/li&gt;
&lt;li&gt;文件系统的实现&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之IO管理</title>
    <link href="http://yoursite.com/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIO%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIO%E7%AE%A1%E7%90%86/</id>
    <published>2020-08-05T13:08:03.000Z</published>
    <updated>2020-08-17T10:39:09.256Z</updated>
    
    <content type="html"><![CDATA[<p>本章将涉及: </p><ol><li>IO设备</li><li>盘</li><li>时钟</li><li>其他</li></ol><p><em>本文匆匆赶制, 内容粗糙简陋  <del>背就完事了</del></em> </p><a id="more"></a><h2 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h2><h3 id="IO设备分类-⭐"><a href="#IO设备分类-⭐" class="headerlink" title="IO设备分类 ⭐"></a>IO设备分类 ⭐</h3><ul><li>块设备 (Block device)<ul><li>储存于固定大小的块中, 每块都有自己的地址</li><li>每个块都可以可以独立于其他块进行读写</li><li>例如: 磁盘</li></ul></li><li>字符设备 ( Character device )<ul><li>使用字符流进行传递</li><li>不可寻址, 没有任何查找功能</li><li>例如: 打印机, 键鼠</li></ul></li><li>其他<ul><li>时钟</li></ul></li></ul><p><em>我们接下来的讨论一般是针对块设备</em></p><h3 id="IO-设备部组成"><a href="#IO-设备部组成" class="headerlink" title="IO 设备部组成"></a>IO 设备部组成</h3><ul><li>机械部件(即普遍意义上的设备)</li><li>电子部件</li></ul><p>其中电子部件是用于控制管理机械部件的, 我们将电子部件称为 <strong>设备控制器</strong> .它的主要功能是: </p><p><em><u>知道作用</u></em></p><ul><li><p>Convert the serial bit stream into a block of bytes </p><p>将串行字节流转化未字节块</p></li><li><p>Perform any error correction necessary </p><p>对于运行时可能的出错进行纠正</p></li><li><p>Copy it to main memory</p><p>将字节复制到主存</p></li></ul><p><em>注: 一个设备控制器可能同时负责多个机械设备</em></p><p>此外每个设备控制器都拥有一些寄存器用于与OS通信:</p><ul><li>OS通过写入寄存器来命令设备执行操作等</li><li>OS通过读取寄存器来获取设备的状态</li></ul><p>除了寄存器外, 许多设备还有OS可以读取/写入的数据缓冲区</p><h3 id="与OS的通信方式"><a href="#与OS的通信方式" class="headerlink" title="与OS的通信方式"></a>与OS的通信方式</h3><p>OS和控制器的通信可以分为三种方式 ⭐</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/mmio.png" alt=""></p><ol><li><p>独立空间</p><p>每个控制寄存器器都分配有一个单独的IO端口号</p><p>内存的地址空间和IO的地址空间完全独立</p></li><li><p>内存映射 </p><p>将所有的控制寄存器映射到内存空间.</p><p>这些被映射的内存空间不会被其他内存映射, 只能由控制寄存器使用</p><p><strong>优点</strong></p><ol><li>, a I/O device driver can be written entirely in C. Otherwise, some assembly code is needed</li><li>No special protection mechanism is needed to keep user processes from performing I/O.</li><li>Every instructions that can reference memory can also reference control registers.</li></ol></li><li><p>混合</p><p>IO数据缓冲区采用内存映射, 寄存器采用独立空间</p></li></ol><p>IO软件层次: 驱动</p><p>需要实现:</p><ul><li>设备独立性, 设备在接入前不需要任何特殊处理</li><li>统一命名</li><li>纠错(贴近硬件层, 不需要OS费心)</li><li>异步传输</li><li>缓冲区</li><li>共享设备&amp;专业设备</li></ul><h3 id="IO控制方式-⭐"><a href="#IO控制方式-⭐" class="headerlink" title="IO控制方式 ⭐"></a>IO控制方式 ⭐</h3><ol><li><p>程序控制IO  Programmed I/O </p><p>使用程序不断查询设备以了解是否就绪, 忙等待, 低效 浪费CPU</p></li><li><p>中断控制IO  Interrupt-Driven I/O </p><p>允许CPU在IO工作时干其他时, 当IO完毕时发出中断.</p><p>问题在于IO每次只能传输一个字符, 中断频率过高</p></li><li><p>DMA控制IO⭐  I/O Using DMA </p><p>DMA控制器Direct Memory Access 是一个能够独立于CPU访问系统总线的控制器, 相当于一个字符缓冲池, 当缓冲池满了再向CPU发出中断信号.</p><blockquote><p>DMA controller <strong>has access to the system bus independent of the CPU</strong>. It contains several registers that can be written and read by the CPU</p></blockquote><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/dmA.png" alt=""></p><ol><li>CPU向DMA发出指令(而后CPU继续运行其他进程)</li><li>DMA向IO控制器发送传输指令</li><li>IO控制器与存储单元传输数据</li><li>传输控制器回应DMA</li><li>DMA向CPU发出IO中断信号(CPU处理)</li></ol></li></ol><h3 id="IO软件层次"><a href="#IO软件层次" class="headerlink" title="IO软件层次"></a>IO软件层次</h3><p>中断处理</p><p>最好是隐藏的, 不被感知. </p><p>一般需要大量时间, 负责设备与设备驱动之间的通信.</p><p>设备驱动器</p><p>设备独立性 : 设备在接入前不需要任何特殊处理</p><p>统一接口</p><p>缓冲区</p><p>​    双BUFFER区(乒乓机制)</p><h2 id="盘"><a href="#盘" class="headerlink" title="盘"></a>盘</h2><ol><li><p>每个byte由 14个bits构成</p></li><li><p>每42个byte构成1个帧(frame)</p><p>但是每frame种只有24byte用于记录数据, 剩下的用于校验和控制</p></li><li><p>98个帧构成扇区sector </p><p>每个扇区有16byte的引导符preamble, 后面又有288byte的ECC(纠错)</p></li></ol><p>柱面斜进, 每圈的零扇区在磁盘上不是位于同一条直线上.</p><p>磁盘交错. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/DISK%20FORMAT.png" alt=""></p><ol><li>无交错, 每个扇区顺序排列</li><li>单交错</li><li>双交错</li></ol><p><em>(以上了解)</em></p><h3 id="磁盘臂调度算法⭐"><a href="#磁盘臂调度算法⭐" class="headerlink" title="磁盘臂调度算法⭐"></a>磁盘臂调度算法⭐</h3><p>磁盘在读写过程种有三个时间决定: </p><ul><li><p>寻道时间Seek Time </p><p>将磁盘臂移动到适当的柱面上需要的时间</p></li><li><p>旋转延迟Rotational delay</p><p>等待适当的扇区旋转到磁头下的时间</p></li><li><p>数据传输时间Actual data trasfer time.</p><p>相比前面两个来说非常小</p></li></ul><p>传输时间相对忽略不计, 旋转延迟由机械决定, 讨论寻道时间</p><h4 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h4><p>按照柱面访问顺序进行访问. </p><h4 id="Shortest-Seek-Frist-最近柱面优先"><a href="#Shortest-Seek-Frist-最近柱面优先" class="headerlink" title="Shortest Seek Frist 最近柱面优先"></a>Shortest Seek Frist 最近柱面优先</h4><p>每次都访问离当前最近的</p><h4 id="The-elevator-algorithm-电梯调度"><a href="#The-elevator-algorithm-电梯调度" class="headerlink" title="The elevator algorithm 电梯调度"></a>The elevator algorithm 电梯调度</h4><p>每次都从头到尾,再从尾到头</p><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>作用⭐</p><ol><li><p>Maintaining the time of day  维持一天中的时间。 </p></li><li><p>Preventing pro running longer  防止进程运行超出允许的时间</p><p>在启动进程时设定一个计数器, 每个时钟中断处将计数器—, When it gets to zero, the clock driver calls the scheduler to set up another process.</p></li><li><p>Accounting for CPU usage  计算CPU使用率</p><p>每当启动进程时，启动一个不同于主系统计时器的第二个计时器。当该过程停止时，可以读出计时器以告知该过程已运行了多长时间。</p></li><li><p>Handling the alarm system call  处理用户进程发出的警报系统调用</p></li><li><p>Providing watchdog timers  为系统本身的各个部分提供监视定时器</p><p>例如: 在一定时间间隔内未确认的数据包必须重新发送</p></li></ol><p><em><u>其他了解即可</u></em></p><h2 id="Network-terminals-网络终端"><a href="#Network-terminals-网络终端" class="headerlink" title="Network terminals                    网络终端"></a>Network terminals                    网络终端</h2><h3 id="两类终端"><a href="#两类终端" class="headerlink" title="两类终端"></a>两类终端</h3><ul><li><p>胖终端  X Windows</p><p>终端具有大量的计算能力和内存，以便运行复杂的协议来压缩通过网络发送的数据量。 </p></li><li><p>瘦终端 SLIM</p><p>终端非常简单，基本上是显示像素，并且为了使其便宜而没有做太多的复杂设计</p></li></ul><p><em><u>其他了解即可</u></em></p><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>操作系统之IO管理  (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将涉及: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IO设备&lt;/li&gt;
&lt;li&gt;盘&lt;/li&gt;
&lt;li&gt;时钟&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;本文匆匆赶制, 内容粗糙简陋  &lt;del&gt;背就完事了&lt;/del&gt;&lt;/em&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之子午古道</title>
    <link href="http://yoursite.com/2020/08/05/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%AD%90%E5%8D%88%E5%8F%A4%E9%81%93/"/>
    <id>http://yoursite.com/2020/08/05/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%AD%90%E5%8D%88%E5%8F%A4%E9%81%93/</id>
    <published>2020-08-05T03:08:22.000Z</published>
    <updated>2020-08-05T04:27:28.427Z</updated>
    
    <content type="html"><![CDATA[<p>2020年8月2日    海拔1564</p><p>子午古道: 拐儿崖-金仙观-土地梁-尖山 (原路返回)</p><a id="more"></a><p>正儿八经的第一篇徒步记录. 其实是第二次徒步了, 上一篇见2020-07-2的周记. 前两天斥资五百大洋购买了正经装备, 拿这次热热身😄</p><p>学校还在因为疫情继续封闭, 大清早通过某种不可言说的手段溜了出来, 自行打车前往峪口. (大清早在省体集合真的对郊区不友好啊) 打车钱都快赶上参团费用了😭. 约八点二十抵达子午口保护总站, 大部队还没来. 琢磨了下子午峪的简介, 不感冒的看官可跳过~</p><blockquote><p>秦岭七十二峪之一，位于陕西省西安市境内。峪长六百六十里，北口曰子，在西安府南百里；南口曰午，在汉中府洋县东一百六十里。</p><p>子午古道始于战国，范睢相秦“栈道千里，通于蜀汉”，使天下畏秦。“子午”之名谢于西汉，西汉修建.长安城时中轴线其南端起于子午谷口。</p><p>子午至唐代变是通畅，巴蜀荔枝由此道直送长安，故又称荔枝道。该递在朝晚期左宗梁任扶甘总替时全线整修，现谷口的石拱桥即为当时所修。</p><p>——- 选自入口处石碑</p></blockquote><p>确实是从西安城里的子午大道正南方. <strong>“一骑红尘妃子笑，无人知是荔枝来”</strong>.自四川涪州置专驿直通长安。每年“飞骑驰进，七日七夜至京，人马多毙于路，百姓苦之”.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BF%9D%E6%8A%A4%E7%AB%99.jpg" alt=""></p><p>入山需要刷身份证, 各位别忘了! 先乘摆渡车至金仙观, 领队带着简单热身之后便开始徒步, 最初一公里依旧是观光道, 虽有坡度但不算难走, 行走约一公里抵达第一个休息点(七里坪村) , 经人家, 过小河, 正式进入山道, 攀升二百余米, 抵达休息点二, 期间一路伴水, 两侧环山, 山泉潺潺, 草木环绕. 昨夜的夜雨夹杂着晨雾带来的露水打湿着蛛网与衣角, 倘若登山杖不小心打在什么树枝丫上, 水滴更是直直簌簌地落在身上, 引起同行者一片惊叫. 烦心的是山路混合着宿雨, 有几处略有湿滑. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E6%99%A8%E9%9C%B2.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E5%B1%B1%E8%B7%AF.jpg" alt=""></p><p>从休息点二继续沿着山路行走, 不多时见着土地梁, 其实是路边一个小土地庙, 同行有人还去拜了拜, 这时领队芃芃喊我们看路边的小野瓜, 大家稍作休整,这才进入更陡峭的野道.此时已经约中午十一点, 日出而林霏开, 同行的小姐姐们发现路边的野蘑菇忽地冒了出来, 在大家不经意间身边就多了好些或白或黄的小蘑菇(当然我们也没作死去挑战), 值得一说的是, 我们下山再次路过它们的时候发现它们已经完全张开了, 此间对比的惊奇非亲历者不可察. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E8%98%91%E8%8F%87.jpg" alt=""></p><p>一路攀登, 不少陡峭湿滑的路段大家互相帮助着都过来了. 到海拔1350左右的最后一个休息区. 领队瑞子说就在这里午餐休整, 想登顶的可以继续. 那我们肯定是继续冲呀哈哈. 最后这段山路我依旧打头, 比较难走, 两旁丛林茂密, 脚下山路难以辨认, 常常有巨石横于路中, 非得手脚并用才可以爬过去, 好在一路上不断有前人留下的引路标, 有时爬累了抬头看看不远处的尖山顶, 互相鼓励说就一点了, 已经望见山顶了 . 最后这两百米硬是爬了一个小时. 终于登顶! </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E5%B2%A9%E7%9F%B3.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E7%99%BB%E9%A1%B6.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E5%90%88%E7%85%A7.jpg" alt=""></p><p>不巧是此时山顶依旧云里雾里, 只能模糊看见近处山体. 返回休息区的路上云雾散去, 芃芃帮着大家拍了好些照片, 大感谢. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BA%91%E6%B5%B71.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BA%91%E6%B5%B72.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BA%91%E6%B5%B73.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E7%85%A7%E7%89%87.jpg" alt=""></p><p>回到休息区, 领队带着食材整了个火锅. (山上一把火真的大丈夫?) 丸子火腿方便面真香. 还有同行的小姐姐前一天准备了好多吃的, 鸭脖鸡翅蛋挞水果…相比之下我是个蹭吃蹭喝的小废物😭</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E7%81%AB%E9%94%85.jpg" alt=""></p><p>大家还惊奇地发现不知道从哪儿冒出了一直贼乖巧的猫, 一直绕着你脚边伸懒腰———而且太乖巧好看以至于大家一致认为这不是野猫, 那怎么会有游客带着猫爬山呢? 还是说是附近农家养的猫, 已经习惯来找游客骗吃骗喝? 被骗的心甘情愿www</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E6%92%B8%E7%8C%AB.jpg" alt=""></p><p>小憩半小时, 原路返回. </p><p>回去路上发现原来大巴是过大学城的!!!!!! 那我直接在大学城等车不就好了为什么直接打车到峪口!!!! 贵死了都!!!!</p><p>写于 2020年8月5日</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E8%AE%B0%E5%BD%95.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年8月2日    海拔1564&lt;/p&gt;
&lt;p&gt;子午古道: 拐儿崖-金仙观-土地梁-尖山 (原路返回)&lt;/p&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之死锁</title>
    <link href="http://yoursite.com/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%AD%BB%E9%94%81/"/>
    <id>http://yoursite.com/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%AD%BB%E9%94%81/</id>
    <published>2020-08-04T11:23:09.000Z</published>
    <updated>2020-08-15T11:06:21.777Z</updated>
    
    <content type="html"><![CDATA[<p>本章包括以下内容:</p><ol><li>资源与死锁</li><li>处理死锁<ol><li>冷处理: 鸵鸟算法</li><li>热处理: 死锁的检测与恢复</li></ol></li><li>防范死锁<ol><li>避免死锁</li><li>死锁预防</li></ol></li><li>其他策略</li></ol><a id="more"></a><h2 id="资源与死锁"><a href="#资源与死锁" class="headerlink" title="资源与死锁"></a>资源与死锁</h2><h3 id="资源定义与分类"><a href="#资源定义与分类" class="headerlink" title="资源定义与分类"></a>资源定义与分类</h3><p>计算机中具有 <strong>排他性使用</strong> 的对象称为 <strong><u>资源</u></strong> . (即每次只允许一个进程访问). 资源可以是硬件(设备)或软件(信息). 资源随着时间推移必须能<u>获得, 使用, 以及释放</u>.</p><ul><li>可抢占式资源: B进程可以将资源R从进程A出抢占<strong>而不会产生任何副作用</strong>. 例如储存器.</li><li>不可抢占式资源: 在不引起相关失败的情况下, 无法将资源从占有它的进程处抢占过来.例如打印机.</li></ul><p><u>死锁仅可能出现在不可抢占式资源上.</u></p><p>资源的使用流程:</p><ol><li>申请资源</li><li>使用资源</li><li>释放资源</li></ol><p><em>当资源申请失败时,不同系统会采取不同反应: 阻塞申请(等待唤醒) 或 返回错误 (用户决定)</em> </p><h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h3><blockquote><p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件, 那么称这个进程集合的 <strong><u>死锁</u></strong> 的.</p><p><em>A set of processes is deadlocked if each process in the set is waiting for an event that only another process in the set can cause</em> </p></blockquote><p><del>显然这个定义太正经了大家都知道死锁是什么.</del></p><p>当发生死锁时, 任何一个进程都无法: 运行 / 释放资源 / 被唤醒</p><h3 id="死锁的四个必要条件⭐"><a href="#死锁的四个必要条件⭐" class="headerlink" title="死锁的四个必要条件⭐"></a>死锁的四个必要条件⭐</h3><ul><li><p>互斥条件 <strong>Mutual exclusion</strong> condition</p><p>每个资源要么被分给了一个进程, 要么是可用的</p></li><li><p>占有并等待  <strong>Hold and wait</strong> condition </p><p>进程可以在占有资源A的同时等待资源B的分配</p></li><li><p>不可抢占  <strong>No preemption</strong> condition </p><p>已经被分配的资源不可抢占, 只能等待占有它的进程主动释放</p></li><li><p>环路等待  <strong>Circular wait</strong> condition</p><p>系统中有多于一个的进程, 每个进程都在等待下一个进程占有的资源</p></li></ul><p><u>死锁发生时四个条件必须同时满足, 只要使任一条件不被满足即可预防死锁.</u></p><h3 id="死锁建模"><a href="#死锁建模" class="headerlink" title="死锁建模"></a>死锁建模</h3><p>圆形表示进程; 方形表示资源; </p><p>资源指向进程: 该资源已被进程占用;</p><p>进程指向资源: 该进程正在等待资源;</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E6%AD%BB%E9%94%81%E5%BB%BA%E6%A8%A1.png" alt=""></p><p>例如, 上图中进程C在等待被进程D占有的资源T, 进程D在等待被进程C占有的资源U.</p><p><em>如果模型中有闭合有向环, 表明存在死锁.</em></p><hr><h2 id="处理死锁⭐"><a href="#处理死锁⭐" class="headerlink" title="处理死锁⭐"></a>处理死锁⭐</h2><h3 id="冷处理-鸵鸟算法"><a href="#冷处理-鸵鸟算法" class="headerlink" title="冷处理: 鸵鸟算法"></a>冷处理: 鸵鸟算法</h3><p>假装没有问题, 如果进程执行时间过长就重启一下…</p><p>这是由于死锁的产生是取决于进程执行的精确时序, 在同一进程集合的多次运行中可能死锁的出现是非常偶然的; 此外处理死锁的开销往往非常高昂.</p><p>实际中本算法效果较好</p><h3 id="热处理-检测并恢复"><a href="#热处理-检测并恢复" class="headerlink" title="热处理: 检测并恢复"></a>热处理: 检测并恢复</h3><p>系统并不会防范死锁的产生, 而是在死锁发生之后再进行死锁的检测与恢复.</p><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p><strong>DFS算法</strong>: (了解)</p><p>依次将每一个节点作为一棵树的根节点, 并进行深度优先搜索, 如果再次遇到该节点表明找到了环.</p><p><strong>剪枝算法</strong>: </p><p>如果某进程只申请不占有, 将该节点剪去;如果某资源只被占有不被申请, 将该节点剪去;重复这两步直到无法剪去, 存在环.</p><p><strong>矩阵检测</strong>: (了解)</p><p>E 矩阵: 所有资源的总数; A矩阵: 所有资源当前空余量;</p><p>C矩阵: $C_{ij}$ 表示进程 $ i $  当前使用资源 $j$ 的数目;</p><p>R矩阵: $R_{ij}$ 表示进程 $ i $  当前需要资源 $j$ 的数目;</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E7%9F%A9%E9%98%B5%E6%A3%80%E6%B5%8B.png" alt=""></p><p>必定存在以下公式:</p><script type="math/tex; mode=display">\sum^n_{i=1}C_{ij} +A_j=E_j</script><p>如果当前的A矩阵可以使R矩阵按照一定顺序退出, 说明未形成死锁.</p><p>但死锁检测本身即浪费时间, 又需要定期检测, 所以热处理本身效果不佳.</p><h4 id="死锁的恢复"><a href="#死锁的恢复" class="headerlink" title="死锁的恢复"></a>死锁的恢复</h4><ul><li><p>资源抢占</p><p>将资源强制抢占(例如人工干预)</p></li><li><p>状态回滚</p><p>从之前某个状态重新加载, 重新跑未必发生死锁</p></li><li><p>杀死进程</p><p>杀死一个或若干个进程, 直到打破死锁.</p></li></ul><hr><h2 id="防范死锁⭐"><a href="#防范死锁⭐" class="headerlink" title="防范死锁⭐"></a>防范死锁⭐</h2><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><h4 id="资源轨迹图"><a href="#资源轨迹图" class="headerlink" title="资源轨迹图"></a>资源轨迹图</h4><p>当走向轨迹穿越阴影重叠区时<strong>有可能</strong>发生死锁. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E8%B5%84%E6%BA%90%E5%9B%BE.png" alt=""></p><h4 id="安全态"><a href="#安全态" class="headerlink" title="安全态"></a>安全态</h4><p>安全态: 如果没有死锁发生,即使所有进程突然请求最大的资源需求, 也存在某种调度次序使得每一个进程都运行完毕.</p><p>不安全态: 如果没有死锁发生,若所有进程突然请求最大的资源需求, 不存在某种调度次序使得每一个进程都运行完毕.</p><p><u>注意: 不安全态不代表一定发生死锁, 但死锁发生一定经过不安全态.</u></p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E9%93%B6%E8%A1%8C%E5%AE%B6.png" alt=""></p><p>如果A向量能够使用某种次序分配能够使所有进程安全退出就处于安全状态;</p><p>如果一直使其处于安全状态则可以避免死锁.</p><blockquote><p>实际上银行家算法缺少使用价值, 很少有进程在运行前知道需要多少资源, 而且进程数也在随时变化(新任务产生), 而且资源的状态也随时可能变化(例如打印机坏了).</p></blockquote><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>从理论上完全避免死锁的不可能的(因为需要获知未来的请求) , 但是我们可以通过对死锁的四个必要条件的破坏来预防死锁的产生.</p><p><del>其实我觉得预防和避免这种文字游戏没啥意义,但是确实不知道怎么区分</del></p><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>如果资源不被一个进程独占, 则不会产生死锁. </p><p>具体做法是将打印机使用假脱机, 即IO输出实际上是将文件发送至打印机的磁盘中, 再由打印机的控制程序慢慢打印磁盘的内容. 而多个进程可以同时对磁盘输出, 破坏了互斥条件.</p><p>但如果在某些情况下磁盘本身成为了互斥的资源, 这种方法就失效了</p><h4 id="破坏占有并等待"><a href="#破坏占有并等待" class="headerlink" title="破坏占有并等待"></a>破坏占有并等待</h4><p>禁止已持有资源的进程再申请其他资源.</p><p>一种实现方式是在进程开始时申请好全部资源. 但是这是无法实现的 (如果能实现为什么不用银行家呢?) 此外一次性分配资源也是巨大的浪费.</p><p>另一种实现方式是在申请新资源的时候先释放本来占有的资源. 但是开销大也不佳.</p><h4 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h4><p>通过将资源(主要指硬件设备)虚拟化可以使其能够抢占. 但是并不是所有资源都能够虚拟化的. 而且消除了打印机的死锁也可能带来硬盘的死锁.</p><h4 id="破坏环路等待条件"><a href="#破坏环路等待条件" class="headerlink" title="破坏环路等待条件"></a>破坏环路等待条件</h4><p>一种实现方式是每次只允许占据一个资源, 但是这显然不能接受的.</p><p>另一种方式是对所有资源进行编号, 某进程每次请求的资源不能是比自己占有的资源序号低的资源. 这样资源分配图中肯定不会出现环 (而是一条链).这种方式也几乎不能找到一个令人满意的编号次序.</p><hr><h2 id="其他策略"><a href="#其他策略" class="headerlink" title="其他策略"></a>其他策略</h2><ul><li>Two-Phase Locking</li><li>Non-resource Deadlocks</li><li>Starvation</li><li>….</li></ul><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a> (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章包括以下内容:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;资源与死锁&lt;/li&gt;
&lt;li&gt;处理死锁&lt;ol&gt;
&lt;li&gt;冷处理: 鸵鸟算法&lt;/li&gt;
&lt;li&gt;热处理: 死锁的检测与恢复&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;防范死锁&lt;ol&gt;
&lt;li&gt;避免死锁&lt;/li&gt;
&lt;li&gt;死锁预防&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;其他策略&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>初窥HTTP之二_HTTP报文</title>
    <link href="http://yoursite.com/2020/08/03/%E5%88%9D%E7%AA%A5HTTP%E4%B9%8B%E4%BA%8C-HTTP%E6%8A%A5%E6%96%87/"/>
    <id>http://yoursite.com/2020/08/03/%E5%88%9D%E7%AA%A5HTTP%E4%B9%8B%E4%BA%8C-HTTP%E6%8A%A5%E6%96%87/</id>
    <published>2020-08-03T01:00:15.000Z</published>
    <updated>2020-08-03T02:38:19.768Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP 报文的信息 </p><p>HTTP 状态码</p><p>HTTP 首部(待完成)</p><a id="more"></a><h2 id="HTTP-报文的信息"><a href="#HTTP-报文的信息" class="headerlink" title="HTTP 报文的信息"></a>HTTP 报文的信息</h2><p>本段将介绍HTTP报文中包括有那些信息.包括:</p><ol><li>报文的结构</li><li>报文编码</li><li>多部分对象集合</li><li>范围传输</li><li>内容协商</li></ol><h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p>HTTP报文是由多行数据构成的, 每行之间使用<code>CR+LF</code>(\r\n) 进行换行.</p><p>报文可被分为报文首部与报文主体, 后者并不是必须的.</p><p>报文首部包括:</p><ul><li>请求行 / 状态行</li><li>请求首部字段 / 响应首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他</li></ul><p><strong>请求行</strong></p><p>包括请求的方法, 请求URI, HTTP版本</p><p><strong>状态行</strong></p><p>包括响应的结果状态码, 原因短语, HTTP版本</p><p><strong>首部字段</strong></p><p>包括表示各种条件和属性的各类首部语句. 分为四种: </p><ol><li>请求首部字段(仅在请求报文中出现); </li><li>响应首部字段(仅在响应报文中出现); </li><li>通用首部字段; </li><li>实体首部字段;</li></ol><p><strong>其他</strong></p><p>其他未在RFC中定义的字段, 如Cookie</p><h3 id="报文编码"><a href="#报文编码" class="headerlink" title="报文编码"></a>报文编码</h3><p>对传输的数据进行编码可以提高传输速率, 但是编码与解码会消耗CPU资源.</p><h4 id="报文主体与实体主体"><a href="#报文主体与实体主体" class="headerlink" title="报文主体与实体主体"></a>报文主体与实体主体</h4><p>报文是HTTP实际传输的字节流. 报文包括报文首部与报文主体.(报文主体可以是0个或1个)</p><p>实体是作为请求或响应的有效载荷数据. 由实体首部与实体主体组成.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(没有报文主体)</span><br><span class="line">没有实体</span><br><span class="line">if(有报文主体)</span><br><span class="line">if(有1个实体)</span><br><span class="line">if(实体未被处理)&#x2F;&#x2F;处理指: 传输中进行编码操作</span><br><span class="line">无实体首部</span><br><span class="line">实体主体&#x3D;&#x3D;报文主体</span><br><span class="line">if(实体被处理)</span><br><span class="line">有实体首部</span><br><span class="line">实体主体!&#x3D;报文主体</span><br><span class="line">if(有多个实体)</span><br><span class="line">有实体首部</span><br><span class="line">实体主体!&#x3D;报文主体</span><br></pre></td></tr></table></figure><p>个人理解,不一定对.</p><p><a href="https://www.zhihu.com/question/263752229" target="_blank" rel="noopener">知乎:http报文和实体的差别？</a></p><h4 id="压缩传输"><a href="#压缩传输" class="headerlink" title="压缩传输"></a>压缩传输</h4><p>将实体内容通过编码进行压缩, 常见的内容编码有:</p><ul><li>gzip</li><li>compress</li><li>deflate</li><li>identify (不进行编码)</li></ul><h3 id="分割传输"><a href="#分割传输" class="headerlink" title="分割传输"></a>分割传输</h3><p>将大容量的数据分割传输, 让浏览器逐步显示页面, 称作 <strong>分块传输编码</strong>(Chunked Transfer Coding).</p><p>实体被分割成的多个部分使用一个十六进制来标记块的大小. </p><h3 id="多部份对象集合"><a href="#多部份对象集合" class="headerlink" title="多部份对象集合"></a>多部份对象集合</h3><p><a href="https://en.wikipedia.org/wiki/MIME" target="_blank" rel="noopener"><em>Wiki:MIME</em></a></p><p>多功能Internet邮件扩展（MIME）是一种Internet标准，以支持除ASCII以外的字符集以及音频，视频，图像和应用程序附件的文本.</p><p>MIME使用了Multipart 的方法来容纳多种不同类型的数据, 这个方法也被HTTP 采纳.</p><ul><li><p>multipart/form-data</p><p>这是在Web上传表单时使用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;fieldl&quot;</span><br><span class="line"></span><br><span class="line">Joe Blow</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;pics&quot;: filename&#x3D;filel. txt&quot;</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line"></span><br><span class="line">(fi1e1.txt的数据)</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure><ul><li><p>multipart/byteranges</p><p>状态码206（Partial Content，部分内容）</p><p>响应报文包含了多个范围的内容时使用。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Http&#x2F;1.1 206 parTial Content</span><br><span class="line">Date: Fri, 13 Jul 2012 02: 45: 26 GMT</span><br><span class="line">Last-Modified: Fri, 31 Aug 2007 02: 02: 20 GMT</span><br><span class="line">Content-Type: multipart&#x2F;byteranges: boundary&#x3D;THIS_STRING_SEPARATES</span><br><span class="line"></span><br><span class="line">--THIS_STRING_SEPARATES</span><br><span class="line">Content-Type: application&#x2F;pdf</span><br><span class="line">Content-Range: bytes 500-999&#x2F;8000</span><br><span class="line"></span><br><span class="line">...(范围指定的数据)...</span><br><span class="line">--THIS_STRING_SEPARATES</span><br><span class="line">Content-Type: application&#x2F;pdf</span><br><span class="line">Content-Range: bytes 7000-7999&#x2F;8000</span><br><span class="line"></span><br><span class="line">...(范围指定的数据)...</span><br><span class="line">--THIS_STRING_SEPARATES--</span><br></pre></td></tr></table></figure><ul><li><p>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type；</p></li><li><p>报文主体中包括多个实体,每个实体都由实体头部与实体主体组成</p><p>实体的头部与主体之间依旧使用CR+LF换行.</p></li><li><p>使用boundary字符串来划分多部分对象集合指明的各类实体。在boundary字符串指定的各个实体的起始行之前插入”—“标记作为结束.</p></li><li><p>也可以在某处嵌套使用多部份对象集合</p></li></ul><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>指定范围发送的请求叫做<code>范围请求</code>(Range Request)。执行范围请求时，会用到首部字段<code>Range</code>来指定资源的byte范围。byte范围的指定形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes&#x3D;5001-10000&#x2F;&#x2F;5001~10000字节</span><br><span class="line">Range: bytes&#x3D;5001-&#x2F;&#x2F;从5001字节之后全部的</span><br><span class="line">Range: bytes&#x3D;-3000, 5000-7000&#x2F;&#x2F;从一开始到3000字节和5000~7000字节的多重范围</span><br></pre></td></tr></table></figure><p>针对范围请求，响应会返回状态码为<code>206 Partial Content</code>的响应报文。</p><p>对于多重范围的范围请求，响应会在首部字段<code>Content-Type</code>表明<code>multipart/byteranges</code>后返回响应报文。</p><p>如果服务器端无法响应范围请求，则会返回状态码<code>200 OK</code>和完整的实体内容。</p><h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><p><code>内容协商</code>(Content Negotiation)机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</p><p>包含在请求报文中的某些首部字段就是判断的基准，比如：<code>Accept</code>、<code>Accept-Charset</code>、<code>Accept-Encoding</code>、<code>Accept-Language</code>、<code>Content-Language</code>。</p><p>内容协商技术有以下3种类型：服务器驱动协商(Server-driven Negotiation)、客户端驱动协商(Agent-driven Negotiation)、透明协商(Transparent Negotiation)。</p><hr><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><div class="table-container"><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational  (信息性状态码)</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table></div><h3 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx 成功"></a>2xx 成功</h3><blockquote><p>表明请求被正常处理了</p></blockquote><ul><li><p>200(OK) : 正常处理, 该返回啥返回啥</p></li><li><p>204(No Content): 请求处理成功, 但没有资源可返回. 浏览器显示的页面不会更新.</p><p>一般用在只需要从客户端往服务器发送消息,而对客户端不需要发送新消息内容的情况下</p></li><li><p>206(Partial Content): 范围请求,响应报文中包含<code>Content-Range</code>指定范围实体</p></li></ul><h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h3><blockquote><p>表明浏览器需要执行某些特殊处理以正确处理请求</p></blockquote><ul><li>301(Moved Permanently): 永久性重定向,资源<code>URI</code>改变.</li><li>302(Found): 临时性重定向.希望用户(本次)使用新的<code>URI</code>访问</li><li>303(See Other): 和302来ISI,但是明确表示客户端应当采用GET方法获取资源.</li><li>304(Not Modified): 资源已找到,但未符合条件(不把任何相应主体).虽然是<code>3</code>系列,但和重定向没有关系</li><li>307(Temporary Redirect): 临时重定向.和<code>302</code>类似.</li></ul><h3 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h3><blockquote><p>表明客户端是发生错误的原因所在</p></blockquote><ul><li>400(Bad Request): 请求报文中存在语法错误.浏览器会像200一样对待此状态码</li><li>401(Unauthorized): 发送的请求需要通过<code>HTTP</code>认证.若之前已进行过一次请求,则表示用户认证失败.(初次会弹出认证用的对话框)</li><li>403(Forbidden): 对请求资源的访问被服务器拒绝了.服务端可以(也可以不)给出 <code>拒绝的详细理由</code></li><li>404(Not Found): 没有找到请求的资源. (也有可能是拒绝但且不想说明理由时使用)</li></ul><h3 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h3><blockquote><p>表明服务器本身发生错误</p></blockquote><ul><li>500(Internal Server Error): 执行请求时发生错误.可能是<code>Web</code>应用的<code>bug</code>或<code>临时故障</code></li><li>503(Service Unavailable): 服务器暂时处于超负荷或者正在进行停机维护.</li></ul><p>事实上不少返回的<code>状态码</code>是错误的.</p><p>此外, 服务器可以指定自己与客户端的协商状态码.</p><hr><h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><p>待完成</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP 报文的信息 &lt;/p&gt;
&lt;p&gt;HTTP 状态码&lt;/p&gt;
&lt;p&gt;HTTP 首部(待完成)&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Web开发" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Web%E5%BC%80%E5%8F%91/HTTP/"/>
    
    
      <category term="读书笔记:技术" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>初窥HTTP之一_HTTP基础</title>
    <link href="http://yoursite.com/2020/08/01/%E5%88%9D%E7%AA%A5HTTP%E4%B9%8B%E4%B8%80_HTTP%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/08/01/%E5%88%9D%E7%AA%A5HTTP%E4%B9%8B%E4%B8%80_HTTP%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-01T08:06:08.000Z</published>
    <updated>2020-08-03T00:55:32.044Z</updated>
    
    <content type="html"><![CDATA[<ol><li>TCP/IP 基础</li><li>HTTP简介</li></ol><a id="more"></a><h2 id="TCP-IP-基础"><a href="#TCP-IP-基础" class="headerlink" title="TCP/IP 基础"></a>TCP/IP 基础</h2><p>字面上看, TCP/IP包括了TCP与IP这两大协议．但一般意义上认为TCP/IP是指得以TCP,IP为核心协议的一系列协议族<del>(ko no IPS da!)</del>, 这个协议族是整个互联网运作的基础. HTTP协议是包含在TCP/IP协议族的一个子集.</p><blockquote><p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP 。因为该协定家族的两个核心协定：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。</p><p>协议还包括: ARP，IP，ICMP，UDP，TCP，DNS，HTTP，FTP , SMTP，POP3，SNMP，ECHO，DHCP，SSH，NNTP 等.</p><p>From: <a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F" target="_blank" rel="noopener">wiki: TCP/IP协议族</a></p></blockquote><p>本段将简单介绍:</p><ol><li>TCP/IP 的分层管理</li><li>通信传输流,</li><li>IP: 传输</li><li>TCP:可靠性</li><li>DNS: 域名解析</li><li>URI : 资源定位</li></ol><p>以及他们与HTTP是怎么互相协作的.本段不涉及具体的HTTP内容.</p><h3 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h3><p>假设你已经知道了 <a href="https://zh.wikipedia.org/zh-cn/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI模型</a> 将信息传输分为七层, 他们依次是</p><ol><li>第7层 应用层</li><li>第6层 表达层</li><li>第5层 会话层</li><li>第4层 传输层</li><li>第3层 网络层</li><li>第2层 数据链路层</li><li>第1层 物理层</li></ol><p>TCP/IP协议簇(再次提醒并不是TCP与IP这两个协议) 将其简化成了四个层次:</p><ol><li><p>应用层, 对应OSI模型中的7~5层</p><blockquote><p>该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。</p><p>包括<strong>HTTP</strong>（万维网服务）、<strong>FTP</strong>（文件传输）、<strong>SMTP</strong>（电子邮件）、<strong>SSH</strong>（安全远程登录）、<strong>DNS</strong>（名称&lt;-&gt; IP地址寻找）以及许多其他协议</p></blockquote></li><li><p>传输层, 对应OSI模型中的第4层</p><blockquote><p>解决诸如端到端可靠性（“数据是否已经到达目的地？”）和保证数据按照正确的顺序到达这样的问题。在TCP/IP协议组中，传输协议也包括所给数据应该送给哪个应用程序。</p><p>包括 TCP与UDP 协议等</p><blockquote><p>TCP : 是一个“可靠的”、面向链接, 基于字节流的传输机制</p><p>UDP: 是一个无链接的数据报协议。它是一个“尽力传递”（best effort）的协议, 因为它不检查数据包是否已经到达目的地，并且不保证它们按顺序到达。<del>但是快</del></p></blockquote></blockquote></li><li><p>网络互连层, 对应OSI模型中的第3层</p><blockquote><p>解决在网络上流动的数据包. 解决如何选取网络中的路径将数据从源网络传输到目的网络.</p><p>例如IP协议</p></blockquote></li><li><p>网络链路层, 对应OSI模型中的第1~2层</p><blockquote><p>用来处理连接网络的硬件部分, 包括控制操作系统, 硬件设备驱动, NIC(网络适配器, 即网卡) , 以及光纤等物理部分</p></blockquote></li></ol><h3 id="通信传输流"><a href="#通信传输流" class="headerlink" title="通信传输流"></a>通信传输流</h3><ol><li>首先作为发送端的客户端在应用层利用（http）发出一个想看某个Web页面的HTTP请求。</li><li>为了传输方便，在传输层把(TCP)从应用层传下来的数据进行分割，并在各个报文上打上标记序号及端口号发给网络层</li><li>在网络层(IP)，给数据加上作为通信目的地址的MAC地址后发给链路层。到此发送网络的通信请求就准备齐全了</li><li>接收端的服务器在链路层接收到数据，按序往上层发送，直到应用层。才算是真正接收到从客户端发送过来的HTTP请求</li></ol><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E6%B5%81.png" alt=""></p><p>发送端在层与层之间传输数据时，每经过一层必定会被打伤一个该层所属的首部信息。反之，接收端则会一层一层的去掉</p><h3 id="IP-传输"><a href="#IP-传输" class="headerlink" title="IP : 传输"></a>IP : 传输</h3><p><em><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">wiki链接</a></em></p><p>网际协议（英语：Internet Protocol，缩写：IP；也称互联网协议）是用于分组交换数据网络的一种协议。</p><blockquote><p>IP是在TCP/IP协议族中网络层的主要协议，任务仅仅是根据源主机和目的主机的地址来传送数据。为此目的，IP定义了寻址方法和数据报的封装结构。第一个架构的主要版本为IPv4，目前仍然是广泛使用的互联网协议，尽管世界各地正在积极部署IPv6。</p></blockquote><p>要保证数据能够传输需要两个重要条件: IP地址与MAC地址.</p><p>MAC地址是烧录在网卡或者接口上的<strong>物理地址</strong>，具有二层意义和<strong>全球唯一性</strong>，一般不能被改变。IP地址是网络中的主机或者三层接口在网络中的<strong>逻辑地址</strong>，在<strong>同一个网络内具有唯一性</strong>。</p><p>IP地址通过ARP协议与MAC对应, IP地址是可变换的, MAC 地址是不变的.MAC 地址是杂乱无序的, 如果只是用MAC地址尽管可以传输但是造成浪费.(要从整个互联网中找到你这个MAC地址) , 使用IP地址则可以找到你所处的网络, 在从该网络设备转交给你. </p><p><a href="https://www.zhihu.com/question/49335649/answer/120746792" target="_blank" rel="noopener"><em>IP地址和 MAC地址的区别和联系是什么?</em></a></p><h3 id="TCP-可靠性"><a href="#TCP-可靠性" class="headerlink" title="TCP : 可靠性"></a>TCP : 可靠性</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener"><em>wiki链接</em></a></p><p>TCP提供了可靠的字节流服务. 字节流是指将大块数据分割更小块的<strong>报文段 </strong>(segment) 为单位进行传输. 并且能够将数据准确地传给对方, 并且确认数据的送达.</p><p>为了保证数据可靠地送达, TCP 使用了<strong>三次握手</strong>.其中使用了 TCP 的标志（flag): SYN（synchronize） 和 ACK(acknowledgement)</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt=""></p><h3 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS : 域名解析"></a>DNS : 域名解析</h3><p><a href="https://zh.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener"><em>Wiki链接</em></a></p><p><strong>DNS</strong>（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务，或逆向从IP地址反查域名的服务。</p><p>用户输入一个网址, 客户机首先向DNS请求IP地址, 获得后由HTTP协议生成针对目标服务器的 <em>请求报文</em> . TCP 将 请求报文分割成多个报文段并负责传输的可靠性. IP协议将这些报文段传送至指定的目标服务器. </p><p>服务器收到这些报文段后由TCP协议将报文段还原成HTTP的请求报文并检查完整性（如果出错再引起另外的处理), HTTP协议对请求报文进行处理, 并返回响应报文, 后续过程类似. </p><h3 id="URI-资源定位"><a href="#URI-资源定位" class="headerlink" title="URI : 资源定位"></a>URI : 资源定位</h3><p>统一资源标识符（英语：Uniform Resource Identifier，缩写：URI）在电脑术语中是一个用于标识某一互联网资源名称的字符串。</p><p>注意 : URI 是用字符串标识的某一互联网资源, 而URL是资源在互联网上的地址, URL是URI的子集.</p><p>通用URI的格式如下：</p><blockquote><p>[协议名]://用户名:密码@主机名:端口/路径?查询参数#片段ID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                    hierarchical part</span><br><span class="line">        ┌───────────────────┴─────────────────────┐</span><br><span class="line">                    authority               </span><br><span class="line">        ┌───────────────┴───────────────┐</span><br><span class="line">  abc:&#x2F;&#x2F;username:password@example.com:123&#x2F;path&#x2F;data?key&#x3D;value&amp;key2&#x3D;value2#fragid1</span><br><span class="line">  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘ └───┬───┘ └─────────┬─────────┘ └──┬──┘</span><br><span class="line">scheme  user information     host     port  path            query         fragment</span><br><span class="line"> 协议   用户的登录信息  服务器地址  端口  路径    查询参数  片段ID</span><br><span class="line">  urn:example:mammal:monotreme:echidna</span><br><span class="line">  └┬┘ └──────────────┬───────────────┘</span><br><span class="line">scheme              path</span><br></pre></td></tr></table></figure><ul><li><p><strong>协议方案</strong></p><p>使用<code>http:</code> 或<code>https：</code>等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号<code>：</code> . 也可使用<code>data：</code>或 <code>javascript：</code>这类指定数据或脚本程序的方案名。</p></li><li><p><strong>登录信息（认证）</strong></p></li></ul><p>​    指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</p><ul><li><strong>服务器地址</strong></li></ul><p>​    使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的Pv6地址名。</p><ul><li><strong>服务器端口</strong></li></ul><p>​    指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。带层次的文件路径。指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p><ul><li><strong>带层次的文件路径</strong></li></ul><p>​    指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p><ul><li><strong>查询字符串</strong></li></ul><p>​    针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</p><ul><li><p><strong>片段标识符</strong></p><p>使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也为可选项。</p></li></ul><hr><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>本段将非常粗略地一览HTTP基本情况, 包括以下内容:</p><ol><li>HTTP基本情况</li><li>HTTP报文</li><li>HTTP方法与命令</li><li>持久连接</li><li>Cookie : 状态管理</li></ol><h3 id="HTTP基本情况"><a href="#HTTP基本情况" class="headerlink" title="HTTP基本情况"></a>HTTP基本情况</h3><p>HTTP协议用于客户端与服务端之间的通信. 客户端向服务端发出一个访问资源的<strong>请求</strong>, 服务端针对这个请求做出 <strong>响应</strong>. 服务端无法主动地向客户端建立通信.(除非附加了其他协议). 请求与响应都是通过HTTP报文来传送数据的.</p><p>计算机扮演客户端与服务端的角色可能会切换, 但对于每条通信线路二者的角色是确定的.</p><p>HTTP是<strong>无状态协议</strong>, HTTP协议自身对先前的通信状态不进行保存, 不进行持久化处理.这是为了快递处理大量事物,保证协议的可伸缩性.为了实现通信状态的保持状态, 引入了Cookie来实现持久化通信.</p><p>HTTP使用URI进行资源的定位, 指定URI的方式有很多:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 完整的请求URI</span><br><span class="line">GET http:&#x2F;&#x2F;www.baidu.com&#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">2. 使用相对URI地址</span><br><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">HOST: baidu.com</span><br></pre></td></tr></table></figure><p>除此之外, 如果对于服务器本身(而不是访问资源)的请求, 可以只用<code>*</code>来代替请求URI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS * HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>如前所述, HTTP是通过<strong>请求报文</strong>与<strong>响应报文</strong>进行信息传递的. </p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">HOST: baidu.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Content-Length: 5000</span><br><span class="line">If-Modified-Since: Thu. 12 Jul 2020 07: 30: 00 GMT</span><br><span class="line"></span><br><span class="line">name&#x3D;ueno&amp;age&#x3D;37</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>起始处的<code>GET</code> 表示向服务器请求的访问类型, 被称为 <strong>方法</strong>. 而后的字符串<code>/index.html</code> 是使用URI表示的请求访问的资源对象, 被称为 <strong>请求URI</strong>.  <code>HTTP/1.1</code> 是用于表明客户端使用的协议 的 <strong>协议版本号</strong>.</p><p>以上三个参数组成了请求报文的 <strong>请求行.</strong></p><p>后面的几行被称之为 <strong>请求首部字段</strong> (示例中2-6行), 存储了对请求的进一步要求. 最后接上 <strong>内容实体</strong> 的主体.(示例中8行及以后)</p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Http&#x2F;1.1 200 Ok</span><br><span class="line">Date: Thu. 12 Jul 2020 07: 30: 00 GMT</span><br><span class="line">Content-type:message&#x2F;http</span><br><span class="line">Content-Length: 1024</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>首行依次是 <strong>协议版本号</strong>, <strong>状态码</strong>, <strong>状态码的原因短语</strong>, 这一行被称作 <strong>状态行.</strong></p><p>后面几行被称为 <strong>响应首部字段</strong>, 最后被称为 <strong>资源实体</strong>的主体.</p><h3 id="HTTP方法与命令"><a href="#HTTP方法与命令" class="headerlink" title="HTTP方法与命令"></a>HTTP方法与命令</h3><p>下面介绍一些HTTP/1.1中的方法.</p><ul><li><p>GET：获取资源<br>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGl（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。<br><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/GET.png" alt=""></p></li><li><p>POST：传输实体主体<br>POST方法用来传输实体的主体。虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/POST.png" alt=""></p></li><li><p>PUT：传输文件<br>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST （REpresentational State Transfer，表征状态转移）标准的同类Web网站，就可能会开放使用PUT方法。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/PUT.png" alt=""></p></li><li><p>HEAD：获得报文首部<br>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。 </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/HEAD.png" alt=""></p></li><li><p>DELETE：删除文件<br>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制，或遵守REST标准时还是有可能会开放使用的。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/DELETE.png" alt=""></p></li><li><p>OPTIONS：询问支持的方法<br>OPTIONS方法用来查询针对请求URI指定的资源支持的方法</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/OPTIONS.png" alt=""></p></li><li><p>TRACE：追踪路径<br>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200OK的响应。</p><p>客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。但是，TRACE方法本来就不怎么常用，再加上它容易引发XST(Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。 </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/TRACE.png" alt=""></p></li><li><p>CONNECT：要求用隧道协议连接代理<br>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/CONNECT.png" alt=""></p></li></ul><p>方法的名称区分大小写, 注意使用大写字母.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/ALL.png" alt=""></p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>在最开始我们讲到通信建立前TCP协议需要进行三次握手, 此外在结束后还要进行四次挥手. 在HTTP协议的最初版本, 每进行一次通信就要重复执行上述步骤, 导致了大量资源的浪费. (例如一个网页中的多张图片均需要进行请求). 因此在/1.1版本中加入了<a href="https://zh.wikipedia.org/zh-hans/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener"> <strong>持久连接</strong> </a>的方法. 只要任意端没有主动断开连接, 则持续保持TCP的连接状态. </p><p>在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。</p><h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p><a href="https://zh.wikipedia.org/zh-cn/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96" target="_blank" rel="noopener">HTTP管线化</a>（英语：HTTP pipelining）是将多个HTTP请求（request）整批提交的技术，而在发送过程中不需先等待服务器的回应。这是基于持久连接完成的.</p><h3 id="Cookie-状态管理"><a href="#Cookie-状态管理" class="headerlink" title="Cookie : 状态管理"></a>Cookie : 状态管理</h3><p>为了保留无状态协议的轻便性又解决状态保存的问题引入了Cookie技术. 通过在请求与响应报文中写入Cookie信息来控制客户端的状态.</p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 <strong>Set-Cookie</strong> 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请求报文1</span><br><span class="line">GET &#x2F;reader&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;响应报文</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">＜Set-Cookie: sid&#x3D;1342077140226724; path&#x3D;&#x2F;; expires&#x3D;Wed,10-Oct-12 07:12:20 GMT＞</span><br><span class="line">Content-Type: text&#x2F;plain; charset&#x3D;UTF-8</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请求报文2</span><br><span class="line">GET &#x2F;image&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid&#x3D;1342077140226724</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;TCP/IP 基础&lt;/li&gt;
&lt;li&gt;HTTP简介&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Web开发" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Web%E5%BC%80%E5%8F%91/HTTP/"/>
    
    
      <category term="读书笔记:技术" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>时与光W-202007-4</title>
    <link href="http://yoursite.com/2020/07/31/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-4/"/>
    <id>http://yoursite.com/2020/07/31/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-4/</id>
    <published>2020-07-31T11:42:02.000Z</published>
    <updated>2020-07-31T12:56:57.028Z</updated>
    
    <content type="html"><![CDATA[<p>2020年7月20日~7月26日</p><p>宿舍小厨</p><a id="more"></a><h2 id="宿舍小厨"><a href="#宿舍小厨" class="headerlink" title="宿舍小厨"></a>宿舍小厨</h2><p>上周买的食材陆陆续续到了, 即将开始与导员宿管的躲猫猫生活. 由于我手残下单鸡蛋的时候多下了一份,现在我对着80个鸡蛋欲哭无泪… </p><p>整理下目前的装备与食材.</p><ol><li>锅*2, 一个口深适合煮汤, 一个口浅适合煎东西;</li><li>一个蒸蛋器</li><li>面板, 擀面杖, 刀具餐具</li></ol><p>食材:</p><ol><li>鸡蛋</li><li>紫薯</li><li>黑小麦全麦粉</li><li>鸡肉肠, 鸡胸肉,金枪鱼肉罐头</li><li>燕麦麦片</li><li>荞麦面</li><li>全麦面包</li></ol><h3 id="鸡蛋羹"><a href="#鸡蛋羹" class="headerlink" title="鸡蛋羹"></a>鸡蛋羹</h3><p>试图使用蒸蛋器蒸出鸡蛋羹, 但是挺失败的, 尽管在网上找了很多食谱…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">鸡蛋羹做法</span><br><span class="line"></span><br><span class="line">少水蛋(质地硬)</span><br><span class="line">1. ⭐蛋:水&#x3D;1:1.5</span><br><span class="line">2. ⭐小火&gt;&gt;大火</span><br><span class="line">3. 温水&gt;凉水</span><br><span class="line">4. 电解质&gt;水        #电解质:盐&#x2F;高汤</span><br><span class="line">5. 加盖&gt;无盖        #用布反向包裹锅盖</span><br><span class="line">6. ⭐时间刚好&gt;&gt;多蒸一会</span><br><span class="line">7. ⭐凉开水&gt;&gt;自来水</span><br><span class="line"></span><br><span class="line">多水蛋(质地软)</span><br><span class="line">1. 蛋:水&#x3D;1:2 or 1:3</span><br><span class="line">2. 一定要加电解质</span><br><span class="line">3. 火候,时间相对不重要</span><br><span class="line"></span><br><span class="line">其他</span><br><span class="line">1. 蒸锅上汽之后再放入</span><br><span class="line">总结自B站UP喃猫小厨房,BV1x441117r4</span><br></pre></td></tr></table></figure><p>但是总是蒸出来蜂窝蛋…</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E9%B8%A1%E8%9B%8B%E7%BE%B9.jpg" alt=""></p><h3 id="煎鸡蛋"><a href="#煎鸡蛋" class="headerlink" title="煎鸡蛋"></a>煎鸡蛋</h3><p>从最开始打在锅里面热一热, 到后面在少放油的情况下尽量更香, 味道好极了现在.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%85%8E%E8%9B%8B.jpg" alt=""></p><h3 id="什锦-燕麦-紫薯-鸡蛋-牛奶饼"><a href="#什锦-燕麦-紫薯-鸡蛋-牛奶饼" class="headerlink" title="什锦-燕麦-紫薯-鸡蛋-牛奶饼"></a>什锦-燕麦-紫薯-鸡蛋-牛奶饼</h3><p>总而言是是各种奇妙的搭配组合…</p><h4 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h4><p>两个鸡蛋不加水搅拌,加入全麦粉, 加入烤熟切块的紫薯, 放入锅中烤熟.<br>但是我总觉得这么厚的饼不太适合直接烤, 不容易烤熟…而且紫薯块太大, 翻面的时候总是支离破碎.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%B4%AB%E8%96%AF%E9%A5%BC.jpg" alt=""></p><h4 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h4><p>第一次失败后决定做薄饼. 鸡蛋+麦片, 第一锅完全成了炒鸡蛋, 后续陆续放入面粉, 最终成形. 燕麦片本身的厚度使饼没有想象中那么薄, 但相比上一版好多了.</p><p>味道其实不太行, 由于只加入了少许盐, 基本没有任何滋味, 食之无味.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%85%8E%E9%A5%BC0.5.jpg" alt=""></p><h4 id="尝试3"><a href="#尝试3" class="headerlink" title="尝试3"></a>尝试3</h4><p>将燕麦片牛奶泡一晚, 次日打入鸡蛋搅拌, 放油下锅. 煎出来了奇形怪状的小饼干(疑似), 依旧没什么味道.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%85%8E%E9%A5%BC.jpg" alt=""></p><h4 id="尝试4"><a href="#尝试4" class="headerlink" title="尝试4"></a>尝试4</h4><p>直接鸡蛋液打匀分次倒入铺满锅底即可. 本来想加入切丁的鸡肉肠, 但是鸡蛋饼太薄肉丁根本镶嵌不上去, 最后变成了鸡蛋饼+炒肉丁.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E9%B8%A1%E8%9B%8B%E9%A5%BC%E8%82%89%E4%B8%81.jpg" alt=""></p><h3 id="紫薯燕麦粥"><a href="#紫薯燕麦粥" class="headerlink" title="紫薯燕麦粥"></a>紫薯燕麦粥</h3><p>紫薯蒸熟切块, 加水熬制30min,加入麦片熬煮20min, 香浓的燕麦紫薯粥就做好了.</p><p>粥越煮越稠, 我中间还以为自己水加多了去了点, 结果最后快熬干了orz.</p><p>水量没过紫薯上表面1-2公分.</p><p>味道还可以, 口中直呼烫烫烫</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%B2%A5.jpg" alt=""></p><h4 id="荞麦面-煎鸡蛋-炒金枪鱼肉"><a href="#荞麦面-煎鸡蛋-炒金枪鱼肉" class="headerlink" title="荞麦面+煎鸡蛋+炒金枪鱼肉"></a>荞麦面+煎鸡蛋+炒金枪鱼肉</h4><p>好吧这个没啥技术含量..看图吧</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E9%9D%A2.jpg" alt=""></p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>千里之行始于足下, 疫情期间也是看着其他人都化身大厨. 一直想开始却迟迟没有动身. 在学校尝试着开始自己做菜做饭才发现其实没有想象中那么困难, 没有锅碗瓢盆就想办法解决, 没有食材就京东天猫冷链, 缺少绿叶菜就多买水果补充维生素. 天下是有难易乎? 为之, 则难者亦易也.</p><p>还有就是对任何事情都不能等闲视之, 哪怕是简单的鸡蛋羹, 小学三年级在家里面拿微波炉轻松搞定的东西换了厨具做的依旧很糟糕. 煎鸡蛋放多少油? 做饼的面水比例是多少才不粘锅有能均匀铺开? 听到什么声音说明是火候太过了? 好多细节都是没有实操的情况下光靠别人的转述学不到的. 就像这几天在学校招新群里讨论的家长, 自己其实根本不了解行业情况, 道听途说地从别人的谈论, 亲戚朋友的个例中断定专业的优劣. 纸上得来终觉浅,绝知此事要躬行啊.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/ai.png" alt=""></p><h2 id="其他琐碎事件"><a href="#其他琐碎事件" class="headerlink" title="其他琐碎事件"></a>其他琐碎事件</h2><p>跟着宗主任去招新群里面答疑打白工, 每天都能碰见各种神奇的家长, 常面一度十分欢乐</p><h2 id="上周目标完成度"><a href="#上周目标完成度" class="headerlink" title="上周目标完成度"></a>上周目标完成度</h2><h3 id="下周目标"><a href="#下周目标" class="headerlink" title="下周目标"></a>下周目标</h3><p>完全搞定数电+计组</p><p>检查牙齿</p><p>购买装备&amp;爬山</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年7月20日~7月26日&lt;/p&gt;
&lt;p&gt;宿舍小厨&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
</feed>
