<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>船坞</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-09-06T10:11:17.001Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LUY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分算法细节详解</title>
    <link href="http://yoursite.com/2021/07/18/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2021/07/18/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-07-18T10:09:31.000Z</published>
    <updated>2021-09-06T10:11:17.001Z</updated>
    
    <content type="html"><![CDATA[<p>做了忘忘了做，毁灭吧二分</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 旨在给出一个通用模板, 包括了普通二分、最左二分与最右二分</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 搜索区间 *******/</span></span><br><span class="line">    <span class="comment">// left、right 为搜索区间的边界</span></span><br><span class="line">    <span class="comment">// 搜索区间为: [left, right], 左闭右闭</span></span><br><span class="line">    <span class="comment">// 这要求稍后的 while 条件必须为: left &lt;= right</span></span><br><span class="line">    <span class="comment">// 即终止条件为: left = right + 1</span></span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 中位数 mid *******/</span></span><br><span class="line">    <span class="comment">// mid 为 (left+right)/2</span></span><br><span class="line">    <span class="comment">// mid 向下取整, 例如 left = 1; right = 2; 则 mid = 1</span></span><br><span class="line">    <span class="comment">// mid可能会存在数据溢出的情况，以下四种取 mid 的方法：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mid1 := (left + right) / 2</span></span><br><span class="line">    <span class="comment">// mid2 := (left + right) &gt;&gt; 1</span></span><br><span class="line">    <span class="comment">// 当 left+right &gt; INT_MAX_VALUE 时，这两种情况均可能会导致整型溢出</span></span><br><span class="line">    <span class="comment">// 第二种方式使用位移运算代替除法，可以提高性能。</span></span><br><span class="line">    <span class="comment">// 在 golang 中，int 的位数至少为 32 位，取决于平台。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mid3 := (left + (right - left) / 2)</span></span><br><span class="line">    <span class="comment">// mid4 := (left + (right - left) &gt;&gt; 1)</span></span><br><span class="line">    <span class="comment">// 这两种方式可以避免整型溢出</span></span><br><span class="line">    <span class="comment">// 第四种方式使用位移运算代替除法，可以提高性能。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 判断函数 *******/</span></span><br><span class="line">    <span class="comment">// 我们的目标是，找到数组中符合某种条件的数字。</span></span><br><span class="line">    <span class="comment">// 使用 isMatch(a) 表示该数字是否符合条件</span></span><br><span class="line">    <span class="comment">// isMatch(a) 的返回值为 int，其实是三种情况：</span></span><br><span class="line">    <span class="comment">// 1. a 满足匹配条件, 返回 0。</span></span><br><span class="line">    <span class="comment">// 2. a 不满足匹配条件，且满足条件的数字在 a 的右侧, 返回大于 0 的数字。</span></span><br><span class="line">    <span class="comment">// 3. a 不满足匹配条件，且满足条件的数字在 a 的左侧, 返回小于 0 的数字。</span></span><br><span class="line"></span><br><span class="line">    isMatch := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="comment">// if ...</span></span><br><span class="line">        <span class="comment">// return 1</span></span><br><span class="line">        <span class="comment">// if ...</span></span><br><span class="line">        <span class="comment">// return -1</span></span><br><span class="line">        <span class="comment">// if ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 多个符合预期的数 *******/</span></span><br><span class="line">    <span class="comment">// 假设我们想要最简单的二分查找</span></span><br><span class="line">    <span class="comment">// nums:  [1, 2, 3, 3, 3, 4, 5]</span></span><br><span class="line">    <span class="comment">// index:  0, 1, 2, 3, 4, 5, 6</span></span><br><span class="line">    <span class="comment">// target: 3</span></span><br><span class="line">    <span class="comment">// 可见，满足条件的数字下标为：2、3、4;</span></span><br><span class="line">    <span class="comment">// 我们有三种需求：a）找到任意一个满足条件的数；b）找到最左侧的满足条件的数；c）找到最右侧的满足条件的数；</span></span><br><span class="line">    <span class="comment">// 预期解答依次为：a）2/3/4;                b) 2;                   c) 4;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于第一种，我们找到任意一个满足条件的即可返回 mid</span></span><br><span class="line">    <span class="comment">// 对于第二种，我们在找到满足条件的数字时，依旧需要将区间向左缩小。</span></span><br><span class="line">    <span class="comment">// 直到 left == right+1, 最左侧的边界为 left</span></span><br><span class="line">    <span class="comment">// 对于第三种，我们在找到满足条件的数字时，依旧需要将区间向右缩小。</span></span><br><span class="line">    <span class="comment">// 直到 left == right+1, 最右侧的边界为 right</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 区间变动 *******/</span></span><br><span class="line">    <span class="comment">// 由于我们的搜索区间为闭区间，所以若 mid 不满足条件，我们可以直接将其排除在下一次区间之外。</span></span><br><span class="line">    <span class="comment">// if isMatch(a) &gt; 0 &#123;</span></span><br><span class="line">    <span class="comment">//  left = mid + 1</span></span><br><span class="line">    <span class="comment">// &#125; else if isMatch(a) &lt; 0 &#123;</span></span><br><span class="line">    <span class="comment">//  right = mid - 1</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 mid 满足条件，那么需要考虑是上述三种情况的哪一种。</span></span><br><span class="line">    <span class="comment">// a) 情况不用说，直接返回 mid 即可</span></span><br><span class="line">    <span class="comment">// b) 情况需要将区间向左缩小。right = mid - 1</span></span><br><span class="line">    <span class="comment">// c) 情况需要将区间向右缩小。left = mid + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := (left + (right - left)) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> isMatch(nums[mid]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// nums[mid] 不满足匹配条件，且满足条件的数字在 mid 的右侧</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> isMatch(nums[mid]) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// nums[mid] 不满足匹配条件，且满足条件的数字在 mid 的左侧</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> isMatch(nums[mid]) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// a) 找到一个即可</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">            <span class="comment">// b) 找最左边界, 向左缩小区间</span></span><br><span class="line">            <span class="comment">// right = mid - 1</span></span><br><span class="line">            <span class="comment">// c) 找最右边界, 向右缩小区间</span></span><br><span class="line">            <span class="comment">// left = mid + 1</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 返回值与检查 *******/</span></span><br><span class="line">    <span class="comment">// 上述行为并不一定能够保证找到满足条件的解，数组也可能不存在满足条件的解。</span></span><br><span class="line">    <span class="comment">// 所以需要进行结果检查，如果 isMatch(a) 不满足，说明数组中不存在目标解。</span></span><br><span class="line">    <span class="comment">// 此外，left 和 right 都有可能超出边界。</span></span><br><span class="line">    <span class="comment">// a): 并不需要额外检查，如果走到这一步说明确定没有解，返回 -1 即可</span></span><br><span class="line">    <span class="comment">// b): 需要检查 left 是否越界，或 nums[left] 不满足要求</span></span><br><span class="line">    <span class="comment">// c): 需要检查 right 是否越界，或 nums[right] 不满足要求</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// a) 找到一个即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="comment">// b) 找最左边界, 向左缩小区间</span></span><br><span class="line">    <span class="comment">// if left &gt;= 0 &amp;&amp; isMatch(nums[left]) == 0&#123;</span></span><br><span class="line">    <span class="comment">//  return left</span></span><br><span class="line">    <span class="comment">// &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//  return -1</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// c) 找最右边界, 向右缩小区间</span></span><br><span class="line">    <span class="comment">// if right &lt;= len(nums)-1 &amp;&amp; isMatch(nums[right]) == 0&#123;</span></span><br><span class="line">    <span class="comment">//  return right</span></span><br><span class="line">    <span class="comment">// &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//  return -1</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做了忘忘了做，毁灭吧二分&lt;/p&gt;
    
    </summary>
    
    
      <category term="屠龙术" scheme="http://yoursite.com/categories/%E5%B1%A0%E9%BE%99%E6%9C%AF/"/>
    
      <category term="算法与刷题" scheme="http://yoursite.com/categories/%E5%B1%A0%E9%BE%99%E6%9C%AF/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>分享讲座_事务与隔离性</title>
    <link href="http://yoursite.com/2021/06/03/%E5%88%86%E4%BA%AB%E8%AE%B2%E5%BA%A7-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E6%80%A7/"/>
    <id>http://yoursite.com/2021/06/03/%E5%88%86%E4%BA%AB%E8%AE%B2%E5%BA%A7-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E6%80%A7/</id>
    <published>2021-06-03T09:53:08.000Z</published>
    <updated>2021-09-06T09:56:38.386Z</updated>
    
    <content type="html"><![CDATA[<p>这是在工作室与大家分享的关于事务与隔离性的一篇文章。</p><a id="more"></a><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><ul><li><p>回顾 ACID</p></li><li><ul><li>原子性：中止与回滚；简化出错处理；不保证并发；</li><li>一致性：歧义；数据某种约束；应用层职责</li><li>隔离性：模拟串行化；弱隔离性</li><li>持久性：不存在完美的持久880</li></ul></li><li><p>开胃菜</p></li><li><ul><li>脏读：邮箱问题</li><li>更新丢失：递增计数器问题</li></ul></li><li><p>几种弱隔离级别：</p></li><li><ul><li><p>读提交</p></li><li><ul><li>脏读与脏写</li><li>实现：行级锁/两版本</li><li>依旧存在的问题：读倾斜</li></ul></li><li><p>快照隔离</p></li><li><ul><li>一致性快照；读写不干扰；</li><li>实现：MVCC</li><li>更新丢失</li></ul></li></ul></li><li><p>可串行化它不香吗</p></li><li><ul><li><p>幻读与写倾斜</p></li><li><p>隔离级别的弊病</p></li><li><p>三种实现技术</p></li><li><ul><li><p>严格串行化</p></li><li><ul><li>可行性</li></ul></li><li><p>两阶段加锁（悲观锁）</p></li><li><ul><li>写写互斥、读写互斥；读写锁；</li><li>死锁与性能</li><li>幻读：表级锁与区间锁</li></ul></li><li><p>可串行化的快照隔离（乐观锁）</p></li><li><ul><li>基于快照隔离</li><li>提交前检查冲突</li></ul></li></ul></li></ul></li></ul><hr><h2 id="回顾-ACID"><a href="#回顾-ACID" class="headerlink" title="回顾 ACID"></a>回顾 ACID</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>什么是原子？原子就是不可继续分割的东西。</p><p>在计算机的不同讨论范畴内，这个词拥有不同的内涵。例如，当我们讨论 原子操作 的时候，这表明线程  Bob  是无法看到线程 A 的操作的中间态的——要么操作之前，要么操作之后。</p><p>但是在 ACID 中，原子性并不涉及到并发性。原子性表示这种可能性是可能存在的：可能有两个原子同时在执行，而它们之间也许可能看到彼此的中间状态。事实上，这是隔离性的职责。</p><p>原子性提供的保证是：事务要么成功，要么失败。</p><p>如果成功，那么成功；</p><p>如果失败，那么中止并回滚。</p><p>原子性的意义在于，当出现问题时，上层应用并不需要考虑 “恢复现场” 的行为；但是它本身并 不提供任何能够防止问题出现 的帮助。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性这个词汇的歧义更大。例如，我们在谈论 “CAP” 时，是指 对某个指定的客户端来说，读操作能返回最新的写操作。而在我们 ACID 这里，一致性是指，数据处于某种被约束好的一致状态下。</p><p>关于一致性的歧义问题可以参考：<a href="https://juejin.cn/post/6844903782329876494#heading-2" target="_blank" rel="noopener">谈谈数据一致性</a></p><p>举个栗子：</p><p>银行账户中，Alice 账户中有￥114014，Bob 账户中有￥500。Alice 转100元给 Bob ，Alice 扣减100， Bob 加上100。在事务开始前和事务完成之后都能保证他们的帐是对上的，都是满足 “A + B = 114514” 这个约束。</p><p>但是在事务过程中有可能会出现Alice 扣减了100元， Bob 没有加上100元的情况，这就是不一致，不再满足 “A + B = 114514” 这个约束。</p><p>当然，如果出现这种情况下，应该是被认为事务失败、触发原子性、进行中止并回滚。这是原子性的职责了。</p><p>严格来说，一致性这个职责本质上来说不应该是数据库背的锅。类似账户之和为定值这种数据之间存在的依赖关系应当是应用层负责的业务逻辑 。而事实上，ACID中的C其实最开始是为了顺口而加上的。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>原子性并不考虑多个原子（也就是事务）并发执行下可能出现的问题，隔离性来考虑这些。</p><p>隔离性的职责是：在多个事务并发执行的情况下，将其互相隔离，使最终结果就像这些事务串行化执行一样。</p><p>我们在这里不展开讲了，毕竟后面全都是在展开这玩意。</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>如果事务一旦提交成功，那么无论发生什么，数据总不会消失。</p><p>很显然，完美的持久性是不存在的——没准下一秒银河系超空间计划委员会跑过来说由于修建超空间快速通道的行政规划需要毁灭地球呢。我们只是能够防范普通的问题：例如数据库崩溃或者硬件故障等。</p><h2 id="开胃菜"><a href="#开胃菜" class="headerlink" title="开胃菜"></a>开胃菜</h2><p>下面我们回归到隔离性，先来两个开胃菜，看看如果没有隔离性（或者隔离性较弱）的情况下会发生什么。</p><p>在此之前，请先暂时忘掉你们所知道的各种并发处理措施，我们一点点开始。</p><ol><li><h3 id="脏读：邮箱问题"><a href="#脏读：邮箱问题" class="headerlink" title="脏读：邮箱问题"></a>脏读：邮箱问题</h3></li></ol><p>一个邮箱系统为了方便，在显眼处统计了“未读消息”。</p><p>​                 <img src="https://docimg1.docs.qq.com/image/b9ou2YD54CagEHW6Vd_aGA?w=700&amp;h=293" alt="img">        </p><p>​                 <img src="https://docimg7.docs.qq.com/image/-0LkhUHLNBQFdaKo93e6Xg?w=1124&amp;h=468" alt="img">        </p><p>在这里，User 2 在 U1 的两次写入之间读取了信息。这使得 User 2 很困惑：为什么我的邮箱列表中存在未读邮件（count(emails) != 0），而未读邮件数（mailbox.unread）是0呢？</p><p>脏读：读到未被提交的写入。</p><p>在这里，U1 的两次写入应当是属于同一个事务，而 U2 却在事务未提交时，读取了事务的中间状态。这是隔离性不允许的。</p><p>我们会在稍后看到如何解决这个问题。</p><ol><li><h3 id="更新丢失：递增计数器"><a href="#更新丢失：递增计数器" class="headerlink" title="更新丢失：递增计数器"></a>更新丢失：递增计数器</h3></li></ol><p>有一个递增计数器，它的工作是：从数据库中读取一个数据，加一，然后写入数据库。</p><p>​                 <img src="https://docimg4.docs.qq.com/image/0MXhkJhRUgr9ieVQhvaeVw?w=1124&amp;h=352" alt="img">        </p><p>在这里，两个递增操作进行完毕后，数据竟然是 42 -&gt; 43 ！</p><p>这显然是隔离性上的问题。还记得隔离性的职责吗？将并发的结果好像是串行化一样，43肯定不是串行化得到的结果，44才是。</p><p>如何解决更新丢失其实是个很困难的工作。我们会在很后面遇到它，希望我们时间够用。</p><p>这是就有同学问了，既然隔离性的目的是去模拟串行化，为什么不直接进行串行化呢？</p><p>这个问题很有意思，标准回答是，串行化太慢了，就像你天天上班摸鱼老板肯定要多找几个实习生来卷你。性能是非常非常非常重要的，想一想，你作为底层的数据库都这么摸的话，再经过应用的各种业务逻辑处理的放大，用户可谓是一秒一卡，十分潇洒，五步一停，不服不行。</p><p>所以聪明的人们想出了各种方法来优化隔离性，并将之称为弱隔离级别。这些隔离级别可以防止部分并发问题，但不能防范全部。由于并发问题其实是个概率问题，而众所周知概率一向是玄不救非氪不改命，有些人认为一些应用中并不需要过于在意偶尔出现的并发问题，加上性能优势，它们还是被广泛使用。</p><p>但是更有意思的事情是，随着我们接下来的讨论，我们会发现各种隔离级别是如此难以理解。弱隔离级别是工业界妥协的产物，于是后来又有人觉得，去tmd弱隔离，串行化真香！</p><p>接下来，我们会讨论读-提交，快照隔离与可串行化。这些隔离级别逐步增强，可串行化已经能够解决所有的并发问题了。</p><p>我们将会讨论下面这些并发问题：脏读、脏写；读倾斜、更新丢失；写倾斜、幻读；</p><p>我们将会讨论下面这些隔离实现：行级锁、MVCC、两阶段加锁、可串行化快照隔离。</p><p>希望时间够用：）</p><h2 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h2><h3 id="读-提交（Read-Committed）"><a href="#读-提交（Read-Committed）" class="headerlink" title="读-提交（Read Committed）"></a>读-提交（Read Committed）</h3><ol><li>从数据库读时，只能看到已提交的数据（没有脏读（dirty reads））</li><li>写入数据库时，只会覆盖已经写入的数据（没有脏写（dirty writes））</li></ol><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>设想一个事务 A 已经将一些数据写入数据库，但事务A还没有提交或中止。另一个事务B可以看到未提交的数据吗？如果可以，那么这种并发问题就称之为脏读。</p><p>脏读的一个例子我们已经在前面举过了。另外一种情况是，如果 B 将读到的数据返回给应用，但是A最后出问题了，没提交成功而是回滚了。B 的数据将是无中生有出来的，所以说，不要见着风是得雨。假使这些完全无中生有的东西，B帮A上传给应用了，等于 —— B 也有责任吧？！</p><p>我们举一个脏写的例子。</p><div class="table-container"><table><thead><tr><th>事务A</th><th>事务B</th><th>数据库</th></tr></thead><tbody><tr><td>begin transaction</td><td>begin transaction</td><td>x = 0</td></tr><tr><td>write( x = 1 )</td><td></td><td>ok! x = 1</td></tr><tr><td></td><td>write( x = 2)</td><td>ok! x = 2</td></tr><tr><td>No, I want roll back it….</td><td></td><td>ok! x = 0</td></tr><tr><td></td><td>commit</td><td>ok!</td></tr><tr><td></td><td>Let me read x…</td><td>ok! x = 0</td></tr></tbody></table></div><p>事务B：WTF？</p><p>这个例子重点在于，rollback 操作将事务 B 的未提交的写入覆盖成 0 了。</p><p>另外需要注意的是：更新丢失并不是脏写的一种，可以结合下面自己理解，下面这种情况是更新丢失，但不是脏写。准确的说法是，脏xie和更新丢失有一些交集。</p><div class="table-container"><table><thead><tr><th>事务A</th><th>事务B</th><th>数据库</th></tr></thead><tbody><tr><td>begin transaction</td><td>begin transaction</td><td>x = 42</td></tr><tr><td>read(x)</td><td></td><td>ok! x = 42</td></tr><tr><td></td><td>read(x)</td><td>ok! x = 42</td></tr><tr><td>y = x + 1</td><td>z = x + 1</td><td></td></tr><tr><td>write(x = y)</td><td></td><td>ok! x = y = 43</td></tr><tr><td>commit</td><td></td><td>ok!</td></tr><tr><td></td><td>write(x = z)</td><td>ok! x = z = 43</td></tr><tr><td></td><td>commit</td><td>ok!</td></tr></tbody></table></div><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>最常见的情况是，数据库通过使用行锁（row-level lock） 来防止脏写：</p><p>当事务想要修改特定对象（行或文档）时，它必须首先获得该对象的锁。然后必须持有该锁直到事务被提交或中止。</p><p>一次只有一个事务可持有任何给定对象的锁；如果另一个事务要写入同一个对象，则必须等到第一个事务提交或中止后，才能获取该锁并继续。</p><p>那么脏读呢？</p><p>一种方式是使用相同的锁，并要求任何想要读取对象的事务来简单地获取该锁，然后在读取之后立即再次释放该锁。</p><p>但是要求读锁的办法在实践中效果并不好。因为一个长时间运行的写入事务会迫使许多只读事务等到这个慢写入事务完成。</p><p>脏读的另外一种解决方式是使用两个版本的数据。对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。 当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值。我喜欢把这个处理办法叫做 迷你的快照隔离（并非官方称呼，只是我喜欢）</p><p>也许有人会考虑读锁与写锁，那是个很棒的主意，但是我们会在最最后面谈论它了。在这里，读与写操作使用的是相同的锁。</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>读-提交 依旧存在一些无法解决的并发问题。例如最开始的版本更新问题。我们下面介绍另外一种它无法处理的问题，称为 读倾斜（read skew），又名 不可重复读（nonrepeatable read）。</p><p>Alice 拥有两个账户，每个账户 500 元。现在另外一个人试图从账户1中转100块到账户2上（这是一个事务）。Alice 同时在查询自己的余额（这是另一个事务）。她发现自己账户2消失了一百块！</p><p>​                 <img src="https://docimg4.docs.qq.com/image/BaWjd10ugyetbS27PlQqMg?w=1120&amp;h=524" alt="img">        </p><p>需要注意，这个case并不违背读-提交。A 的两次read均没有读到未提交的数据。但是就是出问题了呢？</p><p>是的，Alice 只需要稍后再查一遍账户1就会发现其实没有问题，也就是说之前的读的结果是不可重复的。这里并不是个大问题。但是在另外一些情况下，这种暂时性的不一致也是不能容忍的。</p><p>例如，备份。你不能为了备份就强行停掉数据库的业务能力，但是如何保证数据库在备份过程中（可能持续几小时）不被类似的情况干扰呢？</p><p>也许，我们需要一种方式，能够在瞬间给整个数据库拍个照片。备份操作基于照片，而业务操作继续正常运行。</p><p>是的，这种照片被称为快照。</p><h3 id="快照隔离"><a href="#快照隔离" class="headerlink" title="快照隔离"></a>快照隔离</h3><p>快照隔离的口号是：读写分离。或者是读不阻塞写，写不阻塞读。</p><p>MVCC 的思路和上面的拍照片的比喻还不太一样：比喻中，我们只在备份前拍照，而实际上，我们随时随地都在拍照。或者说，我们拥有时间轴上的数据库的每个时刻的切片，我们根据需要访问。（当然这个切片不会把原子切开）</p><p>每个事务都从数据库的一致快照（consistent snapshot） 中读取——也就是说，事务可以看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改，每个事务也只能看到该特定时间点的旧数据。</p><p>我们直接来看吧。</p><ul><li><p>当一个事务开始时，它被赋予一个唯一的，永远增长的事务ID。</p></li><li><p>当事务向数据库写入（插入删除更新）任何内容时，它所写入的数据都会被标记上写入者的事务ID。</p></li><li><p>当事务读取某行：</p></li><li><ul><li>事务开始时，数据库列出当时所有其他（尚未提交或中止）的事务清单，即使之后提交了，这些事务的写入也都会被忽略。</li><li>被中止事务所执行的任何写入都将被忽略。</li><li>由具有较晚事务ID（即，在当前事务开始之后开始的）的事务所做的任何写入都被忽略，而不管这些事务是否已经提交。</li><li>所有其他写入，对应用都是可见的。</li></ul></li></ul><p>粗糙理解：在事务开始时拍个照，然后只看照片。</p><p>拓展：有没有什么情况下是看最新值呢？有的，这被称为当前读。而上面说的过程被称为快照读。这里就不展开了。参考链接：<a href="https://www.ouyym.com/wen/20383/" target="_blank" rel="noopener">MVCC多版本并发控制</a></p><h3 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h3><p>快照隔离隔离了读与写，规避了在并发情况下的读写冲突。但是并不能解决写-写的并发问题。解决写写的并发问题有多种可行的解决方案。</p><h4 id="原子写操作"><a href="#原子写操作" class="headerlink" title="原子写操作"></a>原子写操作</h4><p>如果数据库系统提供了原子更新操作，那么可以在数据库中原子地更新数据。数据库层面保证它们是并发安全的。例如 Redis 中某些特定的数据结构的操作。</p><h4 id="显式加锁"><a href="#显式加锁" class="headerlink" title="显式加锁"></a>显式加锁</h4><p>在应用层面显式加锁来解决这个问题。又被称为悲观锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT  FROM xxx </span><br><span class="line">    WHERE ...</span><br><span class="line">    FOR UPDATE;    &#x2F;&#x2F; 注意这个FOR UPDATE</span><br><span class="line">UPDATE xxx ...;</span><br></pre></td></tr></table></figure><h4 id="自动检测更新丢失"><a href="#自动检测更新丢失" class="headerlink" title="自动检测更新丢失"></a>自动检测更新丢失</h4><p>原子操作和锁是通过强制读取-修改-写入序列按顺序发生，来防止丢失更新的方法。另一种方法是允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其读取-修改-写入序列。又被称作乐观锁。</p><p>这种方法的一个优点是，数据库可以结合快照隔离高效地执行此检查。但是，MySQL/InnoDB的可重复读并不会检测丢失更新。一些人认为，数据库必须能防止丢失更新才称得上是提供了快照隔离，所以在这个定义下，MySQL下不提供快照隔离。</p><h4 id="原子比较和设置（CAS）等"><a href="#原子比较和设置（CAS）等" class="headerlink" title="原子比较和设置（CAS）等"></a>原子比较和设置（CAS）等</h4><p>略</p><h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><p>上一小节的各种操作依旧不能完全解决并发问题。存在写倾斜：</p><p>例如，预定会议室之前需要先检查会议室是否被预定，然后发出预定请求。当A和B分别预定会议室R时，他们同时去检查了会议室预定表，发现没有房间R在那段时间的记录，然后都预订了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOK_TABLE (room_id, date, start_time, end_time, username)</span><br></pre></td></tr></table></figure><p>写倾斜的实质是：</p><ol><li>应用通过SELECT语句，匹配出一些特定条件的记录。</li><li>根据匹配结果，应用层代码来确定下一步的操作（是预定还是返回已占用的错误）</li><li>如果应用层继续执行，那么它将进行数据库的写入操作</li></ol><p>但是，第三步的数据库写入操作将会改变第一步的匹配结果，进而影响第二步的判断结果。在并发时，不同的事务之间就会影响对方。</p><p>一个很自然的想法是加锁，但是：并不存在加锁的客体。注意是根据记录表种的记录来判断这个时间段的房子是否被占用，你没有办法将一个不存在的记录加锁。</p><p>由加锁延伸出的解决方案是，将所有房间与时间段进行排列组合，然后对结果进行加锁。这种解决方式被称为实体化冲突。但是，为了一个应用层的小需求大幅度改变数据库的底层设计是不好的，相比之下更推荐使用串行化的处理。</p><p>与写倾斜类似的一个并发问题被称为幻读。他们的是出现原因是相同的：一个事务的写入改变了另外一个事务的查询结果。</p><h3 id="隔离级别的弊病"><a href="#隔离级别的弊病" class="headerlink" title="隔离级别的弊病"></a>隔离级别的弊病</h3><ul><li>隔离级别难以理解，并且在不同的数据库中实现的不一致（例如，“可重复读”的含义天差地别）。</li><li>光检查应用代码很难判断在特定的隔离级别运行是否安全。 特别是在大型应用程序中，您可能并不知道并发发生的所有事情。</li><li>没有检测竞争条件的好工具。原则上来说，静态分析可能会有帮助，但研究中的技术还没法实际应用。并发问题的测试是很难的，因为它们通常是非确定性的 —— 只有在倒霉的时机下才会出现问题。</li></ul><h3 id="三种实现"><a href="#三种实现" class="headerlink" title="三种实现"></a>三种实现</h3><h4 id="严格串行化"><a href="#严格串行化" class="headerlink" title="严格串行化"></a>严格串行化</h4><p>可行性</p><p>内存足够便宜了，许多场景现在都可以将完整的活跃数据集保存在内存中。当事务需要访问的所有数据都在内存中时，事务处理的执行速度要比等待数据从磁盘加载时快得多。</p><p>数据库设计人员意识到OLTP事务通常很短，而且只进行少量的读写操作.相比之下，长时间运行的分析查询通常是只读的，因此它们可以在串行执行循环之外的一致快照（使用快照隔离）上运行。</p><h4 id="两阶段加锁（悲观锁）"><a href="#两阶段加锁（悲观锁）" class="headerlink" title="两阶段加锁（悲观锁）"></a>两阶段加锁（悲观锁）</h4><p>之前我们看到锁通常用于防止脏写：如果两个事务同时尝试写入同一个对象，则锁可确保第二个写入必须等到第一个写入完成事务（中止或提交），然后才能继续。</p><p>在那个时候，我们的读与写都是使用的同样的锁。但是——正如大家在数据库课上学的一样——我们接下来使用了两种不同的锁。别称为两阶段锁定（2PL，two-phase locking ）</p><p>两阶段锁定类似，但使锁的要求更强。只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入（修改或删除），就需要独占访问（exclusive access） 权限。</p><p>写写互斥、读写互斥</p><p>2PL 怎么解决前面的写倾斜问题呢？</p><ul><li>A在查询某一时间段的房间预定情况时，会把这个时间段的记录加上读锁。如果此时B拥有写锁，那么A将会等待；</li><li>A在试图写入时，需要将自己的读锁升级为写锁。检查是否由其他事务正在使用读锁，如果有，那么A等待。</li></ul><p>等等，刚才的问题在于，怎么给一个不存在的记录上锁？我们引进了 谓词锁。它能够作用于某一些满足条件的查询对象。</p><p>此外，索引区间锁是大多数数据库采用的，它是谓词锁的近似版本，但是提高性能。</p><p>2PL 的严重问题在于，性能太慢了，而且死锁的出现相当频繁。</p><h4 id="可串行化的快照隔离（乐观锁）"><a href="#可串行化的快照隔离（乐观锁）" class="headerlink" title="可串行化的快照隔离（乐观锁）"></a>可串行化的快照隔离（乐观锁）</h4><p>一方面，我们实现了性能不好（2PL）或者扩展性不好（串行执行）的可序列化隔离级别。另一方面，我们有性能良好的弱隔离级别，但容易出现各种竞争条件（丢失更新，写入偏差，幻读等）。数据库中并发控制似乎前途黯淡。</p><p>但是，2008年提出了一种称为 可串行化的快照隔离 （SSI, serializable snapshot isolation） 的技术，提供了完整的可串行化保证，同时兼顾效率。</p><p>两阶段锁是一种所谓的悲观并发控制机制（pessimistic） ：如果有事情可能出错（如另一个事务所持有的锁所表示的），最好等到情况安全后再做任何事情。</p><p>从某种意义上说，串行执行可以称为悲观到了极致：在事务持续期间，每个事务对整个数据库（或数据库的一个分区）具有排它锁，作为对悲观的补偿，我们让每笔事务执行得非常快，所以只需要短时间持有“锁”。</p><p>相比之下，序列化快照隔离是一种乐观（optimistic） 的并发控制技术。在这种情况下，乐观意味着，如果存在潜在的危险也不阻止事务，而是继续执行事务，希望一切都会好起来。当一个事务想要提交时，数据库检查是否有什么不好的事情发生（即隔离是否被违反）；如果是的话，事务将被中止，并且必须重试。只有可序列化的事务才被允许提交。</p><p>顾名思义，SSI基于快照隔离——也就是说，事务中的所有读取都是来自数据库的一致性快照。在快照隔离的基础上，SSI添加了一种算法来检测写入之间的序列化冲突，并确定要中止哪些事务。</p><p>回顾一下写倾斜。它的问题在于，当我们在读取数据时，无法得知这些数据是否会与随后的写事务由因果关系。SSI 需要试图检测出这种可能性。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>事务的意义在于：将数据库封装好，并且简化或者完全消除开发者对于并发的处理。</p><p>我们首先回顾了一下教科书上关于事务的定义：ACID已经他们的具体内涵。然后我们对于其中的 隔离性 进行了进一步的探讨。隔离性的关键在于使得并发执行的事务们能够假装自己在串行化处理。由于串行化本身的过慢的效率，人们提出了各种弱隔离级别的方案，牺牲了部分的隔离性换取执行效率。</p><p>读-提交隔离级别提供了最基础的能力，防范脏读和脏写的问题。</p><p>快照隔离级别使将读、写分离，从而解决了读倾斜的问题。</p><p>更新丢失是另外的一个问题，有些数据库的快照隔离能够自动处理，而另外一些需要手动解决（例如 MYSQL）</p><p>解决了读-写问题后，我们却对一些面对写-写并发的情况开始无能为力，并有了写倾斜和幻读这两个问题。最终，我们表示qtmd弱隔离，串行化真香！并介绍了几种串行化的实现。</p><p>下面是一些参考资料和拓展阅读资料。</p><p>Thanks for coming.</p><h2 id="参考资料与拓展阅读"><a href="#参考资料与拓展阅读" class="headerlink" title="参考资料与拓展阅读"></a>参考资料与拓展阅读</h2><p>DDIA，第七章</p><p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innod Bob 中的事务隔离级别和锁的关系</a></p><p><a href="https://juejin.cn/post/6844903782329876494" target="_blank" rel="noopener">谈谈数据一致性</a></p><p><a href="http://ouyym.com/wen/20383/" target="_blank" rel="noopener">MVCC多版本并发控制</a></p><p><a href="http://coding-geek.com/how-databases-work/" target="_blank" rel="noopener">How does a relational database work</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是在工作室与大家分享的关于事务与隔离性的一篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="数据库系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>GFS论文笔记</title>
    <link href="http://yoursite.com/2021/05/27/GFS%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/05/27/GFS%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-27T09:28:09.000Z</published>
    <updated>2021-09-06T09:34:53.710Z</updated>
    
    <content type="html"><![CDATA[<p>Google File System，是一个可伸缩的、用于海量分布式数据类型应用的分布式文件系统。</p><p>关键词：容错性、可伸缩性、数据存储、集群存储</p><a id="more"></a><p>原文链接：<a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/papers/gfs.pdf</a></p><p>参考链接：</p><p><a href="https://www.cnblogs.com/liyulong1982/p/6001841.html" target="_blank" rel="noopener">中文机翻</a></p><p><a href="https://mr-dai.github.io/gfs/#GFS-的主要需求" target="_blank" rel="noopener">GFS 总结</a></p><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><ol><li><p>和其他布式文件系统类似，它设计时的目标包括：较好的性能、灵活的扩展性、高可靠性以及高可用性（performance, scalability, reliability, and availability）</p></li><li><p>但GFS在设计时还考虑了在大数据下的应用的负载（ application workloads），以及当前的技术环境（ technological environment）。这些考量使得GFS与其他系统有较大的区别。下面列举几点GFS设计时的考量：</p></li><li><ol><li>假设组件失效（component failures）是机器集群的常态。考虑到，我们的机器集群的规模之大、以及单位成本之低（quantity and quality of the components）。这使得单一机器的可靠性并不是那么高（成本限制），而保证集群中的所有机器同时处于可靠状态的几率更小（规模限制）。这些失效可能各种各样：application bugs, operating system bugs, human errors, and the failures of disks, memory, connectors, networking, and power supplies. </li><li>文档的尺寸往往是极大的。GB、甚至TB级别的文件是常态，而KB级别的小文件是较少的。因此在设计时，我们基于大文件重新审视了一些参数，例如IO操作与块的大小（I/O operation and block sizes ）我们支持KB级别的文件处理，但并不会专门去优化它。</li><li>顺序写，而非随机写。大部分文件的变更是采用在追加新数据，而不是重写原有数据的方式。随机写的模式在实际中几乎不存在。一旦写完之后，文件只能读（甚至通常只能顺序读）。考虑到这种针对海量文件的访问模式，我们将性能优化和原子性保证的设计重点放在了数据的追加上（appending ）。此外，客户端对数据块缓存毫无吸引力。</li><li>我们选择应用程序和文件系统API的协同设计，这样可以增加系统的灵活性，并进而有利于系统。例如，我们放松了对GFS一致性模型的要求，不用在应用程序中强加繁重负担，大大简化了文件系统；引入了原子性的追加操作，这样多个客户端可以对一个文件同时进行追加操作，不需要他俩之间额外的同步机制。这些后文会进一步了解。</li></ol></li><li><p>目前（2003）最大的一个GFS集群拥有超过1000个存储节点，超过300TB的硬盘存储，被不同机器上的数百个客户端连续不断的频繁访问。</p></li></ol><h2 id="DESIGN-OVERVIEW"><a href="#DESIGN-OVERVIEW" class="headerlink" title="DESIGN OVERVIEW"></a>DESIGN OVERVIEW</h2><h3 id="Assumptions"><a href="#Assumptions" class="headerlink" title="Assumptions"></a>Assumptions</h3><p>系统的设计基于以下假设：</p><ul><li>系统的组件会频繁失效，前述此略；</li><li>系统主要针对大文件进行优化，前述此略；</li><li>读取方式主要有两种，（大规模的）流式读与（小规模的）随机读；来自同一个客户机的连续操作通常是大规模的读取一个文件中一个连续区域。小规模的随机读取通常是在任意位移上读取几个KB数据；</li><li>写入方式主要也有两种。大规模的、顺序的、对文件追加数据的写操作。数据一旦被写入后，文件很少被再次变更。系统支持在文件任意位置写入的小数据的操作，但没有针对这种操作进行优化。</li><li>高可持续的网络带宽比低延迟更重要。我们很看重高速率大批量地处理数据，哪怕其响应速度相对较慢，极少有程序对单一的读写操作有严格的响应时间要求。</li></ul><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><ol><li>整个GFS体系中包括一个Master节点和多个 Chunkservers 节点。客户端Client再与它们交互</li><li>文件会被分为等大小的块（chunks）。每个文件块都被赋予一个64bit长、不可变的标识符，称为块句柄（chunk handle）。Chunkserver 将块保存在本地硬盘上，并且根据指定的块句柄和字节范围来读写数据。每个块都会被冗余存储在不同的 Chunkserver 节点上（默认冗余3份）。</li><li>Master节点用于保存文件系统的元数据（metadata），而具体的文件数据被存放在 Chunkserver 的本地磁盘上。具体内容见 2.4</li><li>Chunkserver、Client 均不会缓存文件数据。客户端的理由是，文件过大且少有会被重复处理的、缓存的收益低。Chunkserver的理由是，数据本身就是以文件存储于系统上的，系统本身提供了缓存功能。但是客户端会缓存元数据，以减少与Master的通信。</li></ol><p>​                 <img src="https://docimg10.docs.qq.com/image/O8jymWznOVP7uB2mqw223A?w=927&amp;h=396" alt="img">        </p><p>见上图。Client先向Master通信，拿到需要的文件块以及offset等相关信息；Cilent再与Chunkserver通信，获得具体的文件数据。具体</p><h3 id="Single-Master"><a href="#Single-Master" class="headerlink" title="Single Master"></a>Single Master</h3><p>系统中仅有一个Master，这种 设计能够简化系统，并且不需要Master花费性能用于多Master的同步开销上。但是受限于此，单节点可能称为系统的瓶颈，这使得设计时尽量将职责从Master上转移。</p><p>出于此，Client并不需要和Master节点进行文件数据的传输，而是和 Chunkserver 进行数据传输。</p><p>Client 如何读取数据？</p><ol><li>客户端将需要读取的数据所处的文件名、偏移量转换为 chunk index（例如，需要的数据位于该文件的第几块上）</li><li>Client 与 Master 通信，发送file name 与 chunk index</li><li>Master查出文件的句柄（ chunk handle）与该文件所处的节点（location）并返回给Client</li><li>同一个文件所处的location可能有多个，Client自行选择一个replicas（通常是最近的）；此外，Client通常会缓存Master返回的这些信息，以便后续减少对Master的频繁请求</li><li>Client 向 chunkserver 发送请求，并获得返回的文件数据。</li></ol><p>后续Client对于相同的块的请求就可以从缓存中直接获取文件的存储节点，也就不需要向Master请求了。</p><p>此外，Client往往会在第二步中请求多个额外块的信息，这些额外信息实际上不会额外占用带宽，但是可以减少后续的C-M请求。</p><h3 id="Chunk-Size"><a href="#Chunk-Size" class="headerlink" title="Chunk Size"></a>Chunk Size</h3><p>块的大小是关键的设计参数之一。我们选择了64MB，这个尺寸远远大于通常文件系统的块大小。每个块副本都以普通Linux文件的形式保存在Chunkserver上。</p><p>大尺寸块有几个重要的优势。</p><ol><li>它减少了客户端和master交互的需求，因为对同一块的读写只需要一次和mater的初始请求来获取块的位置信息。这种缩减我们的工作负载至关重要，因为应用程序大都是连续读写大文件。即使是小规模的随机读取，客户端可以轻松地为一个数TB的工作集缓存所有的块位置信息。</li><li>因为采用较大块，客户端很可能对一个块执行多次操作，这样可以通过与Chunkserver在很长的时间内保持持久的TCP 连接来减少网络负载。</li><li>它减少了在master上保存的元数据的大小。这就允许我们把元数据保存在内存中，这也带来了其它优势，我们将在在2.6.1节进行讨论。</li></ol><p>另一方面，即使配合惰性空间分配，大尺寸块也有其缺点。</p><ol><li>小文件包含少量的块，甚至只有一个块。如果许多客户端访问同一个小文件，存储这些块的Chunkserver就会变成热点。在实际中，由于我们的程序通常是连续的读取包含多个块的大文件，热点还不是主要问题。</li><li>然而，当GFS第一次被批处理队列系统使用的时候，热点问题还是显露了：一个可执行文件作为一个单块文件写在了GFS上，之后同时在数百台机器上启动。存放这个可执行文件的几个Chunkserver被数百个并发请求造成过载。我们通过使用更大的复制因子来保存这样的可执行文件，并且让批处理队列系统错开程序的启动时间的方法解决了这个问题。一个可能的长效解决方案是，在这种的情况下允许客户端从其它客户端读取数据（p2p?）。</li></ol><h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>Master会存储三种类型的元数据：</p><ol><li>文件与块的命名空间</li><li>文件名 ~ 块的映射关系</li><li>每个块的副本的存放位置（location）</li></ol><p>这三种数据是存放在Master的内存之中，但是前两者会使用log的方式进行持久化并备份。这使得Master在崩溃后可以恢复工作。而具体的块副本的位置并不会持久化，在Master启动、Chunkserver加入集群时，Chunkserver会主动向Master提供自己所拥有的块信息。</p><h4 id="In-Memory"><a href="#In-Memory" class="headerlink" title="In-Memory"></a>In-Memory</h4><p>元数据保存在内存之中，因此Master的操作速度非常之快。Master还会在后台周期性地扫描当前的集群状态，扫描结果将会被用于垃圾收集、Chunkserver的失效备份，以及负载均衡、块迁移等。4.3和4.4章节将进一步讨论这些行为。</p><p>将元数据存放在内存中的潜在问题在于：内存的上限导致了块数量存在上限。但实际中问题并不严重，每个块需要的元数据并不大（通常少于64字节）而且，相比于内存存储所带来的简洁性、可靠性、高性能和灵活性而言，针对Master的内存硬件开销是值得的。</p><h4 id="Chunk-Locations"><a href="#Chunk-Locations" class="headerlink" title="Chunk Locations"></a>Chunk Locations</h4><p>前面说过，Master并不会将Chunk Locations 进行持久化记录，而是在启动时轮询chunkservers 来获取这些信息。由于Master本身也需要对chunkservers 进行心跳检测，所以是可以保持Chunk Locations 始终处于最新状态。</p><p>不持久化该信息是出于以下的考量：在chunkservers 加入、离开集群、更名、失效、重启时，需要与Master保持同步Chunk Locations。在节点较多的集群中，类似的事情发送地非常频繁与费时。此外，Chunk Locations 应当由chunkservers 自己说了算，自行处理各类问题并向Master负责。Master就不应该试图保留Chunk Locations 。</p><h4 id="Operation-Log"><a href="#Operation-Log" class="headerlink" title="Operation Log"></a>Operation Log</h4><p>操作日志包含了元数据变更历史记录。它也作为定义同步操作顺序的逻辑时间基线，类似数据库的多版本管理。</p><p>与其他的日志系统似乎没啥大区别，略。</p><h3 id="Consistency-Model"><a href="#Consistency-Model" class="headerlink" title="Consistency Model"></a>Consistency Model</h3><p>GFS提供了一个宽松的一致性模型，这个模型很好地支撑我们的高度分布的应用，但是也不会由于较强的一致性限制拖慢系统。</p><h4 id="Guaranteesby-GFS"><a href="#Guaranteesby-GFS" class="headerlink" title="Guaranteesby GFS"></a>Guaranteesby GFS</h4><p>妈的，看不懂</p><h2 id="SYSTEM-INTERACTIONS"><a href="#SYSTEM-INTERACTIONS" class="headerlink" title="SYSTEM INTERACTIONS"></a>SYSTEM INTERACTIONS</h2><p>系统力图最小化master与所有操作的牵连。在这样的背景下描述客户机、master和Chunkserver如何交互以实现数据变更、原子记录追加以及快照功能。</p><h4 id="Leases-and-Mutation-Order"><a href="#Leases-and-Mutation-Order" class="headerlink" title="Leases and Mutation Order"></a>Leases and Mutation Order</h4><p>变更是改变块内容或者块元数据的操作，包括写操作或者追加操作。由于每个块的信息时冗余存储在不同的副本上，因此每次变更将在块所有的副本上执行。</p><p>租约（Lease）被用于维护副本间的一致性变更顺序。Master向其中一个副本授权一个块租约，我们把这个副本叫做主副本。再由主副本自主决定数据变更的序列顺序。</p><p>租约的初始过期时间为60秒。然而主副本可以请求并且通常会得到master无限期的延长。这些延长请求和批准信息附在定期交换的心跳消息中。</p><p>租约的时效性可以保证，即使master和主副本失去联系，它仍然可以安全地在旧的租约到期后和向另外一个副本授权新的租约。</p><p>​                 <img src="https://docimg1.docs.qq.com/image/Xe34y71yT3nNwRRWkdZ3Xg?w=565&amp;h=501" alt="img">        </p><ol><li>客户机询问master哪一个Chunkserver持有该块当前的租约，以及其它副本的位置。如果没有chunkserver持有租约，master将先把租约授权给Master选择的副本。</li><li>master将主副本的标识符以及其它副本（称为次级副本secondary）的位置返回给客户机。客户机为将来的变更缓存这些元数据，直到租约过期或主副本不可达。</li><li>客户机将需要更改的数据推送到所有的副本中，但是此时并没有正式写入，推送的数据将会缓存在Chunkserver中。</li><li>当所有的副本都确认接收到刚才推送的更改数据后，Client会向主副本发送写请求。主副本可能会同时受到多个client的并发写请求，它自行决定如何将这些更改请求序列化，并顺序执行这些操作并更新自己的状态。</li><li>Primary将写请求转发到secondary中，每个secondary都将根据primary分配的序列顺序来变更数据。</li><li>所有次级副本回复主副本并标明它们已经完成了操作。</li><li>主副本回复客户机。</li></ol><p>这期间，任何副本遇到的任何错误都报告给客户机。出错的情况下，写操作可能在主副本和次级副本的任意子集上执行成功。（如果在主副本失败，就不会分配序列号和转发。）客户端请求被认定为失败，被修改的域处于不一致的状态。我们的客户机代码通过重试失败的变更来处理这样的错误。在退到从头开始重试之前，客户机会将从步骤（3）到步骤（7）做几次尝试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google File System，是一个可伸缩的、用于海量分布式数据类型应用的分布式文件系统。&lt;/p&gt;
&lt;p&gt;关键词：容错性、可伸缩性、数据存储、集群存储&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="乘龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/"/>
    
      <category term="分布式系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="MIT6.824" scheme="http://yoursite.com/tags/MIT6-824/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce_2004_Note</title>
    <link href="http://yoursite.com/2021/05/11/MapReduce-2004-Note/"/>
    <id>http://yoursite.com/2021/05/11/MapReduce-2004-Note/</id>
    <published>2021-05-11T09:42:06.000Z</published>
    <updated>2021-09-06T09:49:57.240Z</updated>
    
    <content type="html"><![CDATA[<p>这是2004年的分布式论文 Map Reduce的阅读笔记。</p><p>论文链接🔗 <a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf</a></p><a id="more"></a><h2 id="文章笔记"><a href="#文章笔记" class="headerlink" title="文章笔记"></a>文章笔记</h2><p>对于每个段落进行概述。</p><h3 id="摘要-Abstract"><a href="#摘要-Abstract" class="headerlink" title="摘要 Abstract"></a>摘要 Abstract</h3><ol><li>MapReduce是一个编程模型，专门用于处理、产生海量数据集的实现。</li><li>用户使用 map 与 reduce 两个方法来达成目标，这两个方法的具体使用在第二部分介绍。</li><li>这种编程模型所产生的程序便于实行并行化，并且对外不需要关心有关分布式的细节：例如分割输入数据、集群上的调度、容错处理以及机器间通信。便于无经验的开发人员使用。</li><li>它可以运行在由普通机器组成的集群上，而这个集群的规模可以灵活调整。</li></ol><ol><li><h3 id="介绍-Introduction"><a href="#介绍-Introduction" class="headerlink" title="介绍 Introduction"></a>介绍 Introduction</h3></li><li><p>在过去，人们编写了大量的用于计算海量数据的程序，例如…（略）</p></li><li>这些程序的数据计算量是很大的，导致时间上的成本不可接受——唯一的解决方案是并行化处理。</li><li>并行化处理带来了更多的问题，并将简单的计算变成了复杂的工程。这些问题例如：how to parallelize the computation, distribute the data, and handle failure</li><li>因此我们设计了一种新的模型来隐藏并行化、容错、分布数据以及负载均衡等细节。</li><li>我们采用了the map and reduce方案：</li></ol><p>We realized that most of our computations involved applying a map operation to each logical “record” in our input in order to compute a set of intermediate key/value pairs, </p><p>and then applying a reduce operation to all the values that shared the same key, in order to combine the derived data appropriately. </p><p>Our use of a functional model with userspecified map and reduce operations allows us to parallelize large computations easily and to use re-execution as the primary mechanism for fault tolerance.</p><ol><li>这个设计的主要贡献是，通过简单有用的接口来实现自动的并行化和大规模分布式计算，通过这个接口设计，可以在大量普通的PC机上实现高性能计算。</li></ol><h3 id="2、程序模型-Programming-Model"><a href="#2、程序模型-Programming-Model" class="headerlink" title="2、程序模型 Programming Model"></a>2、程序模型 Programming Model</h3><p>整个程序的输入（input）为：一个 k-v 键值对的集合；输出（output）为：一个 k-v 键值对的集合；计算过程中包括两个用户自定义的函数：map 和 reduce，</p><p>Map：</p><p>input：从input集合中取出一个 k-v 对（k1, v1）</p><p>output：计算得到一堆的键值对 set(k2,v2)，我们将这一阶段的输出称为 intermediate file </p><p>Reduce:</p><p>input：从Map的计算结果中得到某一键和一系列的值（k2, list(v2)）</p><p>output：根据需要处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从一个 k-v 中得到set(k2,v2)</span><br><span class="line">map(String key,String value):</span><br><span class="line">    &#x2F;&#x2F;key:文档的名字</span><br><span class="line">    &#x2F;&#x2F;value:文档的内容</span><br><span class="line">    for each word w in value:</span><br><span class="line">        EmitIntermediate(w,&quot;1&quot;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;从之前的结果中获取一个k和对应的一系列v</span><br><span class="line">reduce(String key,Iterator values):</span><br><span class="line">    &#x2F;&#x2F;key:一个词</span><br><span class="line">    &#x2F;&#x2F;values:一个计数列表</span><br><span class="line">    int result&#x3D;0;</span><br><span class="line">    for each v in values:</span><br><span class="line">        result+&#x3D;ParseInt(v);</span><br><span class="line">     Emit(AsString(resut));</span><br></pre></td></tr></table></figure><h3 id="3、实现-Implementation"><a href="#3、实现-Implementation" class="headerlink" title="3、实现 Implementation"></a>3、实现 Implementation</h3><p>MapReduce接口可以有不同的实现，但是正如我们所说，这个接口的主要贡献就是，通过简单有用的接口来实现自动的并行化和大规模分布式计算。因此我们将着重介绍每个节点是如何分配工作、如何协作的。</p><h4 id="3-1、Overview"><a href="#3-1、Overview" class="headerlink" title="3.1、Overview"></a>3.1、Overview</h4><p>​                 <img src="https://docimg7.docs.qq.com/image/hAQBWzDu5llyE4ubcrlOHQ?w=1087&amp;h=779" alt="img">        </p><p>Map 操作被分布至多个机器之上分别运行，将原始数据分成 M 片（splits）进行处理。Reduce操作同样如此，我们根据 intermediate value 的key作为依据来进行分割成R块来进行处理。例如hash(key) mod R ，当然这里的分割算法是用户自定的。</p><p>走一下全部的流程：</p><ol><li>首先将所有的输入文件划分为 M 片，每个片的大小一般从 16到64MB(用户可以通过可选的参数来控制). 随后，在集群中我们将会开始大量地拷贝 mapreduce 程序。</li><li>在集群中的程序拷贝中，有一个是用于分配任务的master，其他的都是由master分配任务的worker.有M 个map任务和R个reduce任务将被分配.</li><li>一个执行 map 任务的 worker 会将它所负责的 split 读取，并进行 map 计算。输出的 intermediate k-v 对会暂存在内存之中。</li><li>缓存在内存中的中间结果被周期性地刷写到（本地）磁盘之上，这些中间结果随后会被Reduce过程中使用。这些被写入磁盘中的中间文件的location会被传递到master中，并且被master将地址调度到reduce worker处</li><li>reduce worker接收到来自master的location消息后，使用远程调用来读取磁盘中的中间数据，并对读取到的数据进行排序（如果数据量过大，可能还要外部排序）。排序的理由是：往往不同key的中间结果被分配到了同一个worker中，因此需要将相同key的内容聚合在一起。</li><li>reduce worker 对于每一个中间key，启动一个reduce任务，并使用自定的reduce函数将这个key与一系列value计算出输出结果，将结果追加到输出文件之中。</li><li>在所有的任务完成后，master节点唤醒用户程序，并且将最终结果返回。</li></ol><p>最终的输出结果存放在 R 个文件中，每一个 Reduce 任务都产生一个文件。一般而言用户不会直接使用这些输出结果——他们往往会将结果作为另外一个输入传递到其他的MapReduce调用,或者在可以处理多个分割文件的分布式应用中使用他们.</p><h4 id="3-2、Master"><a href="#3-2、Master" class="headerlink" title="3.2、Master"></a>3.2、Master</h4><p>Master节点会存储每个Map/Reduce 任务的状态（idle, in-progress, or completed）以及执行该任务的worker的标识符（只有后两种状态的任务会有对应worker）。</p><p>Master负责将map阶段完成的结果划分为 R 块，并且追加到reduce worker上，它扮演了一个管道的角色。</p><h4 id="3-3、容错"><a href="#3-3、容错" class="headerlink" title="3.3、容错"></a>3.3、容错</h4><p>在成百上千个机器组成的集群中，发生错误才是正常现象</p><h5 id="Worker-Failue"><a href="#Worker-Failue" class="headerlink" title="Worker Failue"></a>Worker Failue</h5><p>master周期性的ping每个worker. </p><p>如果master在一个确定的时间段内没有收到worker返回的信息,那么它将把这个worker标记成失效.</p><p>该节点上的已经完成map任务被重新设置成它初始的idle状态, 然后被安排给其他的worker.</p><p>该节点上的正在运行的map或reduce任务,也被重新设置成空闲状态,并且将被重新调度.</p><p>由于 Map 阶段的结果被存储在了该节点的本地磁盘上，后续的reduce节点将无法访问它们，所以完成态的map需要被重新运行；而reduce阶段的结果被存储在全局文件系统之中，所以只需要重新运行未完成的reduce任务即可。</p><p>Map worker A失效会通知到所有的Reduce worker，并且它们会在读取A的文件时从新调度的map worker B中读取文件。</p><h5 id="Master-Failue"><a href="#Master-Failue" class="headerlink" title="Master Failue"></a>Master Failue</h5><p>周期性地写入Master的状态，并在失效后从检查点回滚</p><h5 id="Semantics-in-the-Presence-of-Failures"><a href="#Semantics-in-the-Presence-of-Failures" class="headerlink" title="Semantics in the Presence of Failures"></a>Semantics in the Presence of Failures</h5><p>任何一个阶段的操作对于文件的读写都是原子性的。</p><p>Reduce 阶段会在本地磁盘中生成一个临时文件，并且在任务完成后调用 rename() 方法（这个方法是由文件系统支持的）来将临时文件重命名为最终输出文档到全局文件系统中。如果有多个Reduce worker执行了同样的任务，那么他们的输出文档将会被命名为同样的名称。</p><p>Map 阶段会在 Map worker的本地磁盘中生成R个文件，因为 Map 的输入是乱序的，而中间结果的输出将会被输入到R个不同的节点之中。</p><p>如果用户的Map/Reduce方法都是确定的——同样的输入得到同样的输出，那么经过整个流程后输出文件也是确定的；如果他们不是确定的话，那么不同顺序下的输出可能会不一样。</p><h4 id="3-4、存储位置"><a href="#3-4、存储位置" class="headerlink" title="3.4、存储位置"></a>3.4、存储位置</h4><p>尽可能是的数据存储在本地，以便节省网络带宽。</p><h4 id="3-5、任务粒度"><a href="#3-5、任务粒度" class="headerlink" title="3.5、任务粒度"></a>3.5、任务粒度</h4><p>我们细分map阶段成M个片,reduce阶段成R个片.</p><p>M和R应当比worker机器的数量大许多.每个worker执行许多不同的工作来提高动态负载均衡,也可以加速从一个worker失效中的恢复</p><p>但是 R 的数量经常会被用户限制，因为他们可能并不希望获得过多的输出文件。</p><h4 id="3-6、-Backup-Tasks"><a href="#3-6、-Backup-Tasks" class="headerlink" title="3.6、 Backup Tasks"></a>3.6、 Backup Tasks</h4><p>可能会存在落后者的问题，某些任务在执行中由于各种各样的问题导致计算过程的极度缓慢。（例如，磁盘读写突然莫名原因降至3MB/s）这将导致系统的瓶颈被限制到了某个（不确定的）机器上。</p><p>我们有一个一般的机制来减轻这个落后者的问题.当一个MapReduce操作将要完成的时候,master调度备用进程来执行那些剩下的还在执行的任务. 只要任意一些节点完成了剩下的任务，那么我们就视为完全完成了所有的任务。,通常只会占用多几个百分点的机器资源.我们发现这可以显著的减少完成大规模MapReduce操作的时间.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是2004年的分布式论文 Map Reduce的阅读笔记。&lt;/p&gt;
&lt;p&gt;论文链接🔗 &lt;a href=&quot;https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="乘龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/"/>
    
      <category term="分布式系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="MIT6.824" scheme="http://yoursite.com/tags/MIT6-824/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之Object类</title>
    <link href="http://yoursite.com/2020/12/22/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%20Object%20%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/12/22/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%20Object%20%E7%B1%BB/</id>
    <published>2020-12-22T07:45:25.000Z</published>
    <updated>2020-12-31T23:43:28.317Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了关于 Object 类的方法。内容包括：</p><ol><li>所有方法的功能与部分实现</li><li>讨论了 hashCode() 与 equal() 的关系</li><li>讨论了 Cloneable 接口与深浅拷贝</li><li>讨论了 Java 基于 wait() 与 notify（）的管程机制</li></ol><a id="more"></a><p>众所周知，Java 中的 Object 类是所有类的超类。也就是说任意类都会继承 Object 中的方法。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202012/21/image-20201221013916776.png" alt="image-20201221013916776" style="zoom:67%;" /></p><div class="table-container"><table><thead><tr><th style="text-align:left">Modifier and Type</th><th style="text-align:left">Method</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>protected Object</code></td><td style="text-align:left"><code>clone()</code></td><td style="text-align:left">Creates and returns a copy of this object.<br/>创建该对象的一个拷贝</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>equals(Object obj)</code></td><td style="text-align:left">Indicates whether some other object is “equal to” this one.<br/>判断当前对象与传入参数是否“相等”</td></tr><tr><td style="text-align:left"><code>protected void</code></td><td style="text-align:left"><code>finalize()</code></td><td style="text-align:left"><strong>Deprecated.</strong> The finalization mechanism is inherently problematic.<br/>不建议使用。会在对象被GC回收之前调用</td></tr><tr><td style="text-align:left"><code>Class&lt;?&gt;</code></td><td style="text-align:left"><code>getClass()</code></td><td style="text-align:left">Returns the runtime class of this <code>Object</code>.<br/>获取对象的类</td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>hashCode()</code></td><td style="text-align:left">Returns a hash code value for the object.<br/>获取对象的hash值</td></tr><tr><td style="text-align:left"><code>void</code></td><td style="text-align:left"><code>notify()</code></td><td style="text-align:left">Wakes up a single thread that is waiting on this object’s monitor.<br/>任意唤醒一个在此对象监视器上等待的线程</td></tr><tr><td style="text-align:left"><code>void</code></td><td style="text-align:left"><code>notifyAll()</code></td><td style="text-align:left">Wakes up all threads that are waiting on this object’s monitor.<br/>唤醒全部在此对象监视器上等待的线程</td></tr><tr><td style="text-align:left"><code>String</code></td><td style="text-align:left"><code>toString()</code></td><td style="text-align:left">Returns a string representation of the object.<br/>将该对象转为字符串</td></tr><tr><td style="text-align:left"><code>void</code></td><td style="text-align:left"><code>wait()</code></td><td style="text-align:left">Causes the current thread to wait until it is awakened, typically by being <em>notified</em> or <em>interrupted</em>.</td></tr><tr><td style="text-align:left"><code>void</code></td><td style="text-align:left"><code>wait(long timeoutMillis)</code></td><td style="text-align:left">Causes the current thread to wait until it is awakened, typically by being <em>notified</em> or <em>interrupted</em>, or until a certain amount of real time has elapsed.</td></tr><tr><td style="text-align:left"><code>void</code></td><td style="text-align:left"><code>wait(long timeoutMillis, int nanos)</code></td><td style="text-align:left">Causes the current thread to wait until it is awakened, typically by being <em>notified</em> or <em>interrupted</em>, or until a certain amount of real time has elapsed.</td></tr></tbody></table></div><p>本文所有涉及到的源码来自 JDK-15</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="equals-与"><a href="#equals-与" class="headerlink" title="equals 与 =="></a>equals 与 ==</h3><p>Java 中的类型分为 基础类型 和 引用类型。</p><blockquote><p>注意：基本类型并不是类，也不继承 Object 类。</p></blockquote><p>对于引用类型，<code>==</code> 表示它们所引用的对象的地址是一样的，也就是它们必定指向同一个对象。</p><ul><li>从源码我们看到，equals 方法默认就是使用 <code>==</code> 进行比较。也就是说，如果没有覆盖 equals0方法。则通过 equals（）比较该类的两个对象时等价于“==”比较这两个对象。</li><li>如果该方法被覆盖，那么我们认为比较的两个对象是相等的。</li></ul><p>注意：<code>==</code> 比较这两个对象是否是同一个对象；<code>equals</code> 比较这两个对象是否相等。在默认情况下，<code>A==B</code> &lt;=&gt; <code>A.equals(B)</code>；在覆盖过方法的情况下，<code>A==B</code> =&gt; <code>A.equals(B)</code> </p><h3 id="重写-equals-方法"><a href="#重写-equals-方法" class="headerlink" title="重写 equals 方法"></a>重写 equals 方法</h3><p>重写后的 equals 方法应该满足以下五个条件：</p><ol><li>自反性(reflexive)：对于任何非空(null)对象，<code>x.equals(x) == true</code> 恒成立</li><li>对称性(symmetric)：对于任何非空(null)对象，<code>x.equals(y) == y.equals(x)</code> 恒成立</li><li>传递性(transitive)：对于任何非空(null)对象，若<code>x.equals(y) == y.equals(z)</code> ，必有<code>x.equals(z) == true</code></li><li>一致性(consistent)：对于任何非空(null)对象，<code>x.equals(y)</code> 的值在多次调用中始终不变</li><li>非空性(non-null)：对于任何非空(null)对象，<code>x.equals(null) == false</code> 恒成立</li></ol><blockquote><p>为什么要强调非空(null)对象呢？因为如果 x 引用的是 null 的话。那么它根本就没有 <code>equals()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(test==<span class="keyword">null</span>);<span class="comment">// true,因为 == 是比较地址的</span></span><br><span class="line">System.out.println(test.equals(<span class="keyword">null</span>));<span class="comment">// java.lang.NullPointerException</span></span><br></pre></td></tr></table></figure></blockquote><p>很显然，前面三个条件（自反对称传递）也就是集合论中定义的一个<strong>划分</strong>，即体现了这两个集合的<strong>等价关系</strong>。<del>如果上一句话看不懂建议重修离散数学。</del></p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>Java<u>基本类型的包装类</u>的大部分都实现了常量池技术，即Byte，Short，Integer，Long，Character，Boolean；前面4种包装类默认创建了[-128，128]的相应类型的缓存数据，Character创建了数值在[O，127]范围的数据，Boolean直接返回 True Or false.如果超出对应范围仍然会去创建新的。</p><p>对于浮点数的包装类 Float，Double并没有常量池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">127</span>;</span><br><span class="line">Integer b = <span class="number">127</span>;</span><br><span class="line">a == b;<span class="comment">// true,它们指向同一个对象</span></span><br><span class="line">a.equal(b);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">129</span>;</span><br><span class="line">Integer b = <span class="number">129</span>;</span><br><span class="line">a == b;<span class="comment">// false,它们指向不同的对象</span></span><br><span class="line">a.equal(b);<span class="comment">// true,它们确实相等</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">127</span>;</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">127</span>);<span class="comment">// 这种情况下b会创建新的对象</span></span><br><span class="line">a == b;<span class="comment">// false,它们指向不同的对象</span></span><br><span class="line">a.equal(b);<span class="comment">// true,它们确实相等</span></span><br></pre></td></tr></table></figure><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><p>这个方法用于返回该对象的 Hash 值。这里不介绍 Hash 值的意义和用途。</p><p>该方法会返回一个 int 整型。</p><blockquote><p>该方法规约如下：</p><ol><li>在一次程序运行中，对同一个对象多次求哈希值的返回值应当相同。但在同一个程序的多次运行中，并不要求它们的Hash值总是相同</li><li>若 <code>A.equals(B)</code>, 则 <code>A.hashCode() == B.hashCode()</code></li><li>若 <code>A.hashCode() == B.hashCode()</code>，<strong>未必有</strong> <code>A.equals(B)</code>，也<strong>未必有</strong> <code>A == B</code></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>native 修饰符：A native method is a Java method whose implementation is provided by non-java code. 本地方法是使用其他语言编写的 Java 方法，它取决于具体的 JVM。</li><li>该方法的默认行为一般为将对象在堆上的地址转化为整型返回，但是这在实现时并不是必需的。</li></ul><h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h3><p>由于 hashCode 方法默认是根据对象的内存地址生成的。考虑以下关系：</p><blockquote><ol><li>若 <code>A == B</code> 为真，则必有 <code>A.equals(B) == true</code></li><li>若 <code>A.equals(B) == true</code>，则 <code>A == B</code> 未必为真</li><li>若 <code>A.equals(B)</code>, 则 <code>A.hashCode() == B.hashCode()</code></li><li>在默认情况下，若 <code>A == B</code> 为真，则 <code>A.hashCode() == B.hashCode()</code></li></ol></blockquote><p>不难推理出，由于 equals 并不要求两对象的内存地址相同，因此 hashCode 方法应当随着 equals 方法的重写而重写。</p><h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h2><blockquote><p>返回该对象运行时的类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><p>显然这也是一个本地方法，并且不可被重写。</p><ul><li>注意返回的是对象的运行时的类，联系多态，理解下面第四行代码</li><li>Java 泛型是类型擦除的。因此泛型中的值不会显式。<ul><li>类型擦除：指JVM并不会意识到泛型信息</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test a = <span class="keyword">new</span> subTest();</span><br><span class="line">List&lt;String&gt; b = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(a.getClass());<span class="comment">// class StudyObject.subTest</span></span><br><span class="line">System.out.println(b.getClass());<span class="comment">// class java.util.ArrayList</span></span><br><span class="line">System.out.println(c.getClass());<span class="comment">// class java.util.ArrayList</span></span><br></pre></td></tr></table></figure><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><blockquote><p>返回对象的字符串表示形式。该方法应该言简意丰、便于阅读，建议所有类重写该方法。</p><p>如果未重写该方法，会以 <code>&quot;&lt;类名&gt; + &#39;@&#39; + &lt;0xHash值&gt;&quot;</code> 的形式返回。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><blockquote><p>复制出当前对象的一个拷贝。对”拷贝”的定义因类型而异，一般性的共识是满足以下条件</p><ul><li><code>A != B</code>    并不是<strong>同一个</strong>对象</li><li><code>A.getClass() == B.getClass()</code>   是同一类对象</li><li><code>A.equals() == B.equals()</code>       两个对象的相等的</li></ul><p>只有实现了 <code>Cloneable</code> 接口的类才允许调用本方法，否则会抛出 <code>CloneNotSupportedException</code> 异常。</p><p>默认为浅拷贝</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>显然这也是一个本地方法</p><h3 id="Cloneable-接口"><a href="#Cloneable-接口" class="headerlink" title="Cloneable 接口"></a>Cloneable 接口</h3><p>只有实现了本接口的类才被允许使用 Object 中的 clone() 方法。否则会抛出 <code>CloneNotSupportedException</code> 异常。</p><p>Cloneable 是一个标记接口，并不需要真的实现任何方法，仅作标记使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里面真的啥也没有哦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h3><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。</p><p>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制为深拷贝。即递归拷贝</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202012/21/image-20201221040503225.png" alt="image-20201221040503225" style="zoom:50%;" /></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202012/21/image-20201221040618638.png" alt="image-20201221040618638" style="zoom:50%;" /></p><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><blockquote><p>该方法自 JDK9 起被废弃。</p></blockquote><p>当GC认为它不在需要这个对象时，会调用该函数。</p><h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait/notify/notifyAll"></a>wait/notify/notifyAll</h2><blockquote><p>均为本地(naive)方法</p></blockquote><p>这三个函数均涉及到并发编程，<u>下面的内容可能需要一定的并发编程和操作系统基础才能继续阅读</u>。</p><p>在操作系统中我们曾经涉及到管程(Monitor)的概念，Java 通过sychronyzed关键字，和wait()、notify()、notifyAll() 方法实现了整个管程模型。(好像 Java 一般会把 Monitor 翻译成监视器)</p><blockquote><p>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个 synchronized 方法(或者 synchronized 块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p><p>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会<strong>释放该对象的锁</strong>后，进入到了该对象的等待池。</p><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的<strong>等待池</strong>中，等待池中的线程<strong>不会去竞争该对象的锁</strong>。</p><p>当有线程调用了对象的 <strong>notifyAll</strong>()方法（唤醒所有 wait 线程）或 <strong>notify</strong>()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争</p><p>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它<strong>还会留在锁池中</strong>，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p><p>作者：大王叫我来巡山<br>链接：<a href="https://www.zhihu.com/question/37601861/answer/145545371" target="_blank" rel="noopener">https://www.zhihu.com/question/37601861/answer/145545371</a></p></blockquote><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><p>此方法导致当前线程（称为 T）将自己置于该对象的等待池(the wait set)中，然后放弃关于此对象的所有同步声明(即释放锁）。线程 T 将出于线程调度目的而被禁用，并且处于休眠状态，直到发生四件事之一：</p><ol><li>某个拥有 Monitor 的线程调用了该对象的 notify() 方法并且线程 T 正好被选中</li><li>某个拥有 Monitor 的线程调用了该对象的 notifyAll() 方法</li><li>其他线程中断(interrupt())了线程 T</li><li>使用 wait(long timeout) 方法时设定的时间已过</li></ol><p>当发生了上述四种情况之一时，线程 T 进入从等待池中进入锁池(注意此时还不能直接开始运行)。在锁空出时竞争锁资源，如果竞争成功则从调用 wait() 方法处开始运行；如果竞争失败则继续停留在锁池中(并不会返回到等待池中)。</p><p>在个别情况下可能会出现虚假唤醒的可能性，这是指由于 CPU 调度导致的、在上述事件发生时同时唤醒了多个线程的情况(更多关于虚假唤醒的请参考操作系统的 IPC 部分)。因此在代码中需要显性地使用 while 来规避，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (condition does not hold)</span><br><span class="line">obj.wait();</span><br><span class="line">... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"><span class="keyword">while</span> (condition does not hold)</span><br><span class="line">obj.wait();</span><br><span class="line">... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">            <span class="comment">// 当发生虚假唤醒时, while 可以帮助我们持续检查条件, 从而补救这一情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait() 方法具有两个重载：</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>wait(long timeout)</td><td>timeout 为当前线程 T 的等待时间(ms)<br>若超出时长，T 将被唤醒<br>若时长设定为0，则不会自动唤醒</td></tr><tr><td>wait(long timeout, int nanos)</td><td>timeout 定义同上<br>nanos 定义类似，单位为纳秒(ns)<br>nanos 合法值为0~999999<br>若超出时长，T 将被唤醒</td></tr></tbody></table></div><h3 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h3><p>唤醒当前对象的<strong>某个</strong>处于等待池中的线程 T。具体是哪个线程是任意选择的。线程 T 被唤醒时将处于锁池中，等到当前线程放弃该对象的锁后才可以参与竞争进而获得锁并运行。</p><p>此方法仅可以由对象的 Monitor 的拥有者调用，线程通过以下三种情况成为拥有者：</p><ol><li>通过执行该对象的 synchronized 实例方法</li><li>通过执行该对象的 synchronized 代码块</li><li>通过执行某类的 synchronized static 方法</li></ol><p>一次只能有一个线程拥有对象的监视器</p><h3 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h3><p>这是与上述类似的方法，不同之处在于它将唤醒当前对象的处于等待池中的<strong>所有线程</strong>。线程(们)被唤醒时将处于锁池中，等到当前线程放弃该对象的锁后才可以参与竞争进而获得锁并运行。</p><p>此方法仅可以由对象的 Monitor 的拥有者调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了关于 Object 类的方法。内容包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有方法的功能与部分实现&lt;/li&gt;
&lt;li&gt;讨论了 hashCode() 与 equal() 的关系&lt;/li&gt;
&lt;li&gt;讨论了 Cloneable 接口与深浅拷贝&lt;/li&gt;
&lt;li&gt;讨论了 Java 基于 wait() 与 notify（）的管程机制&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java拾遗之Lambda表达式</title>
    <link href="http://yoursite.com/2020/12/10/Java%E6%8B%BE%E9%81%97%E4%B9%8B%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/12/10/Java%E6%8B%BE%E9%81%97%E4%B9%8B%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-12-10T07:45:25.000Z</published>
    <updated>2020-12-31T23:47:34.649Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了 Java8 的特性：Lambda 表达式。</p><p>行文逻辑：接口实现类 -&gt; 静态内部类 -&gt; 局部内部类 -&gt; 匿名内部类 -&gt; Lambda 表达式 -&gt; Lambda 表达式的化简</p><a id="more"></a><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><h2 id="接口的调用"><a href="#接口的调用" class="headerlink" title="接口的调用"></a>接口的调用</h2><p>根据某些乱七八糟的设计原则，系统应该高内聚松耦合。实践这个原则的一个重要手段就是上接口。</p><p>例如，我们设置这个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span>()</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一、传统的接口实现类"><a href="#一、传统的接口实现类" class="headerlink" title="一、传统的接口实现类"></a>一、传统的接口实现类</h3><p>传统上，我们需要对每个接口编写实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Task.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyTask.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask01</span> <span class="keyword">implements</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LambdaTest.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask = <span class="keyword">new</span> MyTask01();</span><br><span class="line">    <span class="comment">// 上面这行用到了多态，懂得都懂</span></span><br><span class="line">    myTask.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、静态内部类"><a href="#二、静态内部类" class="headerlink" title="二、静态内部类"></a>二、静态内部类</h3><p>我们不想为了一个函数再单独编写一个实现类，所以第二个解决方案是编写静态内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Task.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现与调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LambdaTest.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask02</span> <span class="keyword">implements</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask = <span class="keyword">new</span> MyTask02();</span><br><span class="line">    myTask.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、局部内部类"><a href="#三、局部内部类" class="headerlink" title="三、局部内部类"></a>三、局部内部类</h3><p>静态内部类是在当前类里面编写类，这样每次生成外部类的对象时都要生成下内部类（尽管可能不需要用到）。</p><p>因此有了局部内部类，它是在方法里面定义。</p><p>接口还是一样,略；</p><p>调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LambdaTest.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyTask03</span> <span class="keyword">implements</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Task myTask03 = <span class="keyword">new</span> MyTask03();</span><br><span class="line">    myTask03.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、匿名内部类"><a href="#四、匿名内部类" class="headerlink" title="四、匿名内部类"></a>四、匿名内部类</h3><p>局部内部类还是要定义个类啊，那么我要是也懒得写呢？匿名内部类其实和它差不多，也是在方法体内部，仅仅是省略了类的名称等关键词。</p><p>接口同上，略。</p><p>调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LambdaTest.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask04 = <span class="keyword">new</span> Task() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    myTask04.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、Lambda-表达式"><a href="#五、Lambda-表达式" class="headerlink" title="五、Lambda 表达式"></a>五、Lambda 表达式</h3><p>注意：Lambda表达式仅仅在接口只有一个方法时可以用。</p><p>接口同上，但是还是贴一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Task.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask05 = ()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    myTask05.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中：</p><ol><li>实现的是哪个接口呢？这取决于前面的类型 <code>Task</code></li><li>()包裹起来的是参数，这里不传入参数，所以留空</li><li>{}包裹起来的是函数体，它会重写接口中的方法，重写哪个方法呢？注意使用 Lambda 表达式时，接口中有且只有一个方法！否则不能用 Lambda 表达式</li><li>Lambda 表达式还可以继续化简，见下</li></ol><h2 id="Lambda-的化简"><a href="#Lambda-的化简" class="headerlink" title="Lambda 的化简"></a>Lambda 的化简</h2><h3 id="一、标准-Lambda-表达式"><a href="#一、标准-Lambda-表达式" class="headerlink" title="一、标准 Lambda 表达式"></a>一、标准 Lambda 表达式</h3><p>我们先来看下标准的 Lambda表达式。</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Task.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(String a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask06 = (String name, <span class="keyword">int</span> num)-&gt;&#123;</span><br><span class="line">        System.out.println(name+<span class="string">": Good "</span>+num+<span class="string">"! "</span>);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f__k = myTask06.run(<span class="string">"Jack Ma"</span>,<span class="number">996</span>);</span><br><span class="line">    System.out.println(f__k+<span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Lambda 表达式重写了接口中的唯一方法，包括两个参数、多条语句、返回值。</p><h3 id="二、简化参数"><a href="#二、简化参数" class="headerlink" title="二、简化参数"></a>二、简化参数</h3><p>其实在 Lambda 表达式中并不需要指明参数的类型。毕竟已经在接口中声明好了。</p><p><del>什么？你说你改变参数的数量和类型？那还叫🔨的重写。</del></p><p>注意哈，要去类型都去掉，不要一半去一半不去 ❌：<code>String name,num</code> </p><p>接口同上，略。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask07 = (name, num)-&gt;&#123;</span><br><span class="line">        System.out.println(name+<span class="string">":\"Good "</span>+num+<span class="string">"!\""</span>);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f__k = myTask07.run(<span class="string">"Jack Ma"</span>,<span class="number">996</span>);</span><br><span class="line">    System.out.println(f__k+<span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、简化小括号"><a href="#三、简化小括号" class="headerlink" title="三、简化小括号"></a>三、简化小括号</h3><p>如果只有一个参数，可以去掉小括号</p><p>如果没有参数或多个参数，不可去掉</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(String a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask08 = name -&gt; &#123;</span><br><span class="line">        System.out.println(name + <span class="string">":\"Good "</span> + <span class="string">"!\""</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    myTask08.run(<span class="string">"Jack Ma"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、简化花括号"><a href="#四、简化花括号" class="headerlink" title="四、简化花括号"></a>四、简化花括号</h3><p>如果函数体只有一句的话，可以把花括号也取掉。</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask09 = ()-&gt; System.out.println(<span class="string">"Good 996!"</span>);</span><br><span class="line"></span><br><span class="line">    myTask09.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">Java Lambda 表达式</a></p><p><a href="https://www.bilibili.com/video/BV1V4411p7EF?p=10" target="_blank" rel="noopener">狂神说：Lambda表达式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了 Java8 的特性：Lambda 表达式。&lt;/p&gt;
&lt;p&gt;行文逻辑：接口实现类 -&amp;gt; 静态内部类 -&amp;gt; 局部内部类 -&amp;gt; 匿名内部类 -&amp;gt; Lambda 表达式 -&amp;gt; Lambda 表达式的化简&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/"/>
    
      <category term="Java拾遗" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/Java%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="lambda表达式" scheme="http://yoursite.com/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之六大原则</title>
    <link href="http://yoursite.com/2020/12/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2020/12/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</id>
    <published>2020-12-03T07:45:25.000Z</published>
    <updated>2020-12-31T23:47:28.755Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了设计模式中的六大基本原则：</p><ol><li>单一职责原则</li><li>接口隔离原则</li><li>依赖反转原则</li><li>里氏替换原则</li><li>迪米特原则</li><li>开闭原则</li><li>合成复用原则</li></ol><a id="more"></a><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p><strong>单一功能原则</strong>（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。</p><p>Robert Cecil Martin 功能（职责）定义为：“改变的原因”，并且总结出一个类或者模块应该有且只有一个改变的原因。</p><blockquote><p>想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。第一，报表的内容可以改变（编辑）。第二，报表的格式可以改变（打印）。这两方面会的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。</p></blockquote><p>例如，我们定义 <code>Vehicle</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在公路上跑"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在道路上跑");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">    vehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">    vehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就违反了单一职责原则。因为这个类同时<strong>实现了汽车与飞机的运行职责</strong>。换言之，交通工具的本质（汽车还是飞机），以及交通工具的运行方式（在公路上还是道路上）这两种改变原因都可以在该类中发生。</p><p>严格按照 SRP 原则的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在公路上跑"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在道路上跑");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在天上飞"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在空中飘");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">    AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">    vehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">    airVehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，各交通工具类就只能改变交通工具的运行方式（公路/道路，飞/飘）。而不能改变交通工具的本质，AirVehicle 就只能是在上天的交通工具（虽然我们没有进行什么检测，但逻辑上是这样的）。</p><p>严格按照 SRP 原则的代码有一个问题：开销往往过大。如果我们想再加上：水中游的/地里挖的/星际穿梭的/… 那么就必须写很多类。因此一般是采用如下的折中处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRoad</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在公路上跑"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在道路上跑");</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在天上飞"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在空中飘");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">    vehicle.runRoad(<span class="string">"汽车"</span>);</span><br><span class="line">    vehicle.runAir(<span class="string">"飞机"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>严格意义上来说，我们并没有实现 SRP。但这种这种做法是工程中可取的。实际上，这种方法相当于 <strong>方法级别的SRP</strong>。</p><p>请注意：方法级别的 SRP 并不代表可以在一个方法中加入很多 <code>if..else..</code>，将交通工具的本质移动到内部处理虽然解决了问题，但是该方法仍然承担了两个职责（本质/方式）。恰恰相反，SRP强调的是尽量减少<code>if..else..</code>，而是尽可能多地设置类/方法，并在不同情况（不同本质）下调用对应的类/方法。</p><p>例如下面的正确代码中，Vehicle 类的两个方法只承担了运行方式的改变。而交通工具本质的改变被移动到了 main() 函数中处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isRoadVehicle(name))&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在公路上跑"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在道路上跑");</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isAirVehicle(name))&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在天上飞"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在空中飘");</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Yes!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRoad</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在公路上跑"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在道路上跑");</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在天上飞"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在空中飘");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">    String name1 = <span class="string">"汽车"</span>;</span><br><span class="line">    String name2 = <span class="string">"飞机"</span>;</span><br><span class="line">    <span class="keyword">if</span>(isRoadVehicle(name1))&#123;</span><br><span class="line">        vehicle.runRoad(name1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isAirVehicle(name2))&#123;</span><br><span class="line">            vehicle.runAir(name2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>降低类的复杂度，保证每个类的负责事务单一</li><li>提高类的可读性与可维护性</li><li>提高代码的健壮性，降低因为代码变更带来的风险</li><li>在逻辑足够简单的情况下，可以代码级别地违反该原则</li></ol><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><strong>接口隔离原则</strong>（英语：interface-segregation principles， 缩写：ISP）客户端不应依赖它不需要的接口。类间的依赖关系应该建立在最小的接口上。</p><p>如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。换言之，不要把一大堆方法塞进一个接口里，导致这个接口变得臃肿无比。应该要根据实际需要，让接口中只有用得上的方法，也就是说要细化我们的接口。</p><p>有观众就要问了，你说这些是森莫意思？我们来拿例子来说明。</p><p>考虑我们要实现鱼和鸟这两个类，它们共有的方法是<code>breath()</code>和<code>sleep()</code>，特有的方法分别是<code>swim()</code>和<code>fly()</code>。根据依赖倒转原则，我们使用接口。</p><p>错误的实现方式如下：</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202012/03/1606979646815-1606993794924.png" alt="1606979646815"></p><p>我们直接使用一个 Animal 接口完成了这四个方法，而实现这个接口的两个实现类则必须要实现其不需要的方法。（例如 <code>fishImpl</code> 中的 <code>fly()</code>）</p><p>在实体类中的使用时，我们只需要传入 Animal ，即可实现每个实体类所需要的三个方法。但是，在实体类中我们同样可以使用不被需要的第四个方法，这被称作接口污染。整体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Animal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BirdImpl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">birdImpl</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bird - breath"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bird - sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bird - fly"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bird - swim"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FishImpl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fishImpl</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fish - breath"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fish - sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fish - fly"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fish - swim"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bird</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bird_breath</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.breath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bird_sleep</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bird_fly</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fish</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fish_breath</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.breath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fish_sleep</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fish_swim</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的实现方法应该是这样的：</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202012/03/1606981135439-1606993794925.png" alt="1606981135439"></p><p>我们将原来的 Animal 接口拆分成三个接口，如果这个实现类需要接口中的所有方法，那么我们才去实现它。实体类中不会出现冗余的不被需要的方法。这样就保证它们的依赖关系建立在最小的接口上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Common_Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Air_Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Water_Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">birdImpl</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Air_Animal</span>, <span class="title">Common_Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fishImpl</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Water_Animal</span>,<span class="title">Common_Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bird_breath</span><span class="params">(Common_Animal common_animal)</span></span>&#123;</span><br><span class="line">        common_animal.breath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bird_sleep</span><span class="params">(Common_Animal common_animal)</span></span>&#123;</span><br><span class="line">        common_animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bird_fly</span><span class="params">(Air_Animal air_animal)</span></span>&#123;</span><br><span class="line">        air_animal.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fish_breath</span><span class="params">(Common_Animal common_animal)</span></span>&#123;</span><br><span class="line">        common_animal.breath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fish_sleep</span><span class="params">(Common_Animal common_animal)</span></span>&#123;</span><br><span class="line">        common_animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fish_swim</span><span class="params">(Water_Animal waterAnimal)</span></span>&#123;</span><br><span class="line">        waterAnimal.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口隔离原则和单一职责原则非常类似。单一职责原则要求接口的职责是单一的，而接口隔离原则要求接口尽量细化，它们有异曲同工之妙，都是要让我们的接口功能尽量单一，尽量小。</p><p>但是，单一职责原则的着重点是在“职责”，而接口隔离原则只单纯地要求接口最小化。那么，如果已经满足单一职责原则的接口，在当前的需求下还可以继续细化，那么还需要细化吗？答案是不要再细化了。在实践中，接口设计的粒度越小，系统就越灵活，这是事实。但是灵活的同时也带来了系统的复杂化，导致开发难度增加。所以接口并不是越小越好，必须要有一个度。当单一职责原则和接口隔离原则存在矛盾时，以满足单一职责原则为底线。</p><p>以上这段来自 <a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">简书</a> 。</p><h2 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h2><p><strong>依赖反转原则</strong>（Dependency inversion principle，DIP）是指一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</p><p>该原则规定：</p><ol><li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li><li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li></ol><p>这是什么意思呢？下面是一个错误示范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Email:hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span></span>&#123;</span><br><span class="line">        System.out.println(email.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，代码中 Email 是底层类，Receiver 是高层类。但是这里的高层类却完全依赖于底层类的实现。此处的 <code>receive()</code> 方法需要传入一个具体的底层类。</p><p>这有什么问题吗？高层类总要或多或少地知道底层类的东西啊！注意，知道 != 依赖。这里的方法<strong>完全依赖于</strong> Email 实体类。如果是电话、短信、微信，这个 <code>receive()</code>方法直接被废掉了。这就是所谓的<u>高层次的模块不应该依赖于低层次的模块</u>。</p><p>正确的做法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Email:hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wechat</span> <span class="keyword">implements</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wechat:hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">        System.out.println(msg.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在这个例子里：</p><ol><li>Receiver 类不再依赖 Email 类，而是依赖 Message 接口</li><li>Email、Wechat 类不再是自顾自地实现，而是依赖 Message 接口的规范</li><li>在逻辑上，先定义好了  Message 接口，才能以此为规范实现具体的类。（无论是上层类还是下层类）这就是所谓的 <u>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口</u>。</li><li>在这里，接收者依旧知道传入的信息中有 <code>getInfo()</code>,但是它并不用关心这个方法是被谁实现、怎样实现的。知道，但不依赖。</li></ol><p>小结</p><ol><li>依赖倒转（倒置）的中心思想是<strong>面向接口编程</strong></li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在jaνa中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li></ol><blockquote><p>多逼逼两句：</p><p>就像前后端分离一样，应该是先制定出前后端的交互接口，然后在基于接口文档分别开发。前后端彼此并不需要操心对方如何实现，只需要将封装好的接口拿过来用即可。而不是直接调用后端的代码</p></blockquote><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p><strong>里氏替换原则</strong>（Liskov Substitution principle）是对子类型的特别定义。内容可以描述为： “派生类（子类）对象可以在程式中代替其基类（超类）对象。”</p><blockquote><p>我们先来回忆一下知识点：</p><p>继承：</p><p>子类继承父类，父类派生子类。父类中的所有属性方法都被子类继承了（尽管声明为 private 的无法被子类访问，但是它们也被继承了）。子类可以对父类的方法进行 重写（override）</p><p>多态：</p><p>如果子类继承了父类，并且子类重写了父类的方法，并且有父类引用指向子类对象（<code>Parent p = new Child()</code>）那么，当我们调用 <code>p</code> 的某方法时，实际运行的是被子类重写后的该方法。</p></blockquote><p>也就是说，我们希望所有用到父类的地方，都可以将其换为子类。并且程序还能继续运行。</p><p>也就是说，尽量不要让子类重写父类方法，<strong>可以拓展，不要修改</strong>。</p><p><em>对了，对于抽象类的，我们称之为实现，而非重写。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello my dear friend!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示范，重写了父类方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"YOU A Son of Bitch!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示范， 只拓展不修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daughter</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello,uncle!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承实际上让两个类之间的耦合性增强了。如果我们非要重写这个方法呢？那么可以通过聚合、组合、依赖来解决问题。</p><p>组合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello my dear friend!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Parent parent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        parent.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证这一原则，我们在 Java 中可以对父类的、不想被改变的方法加上 <code>final</code> 修饰符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello my dear friend!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;       <span class="comment">//  报错: overridden method is final! </span></span><br><span class="line">        System.out.println(<span class="string">"YOU A Son of Bitch!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p><strong>得墨忒耳定律</strong>（<strong>Law of Demeter</strong>，缩写<strong>LoD</strong>）亦被称作“最少知识原则（Principle of Least Knowledge）”</p><ol><li>每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；</li><li>每个单元只能和它的朋友交谈：不能和陌生单元交谈；</li><li>只和自己直接的朋友交谈。</li></ol><p>这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。</p><p>一个类对自己依赖的类知道的越少越好。对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public方法，不对外泄露任何信息。</p><p>迪米特法则还有个更简单的定义：只与直接的朋友通信</p><p>直接的朋友：每个对象都会与其他对象有耦贪关系，只要两个对象之间有耦合关系我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello my dear friend!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：成员变量parent是直接朋友</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Parent parent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        parent.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：在这里，局部变量parent是个陌生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Parent parent;</span><br><span class="line">        parent.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...这里就不实现了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Message msg = <span class="string">"hello,email"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllMessage</span><span class="params">(Email email)</span></span>&#123;</span><br><span class="line">        Message msg = email.getMsg();</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是错误示范。</p><p>在 <code>Receiver</code> 的 <code>printAllMessage</code> 方法中。引入了一个陌生类 <code>Message</code>,它不是成员变量，方法参数，方法返回值。</p><p>当然这里直接传入Email类也不符合依赖反转原则。这里就不细究了。</p><p>正确示范如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Message msg = <span class="string">"hello,email"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllInfo</span><span class="params">(Email email)</span></span>&#123;</span><br><span class="line">        email.printMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就规避掉了Message在Receiver类中的出现。</p><p>小结</p><ol><li>迪米特法则降低了类与类之间的耦合（不出现陌生类）</li><li>但并不意味着完全消除类之间的依赖关系，只是尽量降低。（允许出现直接朋友）</li><li></li></ol><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><strong>开闭原则</strong>规定“<em>软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的</em>”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为</p><p>说实话我完全没搞懂这个原则是什么意思。表述的太过模糊了。我只能从他人的表述/笔记中知道：这一原则是整个设计模式的核心原则，或者说其他的原则、设计模式都是以满足这个原则为目的的，或者说，如果项目能够满足其他原则/模式，那么自然也就满足了开闭原则。</p><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">// 继承,B1拥有A的所有方法</span></span><br><span class="line">    <span class="comment">// 但是这种耦合性太强</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span></span>&#123;</span><br><span class="line">    <span class="comment">// 依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1B</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        a.func1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B3</span></span>&#123;</span><br><span class="line">    <span class="comment">// 聚合</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a.func1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B4</span></span>&#123;</span><br><span class="line">    <span class="comment">//组合</span></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a.func1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖：</p><p>类B使用到了另一个类A，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是A类的变化会影响到B。表现为：A作为参数被B方法调用</p><p>聚合：</p><p>体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。表现为：A作为B的类属性。</p><p>组合：</p><p>体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑。表现为：A作为B的类属性。</p><p>参见参考资料。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这一份笔记写的极为痛苦。所有的原则都没有难理解的地方。但总觉得如同隔靴搔痒，既不能完全理解原则，也反复意识到自己原来的代码中的各种问题，还会在转瞬之间想“卧槽这种情况改怎么改才能符合原则？根本没法改啊！” 只能寄托于假设自己学的还不到位，等学完23种设计模式，在加上大量的工程项目，再经常回顾思考，或许能理解的更加深入一些。思而不学则殆。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>维基百科</p><blockquote><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">单一功能原则</a></li><li><a href="https://zh.wikipedia.org/zh-cn/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99#cite_note-ASD-1" target="_blank" rel="noopener">接口隔离原则</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">依赖反转原则</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">里氏替换原则</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">开闭原则</a></li></ol></blockquote><p><a href="https://www.bilibili.com/video/BV1G4411c7N4?p=5" target="_blank" rel="noopener">尚硅谷Java设计模式</a></p><p><a href="https://www.jianshu.com/p/fe949c2f081a" target="_blank" rel="noopener">继承、实现、依赖、关联、聚合、组合的联系与区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了设计模式中的六大基本原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单一职责原则&lt;/li&gt;
&lt;li&gt;接口隔离原则&lt;/li&gt;
&lt;li&gt;依赖反转原则&lt;/li&gt;
&lt;li&gt;里氏替换原则&lt;/li&gt;
&lt;li&gt;迪米特原则&lt;/li&gt;
&lt;li&gt;开闭原则&lt;/li&gt;
&lt;li&gt;合成复用原则&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="乘龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="SOLID" scheme="http://yoursite.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统之范式</title>
    <link href="http://yoursite.com/2020/11/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/11/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%8C%83%E5%BC%8F/</id>
    <published>2020-11-20T07:45:25.000Z</published>
    <updated>2020-12-31T23:47:17.280Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了数据库系统设计时的范式问题：</p><ol><li>码与主码</li><li>函数依赖</li><li>第一范式</li><li>第二范式</li><li>第三范式</li><li>BC 范式</li></ol><a id="more"></a><h2 id="理解范式"><a href="#理解范式" class="headerlink" title="理解范式"></a>理解范式</h2><p>范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”</p><p>如何理解这句话? 在设计一个数据库系统时，我们实际上时在设计不同实体之间的<strong>关系</strong>。那么设计关系时所循行的标准，称为范式。具体有哪些标准呢？我们一般将数据库范式分为1NF，2NF，3NF，BCNF，4NF，5NF。这代表着不同级别的设计标准。符合高一级别的范式，必定符合第一级别的范式。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>【前置知识部分来自掘金用户@奋斗的小皇帝，有删改，链接见文末】</p><p>在学习数据库范式之前，我们必须了解一些前置知识，这些知识在后续的内容将会大量使用，如果对这些不了解，那么将会对后面的内容一头雾水。</p><p>首先，我们定义一张表，并添加一些数据，这个表 1 （选课表）有助于我们理解这些概念：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/8/172944729191ddd4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>关系中的某个或者某几个属性的集合，用于唯一地标识每一条数据（这里的每一条数据就是数据库中的每一条记录）。</p><blockquote><p>请注意：码可以是一个或多个属性，一个表中可能存在多个码。例如，{学号，选课}这两个属性组成的码可以唯一地确定数据库的条项。</p></blockquote><h4 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h4><p>在一个表的关系中，可以存在多个关系集合用于唯一确定一条记录，这些多个集合就称为<strong>候选码</strong>，也称为候选键。候选码可以存在多个，每一个候选码都可以唯一地确定一条记录。</p><p>我们换一种更加严谨的说法：假设 K 为某个表中的一个属性或者属性组，如果除去 K 之外的所有属性都<strong>完全函数依赖</strong>（稍后会介绍）于 K，那么我们就称 K 为候选码。</p><p>根据上表的示例我们可以得出一个候选码：</p><ul><li>（学号，课名）</li></ul><h4 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h4><p>通常我们会从候选码中选择一个码作为<strong>主码</strong>，也就是我们通常所说的主键。</p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>在数学上的解释是：<code>y = f(x)</code>，输入一个 X，可以得到一个确定的 Y。</p><p>对应到一个表上就是，在属性X 确定的情况下，必定能够确定某个属性 Y 的值，这就能够称作 Y 函数依赖于 X，写作 X -&gt; Y 。</p><blockquote><p>注意：X未必是一个属性，也可能是属性集合。</p></blockquote><p>记作：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/8/17294478f4b78bd9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>比如下面这些关系都<strong>存在</strong>函数依赖：</p><ul><li>（学号）-&gt;（姓名）</li><li>（学号，课名）-&gt;（分数）</li><li>（系名）-&gt;（系主任）</li></ul><p>但是，下面这些关系就<strong>不存在</strong>函数依赖：</p><ul><li>（姓名）-&gt;（学号），因为有可能会出现重名的情况，所以只依靠姓名是无法确定学号的。</li><li>（学号）-&gt;（分数），因为一个学号有多个科目，每一个科目都存在一个分数，不能只靠学号来确定分数。</li><li>……</li></ul><h4 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h4><p>在一个表中，如果存在 X -&gt; Y，那么对于 X 下的任何一个真子集（X’），X’ -&gt; Y都不成立，那么我们就说 Y 对于 X 完成函数依赖。</p><blockquote><p>如果X可以唯一确定Y，并且找不到X中的更少的属性可以唯一确定Y，那么称之为完全函数依赖。</p></blockquote><p>记作：X -&gt;F  Y</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/8/1729447d6caba0f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>通俗的说，必须通过码中的所有属性才可以唯一确定一个值。比如：</p><ul><li>（学号）-&gt;F（姓名）</li><li>（学号，课名）-&gt;F（分数）</li></ul><h4 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h4><p>在一个表中，如果存在 X -&gt; Y，但是 Y 并不完成依赖于 X。存在一些 X 的子集 X’，X‘ -&gt; Y成立，那么我们就说 Y 对于X 部分函数依赖。</p><p>记作：X -&gt;P Y</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/8/17294481094df130?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>通俗的说，只需要码中的部分属性即可唯一确定一个值。比如：</p><ul><li>（学号，课名）-&gt; （姓名），只需要根据码中的学号即可唯一确定姓名。</li></ul><p><strong>它跟完全函数依赖的区别在于，完全函数依赖必须要通过码中的所有属性才可以唯一确定一个值，而部分函数依赖只需要码中的部分属性即可。</strong></p><h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><p>如果 Z 函数依赖于 Y，Y 函数依赖于 X，并且 X 不函数依赖于 Y，那么我们就说 Z 传递函数依赖于 X。</p><p>记作：X -&gt;T Z</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/8/17294484b7bd7b14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>通俗的说，通过码可以唯一确定一个属性，然后通过该属性可以唯一确定另一个属性，所以就演变为了可以通过码唯一确定一个无函数依赖的属性。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性就是我们在表中定义的每一个列。</p><h4 id="主属性"><a href="#主属性" class="headerlink" title="主属性"></a>主属性</h4><p>在码中的所有属性（每一列）都称为主属性</p><h4 id="非主属性"><a href="#非主属性" class="headerlink" title="非主属性"></a>非主属性</h4><p>除了主属性之外的其他属性，都称为非主属性。</p><h2 id="范式标准"><a href="#范式标准" class="headerlink" title="范式标准"></a>范式标准</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>1NF的定义为：符合1NF的关系中的<strong>每个属性都不可再分</strong>。</p><p>何谓属性不能再分？ 举例：你可以把<code>数量</code> 、<code>单价</code>分别作为两个属性设计，这是符合范式的。如果你设计了<code>进货</code>这一属性，并且将<code>数量</code> 、<code>单价</code>作为两个子属性设计，这不符合范式。事实上这个例子应该是列族数据库。（一种NoSQL）</p><p><strong>1NF是所有关系型数据库的最基本要求</strong>，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。</p><p>但是其实也不一定如此。例如，<code>地址</code>属性中的值可以是“陕西省西安市长安区西安电子科技大学”， 也可以分别设置多个属性：<code>省份</code>、<code>城市</code>、<code>区县</code>、<code>详细地址</code>。<code>地址</code>属性理论上是可以再分的，但实际生产中也可以使用。当然，从数据库设计的角度肯定是设置成多个属性更佳。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/1NF.jpg" alt="1NF"></p><p>即便满足1NF，数据库还可能会出现以下问题：</p><ol><li><p>数据冗余</p><p>每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次</p></li><li><p>插入异常</p><p>假如学校新建了一个系，但是暂时还没有招收任何学生，那么是无法将系名与系主任的数据单独地添加到数据表中去。</p></li><li><p>删除异常</p><p>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。</p></li><li><p>修改异常</p><p>假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据</p></li></ol><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p><strong>2NF 在 1NF 的基础上，消除了非主属性对码的部分函数依赖</strong> 。</p><blockquote><p><strong>码</strong>是可以唯一确定一条记录的属性集合；</p><p><strong>非主属性</strong>是除了码中属性之外的其他属性。</p><p>部分函数依赖：只需要码中的部分属性即可唯一确定一个值。</p></blockquote><p>判断是否符合 2NF 可以通过以下步骤：</p><ol><li>找出表中所有的<strong>码（候选码）</strong>。</li><li>根据第一步得出的码找出所有的<strong>主属性</strong>。</li><li>除了主属性之外的其他属性，就都是<strong>非主属性</strong>。</li><li>判断是否存在非主属性<strong>部分函数依赖</strong>于码。</li></ol><p>例如上例中：</p><ol><li><p>候选码包括：{学号，课程}</p></li><li><p>主属性：学号、课程</p></li><li><p>非主属性：姓名、系名、系主任、分数</p></li><li><p>依次考察这些非主属性：</p><ol><li><p>姓名：有 学号-&gt;姓名，部分函数依赖</p></li><li><p>系名：有 学号-&gt;系名，部分函数依赖</p></li><li><p>系主任：有 学号-&gt;系主任，部分函数依赖</p><blockquote><p>注：显然，系主任也可以被系名唯一确定；这其实是第三范式的问题，我们稍后讨论。</p><p>在此处，系主任也是可以被学号唯一确定的。</p></blockquote></li><li><p>分数：只有 {学号，课程}-&gt;分数，完全函数依赖</p></li></ol></li></ol><p>在上面这张表中，我们发现 <strong>非主属性</strong> 中只有<code>分数</code>这一项完全依赖的。因此我们可以将表拆为两张。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/2NF1.webp" alt="2NF1"></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/2NF2.webp" alt="2NF2"></p><p>再次检查，不难看出学生表也是2NF 的。</p><p>在2NF中，我们可以解决1NF的两个问题：数据冗余和修改异常。这主要是将1NF中的重复的数据单独拎出来建表。但对于另外两个问题，2NF依旧存在：</p><ol><li><p>插入异常</p><p>假如学校新建了一个系，但是暂时还没有招收任何学生，那么是无法将系名与系主任的数据单独地添加到数据表中去。</p></li><li><p>删除异常</p><p>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。</p></li></ol><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>3NF在 2NF 的基础上，消除非主属性对码的<strong>传递函数依赖</strong>。</p><blockquote><p><strong>码</strong>是可以唯一确定一条记录的属性集合；</p><p><strong>非主属性</strong>是除了码中属性之外的其他属性。</p><p><strong>传递函数依赖</strong> 如果 Z 函数依赖于 Y，Y 函数依赖于 X，并且 X 不函数依赖于 Y，那么我们就说 Z 传递函数依赖于 X。</p></blockquote><p>还记得我们在2NF埋下的一个点吗？系名可以由学号唯一确定，系主任也可以由学号唯一确定，可是我们总觉得有那里不对。更优雅的方式应该是：学号决定系名，而系名决定系主任。这里的关键点在于 <strong>传递函数依赖</strong>，事实上，当出现传递函数依赖的时候，我们可以将这一依赖涉及到的属性们再单独拉个表出来。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/3NF2.webp" alt="3NF2"></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/3NF1.webp" alt="3NF1"></p><p>到此为止，我们已经解决了数据冗余、插入异常、删除异常、修改异常。这份数据库也算得上设计恰当了。</p><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>BCNF： 不存在<strong>主属性</strong>对于码的部分函数依赖和传递函数依赖。</p><p>注意哈，我们这里讲的是主属性，而先前的几个范式都是针对的非主属性。</p><p>如果数据库满足第三范式，那么它一定满足第二范式。</p><p>如果满足BCNF，它一定满足第二、第三范式。</p><p>先前的几个例子中，我们由于最开始的设计规避掉了对BCNF的讨论。下面来看另一个例子。</p><ul><li>某公司有若干个仓库</li><li>每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作</li><li>一个仓库中可以存放多种物品，一个物品也可以存放在不同的仓库。每种物品在每个仓库中都有对应的数量。</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/BCFN%201.webp" alt="BCFN1"></p><p>我们来分析一下这个表：</p><ul><li>码：（仓库名，物品名），（管理员，物品名）</li><li>主属性：仓库名、物品名、管理员</li><li>非主属性：数量</li></ul><p>非主属性只有“数量”，而非主属性对于两个码都不存在部分函数依赖和传递函数依赖，所以这个表是符合 3NF的。但是这个表却是不符合 BCNF 的。</p><p>因为存在主属性对码的部分函数依赖：</p><ul><li>（仓库名，物品名）-&gt; 管理员，只要确定仓库名，即可确定管理员，所以管理员部分函数依赖于仓库名。</li><li>（管理员，物品名）-&gt; 仓库名，同上。</li></ul><p>那么我们要将该表进行拆分才能让物品表符合 BCNF。将该表拆分为两个表：仓库表、物品表。(注: 也可以拆分为两个表: 管理员-物品-数量表与仓库-管理员表)</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/BCNF2.webp" alt="BCNF1"></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/BCNF3.webp" alt="BCNF3"></p><p>我们可以来看看拆分之后解决了什么问题：</p><ul><li>如果仓库换管理员，不需要将物品表中的每一个该仓库的数据都进行修改。</li><li>如果物品都被删除，仓库依然存在，仓库管理员也依然于仓库存在关系</li><li>如果新增一个仓库，但是还没有物品，可以直接在仓库表添加一条记录即可，数据库不会出错。</li></ul><p>所以消除了主属性对码的部分函数依赖和传递函数依赖之后，数据库中的操作的异常就不再出现了。</p><p>结论：<strong>在 3NF 的基础上，消除主属性对码的部分函数依赖和传递函数依赖。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zhihu.com/question/24696366/answer/29189700" target="_blank" rel="noopener">如何理解关系型数据库的常见设计范式？ - 刘慰的回答 - 知乎</a></p><p><a href="https://juejin.im/post/6844904183611523086#heading-20" target="_blank" rel="noopener">数据库设计的基础——数据库范式</a></p><p><a href="https://en.wikipedia.org/wiki/Database_normalization" target="_blank" rel="noopener">Database normalization</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了数据库系统设计时的范式问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;码与主码&lt;/li&gt;
&lt;li&gt;函数依赖&lt;/li&gt;
&lt;li&gt;第一范式&lt;/li&gt;
&lt;li&gt;第二范式&lt;/li&gt;
&lt;li&gt;第三范式&lt;/li&gt;
&lt;li&gt;BC 范式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="数据库系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis的安装与基本使用</title>
    <link href="http://yoursite.com/2020/11/10/Redis%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/11/10/Redis%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2020-11-10T14:05:38.000Z</published>
    <updated>2020-11-10T14:10:00.746Z</updated>
    
    <content type="html"><![CDATA[<p>本文是记录大三上学期方向必修课 《数据管理技术》的上机实验。本学期共有四次实验。</p><ol><li>Hadoop环境搭建与配置 </li><li>HBase数据库的部署与配置 </li><li>Redis数据库的部署与配置</li><li>Redis中数据类型使用及命令使用 </li></ol><p>本文将主要记载后两个实验</p><a id="more"></a><h2 id="实验三-Redis数据库的部署与配置"><a href="#实验三-Redis数据库的部署与配置" class="headerlink" title="实验三: Redis数据库的部署与配置"></a>实验三: Redis数据库的部署与配置</h2><h3 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h3><p>相比于<code>HBsae</code>, <code>Redis</code>的安装简直太简单啦! 基本没有什么需要配置的地方。</p><p>在<code>Ubuntu</code>中，安装 <code>Redis</code>服务器只需要一行命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install redis-server</span><br></pre></td></tr></table></figure><p>启动服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>启动客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p>接下来就可以在这里输入命令以操控<code>Redis</code>了</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p>注：主机为 127.0.0.1，端口为 6379，下略</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/redis%20%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E5%AE%A2%E6%88%B7%E7%AB%AF.png" alt="redis 服务器 客户端"></p><h3 id="Redis-配置"><a href="#Redis-配置" class="headerlink" title="Redis 配置"></a>Redis 配置</h3><p>我们还是来看一下<code>Redis</code>的配置。在<code>Redis</code>的根目录中有一个配置文件（<code>redis.conf</code>）。可以通过<code>Redis CONFIG</code>命令获取和设置所有<code>Redis</code>配置。</p><p>语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG GET CONFIG_SETTING_NAME</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 输入</span><br><span class="line">&gt; CONFIG GET loglevel</span><br><span class="line"># 输出 以loglevel为键的KV对</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 显示所有配置项，输入：</span><br><span class="line">&gt; CONFIG GET *</span><br><span class="line"># 输出见下</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/%E6%9F%A5%E7%9C%8B%E5%85%A8%E9%83%A8%E9%94%AE.png" alt="查看全部键"></p><p>我们接下来配置登录密码，语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; CONFIG SET requirepass 123456</span><br></pre></td></tr></table></figure><p>再次尝试命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ping</span><br><span class="line">(error)</span><br><span class="line">&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81.png" alt="设置密码"></p><p>更多配置项可参考 <a href="http://doc.redisfans.com/server/index.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="实验四：Redis中数据类型使用及命令使用"><a href="#实验四：Redis中数据类型使用及命令使用" class="headerlink" title="实验四：Redis中数据类型使用及命令使用"></a>实验四：Redis中数据类型使用及命令使用</h2><h3 id="教师-学生信息管理系统"><a href="#教师-学生信息管理系统" class="headerlink" title="教师-学生信息管理系统"></a>教师-学生信息管理系统</h3><p>利用<code>Redis</code>架设 教师-学生信息管理系统</p><div class="table-container"><table><thead><tr><th>工号</th><th>姓名</th><th>年龄</th><th>职称</th><th>收入</th><th>教授课程</th></tr></thead><tbody><tr><td>100001</td><td>章北海</td><td>42</td><td>副教授</td><td>12000</td><td>基础伪装学，心理学实战应用</td></tr><tr><td>100002</td><td>汪淼</td><td>49</td><td>讲师</td><td>9000</td><td>材料学入门</td></tr><tr><td>100003</td><td>罗辑</td><td>38</td><td>讲师</td><td>7500</td><td>逻辑学，威慑导论</td></tr><tr><td>100004</td><td>张召忠</td><td>56</td><td>教授</td><td>15000</td><td>战略忽悠学，简明海战学</td></tr></tbody></table></div><p>类型为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">teacher-&lt;id&gt;:nameString</span><br><span class="line">teacher-&lt;id&gt;:ageString</span><br><span class="line">teacher-&lt;id&gt;:titleString</span><br><span class="line">teacher-&lt;id&gt;:salaryString</span><br><span class="line">teacher-&lt;id&gt;:courseSet</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>学号</th><th>姓名</th><th>专业</th><th>参加的社团</th><th>课程成绩</th></tr></thead><tbody><tr><td>180100996</td><td>杰克马</td><td>英语</td><td>支教社，口语角，福报协会</td><td>略</td></tr><tr><td>180100997</td><td>强东刘</td><td>社会学</td><td>好兄弟俱乐部</td><td>略</td></tr><tr><td>180200007</td><td>红颜李</td><td>信息管理</td><td>无人车工作室，怡宝洗头社</td><td>略</td></tr></tbody></table></div><p>类型为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">student-&lt;id&gt;:nameString</span><br><span class="line">student-&lt;id&gt;:majorString</span><br><span class="line">student-&lt;id&gt;:clubsList</span><br><span class="line">student-&lt;id&gt;:scoresHash</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">set &#39;teacher-100001:name&#39; &#39;章北海&#39;</span><br><span class="line">set &#39;teacher-100001:age&#39; &#39;42&#39;</span><br><span class="line">set &#39;teacher-100001:title&#39; &#39;副教授&#39;</span><br><span class="line">set &#39;teacher-100001:salary&#39; &#39;12000&#39;</span><br><span class="line">sadd &#39;teacher-100001:course&#39; &#39;基础伪装学&#39; &#39;心理学实战应用&#39;</span><br><span class="line"></span><br><span class="line">set &#39;teacher-100002:name&#39; &#39;汪淼&#39;</span><br><span class="line">set &#39;teacher-100002:age&#39; &#39;49&#39;</span><br><span class="line">set &#39;teacher-100002:title&#39; &#39;讲师&#39;</span><br><span class="line">set &#39;teacher-100002:salary&#39; &#39;9000&#39;</span><br><span class="line">sadd &#39;teacher-100002:course&#39; &#39;材料学入门&#39;</span><br><span class="line"></span><br><span class="line">set &#39;teacher-100003:name&#39; &#39;罗辑&#39;</span><br><span class="line">set &#39;teacher-100003:age&#39; &#39;38&#39;</span><br><span class="line">set &#39;teacher-100003:title&#39; &#39;讲师&#39;</span><br><span class="line">set &#39;teacher-100003:salary&#39; &#39;7500&#39;</span><br><span class="line">sadd &#39;teacher-100003:course&#39; &#39;逻辑学&#39; &#39;威慑导论&#39;</span><br><span class="line"></span><br><span class="line">set &#39;teacher-100004:name&#39; &#39;张召忠&#39;</span><br><span class="line">set &#39;teacher-100004:age&#39; &#39;56&#39;</span><br><span class="line">set &#39;teacher-100004:title&#39; &#39;教授&#39;</span><br><span class="line">set &#39;teacher-100004:salary&#39; &#39;15000&#39;</span><br><span class="line">sadd &#39;teacher-100004:course&#39; &#39;战略忽悠学&#39; &#39;简明海战学&#39;</span><br><span class="line"></span><br><span class="line">set &#39;student-180100996:name&#39; &#39;杰克马&#39;</span><br><span class="line">set &#39;student-180100996:major&#39; &#39;英语&#39;</span><br><span class="line">lpush &#39;student-180100996:clubs&#39; &#39;支教社&#39; &#39;口语角&#39; &#39;福报协会&#39;</span><br><span class="line">hmset &#39;student-180100996:scores&#39; &#39;基础伪装学&#39; &#39;86&#39; &#39;心理学实战应用&#39; &#39;96&#39; &#39;威慑导论&#39; &#39;100&#39;</span><br><span class="line"></span><br><span class="line">set &#39;student-180100997:name&#39; &#39;强东刘&#39;</span><br><span class="line">set &#39;student-180100997:major&#39; &#39;社会学&#39;</span><br><span class="line">lpush &#39;student-180100997:clubs&#39; &#39;好兄弟俱乐部&#39;</span><br><span class="line">hset &#39;student-180100997:scores&#39; &#39;简明海战学&#39; &#39;99&#39; </span><br><span class="line">hset &#39;student-180100997:scores&#39; &#39;心理学实战应用&#39; &#39;86&#39; </span><br><span class="line"></span><br><span class="line">set &#39;student-180200007:name&#39; &#39;红颜李&#39;</span><br><span class="line">set &#39;student-180200007:major&#39; &#39;信息管理&#39;</span><br><span class="line">rpush &#39;student-180200007:clubs&#39; &#39;无人车工作室&#39;</span><br><span class="line">rpush &#39;student-180200007:clubs&#39; &#39;怡宝洗头社&#39;</span><br><span class="line">hset &#39;student-180200007:scores&#39; &#39;基础伪装学&#39; &#39;68&#39;</span><br><span class="line">hset &#39;student-180200007:scores&#39; &#39;心理学实战应用&#39; &#39;96&#39;</span><br><span class="line">hset &#39;student-180200007:scores&#39; &#39;威慑导论&#39; &#39;84&#39;</span><br></pre></td></tr></table></figure><p>另：如何从文件中导入数据？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 命令存储在cmd.txt中</span><br><span class="line">redis-cli &lt; cmd.txt</span><br></pre></td></tr></table></figure><p>接下来依次对四种数据结构的常用操作进行测试</p><h3 id="Redis-数据结构及常用操作"><a href="#Redis-数据结构及常用操作" class="headerlink" title="Redis 数据结构及常用操作"></a>Redis 数据结构及常用操作</h3><p><code>Redis</code>中的数据结构主要有 String，List，Set，ZSet，Hash</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>字符串是Redis的基本类型之一，用于存储字符串、整数、浮点数。</p><ul><li>对整个字符串或者字符串的其中一部分执行操作；</li><li>对整数和浮点数执行自增(increment)或者自减(decrement)操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET key value# 设置指定 key 的值</span><br><span class="line">&gt; GET key # 获取指定 key 的值</span><br><span class="line">&gt; DEL key# 删除此key以及其对应的value，这个命令对5种数据类型都适用</span><br><span class="line">&gt; STRLEN key# 返回 key 所储存的字符串值的长度</span><br><span class="line"></span><br><span class="line">&gt; MSET key value [key value...]# 同时设置一个或多个 key-value 对</span><br><span class="line">&gt; MGET key1 [key2..]# 获取所有(一个或多个)给定 key 的值</span><br><span class="line"></span><br><span class="line">&gt; INCR key# 将 key 中储存的数字值增一</span><br><span class="line">&gt; INCRBY key increment# 将 key 所储存的值加上给定的增量值(increment)</span><br><span class="line">&gt; DECR key</span><br><span class="line">&gt; DECRBY key increment</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; set &#39;teacher-100001:age&#39; &#39;24&#39;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; del teacher-100001:age</span><br><span class="line">(integer)1</span><br><span class="line"></span><br><span class="line">&gt; mset teacher-100001:name 章北海 teacher-100001:age 42</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; strlen teacher-100001:name</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">&gt; INCR teacher-100001:age</span><br><span class="line">43</span><br><span class="line"></span><br><span class="line">&gt; mget teacher-100001:name teacher-100001:age</span><br><span class="line">1) &quot;\xe7\xab\xa0\xe5\x8c\x97\xe6\xb5\xb7&quot;</span><br><span class="line">2) &quot;43&quot;</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/String%20%E6%B5%8B%E8%AF%95.png" alt="String 测试"></p><p>注：<code>redis</code>会将汉字编码为<code>utf-8</code>存储，使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;set China 中国</span><br><span class="line">OK</span><br><span class="line">&gt; save</span><br><span class="line">OK</span><br><span class="line">&gt; exit</span><br><span class="line"></span><br><span class="line">qwert@ubuntu:redis-cli --raw</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/%E4%B8%AD%E6%96%87.png" alt="中文"></p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>一个链表，链表上的每个节点都包含了一个字符串</p><ul><li>从链表的两端推入或者弹出元素(队列操作)；</li><li>根据偏移量对链表进行修剪(trim)；</li><li>读取单个或者多个元素；根据值查找或者移除元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; LPUSH key value1 [value2]# 将一个或多个值插入到列表头部</span><br><span class="line">&gt; RPUSH key value1 [value2]# 在列表尾部添加一个或多个值</span><br><span class="line">&gt; LLEN key# 获取列表长度</span><br><span class="line">&gt; LRANGE key start stop# 获取列表指定范围内的元素</span><br><span class="line">&gt; LTRIM key start stop# 对一个列表进行修剪(trim)，指定区间[start,stop]之外的元素都将被删除,</span><br><span class="line">&gt; LSET key index value# 通过索引设置列表元素的值</span><br><span class="line">&gt; LPOP key# 移出并获取列表的第一个元素</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; LPUSH student-180100996:clubs 支教社</span><br><span class="line">&gt; LPUSH student-180100996:clubs 口语角 福报协会</span><br><span class="line">&gt; RPUSH student-180100996:clubs 曹操发明了世界上第一艘航母</span><br><span class="line">&gt; LLEN student-180100996:clubs</span><br><span class="line">&gt; LRANGE student-180100996:clubs 0 10</span><br><span class="line">&gt; LTRIM student-180100996:clubs 0 2</span><br><span class="line">&gt; LRANGE student-180100996:clubs 0 10</span><br></pre></td></tr></table></figure><p>很让人别扭的是，这里的区间居然是左闭右闭。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/List%20%E6%B5%8B%E8%AF%95.png" alt="List 测试"></p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>包含字符串的无序收集器, 不可包含重复字符串</p><ul><li>添加、获取、移除单个元素；</li><li>检查一个元素是否存在于集合中；</li><li>计算交集、并集、差集；</li><li>从集合里面随机获取元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➢ Hash类型中的hset, hget, hmget, mdel, hlen, hvals等</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SADD key member1 [member2]# 向集合添加一个或多个成员</span><br><span class="line">SCARD key# 获取集合的成员数</span><br><span class="line">SDIFF key1 [key2]# 返回第一个集合与其他集合之间的差集</span><br><span class="line">SINTER key1 [key2]# 返回给定所有集合的交集</span><br><span class="line">SUNION key1 [key2]# 返回所有给定集合的并集</span><br><span class="line">SISMEMBER key member# 判断 member 元素是否是集合 key 的成员</span><br><span class="line">SMEMBERS key# 返回集合中的所有成员</span><br><span class="line">SPOP key [count]# 移除并返回集合中的一个随机元素</span><br><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]# 迭代集合中的元素</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SADD &#39;teacher-100001:course&#39; &#39;基础伪装学&#39; &#39;心理学实战应用&#39;</span><br><span class="line">SMEMBERS teacher-100001:course</span><br><span class="line">SADD &#39;teacher-100002:course&#39; &#39;基础伪装学&#39; &#39;材料学入门&#39;</span><br><span class="line"></span><br><span class="line">SINTER teacher-100001:course teacher-100002:course</span><br><span class="line">SUNION teacher-100001:course teacher-100002:course</span><br><span class="line">SDIFF teacher-100001:course teacher-100002:course</span><br><span class="line"></span><br><span class="line">SISMEMBER teacher-100002:course 基础伪装学</span><br><span class="line">SPOP teacher-100002:course 2</span><br><span class="line">SCARD teacher-100002:course</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/Set%20%E6%B5%8B%E8%AF%95.png" alt="Set 测试"></p><h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><p>字符串成员(member)与浮点数分值(score)之间的<strong>有序映射</strong>，元素的排列顺序由<strong>分值的大小</strong>决定</p><ul><li>添加、获取、删除单个元素；</li><li>根据分值范围(range)或者成员来获取元素</li></ul><p>略，参考<a href="https://www.runoob.com/redis/redis-sorted-sets.html" target="_blank" rel="noopener">此处</a></p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>包含键值对的无序散列表</p><ul><li>添加、获取、移除单个键值对；</li><li>获取所有键值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value#将哈希表 key 中的字段 field 的值设为 value </span><br><span class="line">HMSET key field1 value1 [field2 value2 ]# 将多个 field-value对设置到哈希表 key 中</span><br><span class="line">HGET key field# 获取存储在哈希表中指定字段的值。</span><br><span class="line">HMGET key field1 [field2]# 获取所有给定字段的值</span><br><span class="line">HGETALL key# 获取在哈希表中指定 key 的所有字段和值</span><br><span class="line"></span><br><span class="line">HDEL key field1 [field2]# 删除一个或多个哈希表字段</span><br><span class="line">HLEN key# 获取哈希表中字段的数量</span><br><span class="line">HEXISTS key field# 查看哈希表 key 中，指定的字段是否存在。</span><br><span class="line"></span><br><span class="line">HKEYS key# 获取所有哈希表中的字段</span><br><span class="line">HVALS key# 获取哈希表中所有值。</span><br><span class="line"></span><br><span class="line">HINCRBY key field increment# 为哈希表 key 中的指定字段的整数值加上增量 increment 。</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hset china ali 1</span><br><span class="line">hset china google 1024 hw 251</span><br><span class="line">hkeys china </span><br><span class="line">hvals china </span><br><span class="line"></span><br><span class="line">hlen china</span><br><span class="line">hdel china google</span><br><span class="line">hexists china lianxiang</span><br><span class="line"></span><br><span class="line">hincrby china ali 995</span><br><span class="line">hgetall china</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/hash%E6%B5%8B%E8%AF%95.png" alt="hash测试"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.redis.com.cn/features-of-redis/" target="_blank" rel="noopener">官方：Redis教程</a></p><p><a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">菜鸟教程：Redis教程</a></p><p><a href="https://juejin.im/post/6844903829914271752" target="_blank" rel="noopener">掘金：认识Redis与Redis的数据结构</a></p><p><a href="https://juejin.im/post/6844903827712245774" target="_blank" rel="noopener">掘金：浅谈 Redis 数据结构</a>    涉及源码实现</p><p><a href="https://segmentfault.com/a/1190000037786578" target="_blank" rel="noopener">思否：Redis中对Hash类型的操作命令</a></p><p><a href="https://redis.io/commands" target="_blank" rel="noopener">Redis命令文档</a></p><p><a href="http://doc.redisfans.com/" target="_blank" rel="noopener">Redis命令文档中文版</a></p><p><a href="https://zhuanlan.zhihu.com/p/153015977" target="_blank" rel="noopener">知乎：16000 字 Redis 面试知识点总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是记录大三上学期方向必修课 《数据管理技术》的上机实验。本学期共有四次实验。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hadoop环境搭建与配置 &lt;/li&gt;
&lt;li&gt;HBase数据库的部署与配置 &lt;/li&gt;
&lt;li&gt;Redis数据库的部署与配置&lt;/li&gt;
&lt;li&gt;Redis中数据类型使用及命令使用 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文将主要记载后两个实验&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术小记" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/"/>
    
      <category term="Technology_Stack" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/Technology-Stack/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/Technology-Stack/Redis/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="NoSQL" scheme="http://yoursite.com/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题流水账2020-10</title>
    <link href="http://yoursite.com/2020/11/02/%C2%96LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-10/"/>
    <id>http://yoursite.com/2020/11/02/%C2%96LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-10/</id>
    <published>2020-11-02T06:01:05.000Z</published>
    <updated>2020-11-02T06:05:02.140Z</updated>
    
    <content type="html"><![CDATA[<p>主要是数组, 将官方给的 <a href="https://leetcode-cn.com/leetbook/detail/array-and-string/" target="_blank" rel="noopener">数组字符串</a> 刷完了, 又按照出现频率顺序刷了数组的二十多条,但是(大)部分Hard题目刷不动.</p><a id="more"></a><h2 id="2020年10月4日"><a href="#2020年10月4日" class="headerlink" title="2020年10月4日"></a>2020年10月4日</h2><h3 id="面试题-01-08-零矩阵"><a href="#面试题-01-08-零矩阵" class="headerlink" title="面试题 01.08. 零矩阵"></a>面试题 01.08. 零矩阵</h3><p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p><p>思路: 扫描两遍</p><p>第一遍扫描: 新建两个布尔数组(长度为M和N),分别储存矩阵的横纵坐标是否为零</p><p>第二遍扫描: 如果元素的对应任意数组元素为真,清零</p><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="[977] 有序数组的平方"></a>[977] 有序数组的平方</h3><p>解法一思路很简单, 先平方再排序</p><p>解法2: 使用双指针. 指针从两头逐渐向中间移动. 由于数组递增排序,绝对值两头大中间小. 选择更大的数, 平方后赋值在re数组中(注意要从后向前赋值) </p><hr><h2 id="2020年10月7日"><a href="#2020年10月7日" class="headerlink" title="2020年10月7日"></a>2020年10月7日</h2><h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="[75] 颜色分类"></a>[75] 颜色分类</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>题目要求不使用库中的排序算法. </p><p>解法1: 扫描两次.第一次统计各种元素的个数. 第二次重写数组. 不佳</p><p>解法2: 使用双指针. 分别指向第一个1和最后一个1.一次遍历时遇到0 ,与A[p++]交换; 遇到2, 与A[q—]交换.</p><p>注意: 解法二中, 如果发生了交换, 那么下一个判断的数组还是A[i], 因此i++不能直接写在for循环的末尾循环语句中! </p><h3 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="[498]对角线遍历"></a>[498]对角线遍历</h3><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/diagonal_traverse.png" alt=""></p><p>关键点1: 如果元素的横纵坐标之和是偶数, 说明下一个方向是朝着右上角.</p><p>关键点2: 针对边界的修正. </p><h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="[14]  最长公共前缀"></a>[14]  最长公共前缀</h3><p>这题曾经在2020.09月用CPP实现过. 今天用Java重写了.</p><p>以第一个字符串为基准. 对于该串的每个字符是否与后面的所有串的对应位置的字符相同. 如果不同则将该字符前的子串返回.</p><hr><h2 id="2020年10月9日"><a href="#2020年10月9日" class="headerlink" title="2020年10月9日"></a>2020年10月9日</h2><h3 id="141-环形列表"><a href="#141-环形列表" class="headerlink" title="[141] 环形列表"></a>[141] 环形列表</h3><p>2020年9月份做过了. 使用Java重写.</p><p>另外: 逻辑与, 逻辑或具有短路功能. 因此最初的判断只需要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>即可! 如果head为空引用类型, 后面对next的判断会被短路. 无需担心. </p><hr><h2 id="2020年10月15日"><a href="#2020年10月15日" class="headerlink" title="2020年10月15日"></a>2020年10月15日</h2><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="[27] 移除元素"></a>[27] 移除元素</h3><p>快慢指针 <a href="https://leetcode-cn.com/leetbook/read/array-and-string/cv3bv/" target="_blank" rel="noopener">题解</a></p><p>主要问题: 如何判断两个指针的自增条件?</p><h3 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="[485] 最大连续1的个数"></a>[485] 最大连续1的个数</h3><p>同样用双指针,注意判断时需要同时判断前一位的值: 相异再执行,相同直接下一个, 最后返回fast-slow即可</p><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="[209] 长度最小的子数组"></a>[209] 长度最小的子数组</h3><p>这题写的很难受..又是一看就会一写就废</p><blockquote><p>给定一个含有 <strong>n</strong> 个正整数的数组和一个正整数 <strong>s ，</strong>找出该数组中满足其和 <strong>≥ s</strong> 的长度最小的 <strong>连续</strong> 子数组，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 0。</p></blockquote><p>第一次写的暴力就忽略了. 最优方法是滑动窗口(双指针的一种):</p><p>思想: 若sum小了 fast后移; 若sum大了, slow后移 在此过程中找最小的</p><p>问题: 如何把思想转成代码? 如何再这个过程中找到最小的?</p><p>算法: (先自己写 再看这个)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">每一个fast:</span><br><span class="line">if(当前sum较小)</span><br><span class="line">fast后移</span><br><span class="line">else&#123;</span><br><span class="line">while(当前sum&gt;&#x3D;s)&#123;</span><br><span class="line">更新min</span><br><span class="line">sum中减去slow对应数字</span><br><span class="line">slow后移</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO: 重写</p><h2 id="2020年10月20日"><a href="#2020年10月20日" class="headerlink" title="2020年10月20日"></a>2020年10月20日</h2><h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="[4] 寻找两个正序数组的中位数"></a>[4] 寻找两个正序数组的中位数</h3><p>Hard题</p><p>给两个排序数组, 返回合并后的中位数</p><p>方法一: 暴力</p><p>先合并, 再求中位数; 问题主要转化成了两个正序数组的合并问题.</p><p>返回中位数:不会真有人用双指针吧? 判断元素数目的奇偶, 返回 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">个数为奇数: nums[len&#x2F;2]</span><br><span class="line">个数为偶数: (nums[len&#x2F;2] + nums[len&#x2F;2-1]) &#x2F; 2</span><br></pre></td></tr></table></figure><h2 id="2020年10月21日"><a href="#2020年10月21日" class="headerlink" title="2020年10月21日"></a>2020年10月21日</h2><h3 id="4-寻找两个正序数组的中位数-1"><a href="#4-寻找两个正序数组的中位数-1" class="headerlink" title="[4] 寻找两个正序数组的中位数"></a>[4] 寻找两个正序数组的中位数</h3><p>方法二:二分查找</p><p>在两个数组中进行二分查找,主要的思想还是不变的.(当然写起来问题很多就是了)</p><p>建议直接看<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/" target="_blank" rel="noopener">官方题解的视频,</a>讲的比较到位</p><p>没有太理清楚的点: 在二分查找时,关于奇数的除二,上下取整问题. 以及改变left 和right的时候是<code>i-1</code>,<code>i</code> 还是 <code>i+1</code>呢?</p><p><strong>TODO</strong></p><h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="[11] 盛最多水的容器"></a>[11] 盛最多水的容器</h3><p>双指针. 每次都移动更矮的板子,结果可能更差,但不会错过更好的.</p><p>应该是应用很多的思路.</p><p>注意: 题目不需要返回最佳时的左右板子,只要最多水的容量即可!</p><p>【更新】于2020.11.2 补上证明: 为什么这么做不会错过更大的面积?</p><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="[53] 最大子序和"></a>[53] 最大子序和</h3><p>在九月份时写过C++版本的. 这题主要是动态规划.当时的笔记较为详细.请移步.</p><h2 id="2020年10月23日"><a href="#2020年10月23日" class="headerlink" title="2020年10月23日"></a>2020年10月23日</h2><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="[15] 三数之和"></a>[15] 三数之和</h3><p>终于到了久仰大名的三数之和.这是一条非常经典的双指针题目.</p><blockquote><p>给定一数组, 找出所有满足和为0的三元组,不能重复.</p></blockquote><p>思路如下: </p><p>对于每一个<code>a</code>, 要使得<code>b+c = -a</code>. 我们可以在将<code>b</code>从小到大的同时将<code>c</code>从大到小, 也就是第二重循环和第三重循环实际上是并列的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">我们选出的数分别是a,b,c, 它们在数组中的位置分别是first,second,third</span><br><span class="line">sort(nums)</span><br><span class="line">for first &#x3D; 0..n-1</span><br><span class="line">if(a不是第一个 &amp;&amp; a与nums[first-1]一样)</span><br><span class="line">continue</span><br><span class="line">&#x2F;&#x2F;为了保证不重复</span><br><span class="line">target &#x3D; -1 * a&#x2F;&#x2F;对于这个a,b+c应该等于target</span><br><span class="line">third &#x3D; n-1</span><br><span class="line">second &#x3D; first+1</span><br><span class="line">&#x2F;&#x2F;并列执行二,三重循环,或者说是双指针</span><br><span class="line">for second &#x3D; first+1 .. n-1</span><br><span class="line">            if(b不是a后第一个 &amp;&amp; b与nums[second-1]一样)</span><br><span class="line">                continue</span><br><span class="line">                &#x2F;&#x2F;为了保证不重复</span><br><span class="line">            while nums[first]+nums[second]+nums[third] &gt; 0</span><br><span class="line">                third &#x3D; third-1</span><br><span class="line">            &#x2F;&#x2F; 判断是否有 a+b+c&#x3D;&#x3D;0</span><br><span class="line">            check(first, second, third)</span><br></pre></td></tr></table></figure><p>当然,这里还可以有一些常数级的优化. 略过不表.</p><p>原本的复杂度是<code>O(n^3)</code>. 现在的复杂度是<code>O(N^2)</code></p><blockquote><p>这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 <code>O(N^2)</code>) 减少至 O(N)O(N)。为什么是<code>O(N)</code> 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 bb），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为<code>O(N)</code>，均摊下来，每次也向左移动一个位置，因此时间复杂度为 <code>O(N)</code>。</p><p>注意到我们的伪代码中还有第一重循环，时间复杂度为 <code>O(N)</code>，因此枚举的总时间复杂度为 <code>O(N^2)</code><br>)。由于排序的时间复杂度为 <code>O(N log N)</code>)，在渐进意义下小于前者，因此算法的总时间复杂度为<code>O(N^2)</code>。</p></blockquote><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="[121] 买卖股票的最佳时机"></a>[121] 买卖股票的最佳时机</h3><p>二刷,一条简单的<code>dp</code> 存储目前的最低价和最大收益</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i &#x3D; 0..n-1</span><br><span class="line">if(curr&lt;minPrice) minPrice&#x3D;curr;</span><br><span class="line">if(curr-minPrice&gt;maxProfit) maxProfit&#x3D;curr-minPrice;</span><br></pre></td></tr></table></figure><h2 id="2020年10月24日"><a href="#2020年10月24日" class="headerlink" title="2020年10月24日"></a>2020年10月24日</h2><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="[42] 接雨水"></a>[42] 接雨水</h3><ol><li><p>暴力: 对于每个高度h,找到左边最lm,和右边最大的数rm. 取min(lm,rm)-h的值,若大于0则累计.</p><p>问题在于: 每个高度都要左右扫描一遍 O(n^2)</p></li><li><p>动态编程</p><p>先扫描两边,记录每个h的<code>leftMaxVol[]</code>, <code>rightMaxVol[]</code></p><p>遍历每个高度时,只需要拿两个数组对应的值即可. </p></li><li><p>双指针</p><p>很巧妙, </p><p>定理一：在某个位置<code>i</code>处，它能存的水，取决于它左右两边的最大值中较小的一个。</p><p>定理二：当我们从左往右处理到left下标时，左边的最大值left_max对它而言是可信的，但right_max对它而言是不可信的。（见下图，由于中间状况未知，对于left下标而言，right_max未必就是它右边最大的值）</p><p>定理三：当我们从右往左处理到right下标时，右边的最大值right_max对它而言是可信的，但left_max对它而言是不可信的。</p><p>对于位置<code>left</code>而言，它左边最大值一定是left_max，右边最大值“大于等于”right_max，这时候，如果<code>left_max&lt;right_max</code>成立，那么它就知道自己能存多少水了。无论右边将来会不会出现更大的right_max，都不影响这个结果。 所以当<code>left_max&lt;right_max</code>时，我们就希望去处理left下标，反之，我们希望去处理right下标。</p></li></ol><h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="[238] 除自身以外数组的乘积"></a>[238] 除自身以外数组的乘积</h3><p>题目不让使用除法</p><p>和42题类似,先遍历两边, 算出前缀积和后缀积,再第三次遍历的时候相乘.</p><p>空间都复杂度的优化:</p><p>前缀积可以不用数组, 而用一个整数在最终遍历的时候动态维护. 那么后缀积怎么优化呢? 很鸡贼, 因为题目说不考虑返回数组的空间, 所以把遍历的后缀积放在<code>ans[]</code>数组中…..</p><h2 id="2020年10月27日"><a href="#2020年10月27日" class="headerlink" title="2020年10月27日"></a>2020年10月27日</h2><h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="[16] 最接近的三数之和"></a>[16] 最接近的三数之和</h3><p>啊这, 其实和<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">[15]三数之和</a>基本是完全一致的思路。请直接参照10月23日的笔记。</p><p>常数级优化：若<code>first!=0 &amp;&amp; nums[first]==nums[first-1]</code>, 可直接<code>continue</code>；若<code>tmp3sum == target</code>,可直接返回，因为没有比自身更接近自身的数了。</p><h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="[31] 下一个排列"></a>[31] 下一个排列</h3><p>TODO 这条做的磕磕绊绊的，值得回头再做。比较考验思维。</p><p>可以直接看 <a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode/" target="_blank" rel="noopener">题解</a>。关键点在于：找出规律。先从全降序的入手，找到交换点，最后考虑到逆序。</p><p>说几个容易错的点</p><ol><li>长度为1的边缘情况</li><li>如果全降序，需要全逆序</li><li>找第二个交换点时，要考虑到<code>nums[a]==nums[b-1]</code>相等的情况。例如 1，5，1；应该是 <code>1,5</code>交换，不是<code>1,1</code>交换</li></ol><h2 id="2020年10月28日"><a href="#2020年10月28日" class="headerlink" title="2020年10月28日"></a>2020年10月28日</h2><h3 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="[289] 生命游戏"></a>[289] 生命游戏</h3><p>大名鼎鼎的细胞自动机. 题目本身不难, 关键是如何将规则提取为判断式；同时对规则尽可能地化简。</p><ol><li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li><li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li><li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li><li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for each&#123;</span><br><span class="line">int livesAround &#x3D; countLivesCellAround();</span><br><span class="line">ChangeStatus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么关键问题就变成了，如何计数？又如何改变？有以下问题</p><ol><li><p>如果仅仅使用1/0，那么最大的问题在于，计数时左上方的状态已经被更改过了。</p></li><li><p>对于上一条，我们可以将原始数组实现储存一份。但是空间开销大。</p></li><li><p>我们还可以拓展状态为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: 00 死-&gt;死 </span><br><span class="line">1: 01 活-&gt;死 </span><br><span class="line">2: 10 死-&gt;活 </span><br><span class="line">3: 11 活-&gt;活</span><br></pre></td></tr></table></figure></li><li><p>这样子，如果当前细胞死亡，状态无需改变；如果继续存活，1-&gt;3；如果细胞复活，0-&gt;2</p></li></ol><p>以上就是本题的主要思路了。</p><p>下面介绍一下二位矩阵中，统计周围单元格时对于边界的简便处理手段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int[] dx &#x3D; &#123; -1, -1, -1, 0, 0, 1, 1, 1 &#125;;</span><br><span class="line">int[] dy &#x3D; &#123; -1, 0, 1, -1, 1, -1, 0, 1 &#125;;</span><br><span class="line"></span><br><span class="line">for each&#123;</span><br><span class="line">int nx &#x3D; row + dx[i];</span><br><span class="line">    int ny &#x3D; col + dy[i];</span><br><span class="line">    if (nx &lt; 0 || nx &gt;&#x3D; rows || ny &lt; 0 || ny &gt;&#x3D; cols) &#123;</span><br><span class="line">    continue;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    &#x2F;&#x2F; 正常操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2020年10月29日"><a href="#2020年10月29日" class="headerlink" title="2020年10月29日"></a>2020年10月29日</h2><h3 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="[442] 数组中重复的数据"></a>[442] 数组中重复的数据</h3><blockquote><p>给定一个整数数组 a，其中1 ≤ a[i] ≤ <em>n</em> （<em>n</em>为数组长度）, 其中有些元素出现<strong>两次</strong>而其他元素出现<strong>一次</strong>。</p><p>找到所有出现<strong>两次</strong>的元素。</p></blockquote><p> 思考: 考虑到1 ≤ a[i] ≤ n ,那么应该是一一对应的. </p><p>问题:如何将这个信息存储在原有的数组中?能否不影响数组本身信息的存储?</p><p>答:由于数字都是正数,我们可以利用符号的转变来存储这一二进制信息(正:未遇见过,负:已遇见过)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for each&#123;</span><br><span class="line">index &#x3D; nums[i]-1&#x2F;&#x2F;index是索引,数字范围1~n,对于0~n-1</span><br><span class="line">if(nums[index]&gt;0)</span><br><span class="line">nums[index] * -1</span><br><span class="line">else</span><br><span class="line">&#x2F;&#x2F;说明出现过,添加进结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2020年10月30日"><a href="#2020年10月30日" class="headerlink" title="2020年10月30日"></a>2020年10月30日</h2><h3 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="[41] 缺失的第一个正数"></a>[41] 缺失的第一个正数</h3><p>利用正负来标记信息</p><p><a href="https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p><h5 id="TODO-重做"><a href="#TODO-重做" class="headerlink" title="TODO 重做"></a>TODO 重做</h5><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="[88] 合并两个有序数组"></a>[88] 合并两个有序数组</h3><p>二刷, 很简单的双指针题目. 从后往前指针移动即可.注意一下其中一个数组完成后将后续部分如何放进去</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是数组, 将官方给的 &lt;a href=&quot;https://leetcode-cn.com/leetbook/detail/array-and-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组字符串&lt;/a&gt; 刷完了, 又按照出现频率顺序刷了数组的二十多条,但是(大)部分Hard题目刷不动.&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="屠龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/"/>
    
      <category term="算法与刷题" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%B7%E9%A2%98/"/>
    
      <category term="力扣刷题流水账" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>搭建Hadoop与HBasesse</title>
    <link href="http://yoursite.com/2020/10/26/%E6%90%AD%E5%BB%BAHadoop%E4%B8%8EHBasesse/"/>
    <id>http://yoursite.com/2020/10/26/%E6%90%AD%E5%BB%BAHadoop%E4%B8%8EHBasesse/</id>
    <published>2020-10-26T08:43:19.000Z</published>
    <updated>2020-11-10T14:06:52.100Z</updated>
    
    <content type="html"><![CDATA[<p>本文是记录大三上学期方向必修课 《数据管理技术》的上机实验。本学期共有四次实验。</p><ol><li>Hadoop环境搭建与配置 </li><li>HBase数据库的部署与配置 </li><li>Redis数据库的部署与配置</li><li>Redis中数据类型使用及命令使用 </li></ol><p>本文将主要记载前两个实验</p><a id="more"></a><h2 id="实验一-Hadoop环境搭建与配置"><a href="#实验一-Hadoop环境搭建与配置" class="headerlink" title="实验一:Hadoop环境搭建与配置"></a>实验一:Hadoop环境搭建与配置</h2><p>本次实验目标是配置Hadoop，版本采用目前的最新版（<a href="https://hadoop.apache.org/releases.html" target="_blank" rel="noopener">Hadoop 3.3.0</a> 和 <a href="https://hbase.apache.org/downloads.html" target="_blank" rel="noopener">HBase 2.3.2</a>）。方式为使用两台虚拟机搭建一主一从的完全分布式环境。</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>在 Apache 官网上下载 Hadoop 安装包，注意：Apache通常会给一个source版本和一个binary版本，这两者的区别： SRC版本包含源码，主要给高级开发人员准备，可以去修改其中的源码改变或扩展功能。 BIN版本主要是一般开发人员或使用者准备，只需要使用其固化功能即可，我们下载后者即可。</p><p>在 VMware 中新建两台虚拟机。我们这里使用的版本为 <code>ubuntu-18.04.4</code>，暂时我们只需要创建一台，稍后再克隆过去即可。有关如何使用VMware创建虚拟机在此不表。</p><p>创建成功后，换源，安装必要的包，略去不提</p><h3 id="安装JDK和SSH"><a href="#安装JDK和SSH" class="headerlink" title="安装JDK和SSH"></a>安装JDK和SSH</h3><p>接下来我们安装 <code>jdk</code> 并配置Java环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E6%90%AD%E5%BB%BAHadoop-%E5%AE%89%E8%A3%85jdk.png" alt="安装jdk"></p><p>输入 <code>java -version</code>,检查是否安装成功。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/26/java-version.png" alt="Java version"></p><p>配置Java环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>将以下内容复制进去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Java Environment</span></span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p>保存后运行 <code>source ~/.bashrc</code> 使修改生效。输入 <code>export</code> 检查是否有Java路径。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/java%E7%8E%AF%E5%A2%83%E8%B7%AF%E5%BE%84.png" alt="java环境路径"></p><p>接下来我们安装 <code>SSH</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br><span class="line">ssh localhost</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>此时我们安装好了<code>ssh</code>. 关于<code>ssh</code>的设置先告一段落，我们先克隆一份新的虚拟机。</p><h3 id="克隆虚拟机并完成互连"><a href="#克隆虚拟机并完成互连" class="headerlink" title="克隆虚拟机并完成互连"></a>克隆虚拟机并完成互连</h3><p>将刚才的虚拟机关机，在VMware中克隆刚才的虚拟机，命名为slave。关于如何克隆虚拟机在此不表。</p><p>克隆成功后，新旧虚拟机是完全一样的。为了区分我们需要在新虚拟机中修改系统名，并在两台机子中修改<code>IP</code>映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改系统名</span><br><span class="line">sudo vim &#x2F;etc&#x2F;hostname</span><br><span class="line"># 将文件内容改为 &quot;slave&quot;</span><br><span class="line"># 当然你也可以回去把主机的系统名修改为master</span><br></pre></td></tr></table></figure><blockquote><p>因为我来回做了两边，所以有些截图的名称，路径与IP不太对，以文字为准</p></blockquote><p>接下来修改IP映射，先在两个虚拟机内执行指令 <code>ifconfig</code> 找到 IP 地址并记录。提示：该指令可能需要安装<code>net-tools</code>包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 修改IP映射</span><br><span class="line">sudo vim &#x2F;etc&#x2F;hosts</span><br><span class="line"># 在文件结尾加上IP地址+系统名，例如</span><br><span class="line">192.168.127.140 master</span><br><span class="line">192.168.127.141 slave</span><br><span class="line"># 这一步在两个系统中都要做</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E4%BF%AE%E6%94%B9IP.png" alt="修改ip"></p><p>我们在两台虚拟机内互相<code>ping</code>下对方，检查是否成功互连。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># master</span><br><span class="line">ping slave</span><br><span class="line"># slave</span><br><span class="line">ping master</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/mpings.png" alt="m-ping-s"></p><h3 id="虚拟机间SSH免密登录"><a href="#虚拟机间SSH免密登录" class="headerlink" title="虚拟机间SSH免密登录"></a>虚拟机间SSH免密登录</h3><p>在主机下生成<code>SSH</code>密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh&#x2F;</span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>连续三次回车，第一次将 Key 存放于默认位置(<code>~/.ssh/</code>)，第二次和第三次是设定密码为空。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E9%85%8D%E7%BD%AEssh-%E5%85%8D%E7%99%BB%E5%BD%951.png" alt="生成密钥"></p><p>继续执行以下语句，设定免密登录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch authorized_keys</span><br><span class="line">chmod 600 authorized_keys</span><br><span class="line">cat ./id_rsa.pub &gt;&gt; ./authorized_keys</span><br></pre></td></tr></table></figure><p>这时我们登录本机<code>SSH</code>就不需要密码了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 免密登录本机SSH</span><br><span class="line">ssh localhost</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><blockquote><p>注意：有人（其实就是我）可能会需要以下报错：</p><blockquote><p>The authenticity of host ‘localhost (127.0.0.1)’ can’t be established</p></blockquote><p>请参考本节最后的常见问题</p></blockquote><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E9%85%8D%E7%BD%AEssh-%E5%85%8D%E7%99%BB%E5%BD%952%28%E6%88%90%E5%8A%9F%29.png" alt="本地免密2"></p><p>将公钥文件复制到slave下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~&#x2F;.ssh&#x2F;authorized_keys slave:~&#x2F;.ssh</span><br></pre></td></tr></table></figure><p>切换到<code>slave</code>虚拟机，生成<code>ssh</code>密钥，再把刚才的文件移动到<code>.ssh</code>下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh&#x2F;</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">mv authorized_keys ~&#x2F;.ssh</span><br></pre></td></tr></table></figure><p>回到<code>master</code>, 尝试免密登录<code>slave</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh slave</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E9%85%8D%E7%BD%AEssh-%E5%85%8D%E7%99%BB%E5%BD%95slave3%28%E6%88%90%E5%8A%9F%29.png" alt="免密登录slave3"></p><p>至此虚拟机间SSH免密登录完毕。</p><h3 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h3><p>每个节点的Hadoop配置都一样，由于我们刚才已经在节点之间建立了SSH链接，所以我们只在<code>master</code>中安装配置，稍后直接将它们复制到<code>slave</code></p><p>切到刚才下载好<code>hadoop-3.3.0.tar.gz</code>的文件夹，执行下列命令安装。为了方便我们把解压出来的文件夹命名为<code>hadoop</code>, 并把它移动到<code>/usr/local</code>下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf hadoop-3.3.0.tar.gz -C &#x2F;usr&#x2F;local</span><br><span class="line">cd &#x2F;usr&#x2F;local</span><br><span class="line">mv hadoop-3.3.0 hadoop</span><br><span class="line">chown -R hadoop .&#x2F;hadoop</span><br></pre></td></tr></table></figure><p>然后加入<code>Hadoop</code>的环境变量，方法同 Java 的环境配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>将以下内容复制进去，请注意这里的<code>HADOOP_HOME</code>应该是根据你的安装目录有所变动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Hadoop Environment</span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;hadoop</span><br><span class="line">export CLASSPATH&#x3D;$($HADOOP_HOME&#x2F;bin&#x2F;hadoop classpath):$CLASSPATH</span><br><span class="line">export HADOOP_COMMON_LIB_NATIVE_DIR&#x3D;$HADOOP_HOME&#x2F;lib&#x2F;native</span><br><span class="line">export PATH&#x3D;$PATH:$HADOOP_HOME&#x2F;bin:$HADOOP_HOME&#x2F;sbin</span><br></pre></td></tr></table></figure><blockquote><p>这里的一个坑在于：配置语句对字段规范要求非常严格，例如等号左右不能多空格，4空格!=1tab</p></blockquote><p>保存后运行 <code>source ~/.bashrc</code> 使修改生效。输入 <code>hadoop version</code>，如果出现 Hadoop 版本即说明安装成功。接下来开始配置完全分布式环境。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E5%AE%89%E8%A3%85Hadoop%28%E6%88%90%E5%8A%9F%29.png" alt="安装Hadoop"></p><h3 id="配置Hadoop分布式环境"><a href="#配置Hadoop分布式环境" class="headerlink" title="配置Hadoop分布式环境"></a>配置Hadoop分布式环境</h3><p>切到 <code>/usr/local/hadoop/etc/hadoop</code> 文件夹，修改 <code>hadoop-env.sh</code> 文件，主要是指定 <code>JAVA_HOME</code>，在文件开头部分找到被注释掉的 <code>export JAVA_HOME=</code>，将其取消注释，并将等号后面的路径修改为之前的 <code>JAVA_HOME</code> 环境变量的值，在本文的示例中即为 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64</span><br></pre></td></tr></table></figure><p>修改 <code>core-site.xml</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">             &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">             &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:9000&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">         &lt;property&gt;</span><br><span class="line">             &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">             &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class="line">             &lt;description&gt;Abase for other temporary directories.&lt;&#x2F;description&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><p>注:上面第一个配置决定<code>hadoop</code>的<code>namenode</code>；第二个配置了储存<code>hadoop</code>执行过程中的临时文件地址,如果你的<code>Hadoop</code>不是安装在<code>/urc/local</code>的话,需要根据自己的实际情况进行更改.</p><p>修改 <code>hdfs-site.xml</code> 文件，在 <code>&lt;configuration&gt;</code> 节加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&#x2F;dfs&#x2F;name&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&#x2F;dfs&#x2F;data&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;dfs.http.address&lt;&#x2F;name&gt;</span><br><span class="line">     &lt;value&gt;0.0.0.0:50070&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><p>注：上面第一个配置每一个文件存储几份，默认的是3，但我这里只安装了1个slave，也就是只能存储1份。</p><p>修改文件系统 <code>yarn-site.xml</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><p>修改计算框架 <code>mapred-site.xml</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><p>添加<code>workers</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch workers# 如果没有</span><br><span class="line">vim workers</span><br></pre></td></tr></table></figure><p>在打开的文件里填写你的从节点名，例如我这里填写<code>slave</code>即可。</p><p>在<code>Hadoop 2.0</code>版本，这个文件名为<code>slaves</code>,灯塔国真是奇奇怪怪的政治正确。</p><hr><p>到此，我们已经在主节点中配置好了<code>Hadoop</code>，接下来我们将刚才配置的所有文件直接通过<code>ssh</code>传送给从节点。</p><p>将Hadoop发送到从节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">scp -r hadoop slave:~&#x2F;</span><br></pre></td></tr></table></figure><blockquote><p>这一步可能会出现各种各样的问题，祝你好运</p></blockquote><p>切换到<code>slave</code>机，将刚才传来的文件夹放入我们的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;</span><br><span class="line">sudo mv hadoop&#x2F; &#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure><p>保存上述文件，然后回到主机开始准备格式化 <code>NameNode</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;bin</span><br><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果你是第一次进行到这，应该问题不大。如果你已经是第N次格式化，可能会有报错：需要先将之前的data文件等删除，具体见本节最后的常见问题</p></blockquote><p>(主机上)启动 <code>Hadoop</code> 检查我们的配置结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;sbin</span><br><span class="line">start-dfs.sh</span><br><span class="line">jps</span><br></pre></td></tr></table></figure><p>在输出中出现 <code>Jps</code>、<code>NameNode</code>、<code>DateNode</code>、<code>SecondaryNameNode</code> 和 <code>ResourceManager</code> 即为成功。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/jps%E6%88%90%E5%8A%9F.png" alt="主机jps"></p><p>(从机上)只需要输入<code>jps</code>,如果输出出现 <code>Jps</code>, <code>DataNode</code>即为成功</p><p>访问 <code>localhost:50070</code> 可以查看到下列页面</p><p>注：Hadoop3为9868端口</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/Hadoop%E6%88%90%E5%8A%9F-9868.png" alt="Hadoop成功-9868"></p><p>访问 <code>localhost:8088</code> 可以查看到下列页面</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/Hadoop%E6%88%90%E5%8A%9F-8088.png" alt=""></p><p>我们可以选择左侧的<code>Node</code>页面查看当前节点。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/Hadoop%E6%88%90%E5%8A%9F-8088Nodes.png" alt="Hadoop成功-8088Nodes"></p><hr><h3 id="测试Hadoop"><a href="#测试Hadoop" class="headerlink" title="测试Hadoop"></a>测试Hadoop</h3><p>让我们测试一下Hadoop，统计<code>LICENSE.txt</code>中的单词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir &#x2F;input # 创建 input 文件夹</span><br><span class="line">hdfs dfs -put &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;LICENSE.txt &#x2F;input&#x2F;test.txt # 上传一个测试文件</span><br><span class="line">hadoop jar &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-examples-3.3.0.jar wordcount &#x2F;input&#x2F;test.txt &#x2F;output&#x2F;</span><br></pre></td></tr></table></figure><p>完成之后执行 <code>hdfs dfs -ls /output</code>，可以看到有两个文件出现（下图最上面）。</p><p>再输入<code>hdfs dfs -cat /output/part-r-00000</code>  出现以下输出标识已经正常运行。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/hadoop%E6%B5%8B%E8%AF%95-%E6%88%90%E5%8A%9F.png" alt="Hadoop测试"></p><p>我们还可以在<code>50070</code>的网页中可视化地查看刚才的处理结果。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/hadoop%E6%B5%8B%E8%AF%95-%E6%88%90%E5%8A%9F%28%E7%BD%91%E9%A1%B5%29.png" alt="Hadoop测试-网页"></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><blockquote><p>在SSH登录时，报错The authenticity of host ‘localhost (127.0.0.1)’ can’t be established</p></blockquote><p>参考 <a href="https://blog.csdn.net/stpeace/article/details/79426471" target="_blank" rel="noopener">https://blog.csdn.net/stpeace/article/details/79426471</a></p><blockquote><p>在SSH从节点时，报错 connect to host slave port 22: No route to host lost connection</p></blockquote><p>可能是由于各虚拟机的<code>ip</code>变动（比如重启）重新查看IP并设置hosts文件</p><blockquote><p>报错 Permission denied, please try again</p></blockquote><p>参考<a href="https://blog.csdn.net/qq_39999139/article/details/106174829?utm_medium=distribute.pc_relevant.none-task-blog-title-2&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">ssh远程登录服务器出现Permission denied, please try again</a></p><h4 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h4><blockquote><p>第N次格式化NameNode</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化后，原来的缓存没有清干净</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;</span><br><span class="line">rm -rf tmp</span><br></pre></td></tr></table></figure><p>参考<a href="https://my.oschina.net/HIJAY/blog/220816" target="_blank" rel="noopener">Hadoop中重新格式化namenode</a></p><blockquote><p>Shutting down NameNode at master/192.168.xxx.xxx</p></blockquote><p>无视它，标识是否成功的是上面一行输出。即下图框出来的</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/hadoop%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%88%90%E5%8A%9F.png" alt="hadoop格式化成功"></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><blockquote><p>编辑gedit要编辑的文件，保存之后出现Set document metadata failed: Setting attribute metadata::gedit-position no的警告</p></blockquote><p>只是个警告，无视它。<a href="https://askubuntu.com/questions/798935/set-document-metadata-failed-when-i-run-sudo-gedit" target="_blank" rel="noopener">参考本回答</a></p><blockquote><p>sudo su</p></blockquote><p>该命令会使当前终端进入root管理员的账号，此时的<code>~</code>表示<code>/root</code>而不是<code>home/xxx</code>。参考<a href="https://www.runoob.com/linux/linux-system-contents.html" target="_blank" rel="noopener">Linux 系统目录结构</a></p><h2 id="实验二：HBase的安装配置"><a href="#实验二：HBase的安装配置" class="headerlink" title="实验二：HBase的安装配置"></a>实验二：HBase的安装配置</h2><p>本次实验目标是在实验一的基础上配置<code>HBase</code>，版本采用目前的最新版（ <a href="https://hbase.apache.org/downloads.html" target="_blank" rel="noopener">HBase 2.3.2</a>）。</p><h3 id="安装HBase"><a href="#安装HBase" class="headerlink" title="安装HBase"></a>安装HBase</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf  hbase-2.3.2-bin.tar.gz -C &#x2F;usr&#x2F;local</span><br><span class="line">cd &#x2F;usr&#x2F;local</span><br><span class="line">sudo mv hbase-2.3.2-bin hbase</span><br><span class="line">sudo chown -R hadoop .&#x2F;hbase</span><br></pre></td></tr></table></figure><p>与<code>Hadoop</code>类似,我们依旧将文件夹放入<code>usr/local</code>下</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>将以下内容复制进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># HBase Environment</span><br><span class="line">HBASE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;hbase</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E9%85%8D%E7%BD%AEHbase-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="配置Hbase-环境变量"></p><p>使修改生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><h3 id="配置HBase"><a href="#配置HBase" class="headerlink" title="配置HBase"></a>配置HBase</h3><p>修改<code>hbase</code>中的Java路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;urc&#x2F;local&#x2F;hbase&#x2F;conf</span><br><span class="line">sudo vim hbase-env.sh</span><br></pre></td></tr></table></figure><p>在里面添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64</span><br></pre></td></tr></table></figure><p>修改<code>hbase-site.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.rootdir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:9000&#x2F;hbase&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.cluster.distributed&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;false&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="测试HBase"><a href="#测试HBase" class="headerlink" title="测试HBase"></a>测试HBase</h3><p>在此之前确保自己已经启动了<code>Hadoop</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hbase&#x2F;bin</span><br><span class="line">.&#x2F;start-hbase.sh</span><br><span class="line">jps</span><br></pre></td></tr></table></figure><p>如果多出来 <code>HMaster</code>、<code>HRegionServer</code> 和 <code>HQuorumPeer</code>，说明成功运行。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/hbase-jps%E6%88%90%E5%8A%9F.png" alt="hbase-jps"></p><p>我们访问 <code>localhost:16010</code></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/HBase-%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F.png" alt="HBase16010"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://moefactory.com/3112.moe" target="_blank" rel="noopener">伪分布式配置</a></p><p><a href="https://zhuanlan.zhihu.com/p/59805371" target="_blank" rel="noopener">hadoop3.2.0完全分布式集群搭建</a></p><p><a href="https://www.jianshu.com/p/99f3b52a5c54" target="_blank" rel="noopener">Hadoop安装教程_单机/伪分布式配置</a></p><p><a href="https://zhuanlan.zhihu.com/p/32561305" target="_blank" rel="noopener">Hadoop安装-超详细</a> <del>其实一点也不详细</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是记录大三上学期方向必修课 《数据管理技术》的上机实验。本学期共有四次实验。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hadoop环境搭建与配置 &lt;/li&gt;
&lt;li&gt;HBase数据库的部署与配置 &lt;/li&gt;
&lt;li&gt;Redis数据库的部署与配置&lt;/li&gt;
&lt;li&gt;Redis中数据类型使用及命令使用 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文将主要记载前两个实验&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术小记" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/"/>
    
      <category term="Technology_Stack" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/Technology-Stack/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/Technology-Stack/Hadoop/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="NoSQL" scheme="http://yoursite.com/tags/NoSQL/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之雪中光头峰</title>
    <link href="http://yoursite.com/2020/10/21/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E9%9B%AA%E4%B8%AD%E5%85%89%E5%A4%B4%E5%B3%B0/"/>
    <id>http://yoursite.com/2020/10/21/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E9%9B%AA%E4%B8%AD%E5%85%89%E5%A4%B4%E5%B3%B0/</id>
    <published>2020-10-21T15:31:18.000Z</published>
    <updated>2020-10-21T16:12:54.874Z</updated>
    
    <content type="html"><![CDATA[<p>2020年10月17日</p><p>公里数14.69KM,海拔2838M</p><a id="more"></a><p>国庆收假以来一直是阴雨连绵的天气,真是烦死人了. 衣服晒不干, 裤脚又容易沾的满是泥点子.好不容易熬来一个晴天, 又准备去光头山上, 看看雪后初霁.</p><p>注：下图是在光头山拍的别的山头，右边是鹿角梁</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E8%BF%9C%E6%99%AF.jpg" alt=""></p><h2 id="雪"><a href="#雪" class="headerlink" title="雪"></a>雪</h2><p>万万万万没想到失策了。雪倒是看到了，初霁也差不多，结果两者相遇，山上本来就薄薄的一层积雪全化成雪水，沿着山间的各个角落流下。倘若只是山泉泛滥，小溪充盈也罢，麻烦的是脚下的土路表面也湿哒哒地黏脚，泥泞之处也不在少数。</p><p>对了，其实也有不少地方，平日里只是涓涓细流，今天全成了一道道小瀑布。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E6%B3%89%E6%B0%B4.jpg" alt=""></p><h2 id="路"><a href="#路" class="headerlink" title="路"></a>路</h2><p>可分为三段：最初坡度尚可，道路隐约有些湿滑，由山脚葱郁到落叶青黄相间，铺在地上，虽然没有学校的银杏地毯好看，也是很养眼；中间一段来回穿过小竹林，非得弯腰低头才能穿过，稍有不小心竹枝便抽打在脸上，生疼。竹林也就算了，最讨厌的是带刺的灌木，扎进手指非流血不可；最后上了雪线，周遭只剩下低矮的草甸和零星的松树，遥望山顶的红房子真是遥不可及，雪落的很深，能没过脚面，难走。</p><p>大雪压青松，青松挺且直</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E6%9D%BE%E6%A0%91.jpg" alt=""></p><p>层林尽染</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E5%B1%B1%E6%99%AF.jpg" alt=""></p><h2 id="石"><a href="#石" class="headerlink" title="石"></a>石</h2><p>光头山虽然本身景色不佳，但山顶的几块石头是真出片。会当凌绝顶，一览众山小！</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E7%9F%B3%E5%A4%B43.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E7%9F%B3%E5%A4%B41.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E7%9F%B3%E5%A4%B42.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年10月17日&lt;/p&gt;
&lt;p&gt;公里数14.69KM,海拔2838M&lt;/p&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭##可选" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD-%E5%8F%AF%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成之流水线</title>
    <link href="http://yoursite.com/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <id>http://yoursite.com/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF/</id>
    <published>2020-10-09T07:46:46.000Z</published>
    <updated>2021-01-06T08:52:49.354Z</updated>
    
    <content type="html"><![CDATA[<ul><li>流水线概述<ul><li>定义与原理</li><li>时空图表示</li><li>分类</li></ul></li><li>流水线性能<ul><li>吞吐率</li><li>加速比</li><li>效率</li></ul></li><li>相关<ul><li>相关的定义</li><li>结构相关</li><li>数据相关</li><li>控制相关</li><li>中断</li><li>处理</li></ul></li><li>指令级并行</li><li>其他技术</li></ul><a id="more"></a><h2 id="流水线概述"><a href="#流水线概述" class="headerlink" title="流水线概述"></a>流水线概述</h2><h3 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h3><p>定义: 将一重复的处理过程分解为若干子过程，每个 子过程都可有效地在其专用功能段上与其它子 过程同时执行，这种技术称为流水线技术.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E6%B4%97%E8%A1%A3%E5%BA%971.png" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E6%B4%97%E8%A1%A3%E5%BA%972.png" alt=""></p><ul><li>在流水线中, 单个任务的时间并没有缩短，但多个任务是并行处理的.因此可以提高吞吐率； </li><li>流水线速度限制于最慢流水站的速度</li><li>理论上, 流水线技术的最大加速比=流水站数</li></ul><ul><li>流水过程由多个相关的子过程组成，这些子过程称为流水线的“级”或“段”。段的数目称为流水线 的“深度”。 </li><li>每个子过程由专用的功能段实现，各功能段的时间 应基本相等</li><li>流水线需要经过一定的通过时间才能稳定,因此适合于大量重复的时序过程</li></ul><h3 id="时空图"><a href="#时空图" class="headerlink" title="时空图"></a>时空图</h3><p>时空图是用于描述流水线技术的一种表示图. 从时间和空间两个方面描述流水线的工作过程，横坐 标表示时间，纵坐标表示各流水段。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E6%97%B6%E7%A9%BA%E5%9B%BE-%E6%A0%B7%E4%BE%8B.png" alt=""></p><h3 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h3><h4 id="单功能流水线-多功能流水线"><a href="#单功能流水线-多功能流水线" class="headerlink" title="单功能流水线/多功能流水线"></a>单功能流水线/多功能流水线</h4><ul><li><p>单功能流水线，是指只能完成一种固定功能的流水线。</p></li><li><p>多功能流水线，是指各段可以进行不同的连接，从而完成不同的功能</p></li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/TIASC.png" alt=""></p><p>例如 TI ASC多功能流水线 可以选择部分段来实现浮点相加或定点相乘功能</p><h3 id="静态流水线-动态流水线"><a href="#静态流水线-动态流水线" class="headerlink" title="静态流水线/动态流水线"></a>静态流水线/动态流水线</h3><ul><li><p>静态流水线，是指在同一时间内，流水线的各段 只能按同一种功能的连接方式工作。 </p></li><li><p>动态流水线，是指在同一时间内，当某些段正在实现某种运算时，另一些段却在实现另一种运算。 它会使得流水线控制变得复杂</p></li></ul><p>　在静态流水线中,同一时间内它只能以一种功能方式工作.它可以是单功能的,也可以是多功能的.当是多功能流水线时,则从一种功能方式变为另一种功能方式时,必须先排空流水线,然后为另一种功能设置初始条件后方可使用.显然,不希望这种功能的转换频繁的发生,否则将严重影响流水线的处理效率.</p><p>　　动态流水线则允许在同一时间内将不同的功能段连接成不同的功能子集(前提条件是功能部件的使用不发生冲突),以完成不同的运算功能.显然, <u>动态流水线必是多功能流水线,而单功能流水线则必是静态的</u>.</p><ul><li>动态流水线首先需要是多功能流水线.</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt=""></p><p>如图所示, 动态流水线可以在同一时间进行两种不同的功能. </p><h3 id="部件级-处理机级-处理机间级-流水线"><a href="#部件级-处理机级-处理机间级-流水线" class="headerlink" title="部件级/处理机级/处理机间级 流水线"></a>部件级/处理机级/处理机间级 流水线</h3><p>这类划分是根据流水线的级别的划分, 从上往下由精细到宏观</p><ul><li><p>部件级流水线，又叫运算操作流水线，是把处理机 的算术逻辑部件分段，使得各种数据类型的操作能 够进行流水。 </p><p>例如我们上面涉及到的关于浮点运算的流水想. 把单个运算再细分</p></li><li><p>处理机级流水线，又叫指令流水线，是把解释指令的过程按照流水方式处理。 </p><p>例如 把一条指令的运行分为 取指,取数,执行 三阶段</p></li><li><p>处理机间流水线，又叫宏流水线，是由两个以上的 处理机串行地对同一数据流进行处理，每个处理机 完成一项任务</p><p>例如, 处理器A负责图像的采集, 处理器B负责图像的压缩, 处理器C负责图像的储存. 这种流水线更偏向于宏观层面</p></li></ul><h3 id="线性流水线-非线性流水线"><a href="#线性流水线-非线性流水线" class="headerlink" title="线性流水线/非线性流水线"></a>线性流水线/非线性流水线</h3><ul><li>线性流水线是指流水线的各段串行连接，没有反馈回路</li><li>非线性流水线是指流水线中除有串行连接的通路外，还有反馈回路</li></ul><hr><h2 id="流水线的性能"><a href="#流水线的性能" class="headerlink" title="流水线的性能"></a>流水线的性能</h2><h3 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h3><p>吞吐率是指单位时间内流水线所完成的任务数或 输出结果的数量。</p><ul><li>最大吞吐率 TP max 是指流水线在达到稳定状态后 所得到的吞吐率。 </li><li>设流水线由 m 段组成，完成 n 个任务的吞吐率称为 实际吞吐率，记作TP</li></ul><h4 id="最大吞吐率"><a href="#最大吞吐率" class="headerlink" title="最大吞吐率"></a>最大吞吐率</h4><p>假设流水线各段的时间相同,均为 $\Delta t$, 则 $TP_{max} = 1/\Delta t_0$<br>假设流水线各段的时间不同,第 $i$ 段时间为 $\Delta t_i$, 则 $TP_{max} = 1/max\{\Delta t_i\}$ </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/TPmax.png" alt=""></p><p>图(a) 表示各段的时间相同的流水线, 图(b)表示各段时间不等的流水线.</p><ul><li>由此可见, 最大吞吐率率取决于流水线中最慢一段所需的时间，该段成为流水线的瓶颈</li><li>消除瓶颈的方法主要有:  细分瓶颈段 重复设置瓶颈段</li></ul><p>图为: 细分瓶颈段</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E7%BB%86%E5%88%86%E7%93%B6%E9%A2%88.png" alt=""></p><p>图为: 重复设置瓶颈段</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E9%87%8D%E5%A4%8D%E7%93%B6%E9%A2%88%E6%AE%B5.png" alt=""></p><h4 id="实际吞吐率"><a href="#实际吞吐率" class="headerlink" title="实际吞吐率"></a>实际吞吐率</h4><p>若各段时间相等（假设均为 $Δt_0$),则完成时间 </p><script type="math/tex; mode=display">T_{流水}=m\Delta t_0+(n-1)\Delta t_0</script><p>其中,前一项表示流水线完全启动的时间，后一项表示剩下的工作时间，因此:</p><script type="math/tex; mode=display">TP=\frac n {T_{流水}} = \frac n {m\Delta t_0+(n-1)\Delta t_0} = \frac 1 {(1 + \frac {m-1} n)\Delta t_0} = \frac {TP_{max}} {1 + \frac {m-1} n}</script><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/T%E6%B5%81%E6%B0%B4.png" alt=""></p><p>若各段时间不等（假设为 $Δt_i$ ),则完成时间：</p><script type="math/tex; mode=display">T=\sum^m _{i=1}\Delta t_i+(n-1)\times max\{\Delta t_i\}</script><p>其中,前一项表示流水线完全启动的时间.后一项表示剩下的工作时间,因此:</p><script type="math/tex; mode=display">TP=\frac n T = \frac n {\sum^m _{i=1}\Delta t_i+(n-1)\times max\{\Delta t_i\}}</script><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/TP2.png" alt=""></p><h3 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h3><p>加速比是指流水线速度与等功能的非流水线速度之比。 </p><script type="math/tex; mode=display">加速比 S = \frac {T_{非流水}} {T_{流水}}</script><p>若流水线为 m 段，总计 n 个任务，每段时间均为 $\Delta t_0$：</p><script type="math/tex; mode=display"> T_{非流水}=nm\Delta t_0,T_{流水}=m\Delta t_0+(n-1)\Delta t_0\\ S =\frac {T_{非流水}} {T_{流水}}=\frac {nm} {m+(n-1)}=\frac m {1+\frac {m-1} n}\\ 由此可见,n\gg m时,S\approx m</script><p>各段时间不相等的流水线带入上上个公式即可</p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>效率指流水线的<strong>设备利用率</strong>。 </p><p>画出时空图, 然后数格子</p><script type="math/tex; mode=display">E=\frac {n个任务占用的时空区} {m个段总的时空区}</script><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E6%95%88%E7%8E%87.png" alt=""></p><p>例如, 上图的效率为</p><script type="math/tex; mode=display">E = \frac {紫色格子数目} {总的格子数目} = \frac {n} {n+(m-1)}</script><p>当然, 应当比较的是面积, 这里由于每个格子面积相同故略去。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>流水线并不能减少（一般反而会增加）单条指令 的执行时间，但能够提高吞吐率 </li><li>增加流水线的深度可以提高流水线性能 </li><li>流水线深度受限于流水线的延迟和额外开销 </li><li>需要用高速锁存器作为流水线寄存器 </li><li>指令之间存在的相关，限制了流水线的性能</li></ul><h2 id="流水线中的相关"><a href="#流水线中的相关" class="headerlink" title="流水线中的相关"></a>流水线中的相关</h2><ul><li><p>流水线中的相关是指相邻或相近的两条指令因存在 某种关联，后一条指令不能在原先指定的时钟周期 开始执行。</p></li><li><p>消除相关的基本方法——暂停</p></li></ul><p>暂停流水线中某条指令及其后面所有指令的执行， 该指令之前的所有指令继续执行</p><p>  显然, 暂停会降低吞吐率</p><p>相关的类型 </p><ul><li>结构相关：当指令在重叠执行过程中，硬件资源 满足不了指令重叠执行的要求，发生资源冲突时 将产生“结构相关”。</li><li>数据相关：因一条指令需要用到前面指令的结果， 而无法与产生结果的指令重叠执行时，就发生了 “数据相关”。</li><li>控制相关：当流水线遇到分支指令和其它会改变 PC 值的指令时就发生“控制相关”。</li></ul><h3 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h3><p>当指令在重叠执行过程中，硬件资源 满足不了指令重叠执行的要求，发生资源冲突时 将产生“结构相关”。例如，当一条指令正在从存储器中取出时，另一条指令恰好在将一个数据存储到存储器中，因两者都要访问存储器，故出现冲突</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>假定，4级指令流水线包括：取指、取数、运算和存数，各段时间均为 $\Delta t$，执行下面的指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD MM,R1,R2</span><br><span class="line">SUB R3,R4,R5</span><br><span class="line">AND R7.R6.R10</span><br><span class="line">XOR R8,R9,R10</span><br></pre></td></tr></table></figure><p>在上图中的第四个时间点需要 <u>同时进行取指与存数操作</u>,而同一个存储区不能同时完成读操作和写操作.</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h4><p>结构竞争的原因是硬件不能满足重叠执行的要求。于是我们可以: 1) 用更多硬件 2) 不重叠执行 3) 使硬件可以重叠执行</p><ol><li><p>增加资源副本</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/11/%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3.png" alt=""></p><p>例如上例: 可以设计一个数据存储器和一个指令存储器，这样，流水线的取指段与数据访存段就可以通过两个独立的通路同时访问两个独立的存储器了。</p></li><li><p>暂停(或延迟)流水线</p><p>通过延迟（或暂停）流水线的冲突段, 这被称作在流水线中插入气泡</p><p>气泡在流水线中只占资源不做实际操作. 显然会降低吞吐率</p><p>但是相对其他两个方法硬件成本更低</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/11/%E6%B0%94%E6%B3%A1.png" alt=""></p></li><li><p>改变资源以便它们并发使用</p><p>除上述措施外，在相邻近的指令间尽可能不使用相同的资源。例如，在相邻的m（流水线的段数）条指令中，不相关的数据尽量使用不同的寄存器。如果发生使用寄存器冲突时，可以通过程序再设计或寄存器重命名技术来改变寄存器资源，达到可以同时对期望的寄存器访问的目的。</p></li></ol><h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><p>当指令在流水线中重叠执行时，流水线有可能改变指令读/写操作数的顺序，使之不同于它们在非流水实现时的顺序，这将导致数据相关。</p><h4 id="数据相关的分类"><a href="#数据相关的分类" class="headerlink" title="数据相关的分类"></a>数据相关的分类</h4><p>注: 分类是按照正常顺序</p><ol><li><p>写后读 RAW</p><p>如果先读后写, 那么读取的是错误的数据. 是最常见的数据相关.</p></li><li><p>写后写 WAW</p><p>如果后者先写,前者后写, 可能R中保存着错误的数据.</p></li><li><p>读后写 WAR</p><p>如果后者先写, 可能前者读出了错误数据. 但是这种相关很少发生</p></li><li><p>读后读 RAR</p><p>不会引起数据相关</p></li></ol><h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><ol><li><p>采用直通（forwarding）技术 </p><p>又名定向技术, 旁路, 短路</p><p>控制逻辑将前面指令的结果从其产生的地方直接连通到 当前指令所处的位置。</p></li><li><p>增加专用硬件</p><p>增加流水线互锁（pipeline interlock）硬件。互锁硬件先要 检测流水线中指令的数据相关性，当互锁硬件发现数据 相关时，使流水线工作停顿下来，直到相关消失为止。 </p></li><li><p>利用编译器 流水线调度/指令调度</p><p>编译器可以对指令重新排序或插 入空操作指令，使得加载任何冲突数据的操作被延迟， 但对程序逻辑或输出不受影响</p></li></ol><h3 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h3><p>当流水线遇到分支指令和其它会改变PC值的指令时 就发生“控制相关”</p><ul><li>无条件转移指令（如无条件跳转、调用、返回指令等）<ul><li>某些CPU（如 UltraSPARC l）：紧跟在无条件转移指令之后的指令必须执行。</li><li>另一些CPU：采取相对复杂的方法，如提前计算出转移目标地址</li></ul></li><li>条件分支转移指令（为零跳转、循环控制指令等）<ul><li>不仅需要延迟槽，而且一直到流水线的深处，取指单元才能知道到哪里去取下一条指令。</li><li>条件分支指令对流水线性能的影响远比无条件转移指令要大。</li></ul></li></ul><p>以下是针对条件分支指令的处理方法</p><h4 id="冻结流水线-freeze"><a href="#冻结流水线-freeze" class="headerlink" title="冻结流水线(freeze)"></a>冻结流水线(freeze)</h4><p>一旦在指令译码段检测到分支指令，就在转移目标地址确定之前保存或删除所有紧随分支指令之后的指令，当分支指令从执行段流出、确定出新的PC值时，流水线才继续依据新PC值填充流水线. <u>会严重地影响流水线的性能</u>。</p><h4 id="预取分支目标（-prefetch-branch-target）"><a href="#预取分支目标（-prefetch-branch-target）" class="headerlink" title="预取分支目标（ prefetch branch target）"></a>预取分支目标（ prefetch branch target）</h4><p>当条件分支指令被识别时，除了紧随其后的指令外，分支目标也被预取，并保存到分支指令被执行</p><p>如果分支跳转发生，已预取到的目标指令可立刻执行。</p><h4 id="多流"><a href="#多流" class="headerlink" title="多流"></a>多流</h4><p>有些系统采用在条件分支的两路上同时启动取指令操作，并将指令保存到分支指令被<br>实际执行的时候。分支指令执行时，“真”的执行通路即刻可以获得。这种方法是对预取分<br>支目标的发展。</p><h4 id="循环缓冲器"><a href="#循环缓冲器" class="headerlink" title="循环缓冲器"></a>循环缓冲器</h4><p>在许多处理器中，用循环缓冲器来解决分支程序引起的相关。循环缓冲器是一个容量很小、速度非常高的存储器。它保存着最近获取的n条顺序的指令，由流水线的取指段进行维护。如果分支发生，硬件首先检查分支目标是否在缓冲器中。如果在，下一条指令从缓冲器中获取。</p><ol><li>如果正常顺序运行, 那么就正常顺序运行</li><li>如果发生了分支. 那么在判断之后选择语句执行时, 要执行的语句已经录入缓冲器中, 可相比从内存中取指令更快. 此外, 这也表明<code>if..else..</code>语句性能优于<code>if..if..</code> 语句</li><li>特别是对于循环操作. 如果缓冲器够大, 那么只需要从内存中读取一次循环体的指令, 其余均从缓冲器中读出. 因此命名为循环缓冲器.</li></ol><p>循环缓冲器类似于指令 cache，差别是循环缓冲器仅保留顺序指令，且容量比 cache小得多，因此成本较低。</p><h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><p>为了降低分支指令引起断流（停顿）对流水线可能带来的影响，许多CPU提供了分支<br>预测机构。预测既可以在编译阶段静态完成，也可以由硬件在执行阶段动态完成。要做到<br>百分之百的正确预测几乎是不可能的，但采用分支预测必定能带来某些好处。</p><h4 id="静态分支预测"><a href="#静态分支预测" class="headerlink" title="静态分支预测"></a>静态分支预测</h4><p>静态分支预测是根据某种规则进行分支预测.</p><h5 id="预测分支不会发生"><a href="#预测分支不会发生" class="headerlink" title="预测分支不会发生"></a>预测分支不会发生</h5><p>预测分支不会发生也就是预测分支失败。如果一个程序中大多数条件分支指令是用于出错检测处理，那么采用这种预测机制是有利的，因为在正确合理的设计下，出现错误的概<br>率总是很小的。在这样的预测机制下，在知道分支结果之前，流水线流动着分支指令和紧随其后的指令。若分支预测失败，则正如所预期的那样，流水线照常执行；若分支成功，则要用空操作代替已取得的指令（例如清除执行段之前的各流水线段），并到目标地址重新取指令。</p><h5 id="预测分支总是成功"><a href="#预测分支总是成功" class="headerlink" title="预测分支总是成功"></a>预测分支总是成功</h5><p>如果一个程序中包含较多的循环，那么采用这种预测机制是有利的，因为n次循环仅有<br>次会出现分支转移失败。因此，该方法也称为预测分支成功法。在这样的预测机制下，<br>旦分支转移成功就可以开始从分支目标地址处取指令执行。</p><h5 id="由编译器进行预测"><a href="#由编译器进行预测" class="headerlink" title="由编译器进行预测"></a>由编译器进行预测</h5><p>当编译器看到循环语句<code>for（i=0；&lt;1000000计++）{…}</code>时，它就知道循环尾部的转移<br>几乎肯定会发生。如果能有办法让编译器把这一信息告诉硬件，将会节省大量的时间。但<br>是，使用这种技术会带来体系结构的变化，某些处理器中设计了一组新的条件转移指令，这些指令中有一位可以让编译器设置. 取值单元将根据这指令行动.</p><h5 id="剖面法"><a href="#剖面法" class="headerlink" title="剖面法"></a>剖面法</h5><p>剖面法是一种追踪程序执行状况加以预测的方法。它实际运行了该程序（一般是在模拟器上），以获得程序中不同分支指令发生转移的信息（比如概率），然后将这些信息送给编译器，编译器再使用特殊的条件转移指令来通知硬件该如何操作。</p><p>当静态分支预测错误时, 如何取消已经执行的指令?</p><ul><li>总是执行，结果保存在临时寄存器中。当得知预测成功时再复制至实际寄存器</li><li>将要被覆盖的寄存器的原值保存在临时寄存器中, 当得知预测失败时恢复</li></ul><h3 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h3><p>动态分支预测通过记录分支指令的近期运行的历史信息，并以此作为预测的依据，来提高分支预测的准确度。解决好动态预测的关键是如何记录历史信息和如何决定转移的走向</p><h3 id="延迟分支"><a href="#延迟分支" class="headerlink" title="延迟分支"></a>延迟分支</h3><ul><li><p>这种方法是利用编译器对指令代码进行重新排序，并插入有用指令或空操作指令<br>（NOP），使流水线尽可能保持充满状态。</p></li><li><p>其中心思想就是延迟分支的发生。</p></li><li><p>把分支指令延迟为长度为n的分支指令，其后紧跟有n个延迟槽，延迟槽中放有延迟分支需要执行的指令。流水线遇到分支指令时，按正常方式处理，同时执行延迟槽中的指令，分支延迟槽中的指令“掩盖”了流水线原来必须插入的停顿周期，从而减少分支开销。</p></li><li><p>编译器的任务就是在延迟槽中放入有用的指令，称为延迟槽调度。有三种常用的调度方法：</p><ul><li>从分支前调度</li><li>从目标出调度</li><li>从失败处调度</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/11/%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3.png" alt=""></p></li></ul><p>该方法有两个限制: </p><p>（1）放入延迟槽的指令需要满足一定的条件。<br>（2）编译器要有预测分支是否成功的能力。</p><p>剩下的先咕咕咕</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;流水线概述&lt;ul&gt;
&lt;li&gt;定义与原理&lt;/li&gt;
&lt;li&gt;时空图表示&lt;/li&gt;
&lt;li&gt;分类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流水线性能&lt;ul&gt;
&lt;li&gt;吞吐率&lt;/li&gt;
&lt;li&gt;加速比&lt;/li&gt;
&lt;li&gt;效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相关&lt;ul&gt;
&lt;li&gt;相关的定义&lt;/li&gt;
&lt;li&gt;结构相关&lt;/li&gt;
&lt;li&gt;数据相关&lt;/li&gt;
&lt;li&gt;控制相关&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;li&gt;处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令级并行&lt;/li&gt;
&lt;li&gt;其他技术&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="计算机组成" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机组成" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Java拾遗之基本类库</title>
    <link href="http://yoursite.com/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%BA%93/"/>
    <id>http://yoursite.com/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%BA%93/</id>
    <published>2020-10-08T08:14:15.000Z</published>
    <updated>2020-10-08T08:14:52.196Z</updated>
    
    <content type="html"><![CDATA[<p>第七章 Java基础类库<br>本节应当配备Java Document使用.<br>在线网址: <a href="https://docs.oracle.com/en/java/javase/index.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/index.html</a><br>下载地址: <a href="https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline" target="_blank" rel="noopener">https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline</a></p><ul><li>系统类System</li><li>字符串: String, StringBuffer, StringBuilder</li><li>Math类</li><li>Data与Calendar</li><li>正则表达式</li><li>日志</li></ul><a id="more"></a><h2 id="7-1-与用户交互"><a href="#7-1-与用户交互" class="headerlink" title="7.1 与用户交互"></a>7.1 与用户交互</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><ul><li>main函数的方法签名: <code>public static void main(String[] args){...}</code></li><li>main函数需要暴露给JVM调用,因此使用public修饰;</li><li>main函数在调用时直接通过主类静态调用,因此使用static修饰;</li><li>main函数没有返回值</li><li>main函数的参数可以在运行时指定.例如 <code>java ArgsTest hello world</code> 这里args数组为{“hello”,”world”}</li></ul><h3 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h3><ul><li>Scanner是一种基于正则表达式的文本扫描器. </li><li>hasNextXXX();</li><li>nextXXX();</li></ul><h2 id="7-2-系统交互"><a href="#7-2-系统交互" class="headerlink" title="7.2 系统交互"></a>7.2 系统交互</h2><ul><li>通过C语言实现Java的native方法: <a href="https://blog.csdn.net/hjh_walker/article/details/52439149" target="_blank" rel="noopener">https://blog.csdn.net/hjh_walker/article/details/52439149</a></li><li>可以通过System类访问操作系统的信息</li><li>可以通过Runtime类访问运行环境(JVM)的相关信息.</li><li>还可以通过Runtime类的静态方法exec()新建进程运行操作系统的命令.</li></ul><h2 id="7-3-常用类"><a href="#7-3-常用类" class="headerlink" title="7.3 常用类"></a>7.3 常用类</h2><ul><li>Object类是所有类,数组,枚举类的父类.Object提供了一些静态方法.(所有类都可以使用)</li><li>equals(Object obj); 判断对象是否相等. 这里判断是否是同一个对象(也就是针对地址的判断)</li><li>protected void finalize(); 垃圾回收器调用该方法来回收对象</li><li>getClass(); 返回对象的运行时类</li><li>int hashCode();默认情况下是根据对象的地址计算.但大多数类都重写了该方法.</li><li>toString();默认情况下返回 “类名+@+hashCode” 的值,往往需要对其重写.</li><li>protected clone();会返回一个当前对象的副本.这个方法只能被子类重写或调用.这种克隆更快,但是是浅克隆.</li><li><p>浅克隆:引用类型变量只复制地址; 深克隆:引用类型变量指向的对象也会被复制 参考:<a href="https://segmentfault.com/a/1190000022552883" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022552883</a></p></li><li><p>Java7 新增了一系列工具类.它们大多是空指针安全的.</p></li><li>这些工具类大多以”s”结尾.例如 <code>Objects</code>,<code>Arrays</code></li></ul><h2 id="7-4-字符串操作"><a href="#7-4-字符串操作" class="headerlink" title="7.4 字符串操作"></a>7.4 字符串操作</h2><ul><li>Java中的String是不可变的,直到对象被销毁.</li><li>StringBuffer 是一个字符序列可变的字符串.在操作完该字符序列后使用toSting()将其转换为String对象</li><li>StringBuilder 也代表可变字符串对象. 但Buffer是线程安全的,而Builder是非安全的. 因此Builder的性能更高.</li><li>charAt(); 用于读取字符串的下标.string 的其他方法不列出</li><li>StringBuilder 的常用方法: append(),insert(),delete(),reverse(),length(),capacity()</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第七章 Java基础类库&lt;br&gt;本节应当配备Java Document使用.&lt;br&gt;在线网址: &lt;a href=&quot;https://docs.oracle.com/en/java/javase/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.oracle.com/en/java/javase/index.html&lt;/a&gt;&lt;br&gt;下载地址: &lt;a href=&quot;https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统类System&lt;/li&gt;
&lt;li&gt;字符串: String, StringBuffer, StringBuilder&lt;/li&gt;
&lt;li&gt;Math类&lt;/li&gt;
&lt;li&gt;Data与Calendar&lt;/li&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;li&gt;日志&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/"/>
    
      <category term="Java拾遗" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/Java%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java拾遗之面向对象</title>
    <link href="http://yoursite.com/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-10-08T06:51:34.516Z</published>
    <updated>2020-11-05T12:40:02.338Z</updated>
    
    <content type="html"><![CDATA[<p>又开的新坑~ 目标是把平日里关于Java的学习到的碎片化知识先记录下来, 待日后回顾.</p><p>希望以后会回顾(逃)</p><p>目前在学习的是李刚老师的 <a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂JAVA讲义 (第四版)</a> </p><a id="more"></a><h2 id="第六章：面向对象（下）"><a href="#第六章：面向对象（下）" class="headerlink" title="第六章：面向对象（下）"></a>第六章：面向对象（下）</h2><ul><li>包装类：将基本类型封装成对象使用</li><li>final关键词</li><li>abstract：抽象类</li><li>interface：接口</li></ul><h3 id="6-1-包装类"><a href="#6-1-包装类" class="headerlink" title="6.1 包装类"></a>6.1 包装类</h3><ul><li>自动装箱/拆箱：基本类型与包装类型的直接转换</li><li>包装类的两类静态方法，用于操作string与类型的装换</li></ul><blockquote><p>parseXXX(string str);    将string类型转为XXX类型.例如<code>int a = parseInt(&quot;123&quot;);</code><br>valueOf(string str); 作用同上</p></blockquote><ul><li>String 包装类中也有将其他类型的转为string类的valueOf函数.例如<code>string a = String.valueOf(123.4);</code></li><li>或者可以直接 <code>string a = 123.4 + &quot;&quot; ;</code></li></ul><hr><ul><li>包装类是引用类型,但是直接与基本类型比较时会自动比较其值;但是两个包装类比较时依旧比较引用的对象是否是一个</li><li>不应当对两个装箱后的包装类比较.Integer包装类在初始化时会初始化-128~127的数组.所有被包装的,值在这个范围内的Integer对象指向的是堆中的同一个.但是不在这个范围内的对象指向的不是用一个对象.因此:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D; 2;</span><br><span class="line">Integer b &#x3D; 2;</span><br><span class="line">&#x2F;*这里a&#x3D;&#x3D;b,因为作为引用类型的变量,他们指向堆中的同一个地址(即Integer类被初始化时创建的那个数组)*&#x2F;</span><br><span class="line">Integer A &#x3D; 128;</span><br><span class="line">Integer B &#x3D; 128;</span><br><span class="line">&#x2F;*这里A!&#x3D;B,因为这是新创建的两个不同指向的引用类型的变量,尽管他们指向的地址所储存的值是一样的*&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>这么设置的原因是为了提前针对小值的Integer包装类对象进行缓存,提高性能</p></li><li><p>Java7 对所有的包装类提供了专门用于比较的静态方法compare.例如:<code>Integer.compare()</code>    //TODO:存疑:这个方法是用来比较基本类还是包装类的?还是说可以混合比较?</p></li><li>Java7对Character,Java8对包装类功能增强.</li></ul><hr><h3 id="6-2处理Object"><a href="#6-2处理Object" class="headerlink" title="6.2处理Object"></a>6.2处理Object</h3><ul><li><p>所有类都是Object类的子类</p></li><li><p>Object类中有toString()方法.他会在对象被打印时自动调用.用于自我描述,例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object p;</span><br><span class="line">&#x2F;*以下3行是等价的*&#x2F;</span><br><span class="line">System.out.println(p);</span><br><span class="line">System.out.println(p.toString());</span><br><span class="line">System.out.println(p + &quot;&quot;);</span><br></pre></td></tr></table></figure></li><li><p>基础的toString() 会返回 “类名+@+hashCode” 的值,可以并往往需要对其重写.通常会返回成类似”Apple[color=red,weight=5.6]”的字符串</p></li></ul><hr><ul><li><p>对于基本类型可以使用==进行相等判断,但是引用类型变量必须要指向相同地址时才会返回true.因此Object类提供了静态方法Object.equal(Object obj)</p></li><li><p>默认的equal方法依旧只比较该变量的地址(也就是和==一个效果),因此我们往往也会重写equal方法.该方法需要满足:自反性,对称性,传递性,一致性</p></li><li><p>JVM常量池保证相同的字符串直接量只有一个.</p></li></ul><h3 id="6-3-类成员与static"><a href="#6-3-类成员与static" class="headerlink" title="6.3 类成员与static"></a>6.3 类成员与static</h3><ul><li><p>类成员属于整个类,而非某个对象.被static修饰的就是类成员.</p></li><li><p>当类第一次被使用时,类成员(包括类变量与类方法)被加载,直到类不被使用而被垃圾回收.</p></li><li><p>可以通过类或类的实例对象来访问类成员,但这不代表类成员属于该实例对象.</p></li><li><p>静态初始化块也是类成员的一种, 一般是在类被初始化时执行该块.</p></li><li><p>类成员不能访问实例成员</p></li></ul><hr><ul><li>如果某种类仅允许拥有一个实例,它被称为单例(Singleton)</li><li>该类的构造器被修饰为private</li><li>该类需要提供一个静态方法来产生第一个实例(并且,如果以前产生过实例则返回先前产生的实例)</li><li>需要一个private static 的类变量储存曾经创建的实例(如果有)</li></ul><hr><h3 id="6-4-final"><a href="#6-4-final" class="headerlink" title="6.4 final"></a>6.4 final</h3><ul><li>被final修饰的变量不可被重新赋值.</li><li>final可以修饰成员变量(包括类变量与实例变量),也可以修饰局部变量.这两者有些许不同.</li></ul><h4 id="final修饰成员变量"><a href="#final修饰成员变量" class="headerlink" title="final修饰成员变量"></a>final修饰成员变量</h4><ul><li><p>final修饰类变量: 必需在静态初始化块,或声明类变量时指定初始值.且只能在二处之一指定初始值.</p></li><li><p>final修饰实例变量: 必需在非静态初始化块,或声明实例变量时, 或构造器中指定初始值.且只能在三处之一指定初始值.</p></li></ul><h4 id="final修饰局部变量"><a href="#final修饰局部变量" class="headerlink" title="final修饰局部变量"></a>final修饰局部变量</h4><ul><li><p>final修饰的局部变量可以在声明时不指定初始值.如果没有指定,则可以在后续代码中进行赋值,但只能赋值一次.</p></li><li><p>形参可以被final修饰,那么在函数体中该参数不能被赋值.</p></li><li><p>引用变量可以被final修饰,但是锁定的是该引用类型变量所指向的地址.引用的对象的成员变量的值依旧可以被改变.</p></li><li><p>一个在定义时就指定了初始值的final变量如果在编译时就可以确定初始值,那么它将起到类似宏替换的效果.</p></li></ul><h4 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h4><ul><li>被final修饰的方法无法被子类重写.例如Object类中的 getClass() 方法.</li><li>比较: 被private修饰的方法无法被子类访问; 另外注意区分重写与重载的区别.</li><li>被final和private同时修饰的方法可以在子类中被 “重写”. 但实质上是子类的新方法.并非真正意义上的重写.</li></ul><h4 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h4><ul><li>被final修饰的类无法有子类. 例如java.lang.Math类. </li><li>当子类继承父类时可以访问父类的内部数据,甚至可以重写父类方法.因此需要对该父类限制继承.</li></ul><h4 id="不可变类-immutable"><a href="#不可变类-immutable" class="headerlink" title="不可变类(immutable)"></a>不可变类(immutable)</h4><ul><li>创建出的该类的实例的实例变量是不可改变的.例如8个包装类以及java.lang.String类</li><li><p>TODO:自建不可变类的注意事项</p></li><li><p>由于被final修饰的引用变量依旧是可以改变的.因此直接包括引用变量的不可变类并不是真正的不可变. 可以在涉及到相关操作时创建新的匿名类来规避.</p></li></ul><h3 id="6-5-抽象类与abstract"><a href="#6-5-抽象类与abstract" class="headerlink" title="6.5 抽象类与abstract"></a>6.5 抽象类与abstract</h3><ul><li><p>抽象类必须使用abstract修饰.抽象方法也必须使用abstract修饰,并且不能有方法体.</p></li><li><p>抽象类中未必包括抽象方法.但包括抽象方法的类必须是抽象类.</p></li><li><p>抽象类不能有实体.不能被实例化.可以有构造器但不能被直接构造.(构造器用于被子类重写).</p></li><li><p>其子类需要实现父类的所有抽象类.否则,子类也是一个抽象类.</p></li><li><p>被abstract修饰的类只能被继承,而被final修饰的类不能被继承.因此这两个修饰符不能同时使用.</p></li><li><p>被abstract修饰的方法只能子类实现,而被static修饰的方法只能被该类调用.因此这两个修饰符不能同时修饰方法.但是可以同时修饰部类.</p></li></ul><p>TODO:接口</p><h3 id="6-9-枚举"><a href="#6-9-枚举" class="headerlink" title="6.9 枚举"></a>6.9 枚举</h3><ul><li><p>枚举是一种特殊的类.使用enum进行修饰.(该关键词与class,interface等价).一个java源文件只能有一个被public修饰的enum类.</p></li><li><p>枚举类默认继承java.lang.Enum类(而非Object类).因此枚举类不能显式继承其他父类.Enum提供了一些接口.</p></li><li><p>非抽象的enum类默认使用final修饰,因此不能派生子类.</p></li><li><p>枚举类的构造器只能使用private修饰.</p></li><li><p>枚举类的所有实例必须在第一行显式列出.</p></li><li><p>Enum 类中提供的一些接口:</p><ol><li>int compareTo(E o):用于与相同枚举类型的对象进行比较排序.若该对象位于o之后返回正整数,反之返回负整数或0.</li><li>String name() 与 String toString():都可以返回当前实例的名称.习惯上使用后者.</li><li>int ordinal(): 返回当前枚举实例的索引值(从0开始)</li></ol></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态的三个条件:</p><ol><li><p>要有继承</p></li><li><p>子类要有重写父类的方法</p></li><li>父类引用指向子类对象</li></ol><p>一句话概括: new谁就调用谁的方法，引用是谁，就用谁的成员和静态。</p><p>另一句话概况: 除了重写过的非静态方法之外，都是用的父类的。</p><p>实际的过程: 语句在<strong>堆内存</strong>中开辟了<u>子类的对象</u>，并把<strong>栈内存</strong>中的父类的引用指向了这个子类对象</p><p>详细一点的解释: </p><ol><li>对于(非静态的)成员变量, 依旧是使用的父类的成员变量</li><li>对于(非静态的)成员方法,会时候子类的成员方法</li><li>对于静态的成员变量/方法, 会使用父类的. 这是由于静态的是属于类, 算不上重写 . 那么自然是使用的</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又开的新坑~ 目标是把平日里关于Java的学习到的碎片化知识先记录下来, 待日后回顾.&lt;/p&gt;
&lt;p&gt;希望以后会回顾(逃)&lt;/p&gt;
&lt;p&gt;目前在学习的是李刚老师的 &lt;a href=&quot;https://book.douban.com/subject/3246499/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;疯狂JAVA讲义 (第四版)&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/"/>
    
      <category term="Java拾遗" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/Java%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题流水账2020-09</title>
    <link href="http://yoursite.com/2020/10/02/LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-09/"/>
    <id>http://yoursite.com/2020/10/02/LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-09/</id>
    <published>2020-10-02T13:21:59.000Z</published>
    <updated>2020-10-09T05:25:40.050Z</updated>
    
    <content type="html"><![CDATA[<p>刷完了初级题库, 对各分类的简单算法有了基础的认知</p><p>整理了一些STL的常用函数(不全面) </p><p>开始由C++专向Java</p><a id="more"></a><p>2020年8月22日 “再度”开始刷力扣</p><p>既然决定不读研就好好刷题学工程吧</p><p>每周七题以上. 如果遇到考试周等特别情况可以提前一周完成任务, 不得向后拖延.</p><h2 id="2020年9月1日-week1"><a href="#2020年9月1日-week1" class="headerlink" title="2020年9月1日-week1"></a>2020年9月1日-week1</h2><p>主题:链表+字符串</p><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="[141] 环形链表"></a>[141] 环形链表</h3><p>简单题</p><p>检测给出的链表中有没有环</p><p>第一下自己没有想出来, 看了题解. </p><p>方法1: 哈希表储存节点的出现次数———-只要定义的是<code>map&lt;listNode*, int&gt;</code> 就可以了.</p><p>方法2: 很巧妙, 快慢节点, 快每次走2步, 慢每次走1步. 如果有环快慢指针会相遇, 没有环则快指针会走到尽头.</p><p>注意: 方法2最后的判断应该是: <code>fNode != nullptr &amp;&amp; fNode-&gt;next != nullptr</code> 因为<code>fnode</code>每次走两步!</p><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="[344] 反转字符串"></a>[344] 反转字符串</h3><p>简单题</p><p>双指针, 左右端交换, 向中间靠拢</p><p>记得要 <code>i++, j--</code> ! 第二次忘了!</p><p>小技巧: 3次异或交换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s[left] ^&#x3D; s[right]</span><br><span class="line">s[right] ^&#x3D; s[left]</span><br><span class="line">s[left] ^&#x3D; s[right]</span><br></pre></td></tr></table></figure><p>即可实现两个元素交换,且不用花费额外空间,还快</p><p>此外还可以使用算法库中的 <a href="https://zh.cppreference.com/w/cpp/algorithm/reverse" target="_blank" rel="noopener">reverse(begin, end)</a></p><h2 id="2020年9月2日-week2"><a href="#2020年9月2日-week2" class="headerlink" title="2020年9月2日-week2"></a>2020年9月2日-week2</h2><p>主题: 字符串</p><h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="[7] 整数反转"></a>[7] 整数反转</h3><p>简单题(大概)</p><p>单看数据反转这个要求其实不难, x每次退栈个位数, re此时入栈. 问题在于涉及到溢出的判断.</p><p>这里考察了一下下对于数据储存的理解是否深刻. 见<a href="https://leetcode-cn.com/problems/reverse-integer/solution/hua-jie-suan-fa-7-zheng-shu-fan-zhuan-by-guanpengc/" target="_blank" rel="noopener">题解</a></p><p>此外, 在<code>limit.h</code>中储存的INT_MAX等数据</p><h2 id="2020年9月3日-week2"><a href="#2020年9月3日-week2" class="headerlink" title="2020年9月3日-week2"></a>2020年9月3日-week2</h2><p>主题:字符串</p><h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="[387] 字符串中的第一个唯一字符"></a>[387] 字符串中的第一个唯一字符</h3><p>简单题</p><p>解法一,hash+两次遍历,很容易想到</p><p>解法二,不借助hash 该字符第一次出现的位置和最后一次出现的位置一样，就证明不重复。</p><p>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">s.find_first_of(ch);<span class="comment">//返回索引,找不到返回-1</span></span><br><span class="line">s.find_last_of(ch);<span class="comment">//同上</span></span><br></pre></td></tr></table></figure><p>小优化: 无论字符串多长都只需要26次循环(常数级优化):</p><ol><li><p>若字符串长度&lt;26 同上</p></li><li><p>若&gt;26, 将26个字母遍历, 找到第一个出现一次的. </p></li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">    <span class="keyword">char</span> c = s[i];</span><br><span class="line">    <span class="keyword">int</span> pre = s.find_first_of(c);</span><br><span class="line">    <span class="keyword">if</span>(pre!=<span class="number">-1</span> &amp;&amp; pre==s.find_last_of(c))</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2020年9月4日-week2"><a href="#2020年9月4日-week2" class="headerlink" title="2020年9月4日-week2"></a>2020年9月4日-week2</h2><p>主题: 字符串</p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="[242] 有效的字母异位词"></a>[242] 有效的字母异位词</h3><p>Hash(数组也行) 几次遍历</p><p>为了检查 t 是否是 s 的重新排列，我们可以计算两个字符串中每个字母的出现次数并进行比较。因为 S 和 T 都只包含 A−Z 的字母，所以一个简单的 26 位计数器表就足够了</p><p>我们需要两个计数器数表进行比较吗？实际上不是，因为我们可以用一个计数器表计算 s 字母的频率，用 t 减少计数器表中的每个字母的计数器，然后检查计数器是否回到零。</p><h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="[125] 验证回文串"></a>[125] 验证回文串</h3><p>简单题 </p><p>回文是很熟悉的题型了, 双指针，栈，reverse都行. 这一题着重于String的一些API调用</p><p>以下这些函数定义在<code>&lt;string&gt;</code> 里</p><div class="table-container"><table><thead><tr><th>数值转换</th><th></th></tr></thead><tbody><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/basic_string/stol" target="_blank" rel="noopener">stoi  stol  stoll</a>(C++11)(C++11)(C++11)</td><td>转换字符串为有符号整数 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/basic_string/stoul" target="_blank" rel="noopener">stoul  stoull</a>(C++11)(C++11)</td><td>转换字符串为无符号整数 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/basic_string/stof" target="_blank" rel="noopener">stof  stod  stold</a>(C++11)(C++11)(C++11)</td><td>转换字符串为浮点值 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/basic_string/to_string" target="_blank" rel="noopener">to_string</a>(C++11)</td><td>转换整数或浮点值为 <code>string</code> (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/basic_string/to_wstring" target="_blank" rel="noopener">to_wstring</a>(C++11)</td><td>转换整数或浮点值为 <code>wstring</code> (函数)</td></tr><tr><td>范围访问</td><td></td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/iterator/begin" target="_blank" rel="noopener">begin  cbegin</a>(C++11)(C++14)</td><td>返回指向容器或数组起始的迭代器 (函数模板)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/iterator/end" target="_blank" rel="noopener">end  cend</a>(C++11)(C++14)</td><td>返回指向容器或数组结尾的迭代器 (函数模板)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/iterator/rbegin" target="_blank" rel="noopener">rbegin  crbegin</a>(C++14)</td><td>返回指向一个容器或数组的逆向迭代器 (函数模板)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/iterator/rend" target="_blank" rel="noopener">rend  crend</a>(C++14)</td><td>返回容器或数组的逆向尾迭代器 (函数模板)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/iterator/size" target="_blank" rel="noopener">size  ssize</a>(C++17)(C++20)</td><td>返回容器或数组的大小 (函数模板)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/iterator/empty" target="_blank" rel="noopener">empty</a>(C++17)</td><td>检查容器是否为空 (函数模板)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/iterator/data" target="_blank" rel="noopener">data</a>(C++17)</td><td>获得指向底层数组的指针 (函数模板)</td></tr></tbody></table></div><p>以下这些函数定义在<code>&lt;cctype.h&gt;</code> 里</p><div class="table-container"><table><thead><tr><th>函数</th><th>参数返回值皆为int</th></tr></thead><tbody><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/isalnum" target="_blank" rel="noopener">isalnum</a></td><td>检查字符是否为字母或数字 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/isalpha" target="_blank" rel="noopener">isalpha</a></td><td>检查字符是否为字母 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/isdigit" target="_blank" rel="noopener">isdigit</a></td><td>检查字符是否为数字 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/isupper" target="_blank" rel="noopener">isupper</a></td><td>检查字符是否为大写字符 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/islower" target="_blank" rel="noopener">islower</a></td><td>检查字符是否为小写 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/isxdigit" target="_blank" rel="noopener">isxdigit</a></td><td>检查字符是为十六进制字符 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/iscntrl" target="_blank" rel="noopener">iscntrl</a></td><td>检查字符是否为控制字符 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/isgraph" target="_blank" rel="noopener">isgraph</a></td><td>检查字符是否为图形字符 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/isspace" target="_blank" rel="noopener">isspace</a></td><td>检查字符是否为空白间隔字符 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/isblank" target="_blank" rel="noopener">isblank</a>(C++11)</td><td>检查字符是否为空白字符 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/isprint" target="_blank" rel="noopener">isprint</a></td><td>检查字符是否为打印字符 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/ispunct" target="_blank" rel="noopener">ispunct</a></td><td>检查字符是否为标点符 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/tolower" target="_blank" rel="noopener">tolower</a></td><td>转换字符为小写 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/toupper" target="_blank" rel="noopener">toupper</a></td><td>转换字符为大写 (函数)</td></tr></tbody></table></div><p>此外还有一个将字母转化大小写的小技巧</p><blockquote><p>字母大小写转换的方法：</p><ol><li>统一转成大写：ch &amp; 0b11011111 简写：ch &amp; 0xDF</li><li>统一转成小写：ch | 0b00100000 简写：ch | 0x20</li></ol><p>比较的时候注意加上小括号哦，因为位运算优先级比较低。</p></blockquote><p>但是必须先保证转化的本身就是字母字符  <a href="https://blog.csdn.net/weixin_44190113/article/details/106106495" target="_blank" rel="noopener">原理参考这里,很简单</a></p><h2 id="2020年9月5日"><a href="#2020年9月5日" class="headerlink" title="2020年9月5日"></a>2020年9月5日</h2><p>主题: 字符串</p><h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="[38] 外观数列"></a>[38] 外观数列</h3><p>很有意思的题目, 虽然是简单题但是dp问题还是折腾了快一个小时.</p><blockquote><p>给定一个正整数 <em>n</em>（1 ≤ <em>n</em> ≤ 30），输出外观数列的第 <em>n</em> 项。</p><p>注意：整数序列中的每一项将表示为一个字符串。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure><p>第一项是数字 1</p><p>描述前一项，这个数是 <code>1</code> 即 “一个 1 ”，记作 <code>11</code>L</p><p>描述前一项，这个数是 <code>11</code> 即 “两个 1 ” ，记作 <code>21</code></p><p>描述前一项，这个数是 <code>21</code> 即 “一个 2 一个 1 ” ，记作 <code>1211</code></p><p>描述前一项，这个数是 <code>1211</code> 即 “一个 1 一个 2 两个 1 ” ，记作 <code>111221</code></p></blockquote><p>先获取第<code>n-1</code>项, 然后对其进行分析.</p><p>具体的分析代码就不贴了, 补充一下Vector转String的操作:</p><p><a href="https://zh.cppreference.com/w/cpp/string/basic_string/assign" target="_blank" rel="noopener">str.assign()</a></p><blockquote><p>template&lt; class InputIt &gt;<br>basic_string&amp; assign( InputIt first, InputIt last );</p><p>template&lt; class InputIt &gt;<br>constexpr basic_string&amp; assign( InputIt first, InputIt last );</p></blockquote><p>例如 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v;</span><br><span class="line"><span class="built_in">string</span> re;</span><br><span class="line">re.assign(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="2020年9月13日"><a href="#2020年9月13日" class="headerlink" title="2020年9月13日"></a>2020年9月13日</h2><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="[104]二叉树的最大深度"></a>[104]二叉树的最大深度</h3><p><strong>核心知识点: 递归:</strong></p><ol><li>确定递归函数的参数与返回值: 传入树节点,返回该节点为根的树的深度)</li><li>确定终止: 触底(该节点空), 返回0</li><li>确定单层递归的逻辑: 求左子树深度和右子树深度, 取最大+1返回</li></ol><h2 id="2020年9月16日"><a href="#2020年9月16日" class="headerlink" title="2020年9月16日"></a>2020年9月16日</h2><h3 id="14-最大公共前缀"><a href="#14-最大公共前缀" class="headerlink" title="[14]最大公共前缀"></a>[14]最大公共前缀</h3><p>好像没什么好讲的.. 没有做完全部解法, 回头重做</p><p>TODO</p><h3 id="28-实现strStr-⭐"><a href="#28-实现strStr-⭐" class="headerlink" title="[28]实现strStr()⭐"></a>[28]实现strStr()⭐</h3><p>返回第一个字串, 这题比较有挑战, 很多可以优化的细节</p><p>第一版: 遍历父串每一个字符, 若从此起的后面一段串与子串相同则返回, 否则后移继续</p><p>第二版: 遍历父串每一个字符, 若该字符与子串首字不同则直接继续, 否则再比较</p><p>TODO: KMP</p><p>另外: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1;</span><br><span class="line">str1.substr(1,3);&#x2F;&#x2F;第二个参数是长度而不是结尾索引,返回的是1-4个字符的串</span><br></pre></td></tr></table></figure><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="[98]验证二叉搜索树"></a>[98]验证二叉搜索树</h3><p>递归, 有坑! </p><p>详见<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/bao-zhun-sheng-guo-guan-fang-ti-jie-by-novice2mast/" target="_blank" rel="noopener">这里</a></p><h2 id="2020年9月18日"><a href="#2020年9月18日" class="headerlink" title="2020年9月18日"></a>2020年9月18日</h2><p>主题: 树</p><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="[101] 对称二叉树"></a>[101] 对称二叉树</h3><p>检测一棵树是否是镜面对称的.</p><p><strong>核心知识点: 树的周游(遍历),</strong> 分成两种: BFS与DFS</p><p>深度遍历DFS: 使用栈, 递归实现</p><p>广度遍历BFS: 使用队列. queue实现</p><p>注意: STL中的queue的pop()函数只能等同于删除第一个元素, 不能返回第一个元素. </p><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="[102] 二叉树的层序遍历"></a>[102] 二叉树的层序遍历</h3><p>例如: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">需要返回的是:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>直接使用BFS是相当于中序遍历, 但是返回的会是<code>[3,9,20,15,7]</code>, 也就是说没有实现分层的要求. 如何能识别每层之间的界限? 引入哑节点dummy, 在识别到一个哑节点时表示本层出队列完毕, 也相当于下一层入队列完毕, (如果当前队列还有数字就)在最后插入新的哑节点. </p><h2 id="2020年9月19日"><a href="#2020年9月19日" class="headerlink" title="2020年9月19日"></a>2020年9月19日</h2><h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="[108] 将有序数组转换为二叉搜索树"></a>[108] 将有序数组转换为二叉搜索树</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p>ummm, 显然是曾经学过的内容</p><p>二叉搜索树的中序遍历是升序遍历.取中值作为根, 取左区间作为左子树, 右区间作为右子树.如此递归即可.</p><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="[88] 合并两个有序数组"></a>[88] 合并两个有序数组</h3><blockquote><p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，请你将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>nums1</em> 成为一个有序数组。</p></blockquote><p>简单题~</p><p>两个数组倒叙比较, 插入第n+m-1位.</p><p>最后剩下来的如果是nums1则不用管, 如果是nums2就把前面的这一段全部复制到nums1上</p><h2 id="2020年9月22日"><a href="#2020年9月22日" class="headerlink" title="2020年9月22日"></a>2020年9月22日</h2><h3 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="[278] 第一个错误的版本"></a>[278] 第一个错误的版本</h3><p>一个看上去很简单的二分查找问题, 但是对于萌新来说是有坑的</p><h4 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left==right)</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是这个版本会有问题: 当 <code>left</code> 和 <code>right</code> 都取比较大的整数时, <code>mid</code>可能会出现溢出的问题.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left==right)</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时,  mid = left + (right - left) / 2 在 right 很大、 left 是负数且很小的时候， right - left 也有可能超过 int 类型能表示的最大值，只不过一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此 right - left 溢出的可能性很小。</p><p>再次修正可以使用无符号右移解决,详见<a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/" target="_blank" rel="noopener">本题解</a></p><h4 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h4><p>第一次写的代码如下(注意第13行)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left==right)</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如数组为 1,2,3,4,5 时,</span><br><span class="line">1&gt;&gt; left&#x3D;1,right&#x3D;5,mid&#x3D;3</span><br><span class="line">2&gt;&gt; left&#x3D;3,right&#x3D;5,mid&#x3D;4</span><br><span class="line">3&gt;&gt; left&#x3D;4,right&#x3D;5,mid&#x3D;4</span><br><span class="line">4&gt;&gt; left&#x3D;4,right&#x3D;5,mid&#x3D;4</span><br><span class="line">5&gt;&gt; left&#x3D;4,right&#x3D;5,mid&#x3D;4</span><br><span class="line">...会导致死循环,这是由于取mid的时候舍弃了余数</span><br></pre></td></tr></table></figure><p>同样的原因,如果这么写也会导致死循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">right = mid;<span class="comment">//这里应该改成mid+1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid;</span><br></pre></td></tr></table></figure><p>最终的正确版本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="[70] 爬楼梯"></a>[70] 爬楼梯</h3><p>第一条动态规划!</p><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><script type="math/tex; mode=display">f(n) = f(n-1)+f(n-2)</script><p>爬到第 xx 级台阶的方案数是爬到第 <code>x−1</code> 级台阶的方案数和爬到第 <code>x−2</code> 级台阶的方案数的和。很好理解，因为每次只能爬<code>1</code> 级或 <code>2</code>级，所以 <code>f(x)</code> 只能从 <code>f(x−1)</code> 和 <code>f(x - 2)</code> 转移过来</p><p>方法1: 滚动数组</p><p><img src="https://assets.leetcode-cn.com/solution-static/70/70_fig1.gif" alt=""></p><p>方法2: 利用数组保存动态规划的结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯, 显然这只是个入门dp</p><p>btw 题解视频小姐姐的声音真好听</p><h2 id="2020年9月27日"><a href="#2020年9月27日" class="headerlink" title="2020年9月27日"></a>2020年9月27日</h2><p>主题: 动态规划,其他</p><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="[121] 买卖股票的最佳时机"></a>[121] 买卖股票的最佳时机</h3><p>暴力法: TLE</p><p>dp:</p><p>如果我第<code>i</code>天卖出, 那么我需要在前<code>i-1</code>天中的最低点买入. 我需要记录目前的最低买入点,  并每天比较 <code>dp[i-1]</code> 和 <code>prices[i] - min</code> 的大小,取最大记录在<code>dp[i]</code>中.</p><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="[53] 最大子序和"></a>[53] 最大子序和</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/zheng-li-yi-xia-kan-de-dong-de-da-an-by-lizhiqiang/" target="_blank" rel="noopener">这篇题解</a>对动态规划的讲解非常细致, 适合入门</p><p>dp的核心思路是: 由过往的子问题辅助解决当前的子问题</p><p>关键注意: </p><ol><li>如何将当前的子问题通过之前的子问题表示(也就是递推关系是什么样的)</li><li>如果第<code>i</code>个子问题仅使用到第<code>i-1</code>个子问题的答案, 那么我们不必维护整个数组, 仅仅需要存储的第<code>i-1</code>个子问题的值. 这被称为 <strong>状态压缩</strong>. </li></ol><ul><li>步骤一、定义状态 -&gt; 定义数组元素的含义</li><li>步骤二、状态转移方程 -&gt; 找出数组元素间的关系式</li><li>步骤三、初始化 -&gt; 找出初始条件<br><code>dp[0] = nums[0];</code></li><li>步骤四、状态压缩 -&gt; 优化数组空间<br>每次状态的更新只依赖于前一个状态，就是说 dp[i] 的更新只取决于 dp[i-1] , 我们只用一个存储空间保存上一次的状态即可。</li><li>步骤五、选出结果<br>有的题目结果是<code>dp[i]</code>。<br>本题结果是<code>dp[0]...dp[i]</code> 中最大值。</li></ul><p>TODO: 分治法</p><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="[198] 打家劫舍"></a>[198] 打家劫舍</h3><p>dp, 把状态转移方程搞清楚即可.</p><p><code>dp[i] = max(dp[i-1],dp[i-2]+nums[i])</code> 要么用上一个dp, 要么用本次数字＋上上一个dp</p><p><a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/" target="_blank" rel="noopener">题解</a>小姐姐真好听!!</p><h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="[412] Fizz Buzz"></a>[412] Fizz Buzz</h3><p>用最简单的方法做出来了, 时间复杂度非常糟糕, 看了下似乎在用散列优化,还用了些数学上的小技巧</p><p>例如官当题解和<a href="https://leetcode-cn.com/problems/fizz-buzz/solution/si-lu-jian-dan-xing-neng-da-dao-100-by-jamleon-3/" target="_blank" rel="noopener">这个</a></p><h3 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="[204] 计数质数"></a>[204] 计数质数</h3><p>数学类题目…有很多奇怪的算法</p><p>一般想到的就是: 依次比较, 直到sqrt(m)</p><p>一点细节:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= m; i++)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//而不是</span></span><br><span class="line"><span class="keyword">int</span> sq = <span class="built_in">sqrt</span>(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2020年9月28日"><a href="#2020年9月28日" class="headerlink" title="2020年9月28日"></a>2020年9月28日</h2><p>从今天开始改用Java写了</p><h3 id="724-寻找数组的中心索引"><a href="#724-寻找数组的中心索引" class="headerlink" title="[724] 寻找数组的中心索引"></a>[724] 寻找数组的中心索引</h3><p>中心索引的定义: 数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和</p><p>其实思路相通了就很简单. 首先计算全部元素和. 再遍历第二次, 每次判断 sum_left *2 + curr_value == sum_total 即可!</p><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="[35] 搜索插入位置"></a>[35] 搜索插入位置</h3><p>二分查找</p><p>强推这位兄弟的<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">题解</a></p><h3 id="2020年9月29日"><a href="#2020年9月29日" class="headerlink" title="2020年9月29日"></a>2020年9月29日</h3><h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="[145] 二叉树的后序遍历"></a>[145] 二叉树的后序遍历</h3><p>涉及到树的有两种做法: 一曰递归, 一曰迭代</p><p>这里给出了递归的做法: 关键代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helper(V,root-&gt;left);</span><br><span class="line">helper(V,root-&gt;right);</span><br><span class="line">V.push_back(root-&gt;val);</span><br></pre></td></tr></table></figure><p>TODO: 迭代的做法! </p><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="[56]合并区间"></a>[56]合并区间</h3><p>直接上<a href="https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/" target="_blank" rel="noopener">题解</a>吧 </p><p>如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的. 这是再把可以合并的区间合并即可.</p><p>问题在于: 我们的排序对象是数组(而不是数), 因此是需要在 <code>sort()</code> 函数中指定比较器 <code>Comparator&lt;int[]&gt; c</code> </p><p>排序后: 如何判断区间是否可以合并的? 记录当前区间的左值右值LR, 与下一个区间比较,来决定是合并, 拓展,还是另起区间. </p><h3 id="2020年9月30日"><a href="#2020年9月30日" class="headerlink" title="2020年9月30日"></a>2020年9月30日</h3><p>关键词:数组</p><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="[48] 旋转图像"></a>[48] 旋转图像</h3><p>七月份时做了一个几乎完全一致的题目( <a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">旋转数组</a>) 感觉这题算是讨巧的数学变换, 但是编写代码时要细心.  </p><p>先转置, 再镜像对称  这里的代码编写可能需要绕一会</p><p>此外这题还有很对其他的变换方法, 加入TODO</p><h3 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a>面试题 01.07. 旋转矩阵</h3><p>同上</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷完了初级题库, 对各分类的简单算法有了基础的认知&lt;/p&gt;
&lt;p&gt;整理了一些STL的常用函数(不全面) &lt;/p&gt;
&lt;p&gt;开始由C++专向Java&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="屠龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/"/>
    
      <category term="算法与刷题" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%B7%E9%A2%98/"/>
    
      <category term="力扣刷题流水账" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之二刷子午</title>
    <link href="http://yoursite.com/2020/09/27/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E4%BA%8C%E5%88%B7%E5%AD%90%E5%8D%88/"/>
    <id>http://yoursite.com/2020/09/27/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E4%BA%8C%E5%88%B7%E5%AD%90%E5%8D%88/</id>
    <published>2020-09-27T15:36:42.000Z</published>
    <updated>2020-09-28T07:46:35.659Z</updated>
    
    <content type="html"><![CDATA[<p>2020年9月26日</p><p>子午口-荔枝驿-金仙观-小土地梁-原返</p><a id="more"></a><p>由于我坚持不懈地在朋友圈更新徒步动态, 终于有同学跑过来私聊说想试一试户外了~ 正好本周的打卡山是难度较大的冰晶顶, 自觉水平不够, 就带着N同学一起去了超简单线:子午峪. 子午是我疫情返校后的第一座山, (可以参看8月5日的游记), 对新手非常友好了~</p><h2 id="新队友"><a href="#新队友" class="headerlink" title="新队友"></a>新队友</h2><p>让我惊讶的是居然在队伍里偶遇到西电的本科生. 是一位17级的大四学长, 在此之前我几乎没有碰到过玩户外的其他本科生欸. 事后发现跃跃学长真是dalao哈哈哈. 这个一会再说</p><p>集合点是陕师大门口. 副领队是一只看上去好小的政法小姐姐 , 居然也是大三. 虽说明明也是户外新人怎么就成领队了呢(狗头</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E9%87%91%E4%BB%99%E8%A7%82.jpg" alt=""></p><p>主领队是西电的研究生非鱼. 很皮很欠揍. 提前就约好了一起腐败哈哈哈</p><p>除此之外还有个巨巨巨巨佬Black, 是交大的研究生. 越野老驴, 体能贼强, 回去路上给我们看之前反穿鳌太, 一日太白的照片, 实在是太好看了. 高强度徒步. 除此之外科研生活也两开花, 大佬果然做什么事情都是大佬.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E7%8E%AF%E4%BF%9D.jpg" alt=""></p><h2 id="徒步"><a href="#徒步" class="headerlink" title="徒步"></a>徒步</h2><p>一路上倒是没什么值得记录的, 跟散步一样慢悠悠晃了过来, 没啥景色.</p><p>倒是有队员拍到了山羊的照片,可惜我没看到.还有第一次来的时候见到的猫猫, 两个月不见又胖了一圈</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E7%8C%AB%E5%92%AA.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%F0%9F%90%8F.jpg" alt=""></p><p>有段路满地都是野板栗壳, 都是先前的徒步队留下来的, 我们瞪大了眼睛也找不到一个完整的, 不过回来路上看见别的驴友拎着一大袋子板栗回去, 估计是进山进的更深一些.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E6%9D%BF%E6%A0%97%28%E5%B0%8F%29.jpg" alt=""></p><h2 id="腐败"><a href="#腐败" class="headerlink" title="腐败"></a>腐败</h2><p>那这种轻装休闲线嘛~ 肯定是主要出来腐败的. 提前准备好了海底捞底料, 火腿, 肉肠, 鸡胸肉, 方便面. 甚至还在乐购买了包牛肉卷(容易化, 下次别带了). 其他人也带了两袋子菜蔬, 火锅丸子, 爆浆蛋糕, 鸭脖鸭架, 炒货等待…非鱼还带的一口大锅! 第一次吃这么丰盛的火锅哈哈哈. 最后煮了一盆肉,一盆菜,一盆方便面. 到最后都九个人都没能吃完!!</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E7%81%AB%E9%94%85.jpg" alt=""></p><p>跃跃原来是厨神, 油炸火腿肠(虽然不好吃), 番茄汤底方便面, 最后甚至掏出了一套茶具开始喝茶! 真的绝了~~</p><p>回去路上又临时起意去约饭, 居然还是去的自助~! 感觉这一趟下来胖好多哈哈哈</p><p>但是自助真好吃</p><blockquote><p>还记得去年说, 旅游的意义之一是简单更多的人更广的世界，现在觉得这句话更加正确。</p><p>拘泥于固有的生活节奏的人是井底之蛙，是动了奶酪而不自知的老鼠。</p><p>遇到了交大大佬black，体能好 徒步越野的老驴，文理双修，博闻强识 科研生活两开花<br>遇到了同龄的政法小姐姐，虽然也在迷茫但是很努力在提升自己<br>遇到大一届的学长，在毕业和求职之间忙里偷闲<br>遇到78年高考的大叔，交大毕业，扬州工作，还能跟我们唠的开心</p><p>缘分这种事啊，不迈出第一步就永远也碰不见</p></blockquote><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E5%90%88%E7%85%A7.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年9月26日&lt;/p&gt;
&lt;p&gt;子午口-荔枝驿-金仙观-小土地梁-原返&lt;/p&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之雨中紫阁</title>
    <link href="http://yoursite.com/2020/09/22/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E9%9B%A8%E4%B8%AD%E7%B4%AB%E9%98%81/"/>
    <id>http://yoursite.com/2020/09/22/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E9%9B%A8%E4%B8%AD%E7%B4%AB%E9%98%81/</id>
    <published>2020-09-22T15:35:30.000Z</published>
    <updated>2020-09-28T07:46:43.096Z</updated>
    
    <content type="html"><![CDATA[<p>2020年月日</p><h1 id="在这里简要概括路线"><a href="#在这里简要概括路线" class="headerlink" title="在这里简要概括路线"></a>在这里简要概括路线</h1><a id="more"></a><ul><li>山与水    | 游记<ul><li>不积硅步 | 徒步系列</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年月日&lt;/p&gt;
&lt;h1 id=&quot;在这里简要概括路线&quot;&gt;&lt;a href=&quot;#在这里简要概括路线&quot; class=&quot;headerlink&quot; title=&quot;在这里简要概括路线&quot;&gt;&lt;/a&gt;在这里简要概括路线&lt;/h1&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭##可选" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD-%E5%8F%AF%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统之一_引言</title>
    <link href="http://yoursite.com/2020/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80_%E5%BC%95%E8%A8%80/"/>
    <id>http://yoursite.com/2020/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80_%E5%BC%95%E8%A8%80/</id>
    <published>2020-09-10T11:15:14.000Z</published>
    <updated>2020-09-10T15:49:45.023Z</updated>
    
    <content type="html"><![CDATA[<p>勤能补拙是良训, 一分辛苦一分才.</p><ol><li>系列介绍</li><li>数据库的定义与目标</li><li>数据视图</li><li>数据库语言</li><li>关系数据库</li><li>数据库的设计</li><li>存储与查询</li></ol><a id="more"></a><h1 id="系列介绍"><a href="#系列介绍" class="headerlink" title="系列介绍"></a>系列介绍</h1><p>没错又开新系列了~~ 这次还是以学校开设的 &lt;&lt;数据库系统概念&gt;&gt; 课程为进度安排, 使用教材为机械工业出版社的 <a href="https://book.douban.com/subject/10548379/" target="_blank" rel="noopener">数据库系统概念</a> 黑皮书.</p><p>文章不会针对某一知识点具体展开叙述, 更多地是作为知识点的列举, 以便于日后回顾.</p><p>文章中也可能会穿插部分与期末考试强相关的信息.</p><h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><h2 id="数据库的定义与目标"><a href="#数据库的定义与目标" class="headerlink" title="数据库的定义与目标"></a>数据库的定义与目标</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>数据库管理系统 (Data Base-Management System, DBMS)</strong>由一个<u>互相关联的数据的集合</u>和一组<u>用以访问这些数据的程序(接口)组成</u></p><p>A database-management system (DBMS) is a collection of interrelated data and a set of programs to access those data.</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li><p>DBMS的主要目标</p><p>to provide a way to <em>store and retrieve</em> database information that is both <strong>convenient</strong> and <strong>efﬁcient</strong></p></li><li><p>对数据的管理, 要求有一下几方面:</p><ul><li>信息体的<u>存储结构的定义</u></li><li>信息<u>操作机制的提供</u></li><li>信息<u>安全性</u>保证</li><li>信息共享时带来的冲突</li></ul></li></ul><p>在历史上，数据的管理经历了人工管理-文件系统管理-数据库管理的阶段。文件处理系统的主要弊端有：</p><ol><li>数据的冗余和不一致（data redundancy and inconsistency）</li><li>数据访问困难(difficulty in accessing data)</li></ol><p>需要解决的问题：</p><ol><li>数据孤立(data isolation) </li><li>完整性问题(integrity problem)</li><li>原子性问题(atomicity problem)</li><li>并发访问(concurrent-access anomaly)</li><li>安全性(security problem) </li></ol><h2 id="数据视图"><a href="#数据视图" class="headerlink" title="数据视图"></a>数据视图</h2><p>数据库系统包括：</p><ul><li>一组互相关联的数据</li><li>一组使用户便于读写的程序（接口）</li></ul><p>数据库系统提供了数据的抽象视图</p><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><ul><li>物理层：最低层次的抽象，描述了数据是如何存储的</li><li>逻辑层：描述了系统中存储了什么数据，以及数据之间的关系。面向数据库管理员</li><li><p>视图层：最高层次的抽象，仅仅描述数据库的某个部分。同一个数据库可能拥有多种视图层</p><h3 id="实例与模式"><a href="#实例与模式" class="headerlink" title="实例与模式"></a>实例与模式</h3></li><li>实例：数据库在某一时刻存储在数据库中的信息的集合。</li><li>模式：数据库的总体设计方式</li></ul><p>任意时刻的实例都是该模式的具体，模式是实例的抽象。<br>根据不同的抽象层次模式又分为：</p><ul><li>物理模式：描述了数据库在物理层上的设计抽象模式</li><li>逻辑模式：描述了数据库在逻辑层上的设计抽象模式</li><li><p>子模式：描述了数据库在视图层上的设计抽象模式</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型是一类概念的集合，这些概念描述了数据，数据联系，数据语义以及一致性约束。<br>常见的数据模型：</p></li></ul><ol><li>关系模型</li><li>实体-联系模型</li><li>基于对象数据模型</li><li><p>半结构化数据模型</p><h2 id="数据库语言"><a href="#数据库语言" class="headerlink" title="数据库语言"></a>数据库语言</h2><p>数据库语言分为数据定义语言（DDL）和数据操纵语言（DML）。<br>这两种并非对立的语言，而是同一门数据库语言的两部分。</p><h4 id="数据操纵语言DML"><a href="#数据操纵语言DML" class="headerlink" title="数据操纵语言DML"></a>数据操纵语言DML</h4><p>使用户能够访问或操作数据，包括以下访问类型：</p></li><li>Create 插入新的数据</li><li>Retrieve 从存储在数据库中的信息进行检索</li><li>Update 更新已有的数据</li><li>Delete 删除数据</li></ol><p>有两类基本的数据操纵语言：</p><ol><li>过程化DML ，需要用户指定需要的数据并且如何获得数据</li><li>声明式DML，仅需要指定需要的数据，不需要指明如何获得</li></ol><p>查询（Query）语言本义是特指DML中的检索语句，现在常作为DML的同义词。</p><h4 id="数据定义语言DDL"><a href="#数据定义语言DDL" class="headerlink" title="数据定义语言DDL"></a>数据定义语言DDL</h4><p>DDL不直接操作数据，而是对数据库模式进行设计的一种语言。数据库中的数值必须满足某些一致性约束，DDL正是指定这些约束的工具。DDL可用于：</p><ul><li>域约束</li><li>参照完整性</li><li>断言</li><li>授权</li></ul><p>DDL编写的结果储存在在数据字典中，数据字典中储存的内容被称作元数据。元数据是关于数据的数据，规定了表中数据应当符合的模式。（大概）</p><h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><p>关系型数据库基于关系模型，使用表来展示数据及数据间的联系。关系型数据库是目前最广泛使用的数据库，我们将在接下来几章详细讲解。</p><p>关系型数据库（例如SQL）常常无法用于复杂的计算，因此往往需要宿主语言（Java，C++）。数据库语言提供了一系列接口给宿主语言。</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><ol><li><p>确定用户的数据需求</p></li><li><p>概念设计</p><p>选择合适的数据模型并使用该模型将需求转化为一个数据库的概念模式</p></li><li><p>逻辑设计阶段</p><p>将高层的概念模式映射到实现数据模型上</p></li><li><p>物理设计阶段</p></li></ol><h3 id="实体-关系模型"><a href="#实体-关系模型" class="headerlink" title="实体-关系模型"></a>实体-关系模型</h3><p>实体-联系(E-R)数据模型使用一组称作实体的基本对象，以及这些对象间的联系。</p><p><strong>实体</strong> (entity) 是现实世界中可区别于其他对象的一件“事情”或一个“物体”。例如，每个人是一个实体，每个银行账户也是一个实体。实体通过<strong>属性</strong>(attribute)集合来描述</p><p><strong>联系</strong>(relationship)是几个实体之间的关联。同一类型的所有实体的集合称作实体集(entity set),同一类型的所有联系的集合称作联系集 (relationship set) </p><p>数据库的总体逻辑结构(模式)可以用实体-联系图(entity-relationship diagram, E-R图)进行图形化表示。最常用的方法之一是采用统一建模语言(Unified Modeling Language, UML) </p><ul><li>实体集用矩形框表示，实体名在头部，属性名列在下面。</li><li>联系集用连接一对相关的实体集的菱形表示，联系名放在菱形内部。</li></ul><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p>设计关系数据库所用到的另外一种方法是通常被称为<strong>规范化</strong>的过程。它的目标是生成一个关系模式集合，使我们存储信息时没有不必要的冗余，同时又能很轻易地检索数据。这种方法是设计一种符合适当的<strong>范式</strong>(normal form)的模式</p><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值(null) 表示这个值不存在(或者未知)，未知值可能是 缺失(该值确实存在，但我们没有得到它)或不知道(我们不知道该值是否存在)。空值很难处理，所以最好不要用它。</p><h2 id="存储与查询"><a href="#存储与查询" class="headerlink" title="存储与查询"></a>存储与查询</h2><h3 id="存储管理器"><a href="#存储管理器" class="headerlink" title="存储管理器"></a>存储管理器</h3><p><strong>存储管理器</strong>是数据库系统中负责在数据库中<u>存储的低层数据与应用程序</u>以及<u>向系统提交的查询之间提供接口</u>的部件。存储管理器负责与<strong>文件管理器</strong>进行交互。存储管理器将各种DML语句翻译为底层文件系统命令,并存储在磁盘中。存储管理器负责数据库中数据的<u><em>存储、检索和更新</em></u>。 </p><p>存储管理部件包括：</p><ul><li><p>权限及完整性管理器(authorization and integrity manager)</p><p>它<u>检测是否满足完整性约束</u>，并检查试图访问数据的用户的权限。</p></li><li><p>事务管理器(transaction manager)</p><p>它保证即使发生了故障，数据库也<u>保持在一致的(正确的)状态</u>，并保证并发<u>事务的执行不发生冲突</u>。 </p></li><li><p>文件管理器(file manager)</p><p>它管理磁盘存储空间的分配，管理用于表示磁盘上所存储信息的数据结构。</p></li><li><p>缓冲区管理器(buffer manager)</p><p>它负责将数据从磁盘上取到内存中来，并决定哪些数据应被缓冲存储在内存中。</p></li></ul><p>存储管理器实现了几种<strong><u>数据结构</u></strong>，作为系统物理实现的一部分：</p><ul><li><p>数据文件(data files)</p><p>存储数据库自身。</p></li><li><p>数据字典(data dictionary)</p><p>存储关于数据库结构的元数据，尤其是数据库模式。</p></li><li><p>索引(index)</p><p>提供对数据项的快速访问。和书中的索引一样，数据库索引提供了指向包含特定值的数据的指针。</p></li></ul><h3 id="查询处理器"><a href="#查询处理器" class="headerlink" title="查询处理器"></a>查询处理器</h3><ul><li>DDL 解释器(DDL interpreter),它解释DDL语句并将这些定义记录在数据字典中。 </li><li>DML解释器(DML compiler),将查询语言中的DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令。</li></ul><p>DML编译器还进行查询优化(query optimization),也就是从几种选择中选出代价最小的一种。 </p><ul><li>查询执行引擎(query evaluation engine),执行由DML编译器产生的低级指令。 </li></ul><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p><strong>事务</strong> (transaction): 是数据库应用中完成单一逻辑功能的操作集合。每一个事务是一个既具原子性又具一致性的单元</p><blockquote><p>例如: 资金转账这一逻辑单元由两个基本操作组成: 其中一个系(A系)的账户进行取出操作，而另一个系(B系)的账户进行存入操作。显然，这两个操作必 须保证要么都发生要么都不发生。也就是说，资金转账必须完成或根本不发生。这种要么完成要么不 发生的要求称为<strong>原子性(atomicity)</strong> </p><p>除此以外，资金转账还必须保持数据库的一致性。也就是说，A 和B的余额之和应该是保持不变的。这种正确性的要求称作<strong>一致性(consistency)</strong> .最后，当资金转账 成功结束后，即使发生系统故障，账户A和账户B的余额也应该保持转账成功结束后的新值。这种保持的要求称作<strong>持久性(durability)</strong>。</p></blockquote><p>原子性和持久性的保证是数据库系统自身的职责，确切地说，是恢复管理器(recovery manager)的职责。为了保证原子性，失败的事务必须对数据库状态不产生任何影响。因此，数据库必须被恢复到该失败事务开始执行以前的状态, 即<strong>故障恢复(failure recovery)</strong></p><p>最后，当多个事务同时对数据库进行更新时，即使每个单独的事务都是正确的，数据的一致性也可能被破坏。<strong>并发控制管理器(concurrency-control manager)</strong>控制并发事务间的相互影响，保证数据库一 致性。</p><p>并发控制管理器和恢复管理器 都属于 <strong>事务管理器(transaction manager)</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;勤能补拙是良训, 一分辛苦一分才.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系列介绍&lt;/li&gt;
&lt;li&gt;数据库的定义与目标&lt;/li&gt;
&lt;li&gt;数据视图&lt;/li&gt;
&lt;li&gt;数据库语言&lt;/li&gt;
&lt;li&gt;关系数据库&lt;/li&gt;
&lt;li&gt;数据库的设计&lt;/li&gt;
&lt;li&gt;存储与查询&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="数据库系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之太兴山</title>
    <link href="http://yoursite.com/2020/09/02/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%A4%AA%E5%85%B4%E5%B1%B1/"/>
    <id>http://yoursite.com/2020/09/02/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%A4%AA%E5%85%B4%E5%B1%B1/</id>
    <published>2020-09-02T15:34:09.000Z</published>
    <updated>2020-09-28T07:47:00.820Z</updated>
    
    <content type="html"><![CDATA[<p>2020年月日</p><h1 id="在这里简要概括路线"><a href="#在这里简要概括路线" class="headerlink" title="在这里简要概括路线"></a>在这里简要概括路线</h1><a id="more"></a><ul><li>山与水    | 游记<ul><li>不积硅步 | 徒步系列</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年月日&lt;/p&gt;
&lt;h1 id=&quot;在这里简要概括路线&quot;&gt;&lt;a href=&quot;#在这里简要概括路线&quot; class=&quot;headerlink&quot; title=&quot;在这里简要概括路线&quot;&gt;&lt;/a&gt;在这里简要概括路线&lt;/h1&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭##可选" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD-%E5%8F%AF%E9%80%89/"/>
    
  </entry>
  
</feed>
