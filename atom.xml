<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>(ﾟ∀。)</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-28T14:12:25.030Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LUY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>时与光W_202006-4</title>
    <link href="http://yoursite.com/2020/06/28/%E6%97%B6%E4%B8%8E%E5%85%89W_202006-4/"/>
    <id>http://yoursite.com/2020/06/28/%E6%97%B6%E4%B8%8E%E5%85%89W_202006-4/</id>
    <published>2020-06-28T12:41:22.000Z</published>
    <updated>2020-06-28T14:12:25.030Z</updated>
    
    <content type="html"><![CDATA[<p>2020年6月22日 ~ 28日.</p><p>开始个人小结计划</p><p>学习 CSAPP </p><p>追剧, 玩游戏</p><a id="more"></a><h2 id="时与光-个人小结计划"><a href="#时与光-个人小结计划" class="headerlink" title="时与光:个人小结计划"></a>时与光:个人小结计划</h2><p>听说每天坚持写技术博客有利于知识巩固与技能加深, 自觉没有每天坚持的能力, 想了个折中的办法: 以一周为阶段定期总结. 当然, 每月月底, 每半年, 每年也要整理记录! </p><p>主要内容希望自己能够以技术学习, 生活记录为主. 反正也不会有别人看, 就写的简略且随性一些. </p><p><strong>以下是每次小结的规范:</strong></p><ol><li>小结分为: 周记, 月记, 半年总结, 年度总结 四种, 后缀分别以<code>w,m,h,y</code>标识.</li><li>命名格式例: <ol><li>周记: <code>时与光W_202006-4</code> 末位数字代表本月第几周(周日为准)</li><li>月记: <code>时与光M_202006</code></li><li>半年记: <code>时与光H_2020上半年</code></li><li>年度记: <code>时与光Y_2020年度总结</code></li></ol></li><li>内容包括: <ol><li>技术学习成果与产出总结</li><li>记录生活, 如旅游 读书 观影 游戏</li><li>突如其来的想法</li><li>下一阶段的展望</li></ol></li></ol><h2 id="学习CSAPP"><a href="#学习CSAPP" class="headerlink" title="学习CSAPP"></a>学习CSAPP</h2><p>项目地址:</p><p><a href="https://github.com/luy-0/CS-APP-LABs" target="_blank" rel="noopener">https://github.com/luy-0/CS-APP-LABs</a></p><p>对CSAPP这本书垂涎已久, 趁着疫情的期末大把空闲时间和两位同学组队学习CSAPP以及CMU的15-213课程. 更多学习情况参看README部分.</p><p>本周着重于完成机器级别编程部分, 以及课程配套实验中的Bomb Lab, 这是一个通过 gdb 查看可执行文件的汇编代码, 并且推导出炸弹拆除的密钥. 在这几天习得了基本的汇编代码阅读能力, gdb 的基本运用能力, 对C计算机底层运算的实现有了更深的理解. </p><p>这个Lab真是让人又爱又恨, 每拆除一个炸弹的时候成就感满满, 但是对着汇编代码死活瞪不出逻辑的暴躁和无奈…</p><p>机器级别编程 是指 使用汇编代码完成函数操作. 主要学习内容包括 控制机器执行, 执行过程 数据的存储(数组 结构 联合) 以及其他进阶部分. 其中关于缓存区溢出, 栈攻击, 浮点代码等部分掌握的不好.</p><h2 id="追剧"><a href="#追剧" class="headerlink" title="追剧"></a>追剧</h2><p>这一周在追《隐蔽的角落》 . 改编自紫金陈的推理小说《坏小孩》，讲述了在沿海小城三个孩子(朱朝阳, 岳普, 严良) 在景区游玩时无意间拍摄记录了一次谋杀(张东升, 秦昊饰)，想借机敲诈来筹钱，以及随后发生的一连串的故事。大结局播完豆瓣评分依旧为9.0</p><p>主要是周围同学都在追哈哈哈, 感叹国产网剧真的很成熟了, 前几集导演对于节奏把握的很好, 中间叙事稍有平淡, 最后一部分还没看😂  配乐挺用心, 虽然我听不懂后现代, 但是还是有被情绪感染到. 在展现上制片组的细致程度令人感动, 例如张东升海夜追朝阳时对着脚步印, 例如试卷和板书上的题目真的是初中知识点 , 竟然有一点点对着美剧扣细节的感觉了. 演员也实力诠释, 秦昊的演技令人背后发凉, 小朋友的演技也很稳啊~ 朝阳那种说的少想得多的内向好学生非常真实, 普普的可爱是真的戏里戏外的可爱 ,就是太机灵懂事了, 牛逼的让人心疼(话说我怎么总觉得她最后要黑化一类的?) 严良其实没有很好地演出想象里的小痞子气, 缺点那种坏味.一部很优秀的国产剧, 拯救了我被言情耽改剧摧毁的信心~ (没错我就是指ssss和cql)</p><p>希望结局能够依旧精彩吧! </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/XGYW%25K%7DKW%40MFX%7BQNNHBI95W.jpg" alt=""></p><h2 id="玩游戏"><a href="#玩游戏" class="headerlink" title="玩游戏"></a>玩游戏</h2><p>嗯…最近又入了平安京的坑, MOBA真香:dog: 不过打了一周上了少属就没啥动力了… 快乐咸鱼佛系游戏, 竞技游戏嘛 心态放好就行了~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年6月22日 ~ 28日.&lt;/p&gt;
&lt;p&gt;开始个人小结计划&lt;/p&gt;
&lt;p&gt;学习 CSAPP &lt;/p&gt;
&lt;p&gt;追剧, 玩游戏&lt;/p&gt;
    
    </summary>
    
    
      <category term="时与光" scheme="http://yoursite.com/categories/%E6%97%B6%E4%B8%8E%E5%85%89/"/>
    
    
      <category term="小结" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%BB%93/"/>
    
      <category term="周记" scheme="http://yoursite.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之内存管理</title>
    <link href="http://yoursite.com/2020/06/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-06-09T01:14:11.000Z</published>
    <updated>2020-06-09T06:48:04.382Z</updated>
    
    <content type="html"><![CDATA[<p>本章将会涉及到</p><ol><li>基本内存管理</li><li>Segmentation    分段 </li><li>Swap    交换</li><li>⭐Virtual   虚拟内存</li><li>其他需要考虑的问题</li></ol><a id="more"></a><h2 id="基本内存管理"><a href="#基本内存管理" class="headerlink" title="基本内存管理"></a>基本内存管理</h2><p>本节会涉及到:</p><ol><li>储存层次</li><li>CPU利用率</li><li>重定位<ol><li>Base &amp; Limit</li><li>什么时候重定位</li></ol></li></ol><h3 id="储存层次"><a href="#储存层次" class="headerlink" title="储存层次"></a>储存层次</h3><p>参看计组部分, 不是重点, 略</p><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p>如果考虑到内存的存在, CPU的利用率还将会进一步降低.  如果CPU中同时存在 $n$ 个运行中的程序 (称为多道程序的度 degree) ,则 CPU利用率为</p><script type="math/tex; mode=display">1-P^n</script><p>其中 $P$ 是IO等待时间的占比</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124321.jpg" alt="1591668423275"></p><blockquote><ul><li>These  sizes allow 4 programs to be in memory at once. With an 80% average I/O wait, we have a CPU utilization of 1-0.8^4≈60%. </li><li>Adding another 16MB of memory allow 8 programs, thus raising the CPU utilization to 83%. </li><li>Adding yet another 16MB of memory allow 12 programs, only increase CPU utilization to 93%. </li><li>…97% </li></ul></blockquote><p>下图展示了实际CPU中的资源分配</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124332.jpg" alt="1591668467874"></p><ul><li>0-10秒内 仅Job1 在工作. CPU利用率为 $1-0.8^1=0.2$ 相当于执行了 $10\times0.2=2 min$</li><li>10-15秒内 Job1/2 在工作. CPU利用率为 $1-0.8^2=0.36$ 平均每个任务相当于执行了 $5\times\frac{1}{2}\times0.36=0.9 min$</li><li>15-20 秒内 Job1/2/3 在工作. CPU利用率为 $1-0.8^3=0.49$ 平均每个任务相当于执行了 $5\times\frac{1}{3}\times0.49=0.8 min$</li><li>……</li></ul><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>程序本身包含的数据是从零开始<del>的异世界生活</del> 而在实际运行中, 几乎不可能物理地址恰好从零开始, 因此需要将程序中的逻辑地址(也叫相对地址) 转换成物理地址. 这在CPU中是由 MMU (内存控制单元) 完成的.</p><h4 id="基址与限址-Base-amp-Limit"><a href="#基址与限址-Base-amp-Limit" class="headerlink" title="基址与限址   Base &amp; Limit"></a>基址与限址   Base &amp; Limit</h4><p>Base &amp; Limit 都是作为寄存器储存在PCB中, 每个进程都有一个. </p><p>Base 是逻辑地址0 在物理地址空间中的地址(的指针) , 也就是该进程在内存空间中开始的地方. </p><p>Limit 是进程所拥有的最大地址<strong>数目</strong>, Base + Limit 是 进程的最大地址</p><blockquote><p>​    eg Base = 10000   Limit = 4000  ➡ 最大地址为 14000</p></blockquote><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124344.jpg" alt="重定位图"></p><p>如图, 逻辑地址先与limit比较, 无误后再加上base成为物理地址</p><h4 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h4><p>Memory Management Unit , 内存管理空间, 作用是将虚拟内存转化为实际的物理地址, 再将其送往数据Bus上.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124432.jpg" alt="mmu"></p><h4 id="什么时候发生重定位"><a href="#什么时候发生重定位" class="headerlink" title="什么时候发生重定位?"></a>什么时候发生重定位?</h4><p>一般来说有三种:</p><ol><li>编译时, 这种就要求编译之后的程序代码的地址必须是实际运行中的地址, 常用于直接烧录的嵌入式等.</li><li>载入时, 要求载入后程序在内存中的位置必定不变, 无法进行灵活地管理与切换</li><li>运行时, 支持交换 分页等操作</li></ol><hr><h2 id="Segmentation-分段"><a href="#Segmentation-分段" class="headerlink" title="Segmentation 分段"></a>Segmentation 分段</h2><p>在上述讨论中, 我们是把程序的所有东西整体放入内存中. 而事实上, 程序的数据包括代码段(Code), 数据段(Data), 堆栈段(Stack),….</p><p>可能出现的问题: 修改Data数据时误改了Code段; 批处理时可以复用代码段等.</p><p>所以采用分段.每一段的逻辑地址都从0 开始, 每一段都拥有自己的Base 与 Limit , 这些映射关系储存在段表中.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609082725.jpg" alt="分段"></p><h3 id="GDT-amp-LDT"><a href="#GDT-amp-LDT" class="headerlink" title="GDT &amp; LDT"></a>GDT &amp; LDT</h3><p>每个进程拥有自己的LDT (Local Descriptor Table) 用于储存进程中每个段的Base等数据.</p><p>OS 拥有一个GDT (Global  Descriptor Table) </p><p>存疑 GDT时用来干什么的?</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125624.jpg" alt=""></p><h3 id="段的大小"><a href="#段的大小" class="headerlink" title="段的大小"></a>段的大小</h3><p>一般 Inter 16K段, 每段拥有1 billion 32-bit words</p><h3 id="分段与换页的比较"><a href="#分段与换页的比较" class="headerlink" title="分段与换页的比较"></a>分段与换页的比较</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125600.jpg" alt="比较"></p><hr><h2 id="Swap-交换"><a href="#Swap-交换" class="headerlink" title="Swap 交换"></a>Swap 交换</h2><p>本小节涉及到:</p><ol><li>交换的概念</li><li>碎片/空洞</li><li>⭐内存管理机制<ol><li>位图    bit map    </li><li>链表    list</li></ol></li><li>⭐内存的分配机制</li></ol><p>先前说到内存空间的大小远远不够支撑所有进程同时使用. 因此Swap 出现了, 基本思想是谁用, 内存资源给谁. 当另外一个进程需要CPU资源时, 将原先的进程撤出, 换入目标进程.</p><p>内存分区的可以分成固定大小, 缺点是会造成空间的浪费, 并且无法运行大于分区大小的程序. </p><p>分区大小也可以是可变的, 但是随着时间会有碎片(空洞, Holes) 的产生</p><h3 id="Holes-空洞"><a href="#Holes-空洞" class="headerlink" title="Holes 空洞"></a>Holes 空洞</h3><p>空洞的产生</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124358.jpg" alt=""></p><p>空洞还是难以清除的. 内存是处在高速变化中的, 试图将碎片合并为更大的内存空间片式必须要将目前的进程停滞. 对外表现为长达数十秒甚至分钟的机器假死, 是不可被忍受的.</p><h3 id="内存的管理机制"><a href="#内存的管理机制" class="headerlink" title="内存的管理机制"></a>内存的管理机制</h3><p>将内存划分为更加精细的等大片段, 并记录其是否处于使用中, 如下图</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124410.jpg" alt="内存管理"></p><h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>如图B, 1表示使用中, 0表示未使用.</p><p>pro: 便于管理, 修改只需要取非操作即可</p><p>con: 难于查找, 每次必须查找n位连续的0; 实际位图很大</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>如图C, P表示process, H表示holes, 第二位表示开始位, 第三位表示长度.</p><p>pro: 便于查找, 只需要比较长度, 节约管理成本.</p><p>con: 难于管理, 归还内存时要合并空洞, 合并内存时要分裂空洞</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124419.jpg" alt="合并空洞"></p><h3 id="内存的分配机制"><a href="#内存的分配机制" class="headerlink" title="内存的分配机制"></a>内存的分配机制</h3><h4 id="First-fit"><a href="#First-fit" class="headerlink" title="First fit"></a>First fit</h4><p>从0开始找到第一个合适的</p><h4 id="Next-fit"><a href="#Next-fit" class="headerlink" title="Next fit"></a>Next fit</h4><p>从上一次查找结束的地方开始找到第一个合适的</p><h4 id="Best-fit"><a href="#Best-fit" class="headerlink" title="Best fit"></a>Best fit</h4><p>在所有空洞中找<strong>最略大于</strong>所需内存的空洞</p><h4 id="Worst-fit"><a href="#Worst-fit" class="headerlink" title="Worst fit"></a>Worst fit</h4><p>在所有空洞中找<strong>最大于</strong>所需内存的空洞</p><h4 id="Quick-fit"><a href="#Quick-fit" class="headerlink" title="Quick fit"></a>Quick fit</h4><p>随机查找空洞, 只要够用就安排</p><ul><li><p>Fist , Next , Quick 方式 , 只要找到能用的即可, 不考虑空洞体量是否与所需要的符合.</p></li><li><p>Best 问题:</p><ul><li>碎片产生的太多且小</li><li>查找过程太慢</li></ul></li><li><p>Worst 问题</p><ul><li>迅速消耗大空洞</li><li>查找过程太慢</li></ul></li><li><p>实际性能最好的是 Quick fit</p><p><del>这就是无招胜有招吗 👴就是风清扬, i了i了</del></p></li></ul><h2 id="Virtual-Memory-虚拟内存"><a href="#Virtual-Memory-虚拟内存" class="headerlink" title="Virtual Memory 虚拟内存"></a>Virtual Memory 虚拟内存</h2><p>本节包括:</p><ol><li>分页</li><li>多级页表<ol><li>页表每项对应大小</li><li>页表包括的内容</li></ol></li><li>TLB 快表</li><li><del>反转页表</del></li></ol><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>先前都是按照最大需要的内存来划分空间的. 实际上很多时候是用不到这些空间的. 因此我们在把每个进程(或者段)拆分, 当前使用中的部分在内存中, 其他部分放在磁盘中. </p><p>将进程(或段) 的虚拟空间地址分成一定大小的<strong>页(Page)</strong> , 称为分页.</p><p>将进程(或段) 的物理空间地址分成一定大小的<strong>页帧(Frame)</strong> </p><p>当进程发现所需要的数据所在的页不在内存, 而在磁盘中时, 会发生<strong>页面失效(Page Fault)</strong> , 并通过页面调度将内存中某一页调出, 调入目标页. </p><h4 id="分页过程"><a href="#分页过程" class="headerlink" title="分页过程"></a>分页过程</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125322.jpg" alt="分页"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页算法  伪代码</span></span><br><span class="line">address ad_lo <span class="comment">//逻辑地址,已知</span></span><br><span class="line">address ad_phy<span class="comment">//物理地址,待求</span></span><br><span class="line">address* Base<span class="comment">//已知</span></span><br><span class="line">size Limit<span class="comment">//已知</span></span><br><span class="line">size page_size<span class="comment">//每一页的大小, 一般与页帧大小相同,已知</span></span><br><span class="line">pageTable table[]<span class="comment">//页表,已知</span></span><br><span class="line"><span class="keyword">int</span> pageNo<span class="comment">//页号,未知</span></span><br><span class="line"><span class="keyword">int</span> frameNo<span class="comment">//页帧号,未知</span></span><br><span class="line"></span><br><span class="line">getAd_Phy()&#123;</span><br><span class="line"><span class="keyword">if</span> (ad_lo &gt; *(Base + Limit) )</span><br><span class="line"><span class="keyword">throw</span> error(<span class="string">"地址越界!"</span>)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pageNo = ad_lo % page_size<span class="comment">//页号</span></span><br><span class="line">offset = ad_lo - pageNo * page_size<span class="comment">//页内偏移量</span></span><br><span class="line">frameNo = table[PageNo]<span class="comment">//页帧号</span></span><br><span class="line"><span class="keyword">if</span> (frameNo == null)</span><br><span class="line"><span class="keyword">throw</span> error(<span class="string">"页面失效!"</span>)</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ad_phy = frameNo * page_size + offset</span><br><span class="line"><span class="keyword">return</span> ad_phy</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/img_1173.png" alt="练习"></p><h4 id="分页场景"><a href="#分页场景" class="headerlink" title="分页场景"></a>分页场景</h4><ol><li><p>进程创建时</p><ul><li><p>确定程序体量</p></li><li><p>创建进程表</p></li></ul></li><li><p>程序执行时</p><ul><li><p>MMU刷新</p></li><li><p>TLB刷新</p></li></ul></li><li><p>页面失效时</p><ul><li>判断失效页面, 确定调入页面</li><li>确定并调出调出页面</li><li>调入调入页面</li></ul></li><li><p>程序结束</p><ul><li>释放资源</li></ul></li></ol><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>实际上页表很大($2^{32}$), 但是我们要求它快!</p><ol><li><p>将页表放在硬件(寄存器)中</p><p>……用脚趾头想都不现实</p><p><del>万一哪天科技突飞猛进了后人看到这篇博客会是什么想法呢</del></p></li><li><p>页表放在软件(内存)中</p><p>效率低</p></li></ol><p>多级列表,字面意思,  应该很好懂.</p><p><strong>每项的大小</strong></p><div class="table-container"><table><thead><tr><th>PT1</th><th>PT2</th><th>Offset</th></tr></thead><tbody><tr><td>10 $bits$</td><td>10  $bits$</td><td>12  $bits$</td></tr></tbody></table></div><p>那么总虚拟地址空间大小为 $2^{10+10+12} = 4G$ ,一级页表中每项对应的实际上是 $2^{10+12} = 4M$ 地址空间, 二级页表实际上是$2^{12} = 4K$</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125441.jpg" alt="页面大小"></p><p><strong>实际上页表还包括</strong></p><ol><li>Page frame number 页帧号</li><li>Present /absent  若为1 ,表示该页对应物理地址在内存中</li><li>Protection  标识访问权限, R/W/X</li><li>Modified    标识是否修改过, 若1, 调出时需要写入磁盘</li><li>Referenced  最近是否被访问, 用于页面调度算法的参考</li><li>Caching disabled   不懂</li></ol><h3 id="TLB-快表"><a href="#TLB-快表" class="headerlink" title="TLB 快表"></a>TLB 快表</h3><p>根据二八原则, 20% 的页面被访问80%次, 将它们记录在硬件上, 直查物理地址</p><p>剩下的80%再跑去页表查</p><p>这一块硬件称为 <strong>转换检测缓冲区  (Translation Lookaside Buffers, TLB, 又称快表)</strong></p><p>TLB包括的内容与页表大致相同, 但是更快!</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125452.jpg" alt="内容"></p><h3 id="反转页表"><a href="#反转页表" class="headerlink" title="反转页表"></a>反转页表</h3><p>没听, 好像是从页帧转页, 但是不重要</p><h2 id="页面调度算法"><a href="#页面调度算法" class="headerlink" title="页面调度算法"></a>页面调度算法</h2><p>本节包括</p><ol><li>最优PRA</li><li>NRU  最近未使用</li><li>FIFO  </li><li>SC  第二机会</li><li>Clock PRA</li><li>LRU<ol><li>硬件实现</li><li>软件实现</li></ol></li><li>Working Set</li><li>WSClock </li></ol><p>因为很重要所以单独拉出来一点讲了</p><ul><li><p>刚才提到页面失效,  并随后进行页面调度. 调入的页面是明确的, 但是把什么调出呢? 这就是页面调度算法<strong>(Page Replacement Algorithms ,PRA)</strong></p></li><li><p>除了页面失效外在别的地方也有使用 例如</p><ul><li>缓存</li><li>搜索引擎的热点</li></ul></li></ul><h3 id="最优PRA"><a href="#最优PRA" class="headerlink" title="最优PRA"></a>最优PRA</h3><p>每次都将未来最远不会用到的调走</p><p><del>废话但是我怎么知道啷个是未来不会用到的啊</del></p><p>所以这个算法没有实际意义, 用于评价其他算法的性能</p><h3 id="Not-Recently-Used-NRU-最近未使用"><a href="#Not-Recently-Used-NRU-最近未使用" class="headerlink" title="Not Recently Used (NRU, 最近未使用)"></a>Not Recently Used (NRU, 最近未使用)</h3><p>每个页码都有 Reference bit, Modified bit  (是否被访问, 修改位)</p><p>按照以下顺序调出:</p><ol><li>not referenced, not modified </li><li>not referenced, modified</li><li>referenced, not modified </li><li>referenced, modified</li></ol><h3 id="FIFO-PRA"><a href="#FIFO-PRA" class="headerlink" title="FIFO PRA"></a>FIFO PRA</h3><p>先进先出</p><p>con: 经常将访问过, 修改过的位调出</p><p>下面是它的改进</p><h3 id="Second-Chance-PRA"><a href="#Second-Chance-PRA" class="headerlink" title="Second Chance PRA"></a>Second Chance PRA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;SC PRA</span><br><span class="line">while(页面到队头)&#123;</span><br><span class="line">if(referenceBit &#x3D;&#x3D; 0)</span><br><span class="line">调出;</span><br><span class="line">else &#123;</span><br><span class="line">referenceBit &#x3D; 0;</span><br><span class="line">页面出队;</span><br><span class="line">页面入队; &#x2F;&#x2F;就是扔回队尾了</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="The-Clock-PRA"><a href="#The-Clock-PRA" class="headerlink" title="The Clock  PRA"></a>The Clock  PRA</h3><p>原理相同, 只是改成循环, 改变指针来仿造队列移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while(指针到本页了)&#123;</span><br><span class="line">if(referenceBit &#x3D;&#x3D; 0)</span><br><span class="line">调出;</span><br><span class="line">else &#123;</span><br><span class="line">referenceBit &#x3D; 0;</span><br><span class="line">指针后移;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125508.jpg" alt="clock"></p><h3 id="Least-Recently-Used-LRU-最近最少使用"><a href="#Least-Recently-Used-LRU-最近最少使用" class="headerlink" title="Least Recently Used (LRU, 最近最少使用)"></a>Least Recently Used (LRU, 最近最少使用)</h3><p>是NRU的升级版, 根据<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/15572003?fr=aladdin" target="_blank" rel="noopener">程序局部性原理</a>, 最近被使用的往往将会再次被使用.</p><p>实现方式:</p><ol><li>建立一个最近使用页面的集合</li><li>在每个条目中保留计数器, 每次选择最低的(最少), 定期清零(最近)</li></ol><p><strong>模拟LRU</strong></p><h4 id="硬件模拟"><a href="#硬件模拟" class="headerlink" title="硬件模拟"></a>硬件模拟</h4><ul><li><p>当访问 n 时, 第 n 列置0 , 第 n 行其他位置1</p></li><li><p>当需要调出时, 调出每行和最少的, 如果相同, 调出….</p></li></ul><p>存疑: 不应该是调出离自己最远的吗.? 向下数的第一个?</p><p><strong>缺点</strong></p><p>开销大</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125518.jpg" alt="矩阵"></p><h4 id="软件模拟"><a href="#软件模拟" class="headerlink" title="软件模拟"></a>软件模拟</h4><ul><li>每个页都拥有自己的标识数,每个一段时间将访问的页面对应的标识数的某位置1, 其他置0, 位数后移</li><li>调出时选择标识值最小的调出</li></ul><h3 id="Working-Set"><a href="#Working-Set" class="headerlink" title="Working Set"></a>Working Set</h3><p>没听, 好像是把页面集中成集再调度</p><h3 id="WSClock-PRA"><a href="#WSClock-PRA" class="headerlink" title="WSClock PRA"></a>WSClock PRA</h3><p>类似上面, 采用时钟模拟</p><h2 id="其他需要考虑的"><a href="#其他需要考虑的" class="headerlink" title="其他需要考虑的"></a>其他需要考虑的</h2><h3 id="Local-vs-Global-Allocation-Policies"><a href="#Local-vs-Global-Allocation-Policies" class="headerlink" title="Local vs Global Allocation Policies"></a>Local vs Global Allocation Policies</h3><p>全局调度页面会使得一段时间后内存的利用趋近于实际进程所需的比例.</p><h3 id="Load-Control"><a href="#Load-Control" class="headerlink" title="Load Control"></a>Load Control</h3><p>当 <strong>PFF (page fault frequency 页面失效频率)</strong> 过高时, 主动减少使用内存的进程.</p><p><del>让一部分进程先跑起来</del></p><h3 id="Page-Size"><a href="#Page-Size" class="headerlink" title="Page Size"></a>Page Size</h3><p>small page size (typically 4k or 8k):</p><p>Advantages:</p><ul><li>减少内部碎片</li><li>更好地适合各种数据结构和代码段</li><li>减少内存中未使用的程序</li></ul><p>Disadvantages:</p><ul><li>程序需要很多页，因此产生巨大的页表</li><li>传输小页所需的时间几乎与传输大页所需的时间相同, 但传输效率低</li></ul><h3 id="Cleaning-Policy"><a href="#Cleaning-Policy" class="headerlink" title="Cleaning Policy"></a>Cleaning Policy</h3><p>为了保证在新进程创建的时候有足够的空白页面支持, 必须时刻保证内存中有足够的空白页.</p><p> <strong>paging daemon （分页守护进程）</strong>:当空白页面不足时, 会主动调出页, 但不调入页帧.</p><p>也可以使用clock</p><h2 id="附-Page-Fault-Handling"><a href="#附-Page-Fault-Handling" class="headerlink" title="附: Page Fault Handling"></a>附: Page Fault Handling</h2><ol><li>trap 进内核, 保存PC</li><li>保存进程寄存器</li><li>OS 确定调入页</li><li>OS 确定调出页</li><li>若调出页修改过(dirty), 需要写入磁盘</li><li>调入调入页</li><li>更新页表</li><li>恢复到页面失效的指令</li><li>恢复进程</li><li>恢复寄存器, 恢复PC</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将会涉及到&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本内存管理&lt;/li&gt;
&lt;li&gt;Segmentation    分段 &lt;/li&gt;
&lt;li&gt;Swap    交换&lt;/li&gt;
&lt;li&gt;⭐Virtual   虚拟内存&lt;/li&gt;
&lt;li&gt;其他需要考虑的问题&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之进程间通信</title>
    <link href="http://yoursite.com/2020/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2020-06-08T07:59:19.000Z</published>
    <updated>2020-06-08T08:08:16.844Z</updated>
    
    <content type="html"><![CDATA[<p>本章节包括两个小节</p><ol><li>进程间通信 (InterProess Communicatiin,IPC)</li><li>经典的IPC问题</li></ol><a id="more"></a><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>在本小节会涉及到：</p><ol><li>什么是临界区资源<ol><li>竞争</li><li>保证临界区互斥的4个条件</li></ol></li><li>互斥的策略1 (Busy Waiting)<ol><li>禁止中断</li><li>锁变量</li><li>严格轮换法</li><li>⭐Peterson 算法</li><li>TSL 指令</li></ol></li><li>互斥的策略2<ol><li>上述策略的缺陷（忙等待 优先级反向）</li><li>Sleep &amp; Wakeup<ol><li>问题：唤醒丢失</li></ol></li><li>⭐信号量 Semaphore<ol><li>互斥信号量 Mutexe</li><li>PV操作</li></ol></li><li>管程 Monitor</li><li>消息传递</li><li>屏障</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TODO：第四节：IPC</span><br></pre></td></tr></table></figure><h2 id="Classical-IPC-Problems"><a href="#Classical-IPC-Problems" class="headerlink" title="Classical IPC Problems"></a>Classical IPC Problems</h2><p>本小节将涉及到几个常见IPC模型：</p><ol><li>生产者与消费者</li><li>读者与写者</li><li>进餐的哲学家</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章节包括两个小节&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程间通信 (InterProess Communicatiin,IPC)&lt;/li&gt;
&lt;li&gt;经典的IPC问题&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>使用伪手写体搞定毛概笔记</title>
    <link href="http://yoursite.com/2020/06/06/%E4%BD%BF%E7%94%A8%E4%BC%AA%E6%89%8B%E5%86%99%E4%BD%93%E6%90%9E%E5%AE%9A%E6%AF%9B%E6%A6%82%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/06/%E4%BD%BF%E7%94%A8%E4%BC%AA%E6%89%8B%E5%86%99%E4%BD%93%E6%90%9E%E5%AE%9A%E6%AF%9B%E6%A6%82%E7%AC%94%E8%AE%B0/</id>
    <published>2020-06-06T05:41:39.000Z</published>
    <updated>2020-06-06T08:39:29.488Z</updated>
    
    <content type="html"><![CDATA[<p>毛概课在接连上了五个月网课之后,终于等到了期末!</p><p>对此,毛概老师给全班做出指示: “收  给我收笔记!” </p><a id="more"></a><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>众所周知, 大学的思政课笔记是最无聊虽没意义的形式主义了.</p><p>尤其是他还要求是手写的情况下.</p><p>尤其是手写的笔记还要拍照提交的情况下.</p><p><del>不会吧不会吧, 不会真的有人还在用纸笔记笔记吧? 🐶<del/></p><p>受亲爱的<a href="https://moefactory.com/" target="_blank" rel="noopener">小梦同学</a>提点, 我们来研究一下怎么<strong>仿造手写体</strong>打印材料.</p><p><strong>重要提醒</strong></p><p>由于打印机本身的限制, 实物还是肉眼可见地分辨出伪手写稿. 本学期因为以前的影响只要求把笔记拍照上传检查, 比较好蒙混过关🤔</p><p>如果是线下查收, 还是换个摸鱼方法吧….</p><p>本方法无需编程基础. </p><h2 id="开冲"><a href="#开冲" class="headerlink" title="开冲"></a>开冲</h2><h3 id="Step1-生成自己的手写字体"><a href="#Step1-生成自己的手写字体" class="headerlink" title="Step1. 生成自己的手写字体"></a>Step1. 生成自己的手写字体</h3><p>北京大学计算机科学技术研究所有一个项目<a href="http://59.108.48.27/flexifont-chn/login/" target="_blank" rel="noopener">Flexifont字库</a>, 可以实现自己的字库. 点开注册登录, 根据提示下载模板, 打印书写, 拍照生成就可以了. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/%5DI%7DRW22GJ%7B%401NL7JYIE%2483C.png" alt=""></p><p>如图, 下载不同字数的模板, 打印出来填好,  上传生成即可.</p><p>不过我没整这一步, 直接在字库分享里面下了别人的, 谢谢张建同学.</p><p>下载好.ttf文件后导入系统文件夹(C:\Windows\Fonts)即可.</p><h3 id="Step2-设置-Word-宏命令"><a href="#Step2-设置-Word-宏命令" class="headerlink" title="Step2. 设置 Word 宏命令"></a>Step2. 设置 Word 宏命令</h3><p>参考了 <a href="https://www.zhihu.com/question/20308770" target="_blank" rel="noopener">这个问题 </a>下的回答</p><p>在Word中依次点击 “文件 -&gt; 选项 -&gt; 信任中心 -&gt; 信任中心设置 -&gt; 宏设置” 在右侧选中 “启用所有宏”.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/hongshezhi%20.png" alt="宏设置"></p><p><strong>回到主界面, 视图 - 宏 - 查看宏</strong></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/2020%E5%B9%B46%E6%9C%886%E6%97%A53.png" alt="宏代码编写1"></p><p>输入方案名,新建, 并在弹出的窗口中插入以下代码</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">' 注意是插入 不是直接把原来的替换掉哦</span></span><br><span class="line">    <span class="keyword">Dim</span> R_Character <span class="keyword">As</span> Range</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> FontSize(<span class="number">5</span>)</span><br><span class="line"><span class="comment">' 字体大小在5个值之间进行波动，可以改写 </span></span><br><span class="line"><span class="comment">' 个人建议 如果纸张线条间距为8mm, 字号设置为16左右比较合适</span></span><br><span class="line">    FontSize(<span class="number">1</span>) = <span class="string">"15.5"</span></span><br><span class="line">    FontSize(<span class="number">2</span>) = <span class="string">"15"</span></span><br><span class="line">    FontSize(<span class="number">3</span>) = <span class="string">"16"</span></span><br><span class="line">    FontSize(<span class="number">4</span>) = <span class="string">"17"</span></span><br><span class="line">    FontSize(<span class="number">5</span>) = <span class="string">"17.5"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> FontName(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">'字体名称在三种字体之间进行波动，可改写，但需要保证系统拥有下列字体</span></span><br><span class="line">FontName(<span class="number">1</span>) = <span class="string">"宋体"</span></span><br><span class="line">FontName(<span class="number">2</span>) = <span class="string">"微软雅黑"</span></span><br><span class="line">FontName(<span class="number">3</span>) = <span class="string">"黑体"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> ParagraphSpace(<span class="number">5</span>)</span><br><span class="line"><span class="comment">'行间距 在一定以下值中均等分布，可改写 </span></span><br><span class="line"><span class="comment">' 个人建议 如果纸张线条间距为8mm, 字号设置为23左右比较合适, 并且不建议波动过大</span></span><br><span class="line">    ParagraphSpace(<span class="number">1</span>) = <span class="string">"22"</span></span><br><span class="line">    ParagraphSpace(<span class="number">2</span>) = <span class="string">"22.5"</span></span><br><span class="line">    ParagraphSpace(<span class="number">3</span>) = <span class="string">"23"</span></span><br><span class="line">    ParagraphSpace(<span class="number">4</span>) = <span class="string">"23.5"</span></span><br><span class="line">    ParagraphSpace(<span class="number">5</span>) = <span class="string">"24"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">'下面是功能代码 不想要什么直接删除就行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">For</span> <span class="keyword">Each</span> R_Character <span class="keyword">In</span> ActiveDocument.Characters</span><br><span class="line"></span><br><span class="line">        VBA.Randomize</span><br><span class="line"></span><br><span class="line">        R_Character.Font.Name = FontName(Int(VBA.Rnd * <span class="number">3</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="comment">'上面一行是随机变换字体,不想要可删除</span></span><br><span class="line">        R_Character.Font.Size = FontSize(Int(VBA.Rnd * <span class="number">5</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="comment">'上面一行是随机变换字体大小,不想要可删除</span></span><br><span class="line">        R_Character.Font.Position = Int(VBA.Rnd * <span class="number">3</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">'上面一行对每个字随机上下微调,不想要可删除</span></span><br><span class="line">        R_Character.Font.Spacing = <span class="number">0</span></span><br><span class="line"><span class="comment">'上面一行不要修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line"></span><br><span class="line">    Application.ScreenUpdating = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">For</span> <span class="keyword">Each</span> Cur_Paragraph <span class="keyword">In</span> ActiveDocument.Paragraphs</span><br><span class="line"><span class="comment">'上面三行不要修改</span></span><br><span class="line">        Cur_Paragraph.LineSpacing = ParagraphSpace(Int(VBA.Rnd * <span class="number">5</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="comment">'上面一行对每个行间距微调,不想要可删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line">        Application.ScreenUpdating = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>修改后如图, 记得要把代码16-19行换成你自己的手写体</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200606154923.jpg" alt="代码修改如下"></p><p>点击上面的运行按钮(或者是个小绿三角) 等待</p><p>不出意外结果如下</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/2020%E5%B9%B46%E6%9C%886%E6%97%A515%E7%82%B951%E5%88%86.jpg" alt="记得要把字体换成自己的手写体哦"></p><p>记得把字体换成不同但相近的手写体, 别想现在一样丑不拉几的</p><h3 id="Step3-设置页面与段落"><a href="#Step3-设置页面与段落" class="headerlink" title="Step3. 设置页面与段落"></a>Step3. 设置页面与段落</h3><p>准备好打印机, 复印纸, 以及浪费很多纸张的决心, 开始下一步.</p><p><del>当然你要实现准备好电子笔记, 你不会真的没有记吧?<del/></p><h4 id="字体字号"><a href="#字体字号" class="headerlink" title="字体字号"></a>字体字号</h4><p>在上一步我们应该是基本解决了这个问题, 如果没有, 若纸张线条间距为8mm, 字号设置为16左右比较合适.</p><p>word 中字号的单位是磅, 约为0.3528毫米.也就是说16的字号打印出来大约是5.645毫米高.</p><p>此外可以试一下全部用 <strong>粗体</strong> , 因为我用的字体比较纤细, 看着太假</p><p>多试试, 不要怕废纸</p><h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><p>全选, 右键段落, 设置行间距与段间距.</p><p>间距一栏下</p><p><strong>段前段后:</strong>全部设置成0 空白也要再设置一次</p><p><strong>行距:</strong> 选择固定值, 这里单位依旧是磅数, 如果直线相隔8mm的话大约设置成23磅(23*0.35=8.1144‬)</p><h4 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h4><p>word主页面 - 布局 - 页边距&amp;纸张大小</p><p>自己量一量吧, 上边距是到第一行的<strong>字的上沿</strong>, 下边距是最后一行<strong>字的下沿</strong></p><p>多试试, 不要怕废纸</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/K%607_8GUVFXF0%24PQU81VDCUK.jpg" alt="这么多全是浪费掉的"></p><h3 id="Step4-其他作假手段"><a href="#Step4-其他作假手段" class="headerlink" title="Step4. 其他作假手段"></a>Step4. 其他作假手段</h3><ol><li><p>全部用粗体, 生成的字体过于纤细</p></li><li><p>切换字体确实有效,但是字体风格不能相差太大</p></li><li><p>扫描后对PDF做一下黑白处理, 更难发现</p><p>另外推荐使用app Scanbot扫描, 吊打某某扫描王</p></li><li><p>通过<a href="https://www.ilovepdf.com/compress_pdf" target="_blank" rel="noopener">这个网址</a>对PDF进行全损压缩, 直接挑压缩率最高的那个选项(斜眼笑)</p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>成品还是很满意滴~ </p><p>线上检查的话应该足够以假乱真了吧👌</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200606161805.jpg" alt="效果图1"></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200606161822.jpg" alt="效果图2"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>听说Github上<a href="https://link.zhihu.com/?target=https%3A//github.com/Gsllchb/Handright">这个项目</a>可以进一步微调字体效果,实现同字不同样</p></li><li><p>使用喷墨式打印机应该会稍微好一些</p></li><li><p>学到了磅数这一没什么卵用的知识</p></li><li><p>为了本篇传图开了腾讯云的COS, 终于有图床了</p></li><li><p>其实笔记最好还是自己平时带着记比较好</p><p><del>但是这当然是不可能的啊哈哈哈哈<del/></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毛概课在接连上了五个月网课之后,终于等到了期末!&lt;/p&gt;
&lt;p&gt;对此,毛概老师给全班做出指示: “收  给我收笔记!” &lt;/p&gt;
    
    </summary>
    
    
      <category term="技术小记" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/"/>
    
      <category term="快乐摸鱼" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/%E5%BF%AB%E4%B9%90%E6%91%B8%E9%B1%BC/"/>
    
    
      <category term="手写体" scheme="http://yoursite.com/tags/%E6%89%8B%E5%86%99%E4%BD%93/"/>
    
      <category term="word 宏命令" scheme="http://yoursite.com/tags/word-%E5%AE%8F%E5%91%BD%E4%BB%A4/"/>
    
      <category term="摸鱼" scheme="http://yoursite.com/tags/%E6%91%B8%E9%B1%BC/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之进程线程</title>
    <link href="http://yoursite.com/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-06-05T09:06:22.000Z</published>
    <updated>2020-06-09T06:13:58.037Z</updated>
    
    <content type="html"><![CDATA[<p>本章节包括三个小节</p><ol><li>进程 (Processes)</li><li>线程 (Threads)</li><li>调度 (Scheduling)</li></ol><a id="more"></a><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/%E8%BF%9B%E7%A8%8B%2C%20%E7%BA%BF%E7%A8%8B%2C%20%E8%B0%83%E5%BA%A6.png" alt=""></p><h1 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h1><p>在本小节会涉及到：</p><ol><li>CPU是如何工作的，并由此引入进程的概念与用途</li><li>进程的生命周期：<ol><li>⭐进程的五种状态及之间的转换</li><li>进程的创建</li><li>进程的中止</li><li>两个进程的切换（上下文保存）</li></ol></li><li>⭐Process Control Blocks,PCB (进程表, 进程控制块)<ol><li>为什么要用PCB？</li><li>PCB 中包括什么？</li></ol></li></ol><h2 id="进程的引入及概念"><a href="#进程的引入及概念" class="headerlink" title="进程的引入及概念"></a>进程的引入及概念</h2><p>本章的内容(包括进程线程调度IPC)在于探讨如何更高效地利用CPU. 尽管市面上早已采用了多核架构, 但下述分析均为单核CPU, 如果要考虑多核的情况会事先说明。</p><p>既然是单核CPU，那么在同一时间刻CPU计算资源只能用在一个地方。如果我此时一边敲代码，一边听歌，一边挂QQ，那么实际上CPU的运行状态是在这些工作之间以毫秒级别的速度来回迅速切换，在宏观上造成几个工作同时进行的假象。也即是<strong>“微观串行，宏观并行”</strong>。<br>这样的情况我们被称为<strong>多道程序</strong> ，即同时有多个程序在执行中(宏观)，但实际上只有一个进程在使用CPU(微观)</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/1.jpg" alt="待配图1"></p><p><strong>进程：</strong> an executing program, including the current values of the program counter, register, and variables.<br>进程是进行中的程序。编写好的代码(.c, .py)或可运行的文件(.exe, .bat) 被成为程序。当他们被运行时才被称为进程。<br>一个进程包括：</p><ul><li>program counter, 程序计数器;用于标志该进程当前运行至程序的何处</li><li>stack, 栈; </li><li>data section,数据部分</li></ul><p>那么显然，多道程序中每个程序都拥有自己的PC、stack…</p><h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p>进程是一个动态的客体，可以被创建销毁等。进程总共拥有五种生命状态(state)：</p><ol><li>new               创建</li><li>ready             就绪</li><li>running           运行</li><li>waiting/blocked   阻塞/等待态</li><li>terminated/exit        销毁</li></ol><h4 id="状态之间转换"><a href="#状态之间转换" class="headerlink" title="状态之间转换"></a>状态之间转换</h4><ul><li>new -&gt; ready</li><li>ready -&gt; running</li><li>running -&gt; ready</li><li>running -&gt; blocked</li><li>running -&gt; exit</li><li>blocked -&gt; ready</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/2.jpg" alt="状态转换2"></p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h4 id="进程的创建场景"><a href="#进程的创建场景" class="headerlink" title="进程的创建场景:"></a>进程的创建场景:</h4><ol><li>系统初始化</li><li>系统调用</li><li>用户命令</li><li>批处理作业的初始化</li></ol><h4 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h4><ul><li>父进程不断创建子进程,由此形成进程树</li><li>子进程<strong>可以</strong>继承父的资源(也可以不继承或半继承)</li><li>父子进程可以同时执行,也有可能父等待子</li><li>Unix 中存在这种进程的层级关系,Win 中进程的地位平等,不存在父子关系<ul><li>但是这一说法似乎不当, <a href="https://www.zhihu.com/question/31429459" target="_blank" rel="noopener">参看此处</a></li></ul></li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/3.jpg" alt="Unix进程树3"></p><h3 id="进程的销毁"><a href="#进程的销毁" class="headerlink" title="进程的销毁"></a>进程的销毁</h3><h4 id="进程销毁的场景"><a href="#进程销毁的场景" class="headerlink" title="进程销毁的场景"></a>进程销毁的场景</h4><ol><li><p>Normal exit    正常退出 (自愿)</p></li><li><p>Error exit        错误退出 (自愿)</p></li><li><p>Fatal error      致命性错误退出 (非自愿)</p><p>eg: 除0, 取非法地址</p></li><li><p>被其他进程杀死  (非自愿)</p><p>eg: 父进程, 系统, 其他优先级更高的进程</p></li></ol><h4 id="级联终止"><a href="#级联终止" class="headerlink" title="级联终止"></a>级联终止</h4><p>​    当父进程退出时,子进程必须退出.</p><h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><ul><li>进程的切换非常频繁, 一般在毫秒级</li><li>进程切换需要耗费时间, 称为Gap</li></ul><h4 id="进程切换的场景"><a href="#进程切换的场景" class="headerlink" title="进程切换的场景"></a>进程切换的场景</h4><ol><li><p>时钟中断</p><p>eg 时间轮片用尽</p></li><li><p>IO 中断</p></li><li><p>Memory Fault  内存失效</p><p>eg 内存中页面失效</p></li><li><p>Trap 陷入</p><p>发生错误时</p></li><li><p>Supervisor Call</p><p>管理程序调用</p></li></ol><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>切出时, 必须保存该进程目前的环境.切入时,必须加载先前的环境</p><p>使用 PCB(Processing Control Block, 进程表,进程控制块) 来储存进程的环境</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/4.jpg" alt=""></p><h4 id="进程调度队列"><a href="#进程调度队列" class="headerlink" title="进程调度队列"></a>进程调度队列</h4><p>这一块没听 似乎是调度队列包括以下三种</p><ol><li>Job queue 系统中所有进程的队列</li><li>Ready queue 主存中所有进程的队列, 拿到CPU就跑的那种</li><li>Device queues 等待IO设备的进程队列</li></ol><h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><p>包括:</p><ol><li>进程管理数据<ul><li>寄存器</li><li>PC</li><li>状态字 PSW </li><li>进程状态</li><li>优先级</li><li>调度算法参数</li><li>进程ID</li><li>父进程ID</li><li>组进程ID</li><li>信号量</li><li>进程开始时间</li><li>进程已用时间</li><li>子进程已用时间</li><li>……</li></ul></li><li>内存管理数据<ul><li>指向本进程代码段指针</li><li>指向本进程数据段指针</li><li>指向本进程堆栈段指针</li></ul></li><li>文件管理数据<ul><li>根目录</li><li>工作目录</li><li>文件描述符</li><li>……</li></ul></li></ol><p>以上全部不用记🐶 下面的要记住(精简版)</p><blockquote><ol><li>Process state                 进程状态 </li><li>Program counter 程序计数器 </li><li>CPU registers CPU寄存器</li><li>CPU scheduling information CPU调度信息</li><li>Memory-management information  内存管理信息 </li><li>Accounting information 计账信息</li><li>I/O status information I/O状态信息</li></ol></blockquote><hr><h1 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h1><p>在本小节会涉及到：</p><ol><li>了解进程切换中的缺陷（时空开销过大），并由此引入线程的概念及用途</li><li>了解线程资源的私有与共享（有助于解决上一点的缺陷）, 并认识线程的优势</li><li>几种线程的实现方式及区别<ol><li>Kernel-level Thread   (内核级线程)</li><li>User-level Thread     (用户级线程)</li><li>Hybrid Thread         (混合式线程)</li><li>Pop-up Thread         (弹出式线程)</li></ol></li></ol><h2 id="线程的引入及概念"><a href="#线程的引入及概念" class="headerlink" title="线程的引入及概念"></a>线程的引入及概念</h2><p>你看进程之间切换是不是要保存好多东西,时空开销过大. 线程是轻量级的进程, 它拥有的环境没有进程那么多, 所以线程间的切换更加轻便.</p><ul><li>进程是为了避免等待IO的时间, 线程是为了缩短进程切换中的浪费的时间</li><li>线程是隶属于某一进程, 或者说<em>( traditional or heavyweight )</em>进程是仅有一个线程的进程</li><li>但是线程还是有必要的环境的</li><li>同一个进程的不同线程(兄弟线程)可以共享一部分资源</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/5.jpg" alt="进程与线程5"></p><p>如上图, a图中每个进程都拥有一个线程, 这些线程拥有不同的地址空间. b图进程拥有3个线程, 共享一个进程地址.因此线程之间的切换会更加轻量.</p><p>但是也由于线程之间没有数据保护, 所以要防止线程间相互修改数据.</p><h2 id="进程资源的私有与共享"><a href="#进程资源的私有与共享" class="headerlink" title="进程资源的私有与共享"></a>进程资源的私有与共享</h2><p>对于同一个进程的不同线程(兄弟线程)来说:</p><h3 id="共享的items"><a href="#共享的items" class="headerlink" title="共享的items"></a>共享的items</h3><ol><li>地址空间</li><li>全局变量</li><li>文件流</li><li>子进程</li><li>Pending alarm (这是什么?)</li><li>信号量</li><li>记账信息( Accounting information)</li></ol><h3 id="私有的items"><a href="#私有的items" class="headerlink" title="私有的items"></a>私有的items</h3><ul><li>PC</li><li>寄存器(集)</li><li>堆栈空间</li><li>线程状态</li></ul><blockquote><p>When a multithreaded process is run on a single-CPU system, the threads take turns running</p><p>多线程运用在单核CPU上时并不能提升性能,反而因为线程切换而牺牲效率</p></blockquote><p>此处存疑: 无论单核多核, 线程切换不是总比进程切换高效吗?</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>与进程一致:</p><ol><li>running</li><li>blocked</li><li>ready</li><li>terminated</li></ol><p>我也不知道为什么没有new态, 可能太快忽略不计? ┑(￣Д ￣)┍</p><h2 id="线程的优劣及应用场景"><a href="#线程的优劣及应用场景" class="headerlink" title="线程的优劣及应用场景"></a>线程的优劣及应用场景</h2><p>优势:</p><ul><li>占用空间小,切换时快捷</li><li>划分的资源少, 创建销毁更加容易</li><li>线程常被用于多核CPU</li></ul><p>应用场景:</p><ul><li>同时需要IO与处理的进程(eg 文字处理)</li><li>大型服务器回应用户请求.  作业小而多</li></ul><h2 id="不同级别的线程"><a href="#不同级别的线程" class="headerlink" title="不同级别的线程"></a>不同级别的线程</h2><h3 id="User-level-Thread"><a href="#User-level-Thread" class="headerlink" title="User-level Thread"></a>User-level Thread</h3><p>用户级线程.</p><p>对于线程的控制, 资源的分配都是由进程自己掌控. </p><p>从内核角度, 系统只知进程, 感知不到其线程的存在.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/7.jpg" alt="线程模型6"></p><p>优点</p><ul><li>可以在不支持线程的OS上实现线程.<ul><li>OS管理进程表, 进程本身管理线程表</li><li>管理效率更高, 相比内核管理时更少的函数调用</li></ul></li><li>不同进程的线程调度算法可以采取不同策略</li><li>大大简化了内核的管理压力(需要管理的大量线程托付给进程管理了)</li></ul><h3 id="Kernel-level-Thread"><a href="#Kernel-level-Thread" class="headerlink" title="Kernel-level Thread"></a>Kernel-level Thread</h3><p>内核级线程</p><p>线程还是属于进程, 但是线程的管理有OS负责</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/8.jpg" alt="待配图7"></p><p>优点</p><ul><li><p>内核管理全部的线程, 调度地更加灵活</p><p>指: A进程的A1线程阻塞后, OS可以切换至A2线程 或B进程中的B1线程</p><p><del>但是这不就是进程切换了吗哪儿是优点了啊喂</del>!</p></li></ul><h3 id="Hybrid-Thread"><a href="#Hybrid-Thread" class="headerlink" title="Hybrid Thread"></a>Hybrid Thread</h3><p>混合级线程</p><p>待配图</p><p>就是一部分用户级一部分内核级</p><p><del>其实我也没觉得好哪了</del></p><p>优点</p><ul><li>将用户级 内核级的优势相结合<ul><li>内核级的模仿(mimic?)功能            //存疑 没懂想表达什么</li><li>用户级的性能</li></ul></li><li>避免不必要的用户-内核转换</li><li>Kernel assigns virtual processors to each process //存疑 没懂</li></ul><h3 id="Pop-up-Thread"><a href="#Pop-up-Thread" class="headerlink" title="Pop-up Thread"></a>Pop-up Thread</h3><p>弹出式线程</p><p>每当一个新消息(指外界请求)进入时, 进程弹出线程解决, 解决后销毁进程.</p><p>适用于类批处理任务, 如大型服务器回应用户请求.  作业小而多</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/10.jpg" alt="配图10"></p><p>优势</p><ul><li>线程即用即弃, 没有切换, 也无需保存历史数据</li></ul><h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><p>在本小节会涉及到：</p><ol><li>调度的概念<ol><li>CPU密集型与IO密集型作业</li><li>调度的目的</li><li>什么时候需要调度？</li><li>调度算法的目标（不同OS下目标有差异）</li></ol></li><li>不同系统下常见的调度算法<ol><li>批处理系统 (Batch SystemSs)<ol><li>First-come first-served        (FCFS,先来先服务)</li><li>Shortest job first             (SJF,短作业优先)</li><li>Shortest remaining time first (SRTF,最短剩余时间优先)</li></ol></li><li>交互式系统 (Interactive Systems)<ol><li>Round Robin                    (RR,时间片轮转)</li><li>Priority<ol><li>Statically Priority         (静态优先级)</li><li>Dynamically Priority        (动态优先级)</li></ol></li><li>Shortest Process Next          (SPN, 最短进程优先)</li><li>Others</li></ol></li><li>实时操作系统 (Real-Time Systems)<ol><li>可调度性</li></ol></li></ol></li><li>关于线程调度的一些补充</li></ol><p>需要说明的是，虽然进程调度与线程调度是两种东西，但算法的核心思想是一致的，这里不过分区分。</p><h2 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h2><h3 id="CPU密集型任务与IO密集型任务"><a href="#CPU密集型任务与IO密集型任务" class="headerlink" title="CPU密集型任务与IO密集型任务"></a>CPU密集型任务与IO密集型任务</h3><p>如果一个任务更多地需要CPU资源 (例如Matlab, 大量的运算) 我们称之为CPU密集型任务.</p><p>如果一个任务更多地需要IO资源 (例如Word的打印任务(外设), 读写任务(外存)) 我们称之为CPU密集型任务.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200608155404.jpg" alt="不同的任务种类"></p><h3 id="调度的目的"><a href="#调度的目的" class="headerlink" title="调度的目的"></a>调度的目的</h3><p>还是考虑单核CPU, 在多道程序(即多个进程同时”工作”) 的情况下, 会出现不同进程同时需要CPU的情况. 这时候CPU的资源就需要合理分配.</p><h3 id="什么时候需要调度"><a href="#什么时候需要调度" class="headerlink" title="什么时候需要调度?"></a>什么时候需要调度?</h3><ol><li>新进程的创建</li><li>进程的退出</li><li>某进程需要IO操作,</li><li>IO设备申请CPU中断 (称之为IO中断)</li></ol><h3 id="调度的几个原则"><a href="#调度的几个原则" class="headerlink" title="调度的几个原则"></a>调度的几个原则</h3><p>我们希望什么样的调度算法?</p><h4 id="All-System"><a href="#All-System" class="headerlink" title="All System"></a>All System</h4><ol><li><p>公平</p><p>公平, 公平. 还是tmd公平</p></li><li><p>强制</p><p>策略的调度必须被强制执行</p></li><li><p>平衡</p><p>能够使系统中的各部件都保持busy</p></li></ol><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><ol><li><p>吞吐量</p><p>每小时工作数</p></li><li><p>周转时间</p><p>单次作业开始结束间的时间</p></li><li><p>CPU利用率</p><p>保持CPU始终忙碌</p></li></ol><h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><ol><li><p>响应时间</p><p>快速回应用户请求</p></li><li><p>均衡性</p><p>满足用户请求</p></li></ol><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><ol><li><p>满足deadline</p><p>保证时效性</p></li><li><p>可预测性?</p></li></ol><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="批处理系统-1"><a href="#批处理系统-1" class="headerlink" title="批处理系统"></a>批处理系统</h3><h4 id="FCFS-First-come-first-served"><a href="#FCFS-First-come-first-served" class="headerlink" title="FCFS (First-come first-served )"></a>FCFS (First-come first-served )</h4><p>字面意思  不解释</p><p><strong>优势</strong>:</p><p>便于实现, 绝对平等</p><p><strong>缺点:</strong></p><p>低CPU利用率</p><h4 id="Shortest-Job-First-短作业优先"><a href="#Shortest-Job-First-短作业优先" class="headerlink" title="Shortest Job First (短作业优先)"></a>Shortest Job First (短作业优先)</h4><p><strong>优势:</strong></p><p>提高了CPU利用率</p><p><strong>劣势:</strong></p><p>对长作业不利</p><h4 id="Shortest-remaining-time-next-剩余时间最短优先"><a href="#Shortest-remaining-time-next-剩余时间最短优先" class="headerlink" title="Shortest remaining time next 剩余时间最短优先"></a>Shortest remaining time next 剩余时间最短优先</h4><h3 id="交互式系统-1"><a href="#交互式系统-1" class="headerlink" title="交互式系统"></a>交互式系统</h3><h4 id="Round-Robin-时间片轮转"><a href="#Round-Robin-时间片轮转" class="headerlink" title="Round Robin (时间片轮转)"></a>Round Robin (时间片轮转)</h4><ul><li>每个进程被分配时设置固定的时间轮片</li><li>时间片用完或进程结束, 发生调度</li></ul><p>时间片大小的设置</p><ul><li>过短, CPU将浪费大量时间在频繁的切换上</li><li>过长, 退化成FCFS算法</li></ul><h4 id="Priority-scheduling-优先级调度"><a href="#Priority-scheduling-优先级调度" class="headerlink" title="Priority scheduling (优先级调度)"></a>Priority scheduling (优先级调度)</h4><p>算法思想:</p><ol><li>优先调度优先级高的</li><li>又优先级相同时, 采用其他算法(如FCFS)</li></ol><p>优先级:</p><ul><li>静态优先级, 优先级被确立后不改变</li><li>动态优先级, 变化</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200608155437.jpg" alt=""></p><h4 id="Shortest-process-next-最短进程"><a href="#Shortest-process-next-最短进程" class="headerlink" title="Shortest process next (最短进程)"></a>Shortest process next (最短进程)</h4><p>SJF算法更加适用于批处理系统, 因为每次的任务费时都是确定的.</p><p>Q : 对于交互式系统, 如何预估工作的用时?</p><p>A : 根据其过往表现估算</p><script type="math/tex; mode=display">T_n = \alpha T_NaN + (1-\alpha)T_NaN</script><p>如果 <code>α = 1/2</code> ,那么预估时间为:</p><script type="math/tex; mode=display">T_0\\\frac{T_0}{2}+\frac{T_1}{2}\\\frac{T_0}{4}+\frac{T_1}{4}+\frac{T_2}{2}\\\frac{T_0}{8}+\frac{T_1}{8}+\frac{T_2}{4}+\frac{T_3}{2}</script><h4 id="其他调度算法"><a href="#其他调度算法" class="headerlink" title="其他调度算法"></a>其他调度算法</h4><ol><li><p>多级队列调度</p></li><li><p>确保(部分任务)调度</p></li><li><p>Lottery Scheduling </p><p>乐透调度, 彩票调度 随机</p></li><li><p>Fair-share Scheduling</p><p>考虑进程所属的用户</p></li></ol><h3 id="实时系统-1"><a href="#实时系统-1" class="headerlink" title="实时系统"></a>实时系统</h3><h4 id="系统的可调度性"><a href="#系统的可调度性" class="headerlink" title="系统的可调度性"></a><strong>系统的可调度性</strong></h4><p>假设某一时刻系统有 $m$ 个事件,每个事件 $i$ 需要在 $P_i$ 内完成,需要占据CPU的 $C_i$ 秒来实现<br>倘若满足</p><script type="math/tex; mode=display">\qquad \sum^{m}_{i=1}\frac{C_i}{P_i}\leq1\\</script><p>称此时系统是可调度的 (Schedulable)</p><h2 id="关于线程调度的一些补充"><a href="#关于线程调度的一些补充" class="headerlink" title="关于线程调度的一些补充"></a>关于线程调度的一些补充</h2><p>用户级线程:</p><p>OS把时间片分配给进程, 进程再内部分配到每个线程.</p><h2 id="关于调度的其他补充"><a href="#关于调度的其他补充" class="headerlink" title="关于调度的其他补充"></a>关于调度的其他补充</h2><ul><li><p>调度算法还有 抢占式/非抢占式之分</p></li><li><p>进程调度模块负责专业CPU控制权,包括:</p><ul><li>切换上下文</li><li>切换到用户态</li><li>跳转到程序适当位置并运行之</li></ul></li><li><p>算法的性能参数</p><ul><li><p>CPU利用率    (max)</p></li><li><p>Throughput  (min)</p><p>每个时间单元内进程完成的数目</p></li><li><p>周转时间  (min)</p></li><li><p>等待时间  (min)</p></li><li><p>响应时间  (min)</p></li></ul></li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200608155420.jpg" alt="用户线程调度"></p><p>系统级线程</p><p>OS直接把时间片分配到线程.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200608155427.jpg" alt="系统线程调度"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章节包括三个小节&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程 (Processes)&lt;/li&gt;
&lt;li&gt;线程 (Threads)&lt;/li&gt;
&lt;li&gt;调度 (Scheduling)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hello_Hexo_Blog</title>
    <link href="http://yoursite.com/2020/05/31/Hello-Hexo-Blog/"/>
    <id>http://yoursite.com/2020/05/31/Hello-Hexo-Blog/</id>
    <published>2020-05-31T05:53:07.000Z</published>
    <updated>2020-06-05T09:01:50.723Z</updated>
    
    <content type="html"><![CDATA[<p> 第一篇博客~ 开心</p><a id="more"></a><h3 id="简单记录一下搭建过程"><a href="#简单记录一下搭建过程" class="headerlink" title="简单记录一下搭建过程"></a>简单记录一下搭建过程</h3><p>博客基于<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo框架</a> + Github，域名当然是阿里云了 （6元一年他不香吗hhh）</p><p>感谢舍友 <a href="https://www.117503445.top/" target="_blank" rel="noopener">@117503445</a> 指名了博客搭建的主要方向，搭建过程中主要参考了知乎用户 @吴润 的<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">这篇文章</a>，基本很顺畅地搭建起来了，一并致谢。</p><ol><li>安装并配置Node.js</li><li>安装 Hexo 框架</li><li>关联 Github 仓库</li><li>申请域名并绑定</li><li>发布第一篇博客</li></ol><h3 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h3><p>现在只是把房子搭起来还没有装修啥啊，让俺接着去学一学~</p><p>[x] 更换 Hexo 主题</p><p>[x] 熟悉博客的发布修改标签等功能</p><p>[ ] 建立图床</p><p>[ ] 增加其他的小插件 ~~</p><h3 id="分类设置"><a href="#分类设置" class="headerlink" title="分类设置"></a>分类设置</h3><ul><li>学习笔记    | 系统性的学习<ul><li>专业课<ul><li>操作系统</li></ul></li></ul></li><li>技术小记    | 碎片化知识</li><li>生活随笔<ul><li>山与水    | 游记</li><li>书与影    | 书评影评</li><li>时与光    | 定期总结</li></ul></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 第一篇博客~ 开心&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术小记" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
