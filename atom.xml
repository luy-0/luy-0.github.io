<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>(ﾟ∀。)</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-21T16:12:54.874Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LUY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>山与水-漫步秦岭之雪中光头峰</title>
    <link href="http://yoursite.com/2020/10/21/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E9%9B%AA%E4%B8%AD%E5%85%89%E5%A4%B4%E5%B3%B0/"/>
    <id>http://yoursite.com/2020/10/21/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E9%9B%AA%E4%B8%AD%E5%85%89%E5%A4%B4%E5%B3%B0/</id>
    <published>2020-10-21T15:31:18.000Z</published>
    <updated>2020-10-21T16:12:54.874Z</updated>
    
    <content type="html"><![CDATA[<p>2020年10月17日</p><p>公里数14.69KM,海拔2838M</p><a id="more"></a><p>国庆收假以来一直是阴雨连绵的天气,真是烦死人了. 衣服晒不干, 裤脚又容易沾的满是泥点子.好不容易熬来一个晴天, 又准备去光头山上, 看看雪后初霁.</p><p>注：下图是在光头山拍的别的山头，右边是鹿角梁</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E8%BF%9C%E6%99%AF.jpg" alt=""></p><h2 id="雪"><a href="#雪" class="headerlink" title="雪"></a>雪</h2><p>万万万万没想到失策了。雪倒是看到了，初霁也差不多，结果两者相遇，山上本来就薄薄的一层积雪全化成雪水，沿着山间的各个角落流下。倘若只是山泉泛滥，小溪充盈也罢，麻烦的是脚下的土路表面也湿哒哒地黏脚，泥泞之处也不在少数。</p><p>对了，其实也有不少地方，平日里只是涓涓细流，今天全成了一道道小瀑布。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E6%B3%89%E6%B0%B4.jpg" alt=""></p><h2 id="路"><a href="#路" class="headerlink" title="路"></a>路</h2><p>可分为三段：最初坡度尚可，道路隐约有些湿滑，由山脚葱郁到落叶青黄相间，铺在地上，虽然没有学校的银杏地毯好看，也是很养眼；中间一段来回穿过小竹林，非得弯腰低头才能穿过，稍有不小心竹枝便抽打在脸上，生疼。竹林也就算了，最讨厌的是带刺的灌木，扎进手指非流血不可；最后上了雪线，周遭只剩下低矮的草甸和零星的松树，遥望山顶的红房子真是遥不可及，雪落的很深，能没过脚面，难走。</p><p>大雪压青松，青松挺且直</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E6%9D%BE%E6%A0%91.jpg" alt=""></p><p>层林尽染</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E5%B1%B1%E6%99%AF.jpg" alt=""></p><h2 id="石"><a href="#石" class="headerlink" title="石"></a>石</h2><p>光头山虽然本身景色不佳，但山顶的几块石头是真出片。会当凌绝顶，一览众山小！</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E7%9F%B3%E5%A4%B43.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E7%9F%B3%E5%A4%B41.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E7%9F%B3%E5%A4%B42.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年10月17日&lt;/p&gt;
&lt;p&gt;公里数14.69KM,海拔2838M&lt;/p&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭##可选" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD-%E5%8F%AF%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成之流水线</title>
    <link href="http://yoursite.com/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <id>http://yoursite.com/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF/</id>
    <published>2020-10-09T07:46:46.000Z</published>
    <updated>2020-10-11T03:02:08.283Z</updated>
    
    <content type="html"><![CDATA[<ul><li>流水线概述<ul><li>定义与原理</li><li>时空图表示</li><li>分类</li></ul></li><li>流水线性能<ul><li>吞吐率</li><li>加速比</li><li>效率</li></ul></li><li>相关<ul><li>相关的定义</li><li>结构相关</li><li>数据相关</li><li>控制相关</li><li>中断</li><li>处理</li></ul></li><li>指令级并行</li><li>其他技术</li></ul><a id="more"></a><h2 id="流水线概述"><a href="#流水线概述" class="headerlink" title="流水线概述"></a>流水线概述</h2><h3 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h3><p>定义: 将一重复的处理过程分解为若干子过程，每个 子过程都可有效地在其专用功能段上与其它子 过程同时执行，这种技术称为流水线技术.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E6%B4%97%E8%A1%A3%E5%BA%971.png" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E6%B4%97%E8%A1%A3%E5%BA%972.png" alt=""></p><ul><li>在流水线中, 单个任务的时间并没有缩短，但多个任务是并行处理的.因此可以提高吞吐率； </li><li>流水线速度限制于最慢流水站的速度</li><li>理论上, 流水线技术的最大加速比=流水站数</li></ul><ul><li>流水过程由多个相关的子过程组成，这些子过程称为流水线的“级”或“段”。段的数目称为流水线 的“深度”。 </li><li>每个子过程由专用的功能段实现，各功能段的时间 应基本相等</li><li>流水线需要经过一定的通过时间才能稳定,因此适合于大量重复的时序过程</li></ul><h3 id="时空图"><a href="#时空图" class="headerlink" title="时空图"></a>时空图</h3><p>时空图是用于描述流水线技术的一种表示图. 从时间和空间两个方面描述流水线的工作过程，横坐 标表示时间，纵坐标表示各流水段。</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E6%97%B6%E7%A9%BA%E5%9B%BE-%E6%A0%B7%E4%BE%8B.png" alt=""></p><h3 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h3><h4 id="单功能流水线-多功能流水线"><a href="#单功能流水线-多功能流水线" class="headerlink" title="单功能流水线 / 多功能流水线"></a>单功能流水线 / 多功能流水线</h4><ul><li><p>单功能流水线，是指只能完成一种固定功能的流水 线。</p></li><li><p>多功能流水线，是指各段可以进行不同的连接，从 而完成不同的功能</p></li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/TIASC.png" alt=""></p><p>例如 TI ASC多功能流水线 可以选择部分段来实现浮点相加或定点相乘功能</p><h3 id="静态流水线-动态流水线"><a href="#静态流水线-动态流水线" class="headerlink" title="静态流水线 \ 动态流水线"></a>静态流水线 \ 动态流水线</h3><ul><li><p>静态流水线，是指在同一时间内，流水线的各段 只能按同一种功能的连接方式工作。 </p></li><li><p>动态流水线，是指在同一时间内，当某些段正在实现某种运算时，另一些段却在实现另一种运算。 它会使得流水线控制变得复杂</p></li></ul><p>　在静态流水线中,同一时间内它只能以一种功能方式工作.它可以是单功能的,也可以是多功能的.当是多功能流水线时,则从一种功能方式变为另一种功能方式时,必须先排空流水线,然后为另一种功能设置初始条件后方可使用.显然,不希望这种功能的转换频繁的发生,否则将严重影响流水线的处理效率.</p><p>　　动态流水线则允许在同一时间内将不同的功能段连接成不同的功能子集(前提条件是功能部件的使用不发生冲突),以完成不同的运算功能.显然, <u>动态流水线必是多功能流水线,而单功能流水线则必是静态的</u>.</p><ul><li>动态流水线首先需要是多功能流水线.</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt=""></p><p>如图所示, 动态流水线可以在同一时间进行两种不同的功能. </p><h3 id="部件级-处理机级-处理机间级-流水线"><a href="#部件级-处理机级-处理机间级-流水线" class="headerlink" title="部件级 / 处理机级 / 处理机间级 流水线"></a>部件级 / 处理机级 / 处理机间级 流水线</h3><p>这类划分是根据流水线的级别的划分, 从上往下由精细到宏观</p><ul><li><p>部件级流水线，又叫运算操作流水线，是把处理机 的算术逻辑部件分段，使得各种数据类型的操作能 够进行流水。 </p><p>例如我们上面涉及到的关于浮点运算的流水想. 把单个运算再细分</p></li><li><p>处理机级流水线，又叫指令流水线，是把解释指令的过程按照流水方式处理。 </p><p>例如 把一条指令的运行分为 取指,取数,执行 三阶段</p></li><li><p>处理机间流水线，又叫宏流水线，是由两个以上的 处理机串行地对同一数据流进行处理，每个处理机 完成一项任务</p><p>例如, 处理器A负责图像的采集, 处理器B负责图像的压缩, 处理器C负责图像的储存. 这种流水线更偏向于宏观层面</p></li></ul><h3 id="线性流水线-非线性流水线"><a href="#线性流水线-非线性流水线" class="headerlink" title="线性流水线 / 非线性流水线"></a>线性流水线 / 非线性流水线</h3><ul><li>线性流水线是指流水线的各段串行连接，没有反馈回路</li><li>非线性流水线是指流水线中除有串行连接的通路外，还有反馈回路</li></ul><hr><h2 id="流水线的性能"><a href="#流水线的性能" class="headerlink" title="流水线的性能"></a>流水线的性能</h2><h3 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h3><p>吞吐率是指单位时间内流水线所完成的任务数或 输出结果的数量。</p><ul><li>最大吞吐率 TP max 是指流水线在达到稳定状态后 所得到的吞吐率。 </li><li>设流水线由m段组成，完成n个任务的吞吐率称 为 实际吞吐率，记作TP</li></ul><h4 id="最大吞吐率"><a href="#最大吞吐率" class="headerlink" title="最大吞吐率"></a>最大吞吐率</h4><script type="math/tex; mode=display">假设流水线各段的时间相同,均为\Delta t, 则\\\\TP_{max} = 1/\Delta t_0\\\\假设流水线各段的时间不同,第i段时间为\Delta t_i, 则\\\\TP_{max} = 1/max\{\Delta t_i\}</script><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/TPmax.png" alt=""></p><p>图(a) 表示各段的时间相同的流水线, 图(b)表示各段时间不等的流水线.</p><ul><li>由此可见, 最大吞吐率率取决于流水线中最慢一段所需的时间，该段成为流水线的瓶颈</li><li>消除瓶颈的方法主要有:  细分瓶颈段 重复设置瓶颈段</li></ul><p>图为: 细分瓶颈段</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E7%BB%86%E5%88%86%E7%93%B6%E9%A2%88.png" alt=""></p><p>图为: 重复设置瓶颈段</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E9%87%8D%E5%A4%8D%E7%93%B6%E9%A2%88%E6%AE%B5.png" alt=""></p><h4 id="实际吞吐率"><a href="#实际吞吐率" class="headerlink" title="实际吞吐率"></a>实际吞吐率</h4><p>若各段时间相等</p><script type="math/tex; mode=display">若各段时间相等（假设均为 Δt_0 ),则完成时间 \\T_{流水}=m\Delta t_0+(n-1)\Delta t_0\\其中,前一项表示流水线完全启动的时间.后一项表示剩下的工作时间,因此:\\TP=\frac n T_{流水} = \frac n {m\Delta t_0+(n-1)\Delta t_0} = \frac 1 {(1 + \frac {m-1} n)\Delta t_0} = \frac {TP_{max}} {1 + \frac {m-1} n}</script><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/T%E6%B5%81%E6%B0%B4.png" alt=""></p><p>若各段时间不等</p><script type="math/tex; mode=display">若各段时间不等（假设为 Δt_i ),则完成时间 \\T=\sum^m _{i=1}\Delta t_i+(n-1)\times max\{\Delta t_i\}\\其中,前一项表示流水线完全启动的时间.后一项表示剩下的工作时间,因此:\\TP=\frac n T = \frac n {\sum^m _{i=1}\Delta t_i+(n-1)\times max\{\Delta t_i\}}</script><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/TP2.png" alt=""></p><h3 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h3><p>加速比是指流水线速度与等功能的非流水线速度之比。 </p><script type="math/tex; mode=display">加速比 S = \frac {T_{非流水}} {T_{流水}}</script><p>各段时间相等的流水线:</p><script type="math/tex; mode=display">若流水线为m段，每段时间均为 \Delta t_0\\ T_{非流水}=nm\Delta t_0,T_{流水}=m\Delta t_0+(n-1)\Delta t_0\\ S =\frac {T_{非流水}} {T_{流水}}=\frac {nm} {m+(n-1)}=\frac m {1+\frac {m-1} n}\\ 由此可见,n\gg m时,S\approx m</script><p>各段时间不相等的流水线带入上上个公式即可</p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>效率指流水线的<strong>设备利用率</strong>。 </p><p>画出时空图, 然后数格子</p><script type="math/tex; mode=display">E=\frac {n个任务占用的时空区} {m个段总的时空区}</script><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E6%95%88%E7%8E%87.png" alt=""></p><p>例如, 上图的效率为 </p><script type="math/tex; mode=display">E = \frac {紫色格子数目} {总的格子数目} = \frac {n} {n+(m-1)}</script><p>当然, 应当比较的是面积, 这里由于每个格子面积相同故略去.</p><ul><li>流水线并不能减少（而且一般是增加）单条指令 的执行时间，但能够提高吞吐率 </li><li>增加流水线的深度可以提高流水线性能 </li><li>流水线深度受限于流水线的延迟和额外开销 </li><li>需要用高速锁存器作为流水线寄存器 </li><li>指令之间存在的相关，限制了流水线的性能</li></ul><h2 id="流水线中的相关"><a href="#流水线中的相关" class="headerlink" title="流水线中的相关"></a>流水线中的相关</h2><ul><li><p>流水线中的相关是指相邻或相近的两条指令因存在 某种关联，后一条指令不能在原先指定的时钟周期 开始执行。</p></li><li><p>消除相关的基本方法——暂停<br>暂停流水线中某条指令及其后面所有指令的执行， 该指令之前的所有指令继续执行</p><p>显然, 暂停会降低吞吐率</p></li></ul><p>相关的类型 </p><ul><li>结构相关：当指令在重叠执行过程中，硬件资源 满足不了指令重叠执行的要求，发生资源冲突时 将产生“结构相关”。</li><li>数据相关：因一条指令需要用到前面指令的结果， 而无法与产生结果的指令重叠执行时，就发生了 “数据相关”。</li><li>控制相关：当流水线遇到分支指令和其它会改变 PC值的指令时就发生“控制相关”。</li></ul><h3 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h3><p>当指令在重叠执行过程中，硬件资源 满足不了指令重叠执行的要求，发生资源冲突时 将产生“结构相关”。例如，当一条指令正在从存储器中取出时，另一条指令恰好在将一个数据存储到存储器中，因两者都要访问存储器，故出现冲突</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>假定，4级指令流水线包括：取指、取数、运算和存数，各段时间均为△t.执行下面的<br>指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD MM,R1,R2</span><br><span class="line">SUB R3,R4,R5</span><br><span class="line">AND R7.R6.R10</span><br><span class="line">XOR R8,R9,R10</span><br></pre></td></tr></table></figure><p>在上图中的第四个时间点需要 <u>同时进行取指与存数操作</u>,而同一个存储区不能同时完成读操作和写操作.</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h4><p>结构竞争的原因是硬件不能满足重叠执行的要求. 于是我们可以: 1) 用更多硬件 2) 不重叠执行 3) 使硬件可以重叠执行</p><ol><li><p>增加资源副本</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/11/%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3.png" alt=""></p><p>例如上例: 可以设计一个数据存储器和一个指令存储器，这样，流水线的取指段与数据访存段就可以通过两个独立的通路同时访问两个独立的存储器了。</p></li><li><p>暂停(或延迟)流水线</p><p>通过延迟（或暂停）流水线的冲突段, 这被称作在流水线中插入气泡</p><p>气泡在流水线中只占资源不做实际操作. 显然会降低吞吐率</p><p>但是相对其他两个方法硬件成本更低</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/11/%E6%B0%94%E6%B3%A1.png" alt=""></p></li><li><p>改变资源以便它们并发使用</p><p>除上述措施外，在相邻近的指令间尽可能不使用相同的资源。例如，在相邻的m（流水线的段数）条指令中，不相关的数据尽量使用不同的寄存器。如果发生使用寄存器冲突时，可以通过程序再设计或寄存器重命名技术来改变寄存器资源，达到可以同时对期望的寄存器访问的目的。</p></li></ol><h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><p>当指令在流水线中重叠执行时，流水线有 可能改变指令读/写操作数的顺序，使之不 同于它们在非流水实现时的顺序，这将导 致数据相关。</p><h4 id="数据相关的分类"><a href="#数据相关的分类" class="headerlink" title="数据相关的分类"></a>数据相关的分类</h4><p>注: 分类是按照正常顺序</p><ol><li><p>写后读 RAW</p><p>如果先读后写, 那么读取的是错误的数据. 是最常见的数据相关.</p></li><li><p>写后写 WAW</p><p>如果后者先写,前者后写, 可能R中保存着错误的数据.</p></li><li><p>读后写 WAR</p><p>如果后者先写, 可能前者读出了错误数据. 但是这种相关很少发生</p></li><li><p>读后读 RAR</p><p>不会引起数据相关</p></li></ol><h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><ol><li><p>采用直通（forwarding）技术 </p><p>又名定向技术, 旁路, 短路</p><p>控制逻辑将前面指令的结果从其产生的地方直接连通到 当前指令所处的位置。</p></li><li><p>增加专用硬件</p><p>增加流水线互锁（pipeline interlock）硬件。互锁硬件先要 检测流水线中指令的数据相关性，当互锁硬件发现数据 相关时，使流水线工作停顿下来，直到相关消失为止。 </p></li><li><p>利用编译器 流水线调度/指令调度</p><p>编译器可以对指令重新排序或插 入空操作指令，使得加载任何冲突数据的操作被延迟， 但对程序逻辑或输出不受影响</p></li></ol><h3 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h3><p>当流水线遇到分支指令和其它会改变PC值的指令时 就发生“控制相关”</p><ul><li>无条件转移指令（如无条件跳转、调用、返回指令等）<ul><li>某些CPU（如 UltraSPARC l）：紧跟在无条件转移指令之后的指令必须执行。</li><li>另一些CPU：采取相对复杂的方法，如提前计算出转移目标地址</li></ul></li><li>条件分支转移指令（为零跳转、循环控制指令等）<ul><li>不仅需要延迟槽，而且一直到流水线的深处，取指单元才能知道到哪里去取下一条指令。</li><li>条件分支指令对流水线性能的影响远比无条件转移指令要大。</li></ul></li></ul><p>以下是针对条件分支指令的处理方法</p><h4 id="冻结流水线-freeze"><a href="#冻结流水线-freeze" class="headerlink" title="冻结流水线(freeze)"></a>冻结流水线(freeze)</h4><p>一旦在指令译码段检测到分支指令，就在转移目标地址确定之前保存或删除所有紧随分支指令之后的指令，当分支指令从执行段流出、确定出新的PC值时，流水线才继续依据新PC值填充流水线. <u>会严重地影响流水线的性能</u>。</p><h4 id="预取分支目标（-prefetch-branch-target）"><a href="#预取分支目标（-prefetch-branch-target）" class="headerlink" title="预取分支目标（ prefetch branch target）"></a>预取分支目标（ prefetch branch target）</h4><p>当条件分支指令被识别时，除了紧随其后的指令外，分支目标也被预取，并保存到分支指令被执行</p><p>如果分支跳转发生，已预取到的目标指令可立刻执行。</p><h4 id="多流"><a href="#多流" class="headerlink" title="多流"></a>多流</h4><p>有些系统采用在条件分支的两路上同时启动取指令操作，并将指令保存到分支指令被<br>实际执行的时候。分支指令执行时，“真”的执行通路即刻可以获得。这种方法是对预取分<br>支目标的发展。</p><h4 id="循环缓冲器"><a href="#循环缓冲器" class="headerlink" title="循环缓冲器"></a>循环缓冲器</h4><p>在许多处理器中，用循环缓冲器来解决分支程序引起的相关。循环缓冲器是一个容量很小、速度非常高的存储器。它保存着最近获取的n条顺序的指令，由流水线的取指段进行维护。如果分支发生，硬件首先检查分支目标是否在缓冲器中。如果在，下一条指令从缓冲器中获取。</p><ol><li>如果正常顺序运行, 那么就正常顺序运行</li><li>如果发生了分支. 那么在判断之后选择语句执行时, 要执行的语句已经录入缓冲器中, 可相比从内存中取指令更快. 此外, 这也表明<code>if..else..</code>语句性能优于<code>if..if..</code> 语句</li><li>特别是对于循环操作. 如果缓冲器够大, 那么只需要从内存中读取一次循环体的指令, 其余均从缓冲器中读出. 因此命名为循环缓冲器.</li></ol><p>循环缓冲器类似于指令 cache，差别是循环缓冲器仅保留顺序指令，且容量比 cache小得多，因此成本较低。</p><h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><p>为了降低分支指令引起断流（停顿）对流水线可能带来的影响，许多CPU提供了分支<br>预测机构。预测既可以在编译阶段静态完成，也可以由硬件在执行阶段动态完成。要做到<br>百分之百的正确预测几乎是不可能的，但采用分支预测必定能带来某些好处。</p><h4 id="静态分支预测"><a href="#静态分支预测" class="headerlink" title="静态分支预测"></a>静态分支预测</h4><p>静态分支预测是根据某种规则进行分支预测.</p><h5 id="预测分支不会发生"><a href="#预测分支不会发生" class="headerlink" title="预测分支不会发生"></a>预测分支不会发生</h5><p>预测分支不会发生也就是预测分支失败。如果一个程序中大多数条件分支指令是用于出错检测处理，那么采用这种预测机制是有利的，因为在正确合理的设计下，出现错误的概<br>率总是很小的。在这样的预测机制下，在知道分支结果之前，流水线流动着分支指令和紧随其后的指令。若分支预测失败，则正如所预期的那样，流水线照常执行；若分支成功，则要用空操作代替已取得的指令（例如清除执行段之前的各流水线段），并到目标地址重新取指令。</p><h5 id="预测分支总是成功"><a href="#预测分支总是成功" class="headerlink" title="预测分支总是成功"></a>预测分支总是成功</h5><p>如果一个程序中包含较多的循环，那么采用这种预测机制是有利的，因为n次循环仅有<br>次会出现分支转移失败。因此，该方法也称为预测分支成功法。在这样的预测机制下，<br>旦分支转移成功就可以开始从分支目标地址处取指令执行。</p><h5 id="由编译器进行预测"><a href="#由编译器进行预测" class="headerlink" title="由编译器进行预测"></a>由编译器进行预测</h5><p>当编译器看到循环语句<code>for（i=0；&lt;1000000计++）{…}</code>时，它就知道循环尾部的转移<br>几乎肯定会发生。如果能有办法让编译器把这一信息告诉硬件，将会节省大量的时间。但<br>是，使用这种技术会带来体系结构的变化，某些处理器中设计了一组新的条件转移指令，这些指令中有一位可以让编译器设置. 取值单元将根据这指令行动.</p><h5 id="剖面法"><a href="#剖面法" class="headerlink" title="剖面法"></a>剖面法</h5><p>剖面法是一种追踪程序执行状况加以预测的方法。它实际运行了该程序（一般是在模拟器上），以获得程序中不同分支指令发生转移的信息（比如概率），然后将这些信息送给编译器，编译器再使用特殊的条件转移指令来通知硬件该如何操作。</p><p>当静态分支预测错误时, 如何取消已经执行的指令?</p><ul><li>总是执行，结果保存在临时寄存器中。当得知预测成功时再复制至实际寄存器</li><li>将要被覆盖的寄存器的原值保存在临时寄存器中, 当得知预测失败时恢复</li></ul><h3 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h3><p>动态分支预测通过记录分支指令的近期运行的历史信息，并以此作为预测的依据，来提高分支预测的准确度。解决好动态预测的关键是如何记录历史信息和如何决定转移的走向</p><h3 id="延迟分支"><a href="#延迟分支" class="headerlink" title="延迟分支"></a>延迟分支</h3><ul><li><p>这种方法是利用编译器对指令代码进行重新排序，并插入有用指令或空操作指令<br>（NOP），使流水线尽可能保持充满状态。</p></li><li><p>其中心思想就是延迟分支的发生。</p></li><li><p>把分支指令延迟为长度为n的分支指令，其后紧跟有n个延迟槽，延迟槽中放有延迟分支需要执行的指令。流水线遇到分支指令时，按正常方式处理，同时执行延迟槽中的指令，分支延迟槽中的指令“掩盖”了流水线原来必须插入的停顿周期，从而减少分支开销。</p></li><li><p>编译器的任务就是在延迟槽中放入有用的指令，称为延迟槽调度。有三种常用的调度方法：</p><ul><li>从分支前调度</li><li>从目标出调度</li><li>从失败处调度</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/11/%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3.png" alt=""></p></li></ul><p>该方法有两个限制: </p><p>（1）放入延迟槽的指令需要满足一定的条件。<br>（2）编译器要有预测分支是否成功的能力。</p><p>剩下的先咕咕咕</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;流水线概述&lt;ul&gt;
&lt;li&gt;定义与原理&lt;/li&gt;
&lt;li&gt;时空图表示&lt;/li&gt;
&lt;li&gt;分类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流水线性能&lt;ul&gt;
&lt;li&gt;吞吐率&lt;/li&gt;
&lt;li&gt;加速比&lt;/li&gt;
&lt;li&gt;效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相关&lt;ul&gt;
&lt;li&gt;相关的定义&lt;/li&gt;
&lt;li&gt;结构相关&lt;/li&gt;
&lt;li&gt;数据相关&lt;/li&gt;
&lt;li&gt;控制相关&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;li&gt;处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令级并行&lt;/li&gt;
&lt;li&gt;其他技术&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="计算机组成" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机组成" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Java拾遗之基本类库</title>
    <link href="http://yoursite.com/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%BA%93/"/>
    <id>http://yoursite.com/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%BA%93/</id>
    <published>2020-10-08T08:14:15.000Z</published>
    <updated>2020-10-08T08:14:52.196Z</updated>
    
    <content type="html"><![CDATA[<p>第七章 Java基础类库<br>本节应当配备Java Document使用.<br>在线网址: <a href="https://docs.oracle.com/en/java/javase/index.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/index.html</a><br>下载地址: <a href="https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline" target="_blank" rel="noopener">https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline</a></p><ul><li>系统类System</li><li>字符串: String, StringBuffer, StringBuilder</li><li>Math类</li><li>Data与Calendar</li><li>正则表达式</li><li>日志</li></ul><a id="more"></a><h2 id="7-1-与用户交互"><a href="#7-1-与用户交互" class="headerlink" title="7.1 与用户交互"></a>7.1 与用户交互</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><ul><li>main函数的方法签名: <code>public static void main(String[] args){...}</code></li><li>main函数需要暴露给JVM调用,因此使用public修饰;</li><li>main函数在调用时直接通过主类静态调用,因此使用static修饰;</li><li>main函数没有返回值</li><li>main函数的参数可以在运行时指定.例如 <code>java ArgsTest hello world</code> 这里args数组为{“hello”,”world”}</li></ul><h3 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h3><ul><li>Scanner是一种基于正则表达式的文本扫描器. </li><li>hasNextXXX();</li><li>nextXXX();</li></ul><h2 id="7-2-系统交互"><a href="#7-2-系统交互" class="headerlink" title="7.2 系统交互"></a>7.2 系统交互</h2><ul><li>通过C语言实现Java的native方法: <a href="https://blog.csdn.net/hjh_walker/article/details/52439149" target="_blank" rel="noopener">https://blog.csdn.net/hjh_walker/article/details/52439149</a></li><li>可以通过System类访问操作系统的信息</li><li>可以通过Runtime类访问运行环境(JVM)的相关信息.</li><li>还可以通过Runtime类的静态方法exec()新建进程运行操作系统的命令.</li></ul><h2 id="7-3-常用类"><a href="#7-3-常用类" class="headerlink" title="7.3 常用类"></a>7.3 常用类</h2><ul><li>Object类是所有类,数组,枚举类的父类.Object提供了一些静态方法.(所有类都可以使用)</li><li>equals(Object obj); 判断对象是否相等. 这里判断是否是同一个对象(也就是针对地址的判断)</li><li>protected void finalize(); 垃圾回收器调用该方法来回收对象</li><li>getClass(); 返回对象的运行时类</li><li>int hashCode();默认情况下是根据对象的地址计算.但大多数类都重写了该方法.</li><li>toString();默认情况下返回 “类名+@+hashCode” 的值,往往需要对其重写.</li><li>protected clone();会返回一个当前对象的副本.这个方法只能被子类重写或调用.这种克隆更快,但是是浅克隆.</li><li><p>浅克隆:引用类型变量只复制地址; 深克隆:引用类型变量指向的对象也会被复制 参考:<a href="https://segmentfault.com/a/1190000022552883" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022552883</a></p></li><li><p>Java7 新增了一系列工具类.它们大多是空指针安全的.</p></li><li>这些工具类大多以”s”结尾.例如 <code>Objects</code>,<code>Arrays</code></li></ul><h2 id="7-4-字符串操作"><a href="#7-4-字符串操作" class="headerlink" title="7.4 字符串操作"></a>7.4 字符串操作</h2><ul><li>Java中的String是不可变的,直到对象被销毁.</li><li>StringBuffer 是一个字符序列可变的字符串.在操作完该字符序列后使用toSting()将其转换为String对象</li><li>StringBuilder 也代表可变字符串对象. 但Buffer是线程安全的,而Builder是非安全的. 因此Builder的性能更高.</li><li>charAt(); 用于读取字符串的下标.string 的其他方法不列出</li><li>StringBuilder 的常用方法: append(),insert(),delete(),reverse(),length(),capacity()</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第七章 Java基础类库&lt;br&gt;本节应当配备Java Document使用.&lt;br&gt;在线网址: &lt;a href=&quot;https://docs.oracle.com/en/java/javase/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.oracle.com/en/java/javase/index.html&lt;/a&gt;&lt;br&gt;下载地址: &lt;a href=&quot;https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统类System&lt;/li&gt;
&lt;li&gt;字符串: String, StringBuffer, StringBuilder&lt;/li&gt;
&lt;li&gt;Math类&lt;/li&gt;
&lt;li&gt;Data与Calendar&lt;/li&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;li&gt;日志&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/"/>
    
      <category term="Java拾遗" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/Java%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java拾遗之面向对象</title>
    <link href="http://yoursite.com/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-10-08T06:51:34.516Z</published>
    <updated>2020-10-08T07:00:20.145Z</updated>
    
    <content type="html"><![CDATA[<p>又开的新坑~ 目标是把平日里关于Java的学习到的碎片化知识先记录下来, 待日后回顾.</p><p>希望以后会回顾(逃)</p><p>目前在学习的是李刚老师的 <a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂JAVA讲义 (第四版)</a> </p><a id="more"></a><h2 id="第六章：面向对象（下）"><a href="#第六章：面向对象（下）" class="headerlink" title="第六章：面向对象（下）"></a>第六章：面向对象（下）</h2><ul><li>包装类：将基本类型封装成对象使用</li><li>final关键词</li><li>abstract：抽象类</li><li>interface：接口</li></ul><h3 id="6-1-包装类"><a href="#6-1-包装类" class="headerlink" title="6.1 包装类"></a>6.1 包装类</h3><ul><li>自动装箱/拆箱：基本类型与包装类型的直接转换</li><li>包装类的两类静态方法，用于操作string与类型的装换</li></ul><blockquote><p>parseXXX(string str);    将string类型转为XXX类型.例如<code>int a = parseInt(&quot;123&quot;);</code><br>valueOf(string str); 作用同上</p></blockquote><ul><li>String 包装类中也有将其他类型的转为string类的valueOf函数.例如<code>string a = String.valueOf(123.4);</code></li><li>或者可以直接 <code>string a = 123.4 + &quot;&quot; ;</code></li></ul><hr><ul><li>包装类是引用类型,但是直接与基本类型比较时会自动比较其值;但是两个包装类比较时依旧比较引用的对象是否是一个</li><li>不应当对两个装箱后的包装类比较.Integer包装类在初始化时会初始化-128~127的数组.所有被包装的,值在这个范围内的Integer对象指向的是堆中的同一个.但是不在这个范围内的对象指向的不是用一个对象.因此:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D; 2;</span><br><span class="line">Integer b &#x3D; 2;</span><br><span class="line">&#x2F;*这里a&#x3D;&#x3D;b,因为作为引用类型的变量,他们指向堆中的同一个地址(即Integer类被初始化时创建的那个数组)*&#x2F;</span><br><span class="line">Integer A &#x3D; 128;</span><br><span class="line">Integer B &#x3D; 128;</span><br><span class="line">&#x2F;*这里A!&#x3D;B,因为这是新创建的两个不同指向的引用类型的变量,尽管他们指向的地址所储存的值是一样的*&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>这么设置的原因是为了提前针对小值的Integer包装类对象进行缓存,提高性能</p></li><li><p>Java7 对所有的包装类提供了专门用于比较的静态方法compare.例如:<code>Integer.compare()</code>    //TODO:存疑:这个方法是用来比较基本类还是包装类的?还是说可以混合比较?</p></li><li>Java7对Character,Java8对包装类功能增强.</li></ul><hr><h3 id="6-2处理Object"><a href="#6-2处理Object" class="headerlink" title="6.2处理Object"></a>6.2处理Object</h3><ul><li><p>所有类都是Object类的子类</p></li><li><p>Object类中有toString()方法.他会在对象被打印时自动调用.用于自我描述,例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object p;</span><br><span class="line">&#x2F;*以下3行是等价的*&#x2F;</span><br><span class="line">System.out.println(p);</span><br><span class="line">System.out.println(p.toString());</span><br><span class="line">System.out.println(p + &quot;&quot;);</span><br></pre></td></tr></table></figure></li><li><p>基础的toString() 会返回 “类名+@+hashCode” 的值,可以并往往需要对其重写.通常会返回成类似”Apple[color=red,weight=5.6]”的字符串</p></li></ul><hr><ul><li><p>对于基本类型可以使用==进行相等判断,但是引用类型变量必须要指向相同地址时才会返回true.因此Object类提供了静态方法Object.equal(Object obj)</p></li><li><p>默认的equal方法依旧只比较该变量的地址(也就是和==一个效果),因此我们往往也会重写equal方法.该方法需要满足:自反性,对称性,传递性,一致性</p></li><li><p>JVM常量池保证相同的字符串直接量只有一个.</p></li></ul><h3 id="6-3-类成员与static"><a href="#6-3-类成员与static" class="headerlink" title="6.3 类成员与static"></a>6.3 类成员与static</h3><ul><li><p>类成员属于整个类,而非某个对象.被static修饰的就是类成员.</p></li><li><p>当类第一次被使用时,类成员(包括类变量与类方法)被加载,直到类不被使用而被垃圾回收.</p></li><li><p>可以通过类或类的实例对象来访问类成员,但这不代表类成员属于该实例对象.</p></li><li><p>静态初始化块也是类成员的一种, 一般是在类被初始化时执行该块.</p></li><li><p>类成员不能访问实例成员</p></li></ul><hr><ul><li>如果某种类仅允许拥有一个实例,它被称为单例(Singleton)</li><li>该类的构造器被修饰为private</li><li>该类需要提供一个静态方法来产生第一个实例(并且,如果以前产生过实例则返回先前产生的实例)</li><li>需要一个private static 的类变量储存曾经创建的实例(如果有)</li></ul><hr><h3 id="6-4-final"><a href="#6-4-final" class="headerlink" title="6.4 final"></a>6.4 final</h3><ul><li>被final修饰的变量不可被重新赋值.</li><li>final可以修饰成员变量(包括类变量与实例变量),也可以修饰局部变量.这两者有些许不同.</li></ul><h4 id="final修饰成员变量"><a href="#final修饰成员变量" class="headerlink" title="final修饰成员变量"></a>final修饰成员变量</h4><ul><li><p>final修饰类变量: 必需在静态初始化块,或声明类变量时指定初始值.且只能在二处之一指定初始值.</p></li><li><p>final修饰实例变量: 必需在非静态初始化块,或声明实例变量时, 或构造器中指定初始值.且只能在三处之一指定初始值.</p></li></ul><h4 id="final修饰局部变量"><a href="#final修饰局部变量" class="headerlink" title="final修饰局部变量"></a>final修饰局部变量</h4><ul><li><p>final修饰的局部变量可以在声明时不指定初始值.如果没有指定,则可以在后续代码中进行赋值,但只能赋值一次.</p></li><li><p>形参可以被final修饰,那么在函数体中该参数不能被赋值.</p></li><li><p>引用变量可以被final修饰,但是锁定的是该引用类型变量所指向的地址.引用的对象的成员变量的值依旧可以被改变.</p></li><li><p>一个在定义时就指定了初始值的final变量如果在编译时就可以确定初始值,那么它将起到类似宏替换的效果.</p></li></ul><h4 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h4><ul><li>被final修饰的方法无法被子类重写.例如Object类中的 getClass() 方法.</li><li>比较: 被private修饰的方法无法被子类访问; 另外注意区分重写与重载的区别.</li><li>被final和private同时修饰的方法可以在子类中被 “重写”. 但实质上是子类的新方法.并非真正意义上的重写.</li></ul><h4 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h4><ul><li>被final修饰的类无法有子类. 例如java.lang.Math类. </li><li>当子类继承父类时可以访问父类的内部数据,甚至可以重写父类方法.因此需要对该父类限制继承.</li></ul><h4 id="不可变类-immutable"><a href="#不可变类-immutable" class="headerlink" title="不可变类(immutable)"></a>不可变类(immutable)</h4><ul><li>创建出的该类的实例的实例变量是不可改变的.例如8个包装类以及java.lang.String类</li><li><p>TODO:自建不可变类的注意事项</p></li><li><p>由于被final修饰的引用变量依旧是可以改变的.因此直接包括引用变量的不可变类并不是真正的不可变. 可以在涉及到相关操作时创建新的匿名类来规避.</p></li></ul><h3 id="6-5-抽象类与abstract"><a href="#6-5-抽象类与abstract" class="headerlink" title="6.5 抽象类与abstract"></a>6.5 抽象类与abstract</h3><ul><li><p>抽象类必须使用abstract修饰.抽象方法也必须使用abstract修饰,并且不能有方法体.</p></li><li><p>抽象类中未必包括抽象方法.但包括抽象方法的类必须是抽象类.</p></li><li><p>抽象类不能有实体.不能被实例化.可以有构造器但不能被直接构造.(构造器用于被子类重写).</p></li><li><p>其子类需要实现父类的所有抽象类.否则,子类也是一个抽象类.</p></li><li><p>被abstract修饰的类只能被继承,而被final修饰的类不能被继承.因此这两个修饰符不能同时使用.</p></li><li><p>被abstract修饰的方法只能子类实现,而被static修饰的方法只能被该类调用.因此这两个修饰符不能同时修饰方法.但是可以同时修饰部类.</p></li></ul><p>TODO:接口</p><h3 id="6-9-枚举"><a href="#6-9-枚举" class="headerlink" title="6.9 枚举"></a>6.9 枚举</h3><ul><li><p>枚举是一种特殊的类.使用enum进行修饰.(该关键词与class,interface等价).一个java源文件只能有一个被public修饰的enum类.</p></li><li><p>枚举类默认继承java.lang.Enum类(而非Object类).因此枚举类不能显式继承其他父类.Enum提供了一些接口.</p></li><li><p>非抽象的enum类默认使用final修饰,因此不能派生子类.</p></li><li><p>枚举类的构造器只能使用private修饰.</p></li><li><p>枚举类的所有实例必须在第一行显式列出.</p></li><li><p>Enum 类中提供的一些接口:</p><ol><li>int compareTo(E o):用于与相同枚举类型的对象进行比较排序.若该对象位于o之后返回正整数,反之返回负整数或0.</li><li>String name() 与 String toString():都可以返回当前实例的名称.习惯上使用后者.</li><li>int ordinal(): 返回当前枚举实例的索引值(从0开始)</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又开的新坑~ 目标是把平日里关于Java的学习到的碎片化知识先记录下来, 待日后回顾.&lt;/p&gt;
&lt;p&gt;希望以后会回顾(逃)&lt;/p&gt;
&lt;p&gt;目前在学习的是李刚老师的 &lt;a href=&quot;https://book.douban.com/subject/3246499/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;疯狂JAVA讲义 (第四版)&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="驭龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/"/>
    
      <category term="Java拾遗" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A9%AD%E9%BE%99%E6%9C%AF/Java/Java%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题流水账2020-09</title>
    <link href="http://yoursite.com/2020/10/02/LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-09/"/>
    <id>http://yoursite.com/2020/10/02/LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-09/</id>
    <published>2020-10-02T13:21:59.000Z</published>
    <updated>2020-10-09T05:25:40.050Z</updated>
    
    <content type="html"><![CDATA[<p>刷完了初级题库, 对各分类的简单算法有了基础的认知</p><p>整理了一些STL的常用函数(不全面) </p><p>开始由C++专向Java</p><a id="more"></a><p>2020年8月22日 “再度”开始刷力扣</p><p>既然决定不读研就好好刷题学工程吧</p><p>每周七题以上. 如果遇到考试周等特别情况可以提前一周完成任务, 不得向后拖延.</p><h2 id="2020年9月1日-week1"><a href="#2020年9月1日-week1" class="headerlink" title="2020年9月1日-week1"></a>2020年9月1日-week1</h2><p>主题:链表+字符串</p><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="[141] 环形链表"></a>[141] 环形链表</h3><p>简单题</p><p>检测给出的链表中有没有环</p><p>第一下自己没有想出来, 看了题解. </p><p>方法1: 哈希表储存节点的出现次数———-只要定义的是<code>map&lt;listNode*, int&gt;</code> 就可以了.</p><p>方法2: 很巧妙, 快慢节点, 快每次走2步, 慢每次走1步. 如果有环快慢指针会相遇, 没有环则快指针会走到尽头.</p><p>注意: 方法2最后的判断应该是: <code>fNode != nullptr &amp;&amp; fNode-&gt;next != nullptr</code> 因为<code>fnode</code>每次走两步!</p><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="[344] 反转字符串"></a>[344] 反转字符串</h3><p>简单题</p><p>双指针, 左右端交换, 向中间靠拢</p><p>记得要 <code>i++, j--</code> ! 第二次忘了!</p><p>小技巧: 3次异或交换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s[left] ^&#x3D; s[right]</span><br><span class="line">s[right] ^&#x3D; s[left]</span><br><span class="line">s[left] ^&#x3D; s[right]</span><br></pre></td></tr></table></figure><p>即可实现两个元素交换,且不用花费额外空间,还快</p><p>此外还可以使用算法库中的 <a href="https://zh.cppreference.com/w/cpp/algorithm/reverse" target="_blank" rel="noopener">reverse(begin, end)</a></p><h2 id="2020年9月2日-week2"><a href="#2020年9月2日-week2" class="headerlink" title="2020年9月2日-week2"></a>2020年9月2日-week2</h2><p>主题: 字符串</p><h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="[7] 整数反转"></a>[7] 整数反转</h3><p>简单题(大概)</p><p>单看数据反转这个要求其实不难, x每次退栈个位数, re此时入栈. 问题在于涉及到溢出的判断.</p><p>这里考察了一下下对于数据储存的理解是否深刻. 见<a href="https://leetcode-cn.com/problems/reverse-integer/solution/hua-jie-suan-fa-7-zheng-shu-fan-zhuan-by-guanpengc/" target="_blank" rel="noopener">题解</a></p><p>此外, 在<code>limit.h</code>中储存的INT_MAX等数据</p><h2 id="2020年9月3日-week2"><a href="#2020年9月3日-week2" class="headerlink" title="2020年9月3日-week2"></a>2020年9月3日-week2</h2><p>主题:字符串</p><h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="[387] 字符串中的第一个唯一字符"></a>[387] 字符串中的第一个唯一字符</h3><p>简单题</p><p>解法一,hash+两次遍历,很容易想到</p><p>解法二,不借助hash 该字符第一次出现的位置和最后一次出现的位置一样，就证明不重复。</p><p>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">s.find_first_of(ch);<span class="comment">//返回索引,找不到返回-1</span></span><br><span class="line">s.find_last_of(ch);<span class="comment">//同上</span></span><br></pre></td></tr></table></figure><p>小优化: 无论字符串多长都只需要26次循环(常数级优化):</p><ol><li><p>若字符串长度&lt;26 同上</p></li><li><p>若&gt;26, 将26个字母遍历, 找到第一个出现一次的. </p></li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">    <span class="keyword">char</span> c = s[i];</span><br><span class="line">    <span class="keyword">int</span> pre = s.find_first_of(c);</span><br><span class="line">    <span class="keyword">if</span>(pre!=<span class="number">-1</span> &amp;&amp; pre==s.find_last_of(c))</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2020年9月4日-week2"><a href="#2020年9月4日-week2" class="headerlink" title="2020年9月4日-week2"></a>2020年9月4日-week2</h2><p>主题: 字符串</p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="[242] 有效的字母异位词"></a>[242] 有效的字母异位词</h3><p>Hash(数组也行) 几次遍历</p><p>为了检查 t 是否是 s 的重新排列，我们可以计算两个字符串中每个字母的出现次数并进行比较。因为 S 和 T 都只包含 A−Z 的字母，所以一个简单的 26 位计数器表就足够了</p><p>我们需要两个计数器数表进行比较吗？实际上不是，因为我们可以用一个计数器表计算 s 字母的频率，用 t 减少计数器表中的每个字母的计数器，然后检查计数器是否回到零。</p><h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="[125] 验证回文串"></a>[125] 验证回文串</h3><p>简单题 </p><p>回文是很熟悉的题型了, 双指针，栈，reverse都行. 这一题着重于String的一些API调用</p><p>以下这些函数定义在<code>&lt;string&gt;</code> 里</p><div class="table-container"><table><thead><tr><th>数值转换</th><th></th></tr></thead><tbody><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/basic_string/stol" target="_blank" rel="noopener">stoi  stol  stoll</a>(C++11)(C++11)(C++11)</td><td>转换字符串为有符号整数 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/basic_string/stoul" target="_blank" rel="noopener">stoul  stoull</a>(C++11)(C++11)</td><td>转换字符串为无符号整数 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/basic_string/stof" target="_blank" rel="noopener">stof  stod  stold</a>(C++11)(C++11)(C++11)</td><td>转换字符串为浮点值 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/basic_string/to_string" target="_blank" rel="noopener">to_string</a>(C++11)</td><td>转换整数或浮点值为 <code>string</code> (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/basic_string/to_wstring" target="_blank" rel="noopener">to_wstring</a>(C++11)</td><td>转换整数或浮点值为 <code>wstring</code> (函数)</td></tr><tr><td>范围访问</td><td></td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/iterator/begin" target="_blank" rel="noopener">begin  cbegin</a>(C++11)(C++14)</td><td>返回指向容器或数组起始的迭代器 (函数模板)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/iterator/end" target="_blank" rel="noopener">end  cend</a>(C++11)(C++14)</td><td>返回指向容器或数组结尾的迭代器 (函数模板)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/iterator/rbegin" target="_blank" rel="noopener">rbegin  crbegin</a>(C++14)</td><td>返回指向一个容器或数组的逆向迭代器 (函数模板)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/iterator/rend" target="_blank" rel="noopener">rend  crend</a>(C++14)</td><td>返回容器或数组的逆向尾迭代器 (函数模板)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/iterator/size" target="_blank" rel="noopener">size  ssize</a>(C++17)(C++20)</td><td>返回容器或数组的大小 (函数模板)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/iterator/empty" target="_blank" rel="noopener">empty</a>(C++17)</td><td>检查容器是否为空 (函数模板)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/iterator/data" target="_blank" rel="noopener">data</a>(C++17)</td><td>获得指向底层数组的指针 (函数模板)</td></tr></tbody></table></div><p>以下这些函数定义在<code>&lt;cctype.h&gt;</code> 里</p><div class="table-container"><table><thead><tr><th>函数</th><th>参数返回值皆为int</th></tr></thead><tbody><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/isalnum" target="_blank" rel="noopener">isalnum</a></td><td>检查字符是否为字母或数字 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/isalpha" target="_blank" rel="noopener">isalpha</a></td><td>检查字符是否为字母 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/isdigit" target="_blank" rel="noopener">isdigit</a></td><td>检查字符是否为数字 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/isupper" target="_blank" rel="noopener">isupper</a></td><td>检查字符是否为大写字符 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/islower" target="_blank" rel="noopener">islower</a></td><td>检查字符是否为小写 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/isxdigit" target="_blank" rel="noopener">isxdigit</a></td><td>检查字符是为十六进制字符 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/iscntrl" target="_blank" rel="noopener">iscntrl</a></td><td>检查字符是否为控制字符 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/isgraph" target="_blank" rel="noopener">isgraph</a></td><td>检查字符是否为图形字符 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/isspace" target="_blank" rel="noopener">isspace</a></td><td>检查字符是否为空白间隔字符 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/isblank" target="_blank" rel="noopener">isblank</a>(C++11)</td><td>检查字符是否为空白字符 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/isprint" target="_blank" rel="noopener">isprint</a></td><td>检查字符是否为打印字符 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/string/byte/ispunct" target="_blank" rel="noopener">ispunct</a></td><td>检查字符是否为标点符 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/tolower" target="_blank" rel="noopener">tolower</a></td><td>转换字符为小写 (函数)</td></tr><tr><td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/toupper" target="_blank" rel="noopener">toupper</a></td><td>转换字符为大写 (函数)</td></tr></tbody></table></div><p>此外还有一个将字母转化大小写的小技巧</p><blockquote><p>字母大小写转换的方法：</p><ol><li>统一转成大写：ch &amp; 0b11011111 简写：ch &amp; 0xDF</li><li>统一转成小写：ch | 0b00100000 简写：ch | 0x20</li></ol><p>比较的时候注意加上小括号哦，因为位运算优先级比较低。</p></blockquote><p>但是必须先保证转化的本身就是字母字符  <a href="https://blog.csdn.net/weixin_44190113/article/details/106106495" target="_blank" rel="noopener">原理参考这里,很简单</a></p><h2 id="2020年9月5日"><a href="#2020年9月5日" class="headerlink" title="2020年9月5日"></a>2020年9月5日</h2><p>主题: 字符串</p><h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="[38] 外观数列"></a>[38] 外观数列</h3><p>很有意思的题目, 虽然是简单题但是dp问题还是折腾了快一个小时.</p><blockquote><p>给定一个正整数 <em>n</em>（1 ≤ <em>n</em> ≤ 30），输出外观数列的第 <em>n</em> 项。</p><p>注意：整数序列中的每一项将表示为一个字符串。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure><p>第一项是数字 1</p><p>描述前一项，这个数是 <code>1</code> 即 “一个 1 ”，记作 <code>11</code>L</p><p>描述前一项，这个数是 <code>11</code> 即 “两个 1 ” ，记作 <code>21</code></p><p>描述前一项，这个数是 <code>21</code> 即 “一个 2 一个 1 ” ，记作 <code>1211</code></p><p>描述前一项，这个数是 <code>1211</code> 即 “一个 1 一个 2 两个 1 ” ，记作 <code>111221</code></p></blockquote><p>先获取第<code>n-1</code>项, 然后对其进行分析.</p><p>具体的分析代码就不贴了, 补充一下Vector转String的操作:</p><p><a href="https://zh.cppreference.com/w/cpp/string/basic_string/assign" target="_blank" rel="noopener">str.assign()</a></p><blockquote><p>template&lt; class InputIt &gt;<br>basic_string&amp; assign( InputIt first, InputIt last );</p><p>template&lt; class InputIt &gt;<br>constexpr basic_string&amp; assign( InputIt first, InputIt last );</p></blockquote><p>例如 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v;</span><br><span class="line"><span class="built_in">string</span> re;</span><br><span class="line">re.assign(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="2020年9月13日"><a href="#2020年9月13日" class="headerlink" title="2020年9月13日"></a>2020年9月13日</h2><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="[104]二叉树的最大深度"></a>[104]二叉树的最大深度</h3><p><strong>核心知识点: 递归:</strong></p><ol><li>确定递归函数的参数与返回值: 传入树节点,返回该节点为根的树的深度)</li><li>确定终止: 触底(该节点空), 返回0</li><li>确定单层递归的逻辑: 求左子树深度和右子树深度, 取最大+1返回</li></ol><h2 id="2020年9月16日"><a href="#2020年9月16日" class="headerlink" title="2020年9月16日"></a>2020年9月16日</h2><h3 id="14-最大公共前缀"><a href="#14-最大公共前缀" class="headerlink" title="[14]最大公共前缀"></a>[14]最大公共前缀</h3><p>好像没什么好讲的.. 没有做完全部解法, 回头重做</p><p>TODO</p><h3 id="28-实现strStr-⭐"><a href="#28-实现strStr-⭐" class="headerlink" title="[28]实现strStr()⭐"></a>[28]实现strStr()⭐</h3><p>返回第一个字串, 这题比较有挑战, 很多可以优化的细节</p><p>第一版: 遍历父串每一个字符, 若从此起的后面一段串与子串相同则返回, 否则后移继续</p><p>第二版: 遍历父串每一个字符, 若该字符与子串首字不同则直接继续, 否则再比较</p><p>TODO: KMP</p><p>另外: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1;</span><br><span class="line">str1.substr(1,3);&#x2F;&#x2F;第二个参数是长度而不是结尾索引,返回的是1-4个字符的串</span><br></pre></td></tr></table></figure><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="[98]验证二叉搜索树"></a>[98]验证二叉搜索树</h3><p>递归, 有坑! </p><p>详见<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/bao-zhun-sheng-guo-guan-fang-ti-jie-by-novice2mast/" target="_blank" rel="noopener">这里</a></p><h2 id="2020年9月18日"><a href="#2020年9月18日" class="headerlink" title="2020年9月18日"></a>2020年9月18日</h2><p>主题: 树</p><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="[101] 对称二叉树"></a>[101] 对称二叉树</h3><p>检测一棵树是否是镜面对称的.</p><p><strong>核心知识点: 树的周游(遍历),</strong> 分成两种: BFS与DFS</p><p>深度遍历DFS: 使用栈, 递归实现</p><p>广度遍历BFS: 使用队列. queue实现</p><p>注意: STL中的queue的pop()函数只能等同于删除第一个元素, 不能返回第一个元素. </p><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="[102] 二叉树的层序遍历"></a>[102] 二叉树的层序遍历</h3><p>例如: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">需要返回的是:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>直接使用BFS是相当于中序遍历, 但是返回的会是<code>[3,9,20,15,7]</code>, 也就是说没有实现分层的要求. 如何能识别每层之间的界限? 引入哑节点dummy, 在识别到一个哑节点时表示本层出队列完毕, 也相当于下一层入队列完毕, (如果当前队列还有数字就)在最后插入新的哑节点. </p><h2 id="2020年9月19日"><a href="#2020年9月19日" class="headerlink" title="2020年9月19日"></a>2020年9月19日</h2><h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="[108] 将有序数组转换为二叉搜索树"></a>[108] 将有序数组转换为二叉搜索树</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p>ummm, 显然是曾经学过的内容</p><p>二叉搜索树的中序遍历是升序遍历.取中值作为根, 取左区间作为左子树, 右区间作为右子树.如此递归即可.</p><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="[88] 合并两个有序数组"></a>[88] 合并两个有序数组</h3><blockquote><p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，请你将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>nums1</em> 成为一个有序数组。</p></blockquote><p>简单题~</p><p>两个数组倒叙比较, 插入第n+m-1位.</p><p>最后剩下来的如果是nums1则不用管, 如果是nums2就把前面的这一段全部复制到nums1上</p><h2 id="2020年9月22日"><a href="#2020年9月22日" class="headerlink" title="2020年9月22日"></a>2020年9月22日</h2><h3 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="[278] 第一个错误的版本"></a>[278] 第一个错误的版本</h3><p>一个看上去很简单的二分查找问题, 但是对于萌新来说是有坑的</p><h4 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left==right)</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是这个版本会有问题: 当 <code>left</code> 和 <code>right</code> 都取比较大的整数时, <code>mid</code>可能会出现溢出的问题.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left==right)</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时,  mid = left + (right - left) / 2 在 right 很大、 left 是负数且很小的时候， right - left 也有可能超过 int 类型能表示的最大值，只不过一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此 right - left 溢出的可能性很小。</p><p>再次修正可以使用无符号右移解决,详见<a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/" target="_blank" rel="noopener">本题解</a></p><h4 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h4><p>第一次写的代码如下(注意第13行)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left==right)</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如数组为 1,2,3,4,5 时,</span><br><span class="line">1&gt;&gt; left&#x3D;1,right&#x3D;5,mid&#x3D;3</span><br><span class="line">2&gt;&gt; left&#x3D;3,right&#x3D;5,mid&#x3D;4</span><br><span class="line">3&gt;&gt; left&#x3D;4,right&#x3D;5,mid&#x3D;4</span><br><span class="line">4&gt;&gt; left&#x3D;4,right&#x3D;5,mid&#x3D;4</span><br><span class="line">5&gt;&gt; left&#x3D;4,right&#x3D;5,mid&#x3D;4</span><br><span class="line">...会导致死循环,这是由于取mid的时候舍弃了余数</span><br></pre></td></tr></table></figure><p>同样的原因,如果这么写也会导致死循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">right = mid;<span class="comment">//这里应该改成mid+1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid;</span><br></pre></td></tr></table></figure><p>最终的正确版本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="[70] 爬楼梯"></a>[70] 爬楼梯</h3><p>第一条动态规划!</p><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><script type="math/tex; mode=display">f(n) = f(n-1)+f(n-2)</script><p>爬到第 xx 级台阶的方案数是爬到第 <code>x−1</code> 级台阶的方案数和爬到第 <code>x−2</code> 级台阶的方案数的和。很好理解，因为每次只能爬<code>1</code> 级或 <code>2</code>级，所以 <code>f(x)</code> 只能从 <code>f(x−1)</code> 和 <code>f(x - 2)</code> 转移过来</p><p>方法1: 滚动数组</p><p><img src="https://assets.leetcode-cn.com/solution-static/70/70_fig1.gif" alt=""></p><p>方法2: 利用数组保存动态规划的结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯, 显然这只是个入门dp</p><p>btw 题解视频小姐姐的声音真好听</p><h2 id="2020年9月27日"><a href="#2020年9月27日" class="headerlink" title="2020年9月27日"></a>2020年9月27日</h2><p>主题: 动态规划,其他</p><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="[121] 买卖股票的最佳时机"></a>[121] 买卖股票的最佳时机</h3><p>暴力法: TLE</p><p>dp:</p><p>如果我第<code>i</code>天卖出, 那么我需要在前<code>i-1</code>天中的最低点买入. 我需要记录目前的最低买入点,  并每天比较 <code>dp[i-1]</code> 和 <code>prices[i] - min</code> 的大小,取最大记录在<code>dp[i]</code>中.</p><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="[53] 最大子序和"></a>[53] 最大子序和</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/zheng-li-yi-xia-kan-de-dong-de-da-an-by-lizhiqiang/" target="_blank" rel="noopener">这篇题解</a>对动态规划的讲解非常细致, 适合入门</p><p>dp的核心思路是: 由过往的子问题辅助解决当前的子问题</p><p>关键注意: </p><ol><li>如何将当前的子问题通过之前的子问题表示(也就是递推关系是什么样的)</li><li>如果第<code>i</code>个子问题仅使用到第<code>i-1</code>个子问题的答案, 那么我们不必维护整个数组, 仅仅需要存储的第<code>i-1</code>个子问题的值. 这被称为 <strong>状态压缩</strong>. </li></ol><ul><li>步骤一、定义状态 -&gt; 定义数组元素的含义</li><li>步骤二、状态转移方程 -&gt; 找出数组元素间的关系式</li><li>步骤三、初始化 -&gt; 找出初始条件<br><code>dp[0] = nums[0];</code></li><li>步骤四、状态压缩 -&gt; 优化数组空间<br>每次状态的更新只依赖于前一个状态，就是说 dp[i] 的更新只取决于 dp[i-1] , 我们只用一个存储空间保存上一次的状态即可。</li><li>步骤五、选出结果<br>有的题目结果是<code>dp[i]</code>。<br>本题结果是<code>dp[0]...dp[i]</code> 中最大值。</li></ul><p>TODO: 分治法</p><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="[198] 打家劫舍"></a>[198] 打家劫舍</h3><p>dp, 把状态转移方程搞清楚即可.</p><p><code>dp[i] = max(dp[i-1],dp[i-2]+nums[i])</code> 要么用上一个dp, 要么用本次数字＋上上一个dp</p><p><a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/" target="_blank" rel="noopener">题解</a>小姐姐真好听!!</p><h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="[412] Fizz Buzz"></a>[412] Fizz Buzz</h3><p>用最简单的方法做出来了, 时间复杂度非常糟糕, 看了下似乎在用散列优化,还用了些数学上的小技巧</p><p>例如官当题解和<a href="https://leetcode-cn.com/problems/fizz-buzz/solution/si-lu-jian-dan-xing-neng-da-dao-100-by-jamleon-3/" target="_blank" rel="noopener">这个</a></p><h3 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="[204] 计数质数"></a>[204] 计数质数</h3><p>数学类题目…有很多奇怪的算法</p><p>一般想到的就是: 依次比较, 直到sqrt(m)</p><p>一点细节:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= m; i++)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//而不是</span></span><br><span class="line"><span class="keyword">int</span> sq = <span class="built_in">sqrt</span>(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2020年9月28日"><a href="#2020年9月28日" class="headerlink" title="2020年9月28日"></a>2020年9月28日</h2><p>从今天开始改用Java写了</p><h3 id="724-寻找数组的中心索引"><a href="#724-寻找数组的中心索引" class="headerlink" title="[724] 寻找数组的中心索引"></a>[724] 寻找数组的中心索引</h3><p>中心索引的定义: 数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和</p><p>其实思路相通了就很简单. 首先计算全部元素和. 再遍历第二次, 每次判断 sum_left *2 + curr_value == sum_total 即可!</p><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="[35] 搜索插入位置"></a>[35] 搜索插入位置</h3><p>二分查找</p><p>强推这位兄弟的<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">题解</a></p><h3 id="2020年9月29日"><a href="#2020年9月29日" class="headerlink" title="2020年9月29日"></a>2020年9月29日</h3><h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="[145] 二叉树的后序遍历"></a>[145] 二叉树的后序遍历</h3><p>涉及到树的有两种做法: 一曰递归, 一曰迭代</p><p>这里给出了递归的做法: 关键代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helper(V,root-&gt;left);</span><br><span class="line">helper(V,root-&gt;right);</span><br><span class="line">V.push_back(root-&gt;val);</span><br></pre></td></tr></table></figure><p>TODO: 迭代的做法! </p><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="[56]合并区间"></a>[56]合并区间</h3><p>直接上<a href="https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/" target="_blank" rel="noopener">题解</a>吧 </p><p>如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的. 这是再把可以合并的区间合并即可.</p><p>问题在于: 我们的排序对象是数组(而不是数), 因此是需要在 <code>sort()</code> 函数中指定比较器 <code>Comparator&lt;int[]&gt; c</code> </p><p>排序后: 如何判断区间是否可以合并的? 记录当前区间的左值右值LR, 与下一个区间比较,来决定是合并, 拓展,还是另起区间. </p><h3 id="2020年9月30日"><a href="#2020年9月30日" class="headerlink" title="2020年9月30日"></a>2020年9月30日</h3><p>关键词:数组</p><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="[48] 旋转图像"></a>[48] 旋转图像</h3><p>七月份时做了一个几乎完全一致的题目( <a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">旋转数组</a>) 感觉这题算是讨巧的数学变换, 但是编写代码时要细心.  </p><p>先转置, 再镜像对称  这里的代码编写可能需要绕一会</p><p>此外这题还有很对其他的变换方法, 加入TODO</p><h3 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a>面试题 01.07. 旋转矩阵</h3><p>同上</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷完了初级题库, 对各分类的简单算法有了基础的认知&lt;/p&gt;
&lt;p&gt;整理了一些STL的常用函数(不全面) &lt;/p&gt;
&lt;p&gt;开始由C++专向Java&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="屠龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/"/>
    
      <category term="算法与刷题" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%B7%E9%A2%98/"/>
    
      <category term="力扣刷题流水账" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之二刷子午</title>
    <link href="http://yoursite.com/2020/09/27/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E4%BA%8C%E5%88%B7%E5%AD%90%E5%8D%88/"/>
    <id>http://yoursite.com/2020/09/27/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E4%BA%8C%E5%88%B7%E5%AD%90%E5%8D%88/</id>
    <published>2020-09-27T15:36:42.000Z</published>
    <updated>2020-09-28T07:46:35.659Z</updated>
    
    <content type="html"><![CDATA[<p>2020年9月26日</p><p>子午口-荔枝驿-金仙观-小土地梁-原返</p><a id="more"></a><p>由于我坚持不懈地在朋友圈更新徒步动态, 终于有同学跑过来私聊说想试一试户外了~ 正好本周的打卡山是难度较大的冰晶顶, 自觉水平不够, 就带着N同学一起去了超简单线:子午峪. 子午是我疫情返校后的第一座山, (可以参看8月5日的游记), 对新手非常友好了~</p><h2 id="新队友"><a href="#新队友" class="headerlink" title="新队友"></a>新队友</h2><p>让我惊讶的是居然在队伍里偶遇到西电的本科生. 是一位17级的大四学长, 在此之前我几乎没有碰到过玩户外的其他本科生欸. 事后发现跃跃学长真是dalao哈哈哈. 这个一会再说</p><p>集合点是陕师大门口. 副领队是一只看上去好小的政法小姐姐 , 居然也是大三. 虽说明明也是户外新人怎么就成领队了呢(狗头</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E9%87%91%E4%BB%99%E8%A7%82.jpg" alt=""></p><p>主领队是西电的研究生非鱼. 很皮很欠揍. 提前就约好了一起腐败哈哈哈</p><p>除此之外还有个巨巨巨巨佬Black, 是交大的研究生. 越野老驴, 体能贼强, 回去路上给我们看之前反穿鳌太, 一日太白的照片, 实在是太好看了. 高强度徒步. 除此之外科研生活也两开花, 大佬果然做什么事情都是大佬.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E7%8E%AF%E4%BF%9D.jpg" alt=""></p><h2 id="徒步"><a href="#徒步" class="headerlink" title="徒步"></a>徒步</h2><p>一路上倒是没什么值得记录的, 跟散步一样慢悠悠晃了过来, 没啥景色.</p><p>倒是有队员拍到了山羊的照片,可惜我没看到.还有第一次来的时候见到的猫猫, 两个月不见又胖了一圈</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E7%8C%AB%E5%92%AA.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%F0%9F%90%8F.jpg" alt=""></p><p>有段路满地都是野板栗壳, 都是先前的徒步队留下来的, 我们瞪大了眼睛也找不到一个完整的, 不过回来路上看见别的驴友拎着一大袋子板栗回去, 估计是进山进的更深一些.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E6%9D%BF%E6%A0%97%28%E5%B0%8F%29.jpg" alt=""></p><h2 id="腐败"><a href="#腐败" class="headerlink" title="腐败"></a>腐败</h2><p>那这种轻装休闲线嘛~ 肯定是主要出来腐败的. 提前准备好了海底捞底料, 火腿, 肉肠, 鸡胸肉, 方便面. 甚至还在乐购买了包牛肉卷(容易化, 下次别带了). 其他人也带了两袋子菜蔬, 火锅丸子, 爆浆蛋糕, 鸭脖鸭架, 炒货等待…非鱼还带的一口大锅! 第一次吃这么丰盛的火锅哈哈哈. 最后煮了一盆肉,一盆菜,一盆方便面. 到最后都九个人都没能吃完!!</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E7%81%AB%E9%94%85.jpg" alt=""></p><p>跃跃原来是厨神, 油炸火腿肠(虽然不好吃), 番茄汤底方便面, 最后甚至掏出了一套茶具开始喝茶! 真的绝了~~</p><p>回去路上又临时起意去约饭, 居然还是去的自助~! 感觉这一趟下来胖好多哈哈哈</p><p>但是自助真好吃</p><blockquote><p>还记得去年说, 旅游的意义之一是简单更多的人更广的世界，现在觉得这句话更加正确。</p><p>拘泥于固有的生活节奏的人是井底之蛙，是动了奶酪而不自知的老鼠。</p><p>遇到了交大大佬black，体能好 徒步越野的老驴，文理双修，博闻强识 科研生活两开花<br>遇到了同龄的政法小姐姐，虽然也在迷茫但是很努力在提升自己<br>遇到大一届的学长，在毕业和求职之间忙里偷闲<br>遇到78年高考的大叔，交大毕业，扬州工作，还能跟我们唠的开心</p><p>缘分这种事啊，不迈出第一步就永远也碰不见</p></blockquote><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E5%90%88%E7%85%A7.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年9月26日&lt;/p&gt;
&lt;p&gt;子午口-荔枝驿-金仙观-小土地梁-原返&lt;/p&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之雨中紫阁</title>
    <link href="http://yoursite.com/2020/09/22/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E9%9B%A8%E4%B8%AD%E7%B4%AB%E9%98%81/"/>
    <id>http://yoursite.com/2020/09/22/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E9%9B%A8%E4%B8%AD%E7%B4%AB%E9%98%81/</id>
    <published>2020-09-22T15:35:30.000Z</published>
    <updated>2020-09-28T07:46:43.096Z</updated>
    
    <content type="html"><![CDATA[<p>2020年月日</p><h1 id="在这里简要概括路线"><a href="#在这里简要概括路线" class="headerlink" title="在这里简要概括路线"></a>在这里简要概括路线</h1><a id="more"></a><ul><li>山与水    | 游记<ul><li>不积硅步 | 徒步系列</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年月日&lt;/p&gt;
&lt;h1 id=&quot;在这里简要概括路线&quot;&gt;&lt;a href=&quot;#在这里简要概括路线&quot; class=&quot;headerlink&quot; title=&quot;在这里简要概括路线&quot;&gt;&lt;/a&gt;在这里简要概括路线&lt;/h1&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭##可选" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD-%E5%8F%AF%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统之一_引言</title>
    <link href="http://yoursite.com/2020/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80_%E5%BC%95%E8%A8%80/"/>
    <id>http://yoursite.com/2020/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80_%E5%BC%95%E8%A8%80/</id>
    <published>2020-09-10T11:15:14.000Z</published>
    <updated>2020-09-10T15:49:45.023Z</updated>
    
    <content type="html"><![CDATA[<p>勤能补拙是良训, 一分辛苦一分才.</p><ol><li>系列介绍</li><li>数据库的定义与目标</li><li>数据视图</li><li>数据库语言</li><li>关系数据库</li><li>数据库的设计</li><li>存储与查询</li></ol><a id="more"></a><h1 id="系列介绍"><a href="#系列介绍" class="headerlink" title="系列介绍"></a>系列介绍</h1><p>没错又开新系列了~~ 这次还是以学校开设的 &lt;&lt;数据库系统概念&gt;&gt; 课程为进度安排, 使用教材为机械工业出版社的 <a href="https://book.douban.com/subject/10548379/" target="_blank" rel="noopener">数据库系统概念</a> 黑皮书.</p><p>文章不会针对某一知识点具体展开叙述, 更多地是作为知识点的列举, 以便于日后回顾.</p><p>文章中也可能会穿插部分与期末考试强相关的信息.</p><h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><h2 id="数据库的定义与目标"><a href="#数据库的定义与目标" class="headerlink" title="数据库的定义与目标"></a>数据库的定义与目标</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>数据库管理系统 (Data Base-Management System, DBMS)</strong>由一个<u>互相关联的数据的集合</u>和一组<u>用以访问这些数据的程序(接口)组成</u></p><p>A database-management system (DBMS) is a collection of interrelated data and a set of programs to access those data.</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li><p>DBMS的主要目标</p><p>to provide a way to <em>store and retrieve</em> database information that is both <strong>convenient</strong> and <strong>efﬁcient</strong></p></li><li><p>对数据的管理, 要求有一下几方面:</p><ul><li>信息体的<u>存储结构的定义</u></li><li>信息<u>操作机制的提供</u></li><li>信息<u>安全性</u>保证</li><li>信息共享时带来的冲突</li></ul></li></ul><p>在历史上，数据的管理经历了人工管理-文件系统管理-数据库管理的阶段。文件处理系统的主要弊端有：</p><ol><li>数据的冗余和不一致（data redundancy and inconsistency）</li><li>数据访问困难(difficulty in accessing data)</li></ol><p>需要解决的问题：</p><ol><li>数据孤立(data isolation) </li><li>完整性问题(integrity problem)</li><li>原子性问题(atomicity problem)</li><li>并发访问(concurrent-access anomaly)</li><li>安全性(security problem) </li></ol><h2 id="数据视图"><a href="#数据视图" class="headerlink" title="数据视图"></a>数据视图</h2><p>数据库系统包括：</p><ul><li>一组互相关联的数据</li><li>一组使用户便于读写的程序（接口）</li></ul><p>数据库系统提供了数据的抽象视图</p><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><ul><li>物理层：最低层次的抽象，描述了数据是如何存储的</li><li>逻辑层：描述了系统中存储了什么数据，以及数据之间的关系。面向数据库管理员</li><li><p>视图层：最高层次的抽象，仅仅描述数据库的某个部分。同一个数据库可能拥有多种视图层</p><h3 id="实例与模式"><a href="#实例与模式" class="headerlink" title="实例与模式"></a>实例与模式</h3></li><li>实例：数据库在某一时刻存储在数据库中的信息的集合。</li><li>模式：数据库的总体设计方式</li></ul><p>任意时刻的实例都是该模式的具体，模式是实例的抽象。<br>根据不同的抽象层次模式又分为：</p><ul><li>物理模式：描述了数据库在物理层上的设计抽象模式</li><li>逻辑模式：描述了数据库在逻辑层上的设计抽象模式</li><li><p>子模式：描述了数据库在视图层上的设计抽象模式</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型是一类概念的集合，这些概念描述了数据，数据联系，数据语义以及一致性约束。<br>常见的数据模型：</p></li></ul><ol><li>关系模型</li><li>实体-联系模型</li><li>基于对象数据模型</li><li><p>半结构化数据模型</p><h2 id="数据库语言"><a href="#数据库语言" class="headerlink" title="数据库语言"></a>数据库语言</h2><p>数据库语言分为数据定义语言（DDL）和数据操纵语言（DML）。<br>这两种并非对立的语言，而是同一门数据库语言的两部分。</p><h4 id="数据操纵语言DML"><a href="#数据操纵语言DML" class="headerlink" title="数据操纵语言DML"></a>数据操纵语言DML</h4><p>使用户能够访问或操作数据，包括以下访问类型：</p></li><li>Create 插入新的数据</li><li>Retrieve 从存储在数据库中的信息进行检索</li><li>Update 更新已有的数据</li><li>Delete 删除数据</li></ol><p>有两类基本的数据操纵语言：</p><ol><li>过程化DML ，需要用户指定需要的数据并且如何获得数据</li><li>声明式DML，仅需要指定需要的数据，不需要指明如何获得</li></ol><p>查询（Query）语言本义是特指DML中的检索语句，现在常作为DML的同义词。</p><h4 id="数据定义语言DDL"><a href="#数据定义语言DDL" class="headerlink" title="数据定义语言DDL"></a>数据定义语言DDL</h4><p>DDL不直接操作数据，而是对数据库模式进行设计的一种语言。数据库中的数值必须满足某些一致性约束，DDL正是指定这些约束的工具。DDL可用于：</p><ul><li>域约束</li><li>参照完整性</li><li>断言</li><li>授权</li></ul><p>DDL编写的结果储存在在数据字典中，数据字典中储存的内容被称作元数据。元数据是关于数据的数据，规定了表中数据应当符合的模式。（大概）</p><h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><p>关系型数据库基于关系模型，使用表来展示数据及数据间的联系。关系型数据库是目前最广泛使用的数据库，我们将在接下来几章详细讲解。</p><p>关系型数据库（例如SQL）常常无法用于复杂的计算，因此往往需要宿主语言（Java，C++）。数据库语言提供了一系列接口给宿主语言。</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><ol><li><p>确定用户的数据需求</p></li><li><p>概念设计</p><p>选择合适的数据模型并使用该模型将需求转化为一个数据库的概念模式</p></li><li><p>逻辑设计阶段</p><p>将高层的概念模式映射到实现数据模型上</p></li><li><p>物理设计阶段</p></li></ol><h3 id="实体-关系模型"><a href="#实体-关系模型" class="headerlink" title="实体-关系模型"></a>实体-关系模型</h3><p>实体-联系(E-R)数据模型使用一组称作实体的基本对象，以及这些对象间的联系。</p><p><strong>实体</strong> (entity) 是现实世界中可区别于其他对象的一件“事情”或一个“物体”。例如，每个人是一个实体，每个银行账户也是一个实体。实体通过<strong>属性</strong>(attribute)集合来描述</p><p><strong>联系</strong>(relationship)是几个实体之间的关联。同一类型的所有实体的集合称作实体集(entity set),同一类型的所有联系的集合称作联系集 (relationship set) </p><p>数据库的总体逻辑结构(模式)可以用实体-联系图(entity-relationship diagram, E-R图)进行图形化表示。最常用的方法之一是采用统一建模语言(Unified Modeling Language, UML) </p><ul><li>实体集用矩形框表示，实体名在头部，属性名列在下面。</li><li>联系集用连接一对相关的实体集的菱形表示，联系名放在菱形内部。</li></ul><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p>设计关系数据库所用到的另外一种方法是通常被称为<strong>规范化</strong>的过程。它的目标是生成一个关系模式集合，使我们存储信息时没有不必要的冗余，同时又能很轻易地检索数据。这种方法是设计一种符合适当的<strong>范式</strong>(normal form)的模式</p><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值(null) 表示这个值不存在(或者未知)，未知值可能是 缺失(该值确实存在，但我们没有得到它)或不知道(我们不知道该值是否存在)。空值很难处理，所以最好不要用它。</p><h2 id="存储与查询"><a href="#存储与查询" class="headerlink" title="存储与查询"></a>存储与查询</h2><h3 id="存储管理器"><a href="#存储管理器" class="headerlink" title="存储管理器"></a>存储管理器</h3><p><strong>存储管理器</strong>是数据库系统中负责在数据库中<u>存储的低层数据与应用程序</u>以及<u>向系统提交的查询之间提供接口</u>的部件。存储管理器负责与<strong>文件管理器</strong>进行交互。存储管理器将各种DML语句翻译为底层文件系统命令,并存储在磁盘中。存储管理器负责数据库中数据的<u><em>存储、检索和更新</em></u>。 </p><p>存储管理部件包括：</p><ul><li><p>权限及完整性管理器(authorization and integrity manager)</p><p>它<u>检测是否满足完整性约束</u>，并检查试图访问数据的用户的权限。</p></li><li><p>事务管理器(transaction manager)</p><p>它保证即使发生了故障，数据库也<u>保持在一致的(正确的)状态</u>，并保证并发<u>事务的执行不发生冲突</u>。 </p></li><li><p>文件管理器(file manager)</p><p>它管理磁盘存储空间的分配，管理用于表示磁盘上所存储信息的数据结构。</p></li><li><p>缓冲区管理器(buffer manager)</p><p>它负责将数据从磁盘上取到内存中来，并决定哪些数据应被缓冲存储在内存中。</p></li></ul><p>存储管理器实现了几种<strong><u>数据结构</u></strong>，作为系统物理实现的一部分：</p><ul><li><p>数据文件(data files)</p><p>存储数据库自身。</p></li><li><p>数据字典(data dictionary)</p><p>存储关于数据库结构的元数据，尤其是数据库模式。</p></li><li><p>索引(index)</p><p>提供对数据项的快速访问。和书中的索引一样，数据库索引提供了指向包含特定值的数据的指针。</p></li></ul><h3 id="查询处理器"><a href="#查询处理器" class="headerlink" title="查询处理器"></a>查询处理器</h3><ul><li>DDL 解释器(DDL interpreter),它解释DDL语句并将这些定义记录在数据字典中。 </li><li>DML解释器(DML compiler),将查询语言中的DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令。</li></ul><p>DML编译器还进行查询优化(query optimization),也就是从几种选择中选出代价最小的一种。 </p><ul><li>查询执行引擎(query evaluation engine),执行由DML编译器产生的低级指令。 </li></ul><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p><strong>事务</strong> (transaction): 是数据库应用中完成单一逻辑功能的操作集合。每一个事务是一个既具原子性又具一致性的单元</p><blockquote><p>例如: 资金转账这一逻辑单元由两个基本操作组成: 其中一个系(A系)的账户进行取出操作，而另一个系(B系)的账户进行存入操作。显然，这两个操作必 须保证要么都发生要么都不发生。也就是说，资金转账必须完成或根本不发生。这种要么完成要么不 发生的要求称为<strong>原子性(atomicity)</strong> </p><p>除此以外，资金转账还必须保持数据库的一致性。也就是说，A 和B的余额之和应该是保持不变的。这种正确性的要求称作<strong>一致性(consistency)</strong> .最后，当资金转账 成功结束后，即使发生系统故障，账户A和账户B的余额也应该保持转账成功结束后的新值。这种保持的要求称作<strong>持久性(durability)</strong>。</p></blockquote><p>原子性和持久性的保证是数据库系统自身的职责，确切地说，是恢复管理器(recovery manager)的职责。为了保证原子性，失败的事务必须对数据库状态不产生任何影响。因此，数据库必须被恢复到该失败事务开始执行以前的状态, 即<strong>故障恢复(failure recovery)</strong></p><p>最后，当多个事务同时对数据库进行更新时，即使每个单独的事务都是正确的，数据的一致性也可能被破坏。<strong>并发控制管理器(concurrency-control manager)</strong>控制并发事务间的相互影响，保证数据库一 致性。</p><p>并发控制管理器和恢复管理器 都属于 <strong>事务管理器(transaction manager)</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;勤能补拙是良训, 一分辛苦一分才.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系列介绍&lt;/li&gt;
&lt;li&gt;数据库的定义与目标&lt;/li&gt;
&lt;li&gt;数据视图&lt;/li&gt;
&lt;li&gt;数据库语言&lt;/li&gt;
&lt;li&gt;关系数据库&lt;/li&gt;
&lt;li&gt;数据库的设计&lt;/li&gt;
&lt;li&gt;存储与查询&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="数据库系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之太兴山</title>
    <link href="http://yoursite.com/2020/09/02/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%A4%AA%E5%85%B4%E5%B1%B1/"/>
    <id>http://yoursite.com/2020/09/02/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%A4%AA%E5%85%B4%E5%B1%B1/</id>
    <published>2020-09-02T15:34:09.000Z</published>
    <updated>2020-09-28T07:47:00.820Z</updated>
    
    <content type="html"><![CDATA[<p>2020年月日</p><h1 id="在这里简要概括路线"><a href="#在这里简要概括路线" class="headerlink" title="在这里简要概括路线"></a>在这里简要概括路线</h1><a id="more"></a><ul><li>山与水    | 游记<ul><li>不积硅步 | 徒步系列</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年月日&lt;/p&gt;
&lt;h1 id=&quot;在这里简要概括路线&quot;&gt;&lt;a href=&quot;#在这里简要概括路线&quot; class=&quot;headerlink&quot; title=&quot;在这里简要概括路线&quot;&gt;&lt;/a&gt;在这里简要概括路线&lt;/h1&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭##可选" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD-%E5%8F%AF%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题流水账2020-08</title>
    <link href="http://yoursite.com/2020/09/01/LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-08/"/>
    <id>http://yoursite.com/2020/09/01/LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-08/</id>
    <published>2020-09-01T13:21:59.000Z</published>
    <updated>2020-09-01T13:27:42.865Z</updated>
    
    <content type="html"><![CDATA[<p>Week 4 ✔</p><p>Week 5 ✘ ​</p><a id="more"></a><p>2020年8月22日 “再度”开始刷力扣</p><p>既然决定不读研就好好刷题学工程吧</p><p>每周七题以上. 如果遇到考试周等特别情况可以提前一周完成任务, 不得向后拖延.</p><h2 id="2020年8月22日-week4"><a href="#2020年8月22日-week4" class="headerlink" title="2020年8月22日-week4"></a>2020年8月22日-week4</h2><p>主题: 链表</p><h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="[237] 删除链表中的节点"></a>[237] 删除链表中的节点</h3><p>简单题</p><p>复习单链表</p><h4 id="删除当前节点"><a href="#删除当前节点" class="headerlink" title="删除当前节点"></a>删除当前节点</h4><p>传入参数仅为要删除的节点, (保证不是最后一个节点, 保证链表有两个及以上节点)</p><p>最初的思路自然是<strong>将前驱节点的指针指向后继节点</strong>, 但是无法取得前驱节点.</p><p>正确的思路: <strong>将本节点赋值为后继节点, 并删去后继节点.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="[19] 删除链表的倒数第N个节点"></a>[19] 删除链表的倒数第N个节点</h3><p>中等题</p><p>学习了链表的两个常用技巧: 快慢双指针, 哑节点</p><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a><strong>双指针</strong></h4><p>比较慢的做法是遍历两遍, 一次获取链表长度L, 一次删去倒数第几个数</p><p>可以设置两个指针, 快指针先走n步, 然后快慢指针一起走, 这样快指针到尾的时候慢指针正好到了倒数第n个</p><h4 id="哑节点"><a href="#哑节点" class="headerlink" title="哑节点"></a><strong>哑节点</strong></h4><p>其实就是数据结构课上那个首结点还是什么来着的, 就那个实际第一个节点的前面一个没有数据仅为了引导链表的节点. 加入这玩意可以简化链表操作.</p><blockquote><p>但是当我面对操作<strong>头节点</strong>的问题时，代码就无法通过测试了。<br>例如：我们一共有<strong>四个节点</strong>，需要删除<strong>倒数第四个</strong>节点。<br>因为当我们删除了头节点的时候，我们用什么来返回链表呢？</p></blockquote><h2 id="2020年8月31日-week5"><a href="#2020年8月31日-week5" class="headerlink" title="2020年8月31日-week5"></a>2020年8月31日-week5</h2><p>主题:链表</p><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="[206]反转链表"></a>[206]反转链表</h3><p>简单题</p><p>使用了三种方法解决: 完全地反向构建一个新链表; 原地迭代反转链表; 原地递归反转链表.</p><p>反向复制: 从头到尾地遍历, 每次复制遍历到的节点, 并将该节点的指向为刚才复制的节点.</p><p>原地迭代: 将本节点的指向从后节点指向前节点, 注意储存后节点和本节点的地址</p><p>递归反转: 假设后半段已经复制好了.还是不太能理得清楚. <a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/" target="_blank" rel="noopener">链接</a></p><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="[21] 合并两个有序链表"></a>[21] 合并两个有序链表</h3><p>简单题</p><p>两种: 迭代比较/递归合并</p><p>迭代比较: 双指针, 指向的小的那个并入结果链表(注: 不需要实际复制一遍链表, 只要使用指针即可)</p><p>递归比较: 每次小的指向合并后半部分的返回结果</p><p>注意: 两个链表为空/有一个为空的情况, 只需要两次判断即可</p><h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="[234] 回文链表"></a>[234] 回文链表</h3><p>简单</p><p>On遍历, 将链表的数据储存在数组中, 从前从后比较</p><p>进阶: 时间On 空间O1, 将后半部分链表翻转, 然后双指针比较(未完成)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Week 4 ✔&lt;/p&gt;
&lt;p&gt;Week 5 ✘ ​&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="屠龙术" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/"/>
    
      <category term="算法与刷题" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%B7%E9%A2%98/"/>
    
      <category term="力扣刷题流水账" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%A0%E9%BE%99%E6%9C%AF/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>软件工程之敏捷方法综述:XP与Scrum</title>
    <link href="http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0-XP%E4%B8%8EScrum/"/>
    <id>http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0-XP%E4%B8%8EScrum/</id>
    <published>2020-08-21T08:13:58.000Z</published>
    <updated>2020-08-21T08:16:34.378Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了敏捷方法中的极限编程与Scrum，就二者的相似与区别、各自在实践中的优劣势进行了论述分析。并根据相关资料整理得出其在国内应用的现状，进一步分析其背后的原因，并加以展望未来的发展可能性。</p><p>关键词：敏捷开发，极限编程，Scrum，系统开发方法，软件工程</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>极限编程与 Scrum方法概述<ol><li>什么是极限编程<ol><li>极限编程的简述</li><li>极限编程的目的</li><li>极限编程的12条军规</li><li>极限编程的4个价值</li></ol></li><li>什么是Scrum？<ol><li>Scrum的简述与流程</li><li>Scrum中的三大角色</li></ol></li></ol></li><li>二者的比较分析<ol><li>Xp与scrum的主要异同</li><li>二者的区别<ol><li>迭代长度的不同</li><li>是否允许修改需求</li><li>User Story是否严格按照优先级别来实现</li><li>是否采用严格的工程方法保证进度或者质量</li></ol></li><li>Xp与 Scrum在生产实践中的优劣</li></ol></li><li>国内应用现状</li><li>小结</li></ol><hr><h2 id="一、极限编程与Scrum方法概述"><a href="#一、极限编程与Scrum方法概述" class="headerlink" title="一、极限编程与Scrum方法概述"></a>一、极限编程与Scrum方法概述</h2><h3 id="什么是极限编程（Extreme-Programming，XP）？"><a href="#什么是极限编程（Extreme-Programming，XP）？" class="headerlink" title="什么是极限编程（Extreme Programming，XP）？"></a>什么是极限编程（Extreme Programming，XP）？</h3><h4 id="极限编程的简述"><a href="#极限编程的简述" class="headerlink" title="极限编程的简述"></a>极限编程的简述</h4><p>极限编程是一种软件工程方法学，并且是敏捷软件开发中应用最为广泛和最富有成效的几种方法学之一。相对于传统的软件开发方法学，它更加强调字开发过程中软件需求的不断变化性，认为这种变化是及其正常且不可避免的。正因为如此，极限编程非常注重对于变化的适应，而不是对变化的规避或预测。</p><h4 id="极限编程的目的"><a href="#极限编程的目的" class="headerlink" title="极限编程的目的"></a>极限编程的目的</h4><p>极限编程的主要目标在于<strong>降低因需求变更而带来的成本</strong>。</p><p>在传统系统开发方法中，系统需求在开始阶段后在之后的开发过程中保持不变的。这意味着项目在进入后期阶段时出现的需求变更将导致开发成本急速增加。</p><p>极限编程通过引入基本价值、原则、方法等概念来达到降低变更成本的目的。一个应用了极限编程方法的系统开发项目在应对需求变更时将显得更为灵活。</p><h4 id="极限编程的12条军规"><a href="#极限编程的12条军规" class="headerlink" title="极限编程的12条军规"></a>极限编程的12条军规</h4><p>短交付周期    计划游戏    结对编程    可持续的节奏    </p><p>代码集体所有    编码规范    简单设计    测试驱动开发    </p><p>重构    系统隐喻    持续集成    现场客户</p><h4 id="极限编程的4个价值"><a href="#极限编程的4个价值" class="headerlink" title="极限编程的4个价值"></a>极限编程的4个价值</h4><h5 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h5><p>是在开发小组的成员之间迅速构建与传播制度上的认识的一种方法。极限编程支持设计、抽象、还有用户-程序员间交流的简单化，鼓励经常性的口头交流与回馈。</p><h5 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h5><p>鼓励从最简单的解决方式入手，再通过不断重构达到更好的结果。它只关注于对当前的需求来进行设计、编码。为了将来不确定的需求进行设计以及编码意味着在不必要的方面浪费资源。</p><p>而且设计与代码上的简化可以提高交流的质量。</p><h5 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h5><p>XP团队重视反馈，反馈越快越好。</p><ol><li>来自系统的反馈：通过编写单元测试，程序员能够很直观的得到经过修改后系统的状态。</li><li>来自客户的反馈：功能性测试是由客户还有测试人员来编写的。他们能由此得知当前系统的状态。</li><li>来自小组的反馈：当客户带着新需求来参加项目计划会议时，小组可以直接对于实现新需求所需要的时间进行评估然后反馈给客户。</li></ol><h5 id="勇气"><a href="#勇气" class="headerlink" title="勇气"></a>勇气</h5><p>勇气是软件开发中的一个重要价值，因为它需要勇气来坦率真诚地面对客户，它需要勇气来识别我们自己，我们的团队和我们的组织的缺点，并努力改善这些缺点。</p><h3 id="什么是Scrum？"><a href="#什么是Scrum？" class="headerlink" title="什么是Scrum？"></a>什么是Scrum？</h3><h4 id="Scrum-的简述与流程"><a href="#Scrum-的简述与流程" class="headerlink" title="Scrum 的简述与流程"></a>Scrum 的简述与流程</h4><p>Scrum 是用于开发、交付和持续支持复杂产品的一个框架，是一个增量的、迭代的开发过程。</p><p>在这个框架中，整个开发过程由若干个短的迭代周期（Sprint）组成，每个Sprint的建议长度是一至四周。</p><p>在Scrum中，使用按照商业价值排序的需求列表（Backlog）来管理产品的需求。Scrum团队总是先开发对客户具有较高价值的需求。</p><p>在每一个Sprint计划会议上，将高优先级的需求经过讨论、分析得到相应的任务列表，称它为Sprint backlog。每个成员根据Sprint Backlog再细化成更小的任务。</p><p>在一次迭代环节中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须汇报你昨天完成了什么、承诺你今天要完成什么，以及遇到不能解决的问题。最后要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）</p><p>在每个迭代结束时，Scrum团队将召开  Sprint Retrospective Meeting（回顾会议），总结并讨论改进的地方，放入下一轮Sprint的产品需求中；并递交潜在可交付的产品增量（Increment）</p><h4 id="Scrum中的三大角色"><a href="#Scrum中的三大角色" class="headerlink" title="Scrum中的三大角色"></a>Scrum中的三大角色</h4><h5 id="产品负责人（Product-Owner）"><a href="#产品负责人（Product-Owner）" class="headerlink" title="产品负责人（Product Owner）"></a>产品负责人（Product Owner）</h5><p>主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。</p><h5 id="流程管理员（Scrum-Master）"><a href="#流程管理员（Scrum-Master）" class="headerlink" title="流程管理员（Scrum Master）"></a>流程管理员（Scrum Master）</h5><p>主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。</p><h5 id="开发团队（Scrum-Team）"><a href="#开发团队（Scrum-Team）" class="headerlink" title="开发团队（Scrum Team）"></a>开发团队（Scrum Team）</h5><p>主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。</p><h2 id="二、二者的比较分析"><a href="#二、二者的比较分析" class="headerlink" title="二、二者的比较分析"></a>二、二者的比较分析</h2><h3 id="XP与Scrum的主要异同"><a href="#XP与Scrum的主要异同" class="headerlink" title="XP与Scrum的主要异同"></a>XP与Scrum的主要异同</h3><h4 id="二者的相同"><a href="#二者的相同" class="headerlink" title="二者的相同"></a>二者的相同</h4><p>同属于敏捷开发，都是为了在不确定或混乱的环境中取得项目的成功。</p><p>最终目的相同：都是为了迭代出更好的产品交付给用户。</p><h4 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h4><h5 id="迭代长度的不同"><a href="#迭代长度的不同" class="headerlink" title="迭代长度的不同"></a>迭代长度的不同</h5><p>XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周</p><h5 id="是否允许修改需求"><a href="#是否允许修改需求" class="headerlink" title="是否允许修改需求"></a>是否允许修改需求</h5><p>XP在一个迭代中，如果一个User Story还没有实现， 则可以考虑用另外的需求将其替换， 替换的原则是需求实现的时间量是相等的。</p><p> 而Scrum是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来。</p><h5 id="User-Story是否严格按照优先级别来实现"><a href="#User-Story是否严格按照优先级别来实现" class="headerlink" title="User Story是否严格按照优先级别来实现"></a>User Story是否严格按照优先级别来实现</h5><p>XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活， 可以不按照优先级别来做。</p><h5 id="是否采用严格的工程方法保证进度或者质量"><a href="#是否采用严格的工程方法保证进度或者质量" class="headerlink" title="是否采用严格的工程方法保证进度或者质量"></a>是否采用严格的工程方法保证进度或者质量</h5><p>Scrum没有对软件的整个实施过程定义任何方法。要求开发者自觉保证产品的生产。</p><p>但XP对整个流程方法定义非常严格，规定需要采用TDD, 自动测试， 结对编程，简单设计，重构等约束团队的行为。</p><h3 id="XP与Scrum在生产实践中的优劣"><a href="#XP与Scrum在生产实践中的优劣" class="headerlink" title="XP与Scrum在生产实践中的优劣"></a>XP与Scrum在生产实践中的优劣</h3><p>Scrum的出现实践比极限开发更早。scrum被定义为一个“框架”，提供了宏观上的概念及方法论——鸡类人员、猪类人员、计划会议、每日站立会议、验收会议和回顾会议等等。但是没有提出对于细节的控制与要求（这在前面的区别也有论述），这导致了Scrum更多的是作为一种实践思想与范本，而不是生产过程中的标准。此外，这也导致了Scrum在实际运用中质量的良莠不齐。</p><p>极限开发的出现晚于Scrum ，其中也鲜明地带有或多或少的Scrum烙印。Xp是由“价值观”“原则”和“实践”组成，其中的理念（价值观与）是统筹Xp所有方法的核心。但是在实际的生产实践中，Xp大量的实践约束带来了相当大的成本。无论是人员成本较高的结对编程，还是技术门槛较高的TDD，都给Xp带来了实现的困难。这也导致了在生产实践中，Xp很少会作为一套“完整的流程”，而更多地作为生产中的建议而部分采纳。</p><p>当然，实践中更多地是采用两种多种不同的方法之长进行混合开发。</p><h2 id="三、国内应用现状"><a href="#三、国内应用现状" class="headerlink" title="三、国内应用现状"></a>三、国内应用现状</h2><p>Scrum作为从国外引进的系统开发的技术。在国内的实践并不顺利。酷壳站长陈皓曾经编译过一篇《为什么Scrum不行？》，其中提到了9个Scrum不行的理由。如下：</p><blockquote><p><strong>Reason 1:</strong> Scrum的基石是相信人。创造一个安全的环境，这样每个人都能相互学习，相互直言。但是，这是不行的，这世上有很多人并不关心这些，而且政治和竞争到处都是，办公室里无小事，你和别人交心，你相信他们，最终受伤的你自己。你真的以为那里有空间让你可以去犯错，去冒险吗？</p><p><strong>Reason 2:</strong> Scrum认为只要给员工足够多的自由员工就能做得最好。这该死的理论是基于什么玩意？不可能，人的天性是懒惰的，他们才不会把事做好的，他们只会做相应报酬的工作量，还可能基本甚至达不到其相应的报酬，大多数人都在混日子。尤其是和经理比起来，谁不想能尽快地成为经理或Team leader啊，因为那样他们就可以即不干活，又挣得多。另外，你给他们自由，你就会发现，他们会只会做他们感兴趣的事，要么聊QQ，要么打游戏，看闲书，反正不干正事。直到你催了，他们才动一动。</p><p><strong>Reason 3:</strong> 因为前面的原因，所以，我们仍然要把一个PM放在Scrum团队的上面做管理，这样才会有产出。于是，PM给团队分配任何，管得细枝末节，事无巨细，天天让你做进度汇报，等等。直至把团队拖垮。</p><p><strong>Reason 4:</strong>Scrum只不过是一个流程。这世上有太多的流程，尤其是那那些执行CMMI的公司。几乎所有玩CMMI流程的公司，你都能看到的是员工都是那一副副难看的脸。所以，Scrum的流程同样会这样。因为这些都不是开发团队自发出来的，而是上面管你喜欢不喜欢按给你的。Scrum根本不可能增进你的软件质量和技术，只能是优秀的人才才可能！使用Scrum的公司都是些吝啬鬼，他们不愿花大钱招优秀的人，他们妄图使用Scrum这种东西让现有的这些廉价劳动力发挥更大的生产效率，Scrum成了push程序员最有用的工具。</p><p><strong>Reason 5:</strong>Scrum delivers ‘business value’。不是这样的，实际上，Scrum不可能。这有很多原因。真正了解业务的那帮人根本不可能加入项目团队，那些人谁TMD愿意和苦逼的技术人员加班啊。 那些人喜欢和我们的用户吃吃喝喝，花天酒地的，根本不会和你们那些奇怪的东西（如：backlog）或是那堆ugly的内向古怪的技术人员打交道，更别说什么技术了。所以，你的团队就像一个客服团队或救火队一样疲于奔命。</p><p><strong>Reason 6:</strong> 一个敏捷的团队应该是持续进步的。这就是为什么Scrum总是在问什么干得好，什么需要改进，并定义行动方案。你真的以为员工想进步吗？让他们不得不去想想自己和团队怎么进步，然后他们还不得不去执行行动方案。别天真了，人的天性是不喜欢改变的，人的天性是习惯于一些按部就搬的事，也许那样做令人讨厌，但是人家还是能干点东西出来。如果你逼着人家改变，你就是在压迫人家，人家自然会反抗。</p><p><strong>Reason 7:</strong>Product Owner专注于 ‘what’ 和 ‘why’ 的问题，开发团队决定 ‘how’。很不错的分工，于是可以造就一个即高速有重质量的团队。然而，这根本不行。你的Product Owner马上就想要这个功能，他才不管你的软件开发的技术难题，人家只要快，要你meet deadline，要你给我们重要的客户做出承诺。另外，你千万不要以为你们可以轰走这个初级的product owner，因为他的后台是直接汇报到高层管理。你作为一个程序员可能只是其个小部门的一个小喽啰，或者只是外包公司，你觉得可能吗？你觉得建立信任可能吗？</p><p><strong>Reason 8:</strong> 软件质量和生产率成正比。也就是说，质量越高，生产率越高。如果质量不高，你开发效率就会低下，但是谁管呢？我们朝九晚五的上班，质量好了也是做8小时，质量差了也是做8小时，无所为嘛。另外，我们的project manager (或者是Scrum master!) 总是会批评我们没有按计划完成。所以，这根本不可能。</p><p><strong>Reason 9:</strong> “是的，如果我们只做需要的功能，那么我们就会最低的成本，对吗？”，为什么这世上总是会有这些幼稚的人？这种事怎么可能啊。很多很多的银行或保险公司的项目在你还没有启动项目前就谈好了一个价格（可能还会有回扣），为了打单子，销售什么都干得出来，让你去做项目是因为你是廉价劳动力，而且，他们会不断地加需求，因为软件合同谈好的价格时候，连需求都没有，你去做了才有，还是模糊和不确定或根本就是错的，然后需求是越来越多，越改越多。等你精疲力尽的时候，你才意识到，销售早就把你卖了。</p></blockquote><p>这九点抨击了<strong>Scrum方法体系中过度的理想化，构建了一个平等、高效、友善的类乌托邦式的开发团队</strong>。而作者指出这一理想环境是很难在现实中遇到的，无论是开发团队成员拒绝不断积极地改进重构；还是项目负责人只是追求开发结果；还是业务人员不愿与团队交流…这些都是在社会语境下会存在的实际问题。</p><p>我认为国内对于Scrum方法运用的屡屡碰壁也由此的一部分原因。姑且假设Scrum方法是高效的，但是在我国生产环境及行业背景下却很难将这一高效的特性发挥出来（甚至有可能更加低效）。我国的互联网行业普遍存在高级程序员稀缺、低级程序员泛滥的问题。对于某一出现的问题，可能大部分开发者不适沟通与解决。<strong>Scrum更加适合于一帮资深程序员组成的team，每个人都是牛人，每个人都有激情干活</strong>。在国内大家只是干活拿工资，没什么激情，不适合Scrum。</p><p>极限编程在实践落地中的现状与问题已经在前述优劣处提过，在于<strong>过于复杂的实践带来了更高的成本</strong>。结伴开发。每周40工时等一设想几乎不可能在国内互联网公司（尤其是各中小型公司）推广，更多的公司和PM选择借鉴其中的一部分作为项目开发的“建议”。而Xp中的 <strong>价值观 和原则 更是不被互联网公司重视</strong>，可能在互联网及迅速发展的大背景下，更多的公司热衷于能直接带来红利的狼性文化，而不是沟通、简答、反馈和勇气。</p><p>尽管如此，我们依旧发现<strong>国内的生产实践中存在不少实践成功的事例</strong>。早在2008年，在 google 的 Agile China 讨论组中出现了一系列的帖子讨论Scrum ，内容涉及对Scrum 的理解、CSM 的接受程度及其在国内的实施效果等方面。从这些讨论的字里行间不难看出，业内人员已对“敏捷”有了更深入的思考，而不再是最初的模仿。发展至今，也许以Xp和Scrum为代表的敏捷开发早已深入人心，但是其<strong>在具体实践中的细节仍然需要国内互联网从业者们根据国情进行不断的取舍、优化与迭代。</strong></p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><ol><li>极限编程和Scrum作为21世纪兴起的敏捷开发的代表性方法论，各具特性又互相影响。Scrum更多提供了框架供开发团队参考和自我完善。而极限编程作为一整个价值观、原则与实践，为开发的各项环节确定了可供使用的标准。</li><li>二者思想相近、内容相异，彼此在兴起与发展过程中互相融合补充。也在十数年的实践中体现了各自的优劣性与适用场景。</li><li>目前大多数公司采用以Scrum为框架，Xp中借鉴部分的实践方法进行开发。</li><li>国内目前对于二者的应用并不顺利，在引进这两种高效开发方法的同属遇到了很多我国特定的社会与技术问题有待解决。也许未来随着我国互联网产业的进一步成熟，会在此为框架基础上形成一套适合我国国情的中国特色敏捷开发方法体系。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>什么是敏捷    <a href="http://www.scrumcn.com/agile/scrum-knowledge-libray/agile101.html" target="_blank" rel="noopener">http://www.scrumcn.com/agile/scrum-knowledge-libray/agile101.html</a></li><li>什么是SCRUM    <a href="http://www.scrumcn.com/agile/xp.html" target="_blank" rel="noopener">http://www.scrumcn.com/agile/xp.html</a></li><li>什么是极限编程    <a href="http://www.scrumcn.com/agile/scrum-knowledge-library/scrum.html" target="_blank" rel="noopener">http://www.scrumcn.com/agile/scrum-knowledge-library/scrum.html</a></li><li>xp和scrum在实战中的应用问题    <a href="https://www.cnblogs.com/cly84920/archive/2012/12/26/4426470.html" target="_blank" rel="noopener">https://www.cnblogs.com/cly84920/archive/2012/12/26/4426470.html</a></li><li>敏捷方法之极限编程(XP)和 Scrum区别    <a href="https://www.cnblogs.com/dekevin/p/5613664.html" target="_blank" rel="noopener">https://www.cnblogs.com/dekevin/p/5613664.html</a>)</li><li>运用Scrum做项目管理真实案例    <a href="https://blog.csdn.net/lackin/article/details/7265992" target="_blank" rel="noopener">https://blog.csdn.net/lackin/article/details/7265992</a></li><li>Scrum 在中国——企业实施情况调查实录   <a href="https://www.infoq.cn/article/scrum_china_2008_investigate" target="_blank" rel="noopener">https://www.infoq.cn/article/scrum_china_2008_investigate</a></li><li>凤翼天翔——Scrum 在 Yahoo! 中的成功应用    <a href="https://www.infoq.cn/article/2008/03/Scrum-Adoption-in-Yahoo/" target="_blank" rel="noopener">https://www.infoq.cn/article/2008/03/Scrum-Adoption-in-Yahoo/</a></li><li>国人眼中的 Scrum    <a href="https://www.infoq.cn/article/2008/03/Scrum-Perspective-in-China" target="_blank" rel="noopener">https://www.infoq.cn/article/2008/03/Scrum-Perspective-in-China</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了敏捷方法中的极限编程与Scrum，就二者的相似与区别、各自在实践中的优劣势进行了论述分析。并根据相关资料整理得出其在国内应用的现状，进一步分析其背后的原因，并加以展望未来的发展可能性。&lt;/p&gt;
&lt;p&gt;关键词：敏捷开发，极限编程，Scrum，系统开发方法，软件工程&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="软件工程概论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="敏捷开发" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>软件工程概论之过程模型</title>
    <link href="http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-08-21T08:07:53.000Z</published>
    <updated>2020-08-21T08:12:33.255Z</updated>
    
    <content type="html"><![CDATA[<ol><li>过程</li><li>软件过程模型<ol><li>瀑布模型    Waterfall model </li><li>V-模型  V model </li><li>原型模型 Prototyping model </li><li>阶段性开发：增量与迭代  Phased development:  increments and iteration </li><li>螺旋模型  Spiral model </li><li>敏捷开发 Agile methods</li></ol></li></ol><p><em>之前随便记的,千万别用来备考期末</em></p><a id="more"></a><h1 id="软件工程概论-第二章-过程模型与生命周期"><a href="#软件工程概论-第二章-过程模型与生命周期" class="headerlink" title="软件工程概论  第二章  过程模型与生命周期"></a>软件工程概论  第二章  过程模型与生命周期</h1><h2 id="2-1-过程-Meaning-of-Process"><a href="#2-1-过程-Meaning-of-Process" class="headerlink" title="2.1 过程     Meaning of  Process"></a>2.1 过程     Meaning of  Process</h2><p>软件开发不等于写课后题</p><ol><li>实际软件大而复杂</li><li>多人协作，需要及时沟通及对工程的共同理解</li></ol><h3 id="什么是过程？"><a href="#什么是过程？" class="headerlink" title="什么是过程？"></a>什么是过程？</h3><p> A process defines <strong>who</strong> is doing <strong>what, when</strong> and <strong>how</strong>, in order to reach a certain <strong>goal</strong>.</p><p>一组任务的集合。具体是包括：</p><ul><li>分工及workflow：谁去干什么？先干什么？后干什么？</li><li>产品：不止是最终交付的软件，还包括在过程中的某一环节生产出的各种文档、手册、代码etc</li><li>里程碑 Mailstones：如何标志一个环节结束？</li><li>。。。</li></ul><h3 id="使用过程的重要性"><a href="#使用过程的重要性" class="headerlink" title="使用过程的重要性"></a>使用过程的重要性</h3><ol><li>确保生产过程的一致性，以及对项目的整体结构的把握</li><li>指导如何理解项目、控制环节、检查成果。并改善上述活动</li><li>对同一类型（模型） 的生产过程积攒经验，并在下次处理同类问题时应用</li></ol><h3 id="综上，搭建过程模型的理由："><a href="#综上，搭建过程模型的理由：" class="headerlink" title="综上，搭建过程模型的理由："></a>综上，搭建过程模型的理由：</h3><ol><li>确保所有人对该项目有一个统一普遍的理解；</li><li>To find inconsistencies, redundancies, omissions （？？？）</li><li>确定合适的活动来实现其中每个阶段目标，并在时候对其进行评估；</li><li>对特定的、同类型的工程总结普遍的开发规律，并在日后开发时加以运用。</li></ol><h3 id="定义软件过程"><a href="#定义软件过程" class="headerlink" title="定义软件过程"></a>定义软件过程</h3><p>谁做什么，when，how，并且最终达到什么标准</p><p>生命周期是什么</p><p>图：软件开发中的多种阶段</p><h2 id="2-2-过程模型举例"><a href="#2-2-过程模型举例" class="headerlink" title="2.2 过程模型举例"></a>2.2 过程模型举例</h2><h3 id="2-2-1瀑布模型"><a href="#2-2-1瀑布模型" class="headerlink" title="2.2.1瀑布模型"></a>2.2.1瀑布模型</h3><p>严格地串行化过程。</p><ol><li>需求分析完全结束后，生成需求文档作为里程碑。</li><li>在需求文档基础上开始系统设计，生成功能分析表。</li><li>在功能分析表基础上开始程序设计，生成…….</li><li>…….编程</li><li>…….单元测试、集成测试</li><li>…….系统测试</li><li>…….验收测试 &amp; 交付</li><li>……维护与保养</li></ol><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583564856014.png" alt="瀑布模型"></p><h4 id="瀑布模型的特点"><a href="#瀑布模型的特点" class="headerlink" title="瀑布模型的特点"></a>瀑布模型的特点</h4><p>模型易于理解；后续环节完全基于上游环节；每一步严格地具有输入输出的产品/文档；对不同阶段的开发者定义为不同的角色。</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583637124830.png" alt="1583637124830"></p><h4 id="瀑布模型的问题"><a href="#瀑布模型的问题" class="headerlink" title="瀑布模型的问题"></a>瀑布模型的问题</h4><p>要求每一步都需要完全正确。该模型难以回溯至上层环节。</p><p>Where the waterfall model works fine?</p><ul><li>既定的程序和技术</li><li>不需要太多的需求变化</li><li>•组织良好、角色明确的项目</li><li>“可重复”项目</li><li>时间与资金预算充足的大型项目</li></ul><h3 id="2-2-2-原型模型-Prototyping"><a href="#2-2-2-原型模型-Prototyping" class="headerlink" title="2.2.2 原型模型 Prototyping"></a>2.2.2 原型模型 Prototyping</h3><p>迅速建造一个可以运行的软件原型 ，以便理解和澄清问题，使开发人员与用户达成共识，最终在确定的客户需求基础上开发客户满意的软件产品。在需求分析阶段对软件的需求进行初步而非完全的分析和定义，由用户提出修改和细节，最终再进行实现。<img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583637791886.png" alt="1583637791886"></p><h3 id="2-2-3-V-模型-V-mode"><a href="#2-2-3-V-模型-V-mode" class="headerlink" title="2.2.3 V-模型     V-mode"></a>2.2.3 V-模型     V-mode</h3><p>为了解决开发出的软件质量不高问题</p><p>核心：通过设置多次测试来保证软件的质量</p><p>单元测试、集成测试、系统测试、验收测试</p><p>每一步测试不通过时可以向上回溯。</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583567021149.png" alt="1583567021149"></p><h3 id="2-2-4-阶段性开发-Phased-development"><a href="#2-2-4-阶段性开发-Phased-development" class="headerlink" title="2.2.4 阶段性开发    Phased development:"></a>2.2.4 阶段性开发    Phased development:</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>将整体的任务分解成多个小阶段，从而将工作量化简、并减少错误。</p><h4 id="递增开发，increments"><a href="#递增开发，increments" class="headerlink" title="递增开发，increments"></a>递增开发，increments</h4><p>由某一子系统开始开发，在每次版本更新时逐渐新增功能。</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583567710642.png" alt="1583567710642"></p><h4 id="迭代开发，-iterations"><a href="#迭代开发，-iterations" class="headerlink" title="迭代开发， iterations"></a>迭代开发， iterations</h4><p>由整个系统的测试版开始开发，每次更新完善其中的部分模块</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583567758762.png" alt="1583567758762"></p><h4 id="阶段性开发的优点"><a href="#阶段性开发的优点" class="headerlink" title="阶段性开发的优点"></a>阶段性开发的优点</h4><ul><li>产品可以提前发布，即使功能缺失或不完善</li><li>可以为以前从未提供过的功能提前创建市场</li><li>频繁的发布可以让开发人员快速、全面地解决未预料到的问题</li><li>开发团队可以通过不同的发布专注于不同的专业领域</li></ul><h3 id="2-2-5-螺旋开发-Spiral-model"><a href="#2-2-5-螺旋开发-Spiral-model" class="headerlink" title="2.2.5 螺旋开发    Spiral model"></a>2.2.5 螺旋开发    Spiral model</h3><ul><li>引入风险控制</li><li>开发呈现出围绕以下四个维度的螺旋式开发<ol><li>计划</li><li>定义目标、备选方案及限制</li><li>评估备选方案以及风险</li><li>开发与测试</li></ol></li></ul><p>特点：将与代码相关的内容压缩，大部分内容在开发研究</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583568162769.png" alt="1583568162769"></p><h3 id="2-2-6-混合开发-Hybrid-process-models"><a href="#2-2-6-混合开发-Hybrid-process-models" class="headerlink" title="2.2.6 混合开发 Hybrid process models"></a>2.2.6 混合开发 Hybrid process models</h3><p>过程模型有其优劣点与适用场景，不能一概而论。</p><p>下图为不同年代使用的不同开发模型，可见历史上所出现的所有软件工程模型都没有消亡过。（包括最初的瀑布模型）所以断言某一种模型比另外一种好是不可取的。事实上在实际工程项目中，各模型常常混合使用。</p><p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583638636203.png" alt="1583638636203"></p><h3 id="2-2-7-敏捷开发-Agile-methods"><a href="#2-2-7-敏捷开发-Agile-methods" class="headerlink" title="2.2.7 敏捷开发 Agile methods"></a>2.2.7 敏捷开发 Agile methods</h3><p>2001年敏捷宣言 Agile manifesto</p><blockquote><ul><li>重视<strong>个人和交互</strong>，而不是过程和工具。</li></ul><p>value individuals and interactions over processes and tools</p><ul><li>更愿意花时间在<strong>生产工作软件</strong>上，而不是在生产全面的文档上</li></ul><p>invest time in producing working software rather than in producing comprehensive documentation</p><ul><li>专注于<strong>客户协作</strong>而不是合同谈判，从而使客户参与开发过程的关键方面</li></ul><p>focus on customer collaboration rather than contrast negotiation</p><ul><li>专注于<strong>响应变化</strong>而不是先制定计划然后再执行，因为无法事先预料所有情况</li></ul><p>concentrate on responding to change rather than on creating a plan and then following it</p></blockquote><p>敏捷开发包括多种方法体系，这里主要介绍两种：Extreme programming和S</p><h4 id="2-2-7-1-极限编程-Extreme-programming（简称XP）"><a href="#2-2-7-1-极限编程-Extreme-programming（简称XP）" class="headerlink" title="2.2.7.1 极限编程 Extreme programming（简称XP）"></a>2.2.7.1 极限编程 Extreme programming（简称XP）</h4><p>四大基本特征：</p><ol><li><p>Communication</p><p>所有成员要及时沟通。</p></li><li><p>Simplify</p><p>以用户要求为最高标准，不要画蛇添足；越复杂越易错。</p></li><li><p>Courage</p><p>承担责任。所有成员都有权修改任何代码（并承担所有责任）</p></li><li><p>Feedback</p><p>反馈。不断地与客户反馈，并保证反馈的问题被跟踪、完善、解决。</p></li></ol><h4 id="2-2-7-2-Scrum"><a href="#2-2-7-2-Scrum" class="headerlink" title="2.2.7.2 Scrum"></a>2.2.7.2 Scrum</h4><p>Scrum是一个包括了一系列的实践和预定义角色的过程骨架。</p><p>在每一次冲刺（一个15到30 天周期），开发团队创建可用的软件的一个增量。每一个冲刺所要实现的特性来自产品订单（product backlog，产品目标）哪些订单项（目标项目）会被加入一次冲刺，由冲刺计划会议决定。 </p><p>在会议中，产品负责人告诉开发团队他需要完成产品订单中的哪些订单项。开发团队决定在下一次冲刺中他们能够承诺完成多少订单项。 在冲刺的过程中，没有人能够变更冲刺订单（sprint backlog），即使用户需求发生了变化（称为“冻结”）。</p><p>在冲刺中，每一天都会举行项目状况会议，被称为“scrum”或“每日站立会议”。不论团队规模大小，会议被限制在15分钟。所有出席者都应站立或喝咖啡。（有助于保持会议简短）会议应在固定地点和每天的同一时间举行。在会议上，每个团队成员需要回答三个问题：</p><p>你完成了哪些工作？以后你打算做什么？完成你的目标是否存在什么障碍？</p><p>每一个冲刺完成后，都会举行一次冲刺回顾会议，在会议上所有团队成员都要反思这个冲刺。举行冲刺回顾会议是为了进行持续过程改进。会议的时间限制在4小时。</p><p>、</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;软件过程模型&lt;ol&gt;
&lt;li&gt;瀑布模型    Waterfall model &lt;/li&gt;
&lt;li&gt;V-模型  V model &lt;/li&gt;
&lt;li&gt;原型模型 Prototyping model &lt;/li&gt;
&lt;li&gt;阶段性开发：增量与迭代  Phased development:  increments and iteration &lt;/li&gt;
&lt;li&gt;螺旋模型  Spiral model &lt;/li&gt;
&lt;li&gt;敏捷开发 Agile methods&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;之前随便记的,千万别用来备考期末&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="软件工程概论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件工程概论之期末补天笔记</title>
    <link href="http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E6%9C%9F%E6%9C%AB%E8%A1%A5%E5%A4%A9%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E6%9C%9F%E6%9C%AB%E8%A1%A5%E5%A4%A9%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-21T08:06:48.000Z</published>
    <updated>2020-08-21T08:21:58.769Z</updated>
    
    <content type="html"><![CDATA[<p>综述了学校软件工程概论课程的常考知识点(中英对照), 不保证考点完全覆盖.</p><p>推荐<a href="https://blog.csdn.net/sandalphon4869/category_9045731.html" target="_blank" rel="noopener">一位学长的博客</a>, 建议搭配打印店往年题食用, 效果奇佳.</p><p>西电无纸化之软件工程分群:929629717</p><a id="more"></a><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="定义-软件"><a href="#定义-软件" class="headerlink" title="定义: 软件"></a>定义: <strong>软件</strong></h3><p><em>必考</em></p><p>软件是文档、指令、数据结构的集合</p><ul><li><strong>Documents</strong> that describe the operation and use of the programs.<br>文档描述了程序的操作(operation)和使用(use)。</li><li><strong>Instructions</strong> (computer programs) that when executed provide desired function and performance;<br>指令在执行时提供了所需的功能(function)和性能(performance)。</li><li><strong>Data</strong> <strong>structures</strong> that enable the programs to adequately manipulate information;<br>数据结构使程序能够充分地操作信息(information)。</li></ul><h3 id="软件的3个特性"><a href="#软件的3个特性" class="headerlink" title="软件的3个特性"></a><strong>软件的3个特性</strong></h3><p><em>理解</em></p><ol><li>Software is developed or engineered, it is not manufactured in the classical sense.<br>软件是开发或工程的，而不是传统意义上的制造.</li><li>Software doesn’t “wear out”, but it does deteriorate.<br>软件不会“磨损”，但会恶化。</li><li>Most software is custom-built, rather than being assembled from existing component.<br>大多数软件都是定制的，而不是由现有组件组装而成.</li></ol><h3 id="定义-软件工程"><a href="#定义-软件工程" class="headerlink" title="定义: 软件工程 "></a>定义: <strong>软件工程 </strong></h3><p><em>必考</em></p><p>The application of a <strong>systematic</strong> , <strong>disciplined</strong>, <strong>measure-able</strong> approach to the <strong>development</strong>, <strong>operation</strong>, and <strong>maintenance</strong> of software. That is, the application of engineering to software.</p><p>软件工程是将系统的(systematic)、规范的(disciplined)、可度量的(measurable)方法应用于软件的开发(development)、运行(operation)和维护(maintenance)的过程，即将工程化应用于软件中。</p><h3 id="软件涉及到的人员"><a href="#软件涉及到的人员" class="headerlink" title="软件涉及到的人员"></a>软件涉及到的人员</h3><ul><li>consumer   需求提出者</li><li>developer   开发人员</li><li>user   软件的实际使用者</li></ul><h3 id="质量指标"><a href="#质量指标" class="headerlink" title="质量指标"></a>质量指标</h3><p> <em>理解</em></p><ol><li><p>The Quality of the Product,  <strong>McCall</strong></p><p>度量<strong>软件质量</strong>的指标模型</p></li><li><p>The Quality of the Process,  <strong>CMM</strong> (Capability Maturity Mode)</p><p>度量<strong>过程质量</strong>的指标模型</p></li><li><p>The Quality in the Context of the Business Environment, <strong>ROI</strong></p><p>度量<strong>商业价值</strong>的指标模型</p></li></ol><h2 id="第二章-过程"><a href="#第二章-过程" class="headerlink" title="第二章 过程"></a>第二章 过程</h2><h3 id="定义-过程-process"><a href="#定义-过程-process" class="headerlink" title="定义: 过程 process"></a>定义: <strong>过程 process</strong></h3><p><em>必考</em></p><p>process：</p><ul><li>A series of <strong>ordered steps</strong> involving <u><strong>activities</strong>, <strong>constraints</strong>, and <strong>resources</strong></u> that <strong><u>produce an intended output</u></strong> of some kind.</li><li>一系列涉及活动、约束和资源的步骤，这些步骤会产生某种预期的输出。</li></ul><h3 id="Characteristics-of-process"><a href="#Characteristics-of-process" class="headerlink" title="Characteristics of process"></a>Characteristics of process</h3><p><em>了解</em></p><ol><li>过程描述了所有主要的过程活动。<pre><code>   The process describes all the major  process activities.</code></pre></li><li>这个过程使用资源，但受到一系列限制，并生产中间产品和最终产品。<pre><code>   The process uses the resources, subject to a set of constraints, and produces intermediate and final products.</code></pre></li><li>过程可能由以某种方式链接的子过程组成。<pre><code>     The process may be composed of sub-processes that that linked in some way。</code></pre></li><li>每个过程活动都有进入和退出标准，因此我们知道活动开始和结束的时间。<pre><code>   Each process activity has entry and exit criteria, so that we know when the activity begins and ends .</code></pre></li><li>活动按顺序组织，因此一个活动相对于另一个活动的执行时间很清楚。<pre><code>     The activities are organized in a sequence, so that it is clear when one activity is performed relative to the other activity .</code></pre></li><li>每个过程都有一组指导原则来解释每个活动的目标。<pre><code>     Every process has a set of guiding principles that explain the goals of each activity。</code></pre></li><li>约束或控制可以应用于活动、资源或产品<pre><code>   Constraints  or controls may apply to an activity, resource, or product。</code></pre></li></ol><h3 id="定义-生命周期-Life-cycle"><a href="#定义-生命周期-Life-cycle" class="headerlink" title="定义: 生命周期 Life cycle"></a>定义: <strong>生命周期 Life cycle</strong></h3><p><em>必考</em></p><ul><li>当过程涉及到建设某些产品，我们有时把过程称为生命周期。</li><li>when the process involves the building of some product, we sometimes refer to the process as a life cycle.</li><li>The life cycle of a software product include <strong>conception</strong>(概念化)，<strong>implementation</strong>(实现)，<strong>delivery</strong>(交付)，<strong>use</strong>, <strong>maintenance</strong>.(维护)</li></ul><h3 id="定义-模型"><a href="#定义-模型" class="headerlink" title="定义: 模型"></a>定义: 模型</h3><p>  <em>了解</em></p><ul><li>一个过程可以用多种方法来描述，使用文字、图片或组合</li></ul><p>A process can be described in a variety of ways, using text, pictures or a combination.</p><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a><strong>瀑布模型</strong></h4><p><em>必考(步骤与优缺点)</em></p><h4 id="Step-8"><a href="#Step-8" class="headerlink" title="Step (8)"></a>Step (8)</h4><ol><li>Requirements Analysis 需求分析</li><li>System Design 系统设计</li><li>Program Design 程序设计</li><li>Coding 编程</li><li>Unit &amp; Integration Test 单元&amp;集成测试</li><li>System Test 系统测试</li><li>Acceptance Test 验收测试</li><li>Operation &amp; Maintenance 使用与维护</li></ol><p>特点</p><ol><li><p>One of the first process development models </p><p>是第一个被提出的开发模型之一</p></li><li><p>Works for well understood problems with minimal or no changes in the requirements</p><p>仅需极少的需求或没有任何变化即可解决众所周知的问题</p></li><li><p>It presents a very high-level view of the development process开发过程的顶层理解</p></li><li><p>and sequence of process activities 过程活动的顺序</p></li><li><p>Each major phase is marked by milestones and deliverables  每个主要阶段都具有里程碑和可交付成果</p></li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>The waterfall model can be very useful in <u>helping developers lay out what they need to do</u>.</p><p>在帮助开发人员规划他们需要做的事情时非常有用</p></li><li><p>Its simplicity makes it <u>easy to explain to customers</u> who are not familiar with software development.</p><p>它的简单性使得向不熟悉软件开发的客户解释它很容易</p></li><li><p>It <u>makes explicit which intermediate products are necessary</u> in order to begin the next stage of development.</p><p>它明确了哪些中间产品是必要的，以便开始下一阶段的开发。</p></li><li><p>Many other,more complex models are really just embellishments of waterfall,incorporating feedback loops and extra activities. </p><p>许多其他更复杂的模型实际上只是瀑布的点缀</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>Provides no guidance how to handle changes to products and activities during development (<u>assumes requirements can be frozen</u>)</p><p>没有提供有关如何在开发过程中处理产品和活动更改的指导（假设要求可以冻结）</p></li><li><p>Views software development as manufacturing process rather than as creative process</p><p>将软件开发视为制造过程而非创意过程</p></li><li><p>There is <u>no iterative activities</u> that lead to creating a final Product</p><p>没有迭代活动可以创建最终产品</p></li><li><p>Long wait before a final product</p><p>长时间等待最终产品</p></li></ul><h2 id="第三章-项目管理"><a href="#第三章-项目管理" class="headerlink" title="第三章 项目管理"></a>第三章 项目管理</h2><h3 id="定义-进度-Schedule"><a href="#定义-进度-Schedule" class="headerlink" title="定义: 进度 Schedule"></a>定义: 进度 Schedule</h3><ul><li>A project schedule describes the software development cycle for a particular project by enumerating the phases or stages of the project and breaking each into discrete tasks or activities to be done.</li><li>项目进度通过列举项目的时期或阶段，并将每个阶段分解为待完成的离散任务或活动来描述特定项目的软件开发周期。</li><li>The schedule is a <strong>timeline</strong> that shows when activities will begin and end,and when the related development products while be ready.</li><li>进度是显示活动开始和结束的时间线，以及相关开发产品准备就绪的时间线</li></ul><h3 id="定义-活动"><a href="#定义-活动" class="headerlink" title="定义: 活动"></a>定义: <strong>活动</strong></h3><ul><li>An activity is a <u>part of the project that takes place over a period of time</u>.</li><li>活动是在一段时间内发生的项目的一部分</li></ul><h3 id="定义-里程碑-Milestone"><a href="#定义-里程碑-Milestone" class="headerlink" title="定义: 里程碑 Milestone"></a>定义: <strong>里程碑</strong> Milestone</h3><ul><li>A milestone is <strong><u>the completion of an activity</u></strong>，<strong><u>a particular point in time</u></strong>.</li><li>里程碑是一个活动的完成，一个特定的时间点。</li></ul><h3 id="WBS"><a href="#WBS" class="headerlink" title="WBS"></a>WBS</h3><ul><li>工作分解结构(WBS)将项目描述为一组离散的工作片段。</li><li>work breakdown structure depicts the project as a set of discrete pieces of work.<ul><li>Precursor is an event or set of events that must occur before the activity can begin.<br>前驱是在活动开始之前必须发生的一个或一组事件。</li><li>Due date is the date by which the activity must be completed,frequently determined by contractual deadlines.<br>截止时间是活动必须完成的日期，通常由合同期限决定。</li><li>Duration is length of time needed to complete an activity。<br>工期是完成一项活动所需的时间长度。</li><li>Endpoint is usually a milestone or deliverable<br>终点是里程碑或可交付件。</li></ul></li></ul><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><ul><li>The critical path is the one for which the slack at every node is zero.</li><li>关键路径是每个节点的松弛度为零的路径。</li></ul><p>从活动图找出关键路径!!! 书后两条练习题 ⭐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于活动A_B,P-A-B-S 表示前驱活动P_A,后继活动B_S</span></span><br><span class="line"><span class="comment">//活动A_B可能有不止一个前驱/后继, 此时用Pi_A,B_Si表示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> time_point int<span class="comment">//时刻</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> time_period int<span class="comment">//时间段</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> START 1<span class="comment">//开始时间=1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END END<span class="comment">//结束时间END</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回活动A_B的前驱活动数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回活动A_B的后继活动数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">time_period <span class="title">T</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回活动A_B需要的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">time_point <span class="title">EST</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    time_point re;</span><br><span class="line">    <span class="keyword">int</span> preNum = pre(A_B);</span><br><span class="line">    <span class="keyword">if</span>(preNum == <span class="number">0</span>)</span><br><span class="line">        re = START;</span><br><span class="line">    <span class="keyword">if</span>(preNum == <span class="number">1</span>)</span><br><span class="line">        re = EST(P_A) + T(P_A);</span><br><span class="line">    <span class="keyword">if</span>(preNum &gt; <span class="number">1</span>)</span><br><span class="line">        re = <span class="built_in">max</span>(EST(Pi_A) + T(Pi_A));</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">time_point <span class="title">LST</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    time_point re;</span><br><span class="line">    <span class="keyword">int</span> subNum = sub(A_B);</span><br><span class="line">    <span class="keyword">if</span>(subNum == <span class="number">0</span>)</span><br><span class="line">        re = END - T(A_B);</span><br><span class="line">    <span class="keyword">if</span>(subNum == <span class="number">1</span>)</span><br><span class="line">        re = LST(B_S) - T(A_B);</span><br><span class="line">    <span class="keyword">if</span>(subNum &gt; <span class="number">1</span>)</span><br><span class="line">        re = <span class="built_in">min</span>(LST(B_Si) - T(A_B));</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四章-需求分析"><a href="#第四章-需求分析" class="headerlink" title="第四章 需求分析"></a>第四章 需求分析</h2><h3 id="定义-需求"><a href="#定义-需求" class="headerlink" title="定义: 需求"></a>定义: 需求</h3><ul><li><p>An <strong>Expression</strong> of desired <strong>Behavior</strong></p><p>期望行为的一种表达。</p></li></ul><p>四种需求</p><ul><li><p>functional requirement : 功能性需求</p><p>describes required behavior in terms of required activities</p></li><li><p>nonfunctional requirement (quality function) 非功能性需求(质量需求)</p><p>describes some quality characteristic that the software must possess.</p></li><li><p>design constraint 设计约束</p><p>a design decision,such as choice of platform.</p></li><li><p>process constraint 过程约束</p><p>a restriction on the techniques or resources that can be used to build the system.</p></li></ul><h3 id="ERD（实体关系图）"><a href="#ERD（实体关系图）" class="headerlink" title="ERD（实体关系图）"></a>ERD（实体关系图）</h3><ul><li><p>entity-relationship diagram (ERD): </p><p>is a popular graphical notational paradigm.</p></li><li><p>三要素</p><ul><li>An entity, epicted as a rectangle, represents a collection of  <pre><code>real-world objects that have common properties and behaviors.</code></pre></li><li>A relationship, depicted as an edge between two entities, with diamond<pre><code>in the middle  of the edge specifying the type of relationship.</code></pre></li><li>An attribute, an annotation(注释) on an entity that describes data or <pre><code>properties associated with the entity.</code></pre></li></ul></li></ul><h3 id="DFD-Data-Flow-Diagram数据流图"><a href="#DFD-Data-Flow-Diagram数据流图" class="headerlink" title="DFD Data Flow Diagram数据流图"></a>DFD Data Flow Diagram数据流图</h3><p>Process, data flow, data store, actors </p><h3 id="UCD-（用例图）"><a href="#UCD-（用例图）" class="headerlink" title="UCD （用例图）"></a>UCD （用例图）</h3><ul><li>概念: use-case diagram(UCD) is similar to a top-level data-flow diagram that depicts observable,user-initiated functionality in terms of interactions between the system and its environment.用例图(UCD)类似于顶级数据流图，根据系统和环境之间的交互描述可观察的、用户发起的功能。</li><li>用处: <u>用于表示需求, 不是设计</u></li><li>怎么画?<ul><li>边界</li><li>case</li></ul></li></ul><h3 id="两种文档-区别作用"><a href="#两种文档-区别作用" class="headerlink" title="两种文档 (区别作用)"></a>两种文档 (区别作用)</h3><ul><li><p>require <strong><u>definition</u></strong> 需求分析说明书 For <strong>Customer</strong></p><p>一般是对某个市场或者是客户群来讲的，类似于调研报告，重点是体现出产品要满足哪些功能，哪些是重点、热点。</p></li><li><p>require <strong><u>specificatiuon</u></strong> 需求规格说明书 For <strong>Developer</strong></p><p>是从业务规则讲起的，细一点偏向于软件的概要设计。是从开发、测试的角度去讲产品功能，里面要包含原型界面、业务接口、活动图等 </p></li></ul><h2 id="第五章-体系结构"><a href="#第五章-体系结构" class="headerlink" title="第五章 体系结构"></a>第五章 体系结构</h2><h3 id="定义-设计"><a href="#定义-设计" class="headerlink" title="定义: 设计"></a>定义: 设计</h3><ul><li>Design is the creative process of figuring out how to implement all of the customer’s requirements; </li><li>the resulting plan is also called the design.</li><li>设计是找出如何实现客户所有要求的创造性过程;</li><li>最终的方案也称为设计。</li></ul><h3 id="体系结构三要素-3C-⭐"><a href="#体系结构三要素-3C-⭐" class="headerlink" title="体系结构三要素(3C)⭐"></a>体系结构三要素(3C)⭐</h3><p>软件体系结构={构件，连接件，约束}</p><ul><li>component(构件): 可以是一组代码，如程序模块，也可以是一个独立运行的程序，如数据库服务器。</li><li>connector(连接件):可以是过程调用，管道，远程调用等，用于表示构建之间的相互作用。</li><li>constraint(约束)：对象的连接规则。</li></ul><p>分解</p><p>自顶向下</p><p>合成</p><h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><p>概念! </p><ul><li>管道过滤器 <strong>Piper-and-Filter</strong><ul><li>管道是干什么的? 过滤器是什么?</li><li>Transmit data form one filter to then next</li><li>MIS system of XIDIAN University 西电迎新系统</li></ul></li><li>客户服务器 <strong>Client-Server</strong><ul><li>Most transaction processing system(事务处理系统)    Eg. Bank System</li></ul></li><li>…</li></ul><h2 id="第六章-模块设计"><a href="#第六章-模块设计" class="headerlink" title="第六章 模块设计"></a>第六章 模块设计</h2><p>什么是模块化?</p><ul><li>Modularity, also called separation of concerns, is the principle of keeping separate the various unrelated aspects of a system, so that each aspect can be studied in isolation. </li><li>不相关的方面的相互独立</li></ul><p>什么是独立性? Independence?   Separation of Concern</p><h3 id="Coupling-六耦合"><a href="#Coupling-六耦合" class="headerlink" title="Coupling 六耦合"></a>Coupling 六耦合</h3><ul><li>非直接耦合 Uncoupled</li><li>数据耦合 Data</li><li>标记耦合 Stamp</li><li>控制耦合 Control</li><li>公共耦合 Common</li><li>内容耦合 Content</li></ul><h3 id="Concerns-七内聚"><a href="#Concerns-七内聚" class="headerlink" title="Concerns  七内聚"></a>Concerns  七内聚</h3><ul><li>偶然内聚 Coincidence</li><li>逻辑内聚 Logic</li><li>时间内聚 Temporal</li><li>过程内聚 Procedural</li><li>通信内聚 Communicational</li><li>功能内聚 Functional</li><li>(信息内聚) Information</li></ul><p>耦合与内聚 各考一个(判断是什么类型的耦合\内聚)</p><h2 id="第七章-编程"><a href="#第七章-编程" class="headerlink" title="第七章 编程"></a>第七章 编程</h2><h3 id="程序三要素"><a href="#程序三要素" class="headerlink" title="程序三要素"></a>程序三要素</h3><ul><li>控制结构 Control Structural</li><li>算法 Algorithm</li><li>数据结构 Data Structure</li></ul><h3 id="注释-Head-comment-Block"><a href="#注释-Head-comment-Block" class="headerlink" title="注释: Head_comment_Block"></a>注释: Head_comment_Block</h3><p>里面有什么东西(7个)</p><ol><li>Program SCAN</li><li>Programmer</li><li>Calling sequence</li><li>Version</li><li>Revision</li><li>Purpose</li><li>Data structure</li><li>Algorithm</li></ol><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>内部 Internal documentation</p><ul><li>Head Comment Block</li><li>Other Program Comment</li><li>Meaningful Variable Names and Statement Labels</li><li>Formatting to Enhance Understanding</li></ul><p>外部 External documentation</p><ul><li>describing the problem</li><li>describing the algorithm</li><li>describing the data</li></ul><p>各包括什么content</p><h2 id="第八章-单元测试-⭐"><a href="#第八章-单元测试-⭐" class="headerlink" title="第八章 单元测试 ⭐"></a>第八章 单元测试 ⭐</h2><p>测试方法</p><p>测试用例: </p><ul><li>A test point or test case is <u>a particular choice of <strong>input data</strong></u> to be used in test a program.</li><li>测试点或测试用例是用于测试程序的输入数据的特定选择</li></ul><p>覆盖  由方法选数据</p><p>黑盒白盒: 各测试什么(功能/结构)</p><ul><li>We view the test object form the outside as a <u>closed or black box</u> whose contents are unknown, our testing <strong>feeds inputs to the closed box and notes what output is produced.</strong><br>我们从外部将测试对象视为一个关闭的或内容未知的黑盒，我们的测试将输入输入到关闭的盒子中，并记录产生了什么输出。</li><li>We view the test object as an <u>open</u> <u>box and or white box</u>, we can use the <strong>structure</strong> of the test object to test in different way.<br>我们将测试对象看作是一个开放的盒子或者白盒子，我们可以使用测试对象的结构以不同的方式进行测试。</li></ul><p>路径测试———-给程序, 画流程图,画控制图; 给图, 找测试路径</p><h2 id="第九章-系统测试"><a href="#第九章-系统测试" class="headerlink" title="第九章 系统测试"></a>第九章 系统测试</h2><p>Rush Time 高峰时间</p><p>概念: 前五个</p><ul><li>压力 Stress Test</li><li>容量 Volume Test</li><li>配置 Configuration Test</li><li>Compatibility Test</li><li>Regression Test</li><li>…</li></ul><h2 id="第十章-系统交付"><a href="#第十章-系统交付" class="headerlink" title="第十章 系统交付"></a>第十章 系统交付</h2><p>概念</p><ul><li><p>R 可靠性</p><p>The software reliability is a <strong>possibility</strong> of the system will <strong>operate without failure</strong> under a given conditions and a given time interval.<br>软件可靠性是指系统在给定条件和给定时间间隔下无故障运行的可能性。</p></li><li><p>A 可用性</p><p>The software availability is the <strong>probability</strong> that a system <strong>is operating successfully</strong> according to specification at a given point of time.</p></li><li><p>M 可维护性</p><p>The software maintainability is the probability that , for a given condition of use, a maintenance activity <strong>can be carried out</strong> within stated time interval and using stated procedures and resources.</p><p>给定的使用条件下，可以在规定的时间间隔内并使用规定的过程和资源进行维护活动的可能性。</p></li><li><p>PPT原话!!!!</p></li></ul><h2 id="第十一章-系统维护"><a href="#第十一章-系统维护" class="headerlink" title="第十一章 系统维护"></a>第十一章 系统维护</h2><p>维护的定义</p><p>Any work done to change the system after it is in operation is considered to be maintenance.<br>在系统运行后为改变系统所做的任何工作都被认为是维护。</p><p>四类维护: 判断是什么样的维护…</p><ol><li>Corrective Maintenance     ：Bug 改正性维护</li><li>Adaptive Maintenance    ：Table-Driven Design 适应性维护</li><li>Perfective Maintenance    : DB Upgrade to New Version 完善性维护</li><li>Preventive Maintenance    : Printer Driver: Print-line 预防性维护</li></ol><h2 id="彩蛋-2020年软工概论考题回忆版"><a href="#彩蛋-2020年软工概论考题回忆版" class="headerlink" title="彩蛋: 2020年软工概论考题回忆版"></a>彩蛋: 2020年软工概论考题回忆版</h2><p>题型:选择*15+判断*10+简答*5+大题*3</p><p>选择判断基本全是课后题里面的原句扣关键字</p><p>20年简答:<br>简述瀑布模型及优缺点<br>ERD三要素及功能<br>简述pip and filter的功能<br>简述Head block comment包括的内容<br>简述corrective maintenance</p><p>20年大题:<br>Critical Path<br>Branch Test<br>Logic Flow-&gt;possible path</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;综述了学校软件工程概论课程的常考知识点(中英对照), 不保证考点完全覆盖.&lt;/p&gt;
&lt;p&gt;推荐&lt;a href=&quot;https://blog.csdn.net/sandalphon4869/category_9045731.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一位学长的博客&lt;/a&gt;, 建议搭配打印店往年题食用, 效果奇佳.&lt;/p&gt;
&lt;p&gt;西电无纸化之软件工程分群:929629717&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="软件工程概论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之概述</title>
    <link href="http://yoursite.com/2020/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%A6%82%E8%BF%B0/</id>
    <published>2020-08-14T07:45:25.000Z</published>
    <updated>2020-08-16T07:57:23.751Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统 系列文章链接🔗</p><p>操作系统之概述:</p><ol><li>OS 定义</li><li>OS 历史</li><li>OS 分类</li><li>计算机底层硬件一览</li><li>OS 中的基本概念</li><li>系统调用</li><li>OS 结构</li></ol><a id="more"></a><h1 id="操作系统-系列文章链接🔗"><a href="#操作系统-系列文章链接🔗" class="headerlink" title="操作系统 系列文章链接🔗"></a>操作系统 系列文章链接🔗</h1><ol><li>操作系统之概述 (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol><h1 id="操作系统之概述"><a href="#操作系统之概述" class="headerlink" title="操作系统之概述"></a>操作系统之概述</h1><p>本章将涉及: </p><ol><li>OS 定义</li><li>OS 历史</li><li>OS 分类</li><li>计算机底层硬件一览</li><li>OS 中的基本概念</li><li>系统调用</li><li>OS 结构</li></ol><p><em>本部分基础概念较多, 仅为应付考试, 中英混杂且不做过多解释.  <del>背就完事了</del></em> </p><h2 id="OS定义"><a href="#OS定义" class="headerlink" title="OS定义"></a>OS定义</h2><h3 id="计算机系统的组成部分"><a href="#计算机系统的组成部分" class="headerlink" title="计算机系统的组成部分"></a>计算机系统的组成部分</h3><p>A computer system consists of </p><ol><li>硬件 Hardware </li><li>系统程序 system programs</li><li>应用程序 application programs</li></ol><h3 id="操作系统扮演的角色"><a href="#操作系统扮演的角色" class="headerlink" title="操作系统扮演的角色"></a>操作系统扮演的角色</h3><ol><li>an extended machine (对于用户: 让用户更好地使用机器, 是硬件的包装接口) </li><li>a resource manager (对于机器: 告知机器如何分配硬件资源, 是用户的命令代理执行者, 也是资源的分配者)</li></ol><p>是 an intermediary(中间调解人) between a user of a computer and the computer hardware.</p><h3 id="Operating-system-goals"><a href="#Operating-system-goals" class="headerlink" title="Operating system goals"></a>Operating system goals</h3><ol><li>Execute user programs and make solving user problems <strong>easier</strong>. <strong>简单</strong></li><li>Make the computer system <strong>convenient</strong> to use. <strong>易用</strong></li><li>Use the computer hardware in an <strong>efficient</strong> manner. <strong>高效</strong></li><li>Permit effective development, testing, and introduction of new system functions without interfering with service. （<strong>易于扩充</strong>）</li></ol><h3 id="一些正确叙述"><a href="#一些正确叙述" class="headerlink" title="一些正确叙述"></a>一些正确叙述</h3><ul><li><p><strong>Resource allocator</strong> – manages and allocates resources. </p></li><li><p><strong>Control program</strong> – controls the execution of user programs and operations of I/O devices .</p></li><li><p><strong>Kernel</strong> – the one program running at all times (all else being application programs).</p><p>OS 是唯一运行在内核态的程序, 并且是全程运行, 并且先于其他程序运行</p></li><li><p>OS 与用户交互的界面: <strong>Shell</strong> : 文本交互; <strong>GUI</strong> : 图像交互</p></li><li><p>内核态中, OS对所有的硬件具有完全的访问权, 可以执行任何对于硬件的指令. 而用户级程序只能使用机器指令中的子集</p></li></ul><h2 id="OS历史"><a href="#OS历史" class="headerlink" title="OS历史"></a>OS历史</h2><p>根据计算机本身的发展而发展</p><ul><li><p>真空管, 穿孔卡</p></li><li><p>晶体管, 批处理程序</p></li><li><p>集成电路, 多道程序Multiprogramming        </p><p>多道程序: 在计算机中同时存放多个作业( 但不一定是绝对意义上的 <strong>同时</strong> 运行 详细请参看进程一章)</p></li><li><p>个人计算机</p></li><li><p>手持计算机</p></li></ul><h2 id="OS分类"><a href="#OS分类" class="headerlink" title="OS分类"></a>OS分类</h2><ul><li> Mainframe operating systems （大型机OS）</li><li> Server operating systems （服务器OS） </li><li> Multiprocessor operating systems （多处理机OS） </li><li> Personal computer operating systems （个人计算机OS）</li><li> Real-time operating systems （实时 OS） <ul><li>硬实时: <ul><li>辅助储存空间有限或不存在, 所有数据只在寄存器或只读存储器ROM中保存</li><li>例如: 导弹制动系统</li><li>由于不存在任何辅助储存空间, 因此与分时系统是冲突的</li></ul></li><li>软实时: <ul><li>部分关键实时任务的优先级高于其他任务，并保留该优先级直到完成为止</li><li>例如:  industrial control or robotics 以及 applications (多媒体 VR等) requiring  advanced operating system features.</li></ul></li></ul></li><li> Embedded operating systems （嵌入式OS）</li><li> Smart card operating systems （智能卡OS)</li></ul><h2 id="计算机底层硬件"><a href="#计算机底层硬件" class="headerlink" title="计算机底层硬件"></a>计算机底层硬件</h2><p>计算机包括这些硬件组成部分</p><ol><li>CPU </li><li>Main Memory</li><li>IO Module</li><li>System Bus</li><li>…</li></ol><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/toplevel.png" alt=""></p><h3 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h3><p>从内存中提取指令并执行它们。 </p><ul><li>每个CPU都有一组可以执行的特定指令 称为该CPU的指令集( 例如8086指令集)</li><li>因为访问内存以获取指令或数据字比执行一条指令要花费更长的时间，所以所有CPU都在其中包含一些寄存器来保存键变量和临时结果。</li></ul><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><ul><li>中断是CPU 在工作中的必要操作, 能够使工作更加高效</li><li>An interruption of the normal sequence of execution  </li><li>例如等待IO的过程中执行别的进程, 在IO结束时产生中断回到原进程继续执行</li><li>运行 - 中断 - 恢复 - 运行</li><li>中断分类<ul><li>程序中断<ul><li>运算溢出</li><li>除零</li><li>页面失效</li><li>执行非法指令</li></ul></li><li>时钟中断<ul><li>程序片使用完毕</li></ul></li><li>IO 中断</li><li>硬件错误</li></ul></li></ul><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><h4 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/cache.png" alt=""></p><ul><li>每一级都是下一级的内容的子集</li><li>从上到下: 更大 更慢 更便宜</li></ul><p>详见内存管理章节</p><h4 id="DMA-直接存储器存取"><a href="#DMA-直接存储器存取" class="headerlink" title="DMA 直接存储器存取"></a>DMA 直接存储器存取</h4><p>Transfers a block of data directly to or from memory</p><p>可以在不经有CPU的情况下直接访问Data Bus, 用于进一步简化CPU等待时间</p><h4 id="基址-限址-MMU"><a href="#基址-限址-MMU" class="headerlink" title="基址 限址 MMU"></a>基址 限址 MMU</h4><ul><li>Base register and limit register 基址寄存器和限界寄存器</li><li>MMU (Memory Management Unit) 内存管理单元</li></ul><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>IO设备实际上包括(控制器与设备本身) A controller and the device itself. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/device.png" alt=""></p><p>IO中断</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/io.png" alt=""></p><ul><li>(a) Steps in starting an I/O device and getting interrupt 设备如何发起中断 </li><li>(b) How the CPU is interrupted 中央处理器如何处理中断</li></ul><p>总线</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/bus.png" alt=""></p><h2 id="OS概念"><a href="#OS概念" class="headerlink" title="OS概念"></a>OS概念</h2><h3 id="程序管理相关"><a href="#程序管理相关" class="headerlink" title="程序管理相关"></a>程序管理相关</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li>Process: a program in execution.</li></ul><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><ul><li>Address space: a list of memory locations from some minimum to some maximum, which the process can read and write.</li></ul><h4 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h4><ul><li>Process table: where all the information about each process is stored in.</li></ul><h4 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h4><ul><li>process tree </li></ul><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul><li>process is divided into threads that can run simultaneously </li><li>线程 Thread : <ul><li>CPU可分配的最基本单元</li><li>能够执行与中断</li></ul></li></ul><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><ul><li>Inter-process communication<ul><li>Related processes that are cooperating to get some job done often need to communicate with one another and synchronize their activities.</li><li>为了完成某项工作而进行协作的相关流程通常需要彼此通信并同步其活动。</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>Deadlock: when two or more processes are interacting, they can sometimes get themselves into a stalemate (僵持) situation they cannot get out of.</li></ul><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ul><li>Pipe: a sort of pseudofile that used to connect two processes.</li></ul><h3 id="文件管理相关"><a href="#文件管理相关" class="headerlink" title="文件管理相关"></a>文件管理相关</h3><h4 id="设备无关性"><a href="#设备无关性" class="headerlink" title="设备无关性"></a>设备无关性</h4><p>操作系统的主要功能是隐藏磁盘和其他IO设备的特性，并为程序员提供一个与设备无关的文件的漂亮，简洁的抽象模型。<strong>设备无关性</strong> : device-independent</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li>Director: A place to keep files, a way of grouping files together. System calls are then needed to create and remove directories. </li></ul><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul><li><p>File system: Calls are also provided to put an existing file in a directory, and to remove a file from a directory. Directory entries may be either files or other directories.</p></li><li><p>挂载mount</p></li></ul><h3 id="架构相关"><a href="#架构相关" class="headerlink" title="架构相关"></a>架构相关</h3><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><ul><li>Microkernel architecture （微内核结构）</li><li>assigns only a few essential functions to the kernel 只分配了最基本功能<ul><li>➢ address space </li><li>➢ inter-process communication (IPC)</li><li>➢ basic scheduling</li></ul></li></ul><h4 id="对称多处理"><a href="#对称多处理" class="headerlink" title="对称多处理"></a>对称多处理</h4><ul><li>Symmetric multiprocessing（对称多处理） <ul><li>there are multiple processors 多个处理器</li><li>these processors share same main memory and I/O facilities   共享主存与IO设备</li><li>All processors can perform the same functions  所有处理器可执行相同的功能</li></ul></li></ul><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><ul><li>Distributed operating systems（分布）<ul><li>provides the illusion of a single main memory and single secondary memory space 虽然是分布式但是给人感觉像是单个主存单个辅助存储空间的错觉</li><li>used for distributed file system 常用于分布式文件系统</li></ul></li></ul><h4 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h4><ul><li>Object-oriented design（面向对象设计） <ul><li>used for adding modular extensions to a small kernel  用于向小内核添加模块化扩展</li><li>enables programmers to customize an operating system without disrupting system integrity 使程序员能够自定义操作系统，而不会破坏系统完整性</li></ul></li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="系统调用的流程"><a href="#系统调用的流程" class="headerlink" title="系统调用的流程"></a>系统调用的流程</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/sys%20call.png" alt=""></p><p>系统调用需要11步来实现</p><p>以 <code>read (fd, buffer, nbytes)</code> 为例; 从 <code>fd</code> 文件向<code>buffer</code> 缓冲区中读入 <code>nbytes</code> 内容</p><ol><li>用户程序:  保存 <code>nbytes</code> 参数</li><li>用户程序:  保存 缓冲区地址 参数</li><li>用户程序:  保存 文件 参数</li><li>用户程序:  调用库函数中的代码</li><li>库程序:      将相关代码存入寄存器</li><li>陷入内核, 此时CPU的使用权转移至内核态</li><li>处理指令</li><li>读取数据</li><li>返回库程序</li><li>返回用户程序</li><li>用户程序:  SP++ 执行下一条指令</li></ol><h3 id="常见的系统调用"><a href="#常见的系统调用" class="headerlink" title="常见的系统调用"></a>常见的系统调用</h3><h4 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/unix1.png" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/unix2.png" alt=""></p><h4 id="Win32"><a href="#Win32" class="headerlink" title="Win32"></a>Win32</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/win32.png" alt=""></p><h2 id="OS结构"><a href="#OS结构" class="headerlink" title="OS结构"></a>OS结构</h2><h3 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h3><ul><li>Monolithic system (单体系统): The structure is that there is <strong>no structure</strong>. </li><li>The OS is written as a collection of procedures, each of which can call any of the other ones whenever it needs to.操作系统是作为过程的集合编写的，每个过程都可以在需要时调用任何其他过程。</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/mono.png" alt=""></p><h3 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h3><ul><li>Layered system (分层系统): Organize the OS as a hierarchy of layers, each one constructed upon the one below it 层次结构，每个层次结构都基于其下一层</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/layer.png" alt=""></p><h3 id="微内核系统"><a href="#微内核系统" class="headerlink" title="微内核系统"></a>微内核系统</h3><ul><li>Microkernels (微内核结构): Put as little as possible in kernel model</li></ul><h3 id="Client-Server-Model"><a href="#Client-Server-Model" class="headerlink" title="Client-Server Model"></a>Client-Server Model</h3><ul><li>现代OS的趋势是: 采用<strong>将代码进一步移到更高层</strong>的想法，并尽可能<strong>从内核模式中删除</strong>，从而保留最小的微内核。</li><li>The client-server model, all the kernel does is handle the communication between clients and servers. 内核只负责处理客户端和服务器之间的通信。</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/CS%20Model.png" alt=""></p><h3 id="虚拟系统"><a href="#虚拟系统" class="headerlink" title="虚拟系统"></a>虚拟系统</h3><ul><li>Virtual Machines (虚拟机): 系统的核心被称为 <strong>虚拟机监视器</strong> virtual machine monitor直接运行在硬件层, 并且向下一层提供多个虚拟的机器</li><li>下图仅为虚拟化的一种实现方式, 详见多处理器系统章节</li></ul><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E8%99%9A%E6%8B%9F%E5%8C%961.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统 系列文章链接🔗&lt;/p&gt;
&lt;p&gt;操作系统之概述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OS 定义&lt;/li&gt;
&lt;li&gt;OS 历史&lt;/li&gt;
&lt;li&gt;OS 分类&lt;/li&gt;
&lt;li&gt;计算机底层硬件一览&lt;/li&gt;
&lt;li&gt;OS 中的基本概念&lt;/li&gt;
&lt;li&gt;系统调用&lt;/li&gt;
&lt;li&gt;OS 结构&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之安全</title>
    <link href="http://yoursite.com/2020/08/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2020/08/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%AE%89%E5%85%A8/</id>
    <published>2020-08-11T06:42:28.000Z</published>
    <updated>2020-08-15T11:05:03.963Z</updated>
    
    <content type="html"><![CDATA[<p>本章将涉及:</p><ol><li>安全与威胁</li><li>简易密码学(真的很简易!)</li><li>用户认证</li><li>系统受到的攻击<ol><li>来自内部</li><li>来自外部</li></ol></li><li>保护机制</li><li>信任系统</li><li>OS安全</li></ol><p><em>本文匆匆赶制, 内容粗糙简陋</em></p><a id="more"></a><h2 id="安全与威胁"><a href="#安全与威胁" class="headerlink" title="安全与威胁"></a>安全与威胁</h2><div class="table-container"><table><thead><tr><th>Goal</th><th>Threat</th></tr></thead><tbody><tr><td>Data confidentiality 数据机密性</td><td>Exposure of data 数据泄露</td></tr><tr><td>Data integrity           数据完整性</td><td>Tampering with data 数据篡改</td></tr><tr><td>System available     系统可用性</td><td>Denial of service      拒绝服务</td></tr></tbody></table></div><p>首先保护数据的机密性, 防止数据泄露.   需要保证数据不被外界所知.</p><p>其次要保证数据的完整性, 防止数据被破坏.  不能被外界破坏.</p><p>最后要保证系统的可用性, 防止系统拒绝服务. 例如DoS攻击等</p><p>入侵者 intruder or sometimes 敌人 adversary<br>a) Passive intruders(被动入侵者)- to read files they are not authorized to<br>read<br>b) Active intruders(主动入侵者)- to make unauthorized changes to data</p><p>常见的安全入侵场景有:</p><ol><li>Casual prying (窥探) by nontechnical users     被非专业使用者随意窥探</li><li>Snooping by insiders  被内部人员窥视</li><li>Determined attempt to make money  为了利益</li><li>Commercial or military espionage   商业或军事间谍</li></ol><p>常见的数据丢失场景有:</p><ol><li><p>天灾</p><p>fires, floods, wars</p></li><li><p>软硬件错误</p><p>CPU malfunction, bad disk, program bugs </p></li><li><p>人为错误</p><p>data entry, wrong tape mounted</p><hr></li></ol><h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h2><p><em><u>了解即可</u></em></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>斯巴达将军</li><li>戚继光: 反切注音法</li><li>周恩来: 豪密</li><li>菲利普与玛丽女王</li><li>一战: 齐默尔曼电报</li><li>二战: Enigma密码机, 图灵</li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul><li>? - 1949 古典密码<ul><li>密码学还不是科学, 而是艺术</li><li>数据的安全<strong>基于算法的保密</strong></li><li>一般的加密方法是<strong>替换</strong></li><li>单表替换密码(凯撒密码), 多表替换密码(Playfair密码, Hill密码) , 转轮密码(Enigma)</li></ul></li><li>1949 - 1975 复杂计算的密码<ul><li>由于算力提升使得复杂计算的密码称为可能</li><li>1949年,香农发表了&lt;&lt;保密系统的信息理论&gt;&gt;(The Communication Theory of Secrecy Systems), 它证明了密码编码 学是如何置于坚实的数学基础之上的，从此密码学发展成为 一个专门学科。——标志性事件 </li><li>数据的安全<strong>基于密钥</strong>而不是算法的保密</li></ul></li><li>1975 - 公钥密码<ul><li>公钥密码学成为主要研究方向 </li><li><strong>公钥密码</strong>使得发送端和接收端<strong>无密钥传输的保密通信</strong>成为可能</li></ul></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><ul><li>传统密码/常规密码/私钥密码/单钥密码 conventional / private-key / single-key</li><li>发送方和接收方共享一个共同的密钥</li><li>20世纪70年代以前私钥密码是唯一类型 </li><li>至今仍广泛应用</li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ul><li>公钥/双钥/非对称密码都是指使用两个密钥: <ul><li>公钥：可以对任何人公开的密钥，用于加密消息或 验证签名。 </li><li>私钥：只能由接收者私存，用于解密消息或签名。 </li></ul></li><li>非对称 <ul><li>用于加密消息或验证签名的人不能进行消息的加密或消息的签名。</li></ul></li></ul><hr><h2 id="用户认证⭐"><a href="#用户认证⭐" class="headerlink" title="用户认证⭐"></a>用户认证⭐</h2><p>Authentication<br>user authentication（用户验证） crackers（骇客）</p><p>认证必须要能够标识使用者的身份</p><p>用户认证应当在使用系统之前完成</p><p>三种认证方式</p><ol><li><p>Something the user knows</p><p>密码, 口令</p></li><li><p>Something the user has</p><p>钥匙, 芯片, 动态密码, 验证码</p></li><li><p>Something the user is</p><p>指纹, 虹膜</p></li></ol><blockquote><p>UNIX 安全系统会对输入的密码进行<strong>加盐</strong>(Salt), 即将每一个口令同一个叫做盐（Salt）的n位随机数相关联。无论何时口令改变，这个随机数就改变。将口令和随机数连接起来，一同加密，加密后的结果存放进口令文件。</p><p>One-Time passwords 对于函数 y=f(x) 已知y求x的难度远大于已知x求y的难度. </p></blockquote><h3 id="一些用户认证时的对策"><a href="#一些用户认证时的对策" class="headerlink" title="一些用户认证时的对策"></a>一些用户认证时的对策</h3><ul><li>Limiting times when someone can log in    限制登录时间</li><li>Automatic callback at number prespecified   自动回调 (例如判断密码是否太过简单)</li><li>Limited number of login tries   限制尝试的登录次数</li><li>A database of all logins    记录所有尝试登录的数据</li><li>Simple login name/password as a trap  使用简单的密码作为陷阱 (假装登陆成功)</li><li>security personnel notified when attacker bites 当检测到攻击者时通知安全人员</li></ul><hr><h2 id="系统受到的攻击"><a href="#系统受到的攻击" class="headerlink" title="系统受到的攻击"></a>系统受到的攻击</h2><h3 id="Insider-Attacks-内部攻击"><a href="#Insider-Attacks-内部攻击" class="headerlink" title="Insider Attacks 内部攻击"></a>Insider Attacks 内部攻击</h3><h4 id="Logic-Bombs"><a href="#Logic-Bombs" class="headerlink" title="Logic Bombs"></a>Logic Bombs</h4><p>（逻辑炸弹）由一些公司的编程人员或使用这些受保护的计算机、编制核心软件的员工实施.秘密的嵌在产品的操作系统中的代码，特定情况下爆炸</p><h4 id="Trap-Doors"><a href="#Trap-Doors" class="headerlink" title="Trap Doors"></a>Trap Doors</h4><p>（后门）系统程序员跳过正常的认证过程并插入一段代码造成<br>的。代码审查 code review</p><h4 id="Login-Spoofing"><a href="#Login-Spoofing" class="headerlink" title="Login Spoofing"></a>Login Spoofing</h4><p>（登录欺骗）假冒的登录屏幕</p><h4 id="Trojan-Horses"><a href="#Trojan-Horses" class="headerlink" title="Trojan Horses"></a>Trojan Horses</h4><p>特洛伊木马 诱导用户运行攻击代码</p><h4 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h4><p>缓冲区溢出攻击</p><h3 id="Outside-Attacks-外部攻击"><a href="#Outside-Attacks-外部攻击" class="headerlink" title="Outside Attacks 外部攻击"></a>Outside Attacks 外部攻击</h3><h4 id="Virus"><a href="#Virus" class="headerlink" title="Virus"></a>Virus</h4><p>病毒: 不断地复制自身并传播</p><h4 id="Morris-Worm"><a href="#Morris-Worm" class="headerlink" title="Morris Worm"></a>Morris Worm</h4><p>蠕虫: 先潜伏自己的存在, 直到传播到一定规模后再爆发</p><p>(zero-day Attack</p><p>Zombie</p><p>…</p><h2 id="系统设计的原则"><a href="#系统设计的原则" class="headerlink" title="系统设计的原则"></a>系统设计的原则</h2><ol><li>System design should be public </li><li>Default should be no access </li><li>Check for current authority </li><li>Give each process least privilege possible </li><li>Protection mechanism should be 保护机制应当<ul><li>simple 简单</li><li>uniform  统一</li><li>in lowest layers of system  处于系统底层</li></ul></li><li>Scheme should be psychologically acceptable</li></ol><h2 id="保护机制-⭐"><a href="#保护机制-⭐" class="headerlink" title="保护机制 ⭐"></a>保护机制 ⭐</h2><h3 id="Protection-Domains"><a href="#Protection-Domains" class="headerlink" title="Protection Domains"></a>Protection Domains</h3><p>注: 下文中提到的 <em>用户</em> 也可能指进程</p><p>保护域</p><p>a domain is a set of （object， right） pairs. Each pair specifies an object and some<br>subset of the operations that can be performed. A right means permission to perform one of the operations.<br>一对对象权限的组合，每对组合指定一个对象和一些可在上面运行的操作子集指对某个操作的执行许可.</p><p>人话: 一张表, 记录了所有的文件和每个用户允许对文件进行的操作</p><p>缺点: 太大</p><h3 id="Access-Control-Lists-ACL"><a href="#Access-Control-Lists-ACL" class="headerlink" title="Access Control Lists , ACL"></a>Access Control Lists , ACL</h3><p>访问控制列表</p><p>每个对象的有序列表里包含了所有可访问对象的域以及这些域如何访问这些对象的方法</p><p>人话: 由于文件多而域少, 因此在每个文件处记录哪些域能进行什么操作. 将保护域按文件分解</p><h3 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h3><p>权能字</p><p>使用按行存储时，与每个进程关联的是可访问的对象列表，以及每个对象上叫做权能字列表，每个单独的项目叫做权能字</p><p>人话: 每个用户自己储存对每个文件能进行什么操作, 将保护域按用户分解</p><p>因此要防止权能字被用户自己篡改(三种方法)</p><ol><li>First way, require a tagged architecture </li><li>Second way, keep the C-list inside the OS </li><li>Third way, keep the C-list in user space, but manage the capabilities cryptographically</li></ol><h2 id="可信任系统"><a href="#可信任系统" class="headerlink" title="可信任系统"></a>可信任系统</h2><p>完全可信任的系统是否存在?</p><p>可信任系统的核心是 <strong>可信计算基Trusted Computing Base, TCB</strong></p><p>TCB 是一种机制, 保护所有敏感操作; (例如切换进程, 进程创建, 内存映射管理等) 任何试图访问这些操作的进程必须通过可信计算基的安全审查, 称为 reference monitor (访问监视器)</p><blockquote><p>All system calls go through the reference monitor for security checking</p></blockquote><p>TCB可以通过硬件, 软件, 固件的形式实现, 它只是个机制. </p><p>一旦可信计算机基的某个构件出现程序错误或者安全隐患，就对整个系统的安全造成危害。 与之相反，如果除可信计算基之外的系统的其他部分出现问题，也只是泄漏了系统安全策略赋予它们的相关权限而已，这些权限一般都是比较低的。</p><p>现代操作系统努力降低TCB的大小，使得对其代码库彻底的检查成为可能.</p><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>操作系统之安全  (本文)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将涉及:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安全与威胁&lt;/li&gt;
&lt;li&gt;简易密码学(真的很简易!)&lt;/li&gt;
&lt;li&gt;用户认证&lt;/li&gt;
&lt;li&gt;系统受到的攻击&lt;ol&gt;
&lt;li&gt;来自内部&lt;/li&gt;
&lt;li&gt;来自外部&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;保护机制&lt;/li&gt;
&lt;li&gt;信任系统&lt;/li&gt;
&lt;li&gt;OS安全&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;本文匆匆赶制, 内容粗糙简陋&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之多处理器系统</title>
    <link href="http://yoursite.com/2020/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-08-08T14:59:29.000Z</published>
    <updated>2020-08-15T11:04:34.529Z</updated>
    
    <content type="html"><![CDATA[<p>本章将会涉及:</p><ol><li>多处理器系统</li><li>多计算机系统</li><li>虚拟化</li><li>分布式</li></ol><a id="more"></a><p>对更快的计算是推动计算机进步的动力. 除了从技术层面上突破(如优化芯片) , 人们还设计了这些系统来提高计算水平. </p><ol><li><p>计算机并行处理, 主要体现在同一个计算机中存在多个处理器 , 这些处理器 <u>共享内存模块</u> (share memory model ). 称为 <strong>多处理器系统</strong> (<strong>Multiprocessors</strong>)</p><blockquote><p>注意与 <strong>多核</strong> 的区别</p><p>多处理器指: 在一个机器中有多个处理器;</p><p>多核: 在一个处理器中有多个处理芯片</p></blockquote></li><li><p>多个计算机相互协作. 表现为不同的计算机通过 <u>消息传递</u> 的而协作.(紧耦合)  称为 <strong>多计算机系统</strong> (<strong>Multicomputers</strong> )</p></li><li><p>多个计算机互相协作. 表现为通过 <u>广域分布式系统</u> (指网络) 协作. (松耦合) 称为 <strong>分布式系统</strong> (<strong>Distributed systems</strong>)</p></li></ol><p><img src='https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%89%E7%A7%8D%E6%8A%80%E6%9C%AF.png' height = '500' width = '1300'></img></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E6%AF%94%E8%BE%83.png" alt=""></p><p>除此之外本章还会涉及到 <strong>虚拟化技术</strong> (Virtualization ).</p><h2 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h2><p>在一个计算机系统内部，两个以上的CPU共享对一个公共RAM都拥有的完全访问权限. 根据不同CPU读写速度的不同又分为</p><ol><li><p>UMA ( Uniform Memory Access ， 统一内存访问)</p><p>每个存储器字的读出速度是一样快的。 </p><p>主要有三种硬件实现</p><ol><li>Bus-Based Architectures 总线结构</li><li>Crossbar Switches  交叉开关</li><li>Multistage Switching Networks  多级交换网络</li></ol></li><li><p>NUMA ( Nonuniform Memory Access， 非统一内存 访问 )</p><p>存储器访问时间取决于相对于处理器的存储器位置.</p><p>访问远程存储器的速度比本地存储器慢</p></li></ol><h3 id="UMA-的硬件实现"><a href="#UMA-的硬件实现" class="headerlink" title="UMA 的硬件实现"></a>UMA 的硬件实现</h3><p><em><u>了解</u></em></p><h4 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h4><p>字面意思, 每个CPU通过总线与内存交互. 又可分为三种:</p><ol><li>不带独立cache</li><li>拥有独立cache</li><li>拥有独立cache和私有内存</li></ol><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%89%E7%A7%8D%E6%80%BB%E7%BA%BF.png" alt=""></p><p>问题: CPU会争夺总线的使用权, 引起<strong>竞争</strong>.</p><h4 id="交叉开关"><a href="#交叉开关" class="headerlink" title="交叉开关"></a>交叉开关</h4><p>对于 $n$ 个CPU 构建 $n\times n$ 的交叉开关网络. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%BA%A4%E5%8F%89%E5%BC%80%E5%85%B3.png" alt=""></p><p>优点: 绝对不会竞争或阻塞</p><p>缺点: 开销过大</p><h4 id="多级交换网络"><a href="#多级交换网络" class="headerlink" title="多级交换网络"></a>多级交换网络</h4><p>使用 2*2 的交换机来构建多级交换网络.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E5%A4%9A%E7%BA%A7%E4%BA%A4%E6%8D%A2.png" alt=""></p><p>上图是三级交换网络, 对于 $n$ 个CPU, 仅需要 $3\times \frac n 2$ 个交换机. 同时每个线路的可通达度大幅提高了.</p><h3 id="OS-划分类型"><a href="#OS-划分类型" class="headerlink" title="OS 划分类型"></a>OS 划分类型</h3><h4 id="类型１-每个CPU都有自己的OS"><a href="#类型１-每个CPU都有自己的OS" class="headerlink" title="类型１: 每个CPU都有自己的OS"></a>类型１: 每个CPU都有自己的OS</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E7%8B%AC%E8%87%AA1.png" alt=""></p><ul><li>内存划分为n个部分</li><li>为每个CPU分配自己的专用内存和操作系统的专用副本</li><li>OS每个操作系统都有自己的表，不共享进程；<br>没有共享页面</li></ul><h4 id="类型2-主从处理器"><a href="#类型2-主从处理器" class="headerlink" title="类型2: 主从处理器"></a>类型2: 主从处理器</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%BB%E4%BB%8E2.png" alt=""></p><ul><li>OS及其表的一个副本位于CPU1上</li><li>所有系统调用都重定向到CPU1进行处理</li><li>缺点: 如果从处理器过多, 主处理器的性能将成为系统的瓶颈</li></ul><h4 id="类型3-对称处理器"><a href="#类型3-对称处理器" class="headerlink" title="类型3: 对称处理器"></a>类型3: 对称处理器</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E5%AF%B9%E7%A7%B03.png" alt=""></p><ul><li>内存中只有一个OS副本，但是任何CPU都可以运行它</li><li>使用互斥量(锁)保证只有一个处理器在使用OS </li></ul><h3 id="处理器的调度"><a href="#处理器的调度" class="headerlink" title="处理器的调度"></a>处理器的调度</h3><h4 id="分时调度-Timesharing"><a href="#分时调度-Timesharing" class="headerlink" title="分时调度 Timesharing"></a>分时调度 Timesharing</h4><p>Using a single data structure for scheduling a multiprocessor</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/time.png" alt=""></p><h4 id="分空间调度-Space-sharing"><a href="#分空间调度-Space-sharing" class="headerlink" title="分空间调度 Space sharing"></a>分空间调度 Space sharing</h4><p>multiple threads at same time across multiple CPUs</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/space.png" alt=""></p><h4 id="Gang-Scheduling-（-群调度-）"><a href="#Gang-Scheduling-（-群调度-）" class="headerlink" title="Gang Scheduling （ 群调度 ）"></a>Gang Scheduling （ 群调度 ）</h4><ol><li>Groups of related threads scheduled as a unit (a gang)</li><li>All members of gang run simultaneously （ 同时 ） on different timeshared CPUs </li><li>All gang members start and end time slices together</li></ol><p><em>其他的应该不是重点</em></p><hr><h2 id="多计算机系统"><a href="#多计算机系统" class="headerlink" title="多计算机系统"></a>多计算机系统</h2><p>一言以蔽之: <u>不共享内存的紧密耦合CPU</u></p><p>又称为cluster computers (群集计算机) , clusters of workstations (群集工作站,COW)</p><p>每个CPU的内存连接在自己的CPU上并且不会被其他CPU访问到. </p><p><em>本节不是重点</em></p><h3 id="互联拓扑结构"><a href="#互联拓扑结构" class="headerlink" title="互联拓扑结构"></a>互联拓扑结构</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%BA%92%E8%81%94%E6%8B%93%E6%89%91.png" alt=""></p><p>星型; 环型; 网格; 双环; 立方; 超立方</p><h3 id="存储转发分组交换"><a href="#存储转发分组交换" class="headerlink" title="存储转发分组交换"></a><strong>存储转发分组交换</strong></h3><h3 id="其他链接方式"><a href="#其他链接方式" class="headerlink" title="其他链接方式"></a><strong>其他链接方式</strong></h3><p>电路交换</p><p>虫孔路由</p><p>…</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><ul><li>根据计算能力的需要，可能需要在多台刀片服务器上部署 应用，即分布式应用部署。</li><li>为了在这个分布式计算环境上，给最终用户一个集成的开 发环境，让用户感觉是在一台计算机上进行编程一样，底 层多台刀片服务器之间需要使用远程过程调用RPC。</li><li>选型RPC 框架时，主要考虑三个关键方面：传输协议与数 据类型（JSON、XML 等），数据的存储、传输效率，服 务器端对数据的请求方式。</li></ul><hr><h2 id="虚拟化⭐"><a href="#虚拟化⭐" class="headerlink" title="虚拟化⭐"></a>虚拟化⭐</h2><p>虚拟机技术，通常简称为 <strong>虚拟化</strong> virtualization 。<br>该技术允许一台计算机托管多个虚拟机，每个虚拟机可能运行不同的操作系统。</p><p>优点:</p><ul><li>一个虚拟机的故障不会自动导致其他任何故障。 </li><li>拥有更少的物理机可以节省硬件成本并占用更少的空间</li><li>检查点和迁移虚拟机比普通的要容易得多</li><li>在不再受支持或无法在当前硬件上运行的操作系统上运行旧版应用程序</li><li>在软件开发时确保软件可以在不同的OS上运行。</li></ul><p><strong>Hypervisor</strong>, also called Virtual Machine Monitor (VMM, 虚拟机监视器)它是在硬件层之上，独立于操作系统的一层软件。创建虚拟化平台，OS实例运行在这个平台上，使得硬件可以被多个OS和应用共享.</p><p><em><u>搞清楚几种的区别</u></em></p><h3 id="Type-1-Hypervisor"><a href="#Type-1-Hypervisor" class="headerlink" title="Type 1 Hypervisor"></a>Type 1 Hypervisor</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E8%99%9A%E6%8B%9F%E5%8C%961.png" alt=""></p><ul><li>Hypervisor 直接运行在硬件之上, 其余的OS运行在Hypervisor 上.</li><li>但是OS都以为自己在内核上 (实际是用户态)</li><li>被称为 <strong>虚拟内核态</strong> (virtual kernel mode)</li><li>例如: Hyper-V, Xen, Vmware vSphere</li></ul><h3 id="Type-2-Hypervisors"><a href="#Type-2-Hypervisors" class="headerlink" title="Type 2 Hypervisors"></a>Type 2 Hypervisors</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E8%99%9A%E6%8B%9F%E5%8C%962.png" alt=""></p><ul><li>主OS运行在硬件上, Hypervisor 运行在主OS上, 其余OS 运行在Hypervisor 上.</li><li>当虚拟OS第一次启动时, Hypervisor 引导它们安装在虚拟磁盘上</li><li>例如:  Vmware worksation, Parallels, VM virtualBox</li></ul><h3 id="Paravirtualization-半虚拟化"><a href="#Paravirtualization-半虚拟化" class="headerlink" title="Paravirtualization  半虚拟化"></a>Paravirtualization  半虚拟化</h3><p>修改来宾操作系统的源代码，以便根本不执行敏感指令，而进行 <strong>hypervisor calls</strong>.</p><p>Hypervisor 定义接口，该接口由guest操作系统可以使用的一组过程调用组成（API）.</p><p>这种限制guest操作系统敏感操作的方式称为 <strong>半虚拟化</strong> (paravirtualized)</p><hr><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><em>不是重点</em></p><p>使用中间件技术实现一致性.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%AD%E9%97%B4%E4%BB%B6.png" alt=""></p><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>操作系统之多处理器系统 (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将会涉及:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多处理器系统&lt;/li&gt;
&lt;li&gt;多计算机系统&lt;/li&gt;
&lt;li&gt;虚拟化&lt;/li&gt;
&lt;li&gt;分布式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之文件系统</title>
    <link href="http://yoursite.com/2020/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-08-06T08:27:07.000Z</published>
    <updated>2020-08-15T11:05:18.531Z</updated>
    
    <content type="html"><![CDATA[<p>本章将会涉及:</p><ol><li>文件</li><li>目录</li><li>文件系统的实现</li></ol><a id="more"></a><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>在进程的运行过程中出现了以下需求: 1) 需要储存大量信息; 2)信息需要保存至进程结束后; 3) 多个进程需要同时对数据进行操作.</p><p>为了解决以上问题, 我们将信息存储在磁盘和其他外部介质中, 称之为 <strong>文件</strong>.</p><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>文件的命名要求因操作系统而已. </p><p>有的系统区分文件的大小写, 有的则不区分(MS-DOS).</p><p>许多OS使用字符<code>.</code>将文件名分成两部分, 后半部分称为 <strong>文件后缀名</strong>(file extension)</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E5%90%8E%E7%BC%80.png" alt=""></p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>文件有多种组成结构</p><ol><li>byte sequence  文件由字节序列组成 (UNIX和WIN都是如此)</li><li>record sequence 文件由记录片组成(早期插卡式系统)</li><li>tree 树型 文件是一层层地储存的</li></ol><h3 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h3><p>由使用用途</p><ul><li>系统文件</li><li>用户文件</li><li>库文件</li></ul><p>由数据形式</p><ul><li>源文件</li><li>目标文件</li><li>可执行文件</li></ul><p>由权限</p><ul><li>只可执行文件</li><li>只读</li><li>读写</li></ul><p>由逻辑结构</p><ul><li>结构化数据</li><li>非结构化数据</li></ul><p>由(在硬盘上储存的)物理结构</p><ul><li>顺序文件</li><li>连接文件</li><li>索引文件</li></ul><p>UNIX和WIN都有常规文件和目录文件</p><p>UNIX中还有 字符设备文件 和块设备文件, 进程文件(伪文件)等特殊文件.</p><h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><ul><li><p>顺序访问</p><p>只能从最开始访问</p><p>不能跳转</p></li><li><p>随机访问</p><p>以任意顺序访问</p></li></ul><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>文件包括很多属性,见图</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.png" alt=""></p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li>创建</li><li>删除</li><li>打开</li><li>关闭</li><li>读</li><li>写</li><li>追加</li><li>查找</li><li>访问属性</li><li>设定属性</li><li>重命名</li></ul><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="目录系统的种类"><a href="#目录系统的种类" class="headerlink" title="目录系统的种类"></a>目录系统的种类</h3><ul><li><p>单层析目录</p><p>ROOT 下直接跟随各种文件</p></li><li><p>双层次目录</p><p>ROOT 下由用户创建文件夹, 并在文件夹中储存文件</p></li><li><p>多层次目录</p><p>ROOT 下由用户创建文件夹, 并在文件夹中储存文件或文件夹</p></li></ul><h3 id="路径-⭐"><a href="#路径-⭐" class="headerlink" title="路径 ⭐"></a>路径 ⭐</h3><p>假设文件层次如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root:</span><br><span class="line">├─other1</span><br><span class="line">└─usr</span><br><span class="line">    ├─ast</span><br><span class="line">    │  ├─mailbox</span><br><span class="line">    │  ├─myInfo.txt</span><br><span class="line">    │  └─other3</span><br><span class="line">    └─other2</span><br></pre></td></tr></table></figure><p>假设当前位于<code>ast</code>目录</p><ul><li><p>Absolute path name </p><p>绝对路径(从根目录起) 前加 <code>/</code> </p><ul><li><code>/usr/ast/mailbox</code> (UNIX)   访问mailbox文件夹</li><li><code>/usr/ast/myInfo.txt</code> (UNIX)   访问myInfo.txt</li><li><code>\usr\ast\mailbox</code> (Win)    访问mailbox文件夹</li></ul></li><li><p>Relative path name</p><p>相对目录(从当前目录开始) </p><ul><li><code>mailbox</code>    访问mailbox文件夹</li><li><code>./myInfo.txt</code> 访问myInfo.txt</li></ul><p>如访问当前目录的可执行文件，如果用相对路径必须是 ./filename</p></li><li><p>Working directory ( current directory) </p><ul><li><code>/usr/ast</code> 表示当前目录</li></ul></li></ul><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><ul><li>Create</li><li>Delete</li><li>Opendir</li><li>Closedir</li><li>Readdir</li><li>Rename</li><li>Link(hard link/symbol link)</li><li>Unlink</li></ul><hr><h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><p>文件都是储存在磁盘上的. 大多数磁盘都分为一个或多个区(Partitions) ,  每个区都有自己的独立文件系统.</p><p>磁盘的0扇区被称为 <strong>主引导区</strong> <strong>MBR</strong> (Master Boot Record) , 用于引导计算机启动.</p><blockquote><p> Sector 0 of the disk is called MBR (Master Boot Record) and is used to boot the computer.</p></blockquote><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80.png" alt=""></p><ul><li>Partition table: 给出每个分区开始结束的地址信息gives the starting and ending addresses of each partition. </li><li>Boot block: locate the active partition </li><li>Superblock: magic number, number of blocks, … </li><li>Free space mgmt: 使用位图/链表储存文件的空余信息</li><li>i-nodes: an array of data structure, one per file. </li><li>后面的部分就是真正的文件和目录内容了</li></ul><h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><ul><li>顺序存放</li><li>链接存放</li><li>使用FAT在内存中链接存放 </li><li>I-Node ⭐</li></ul><h4 id="顺序存放"><a href="#顺序存放" class="headerlink" title="顺序存放"></a>顺序存放</h4><p>就是顺序存放.</p><p>优点:</p><ul><li>简单</li><li>读的性能非常高效</li></ul><p>缺点</p><ul><li>文件如果后续需要删除, 重写会造成大量碎片</li></ul><p>常用于后续不会再写入数据. 如CD</p><h4 id="链接存放"><a href="#链接存放" class="headerlink" title="链接存放"></a>链接存放</h4><p>每个文件都指明下一个文件的指针</p><p>缺点: 随机访问非常非常慢, 找一个文件要从头找</p><h4 id="使用FAT在内存中链接存放⭐"><a href="#使用FAT在内存中链接存放⭐" class="headerlink" title="使用FAT在内存中链接存放⭐"></a>使用FAT在内存中链接存放⭐</h4><p>将文件的链接关系放在一张表中, 称为 <strong>文件分配表</strong> (( File Allocation Table), FAT) </p><p>缺点: 需要将整个文件系统的表(通常很大)载入内存.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/FAT.png" alt=""></p><h4 id="I-Node-⭐"><a href="#I-Node-⭐" class="headerlink" title="I-Node ⭐"></a>I-Node ⭐</h4><p>给每个文件赋予一个相关联的数据结构, 称为 <strong>索引节点</strong>（I-Node , index-node），该数据结构列出了文件块的<strong>属性</strong>和<strong>磁盘地址</strong>。仅在访问本文件时, 才需要将节点载入内存.</p><p>也有可能储存文件的磁盘地址比较多, 可以再指向另外一个储存地址的地址</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/inode.png" alt=""></p><h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>目录系统的主要功能是<strong>将文件的ASCII名称映射到定位数据所需的信息</strong>上。</p><p>Windows 系统给每个条目都分配了定长的数据段, 来保存文件的属性. </p><p>UNIX 系统给每个条目分配一个I-node的引用</p><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>UNIX 提供共享文件的机制. 出现在多用户下.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6.png" alt=""></p><p>C的一个文件出现在B的目录下。B的目录与该共享的联系称为一个连接 LINK.</p><p>问题：若目录中包含磁盘地址，则连接文件时，C目录的磁盘地址复制到B目录<br>中，若B或C后又加内容，则新的数据块只会列入进行添加工作的目录中。</p><h4 id="hard-link"><a href="#hard-link" class="headerlink" title="hard link"></a><strong>hard link</strong></h4><p>（硬连接或者实际连接）</p><p>由于Linux里面每个文件都对应一个inode，而文件名是记录在目录的block里的，也就是说文件名和inode没有关系，这样就可以把多个文件名对应同一个inode，这就是hard link，简单的说：hard link只是在某个目录下新建一条文件名连接到某inode号码的关联记录而已。</p><p>缺点</p><ul><li>不能够跨文件系统地做硬连接</li><li>不能够连接到目录</li></ul><h4 id="symbolic-link"><a href="#symbolic-link" class="headerlink" title="symbolic link"></a><strong>symbolic link</strong></h4><p>软连接或者符号连接</p><p>软连接创建一个新的文件，有自己的inode和block，只是在block里记录的是到连接目标文件的指向，读取到这个指向记录以后，系统再从根目录一层层进到目标文件的block里把数据读出来</p><p>symbolic link有如下特点：</p><p>1.等于是文件的一个“快捷方式”，只起一个指向作用</p><p>2.是一个独立的新文件，对目标文件没有任何影响</p><p>3.目标文件一旦删除，软连接会打不开</p><p>两种连接方式都存在的问题: 查找文件时会将同一个文件重复查询.</p><h3 id="Linux虚拟文件系统VFS"><a href="#Linux虚拟文件系统VFS" class="headerlink" title="Linux虚拟文件系统VFS"></a>Linux虚拟文件系统VFS</h3><p> 整个 Linux 系统通过 Virtual Filesystem Switch 的核心功能去 读取 filesystem。整个 Linux 认识的 filesystem 都是 VFS 在 进行管理，使用者并不需要知道每个 partition 的 filesystem 是什么</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/VFS.png" alt=""></p><p><em><u>其他了解即可</u></em></p><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>操作系统之文件系统 (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将会涉及:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件&lt;/li&gt;
&lt;li&gt;目录&lt;/li&gt;
&lt;li&gt;文件系统的实现&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之IO管理</title>
    <link href="http://yoursite.com/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIO%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIO%E7%AE%A1%E7%90%86/</id>
    <published>2020-08-05T13:08:03.000Z</published>
    <updated>2020-08-17T10:39:09.256Z</updated>
    
    <content type="html"><![CDATA[<p>本章将涉及: </p><ol><li>IO设备</li><li>盘</li><li>时钟</li><li>其他</li></ol><p><em>本文匆匆赶制, 内容粗糙简陋  <del>背就完事了</del></em> </p><a id="more"></a><h2 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h2><h3 id="IO设备分类-⭐"><a href="#IO设备分类-⭐" class="headerlink" title="IO设备分类 ⭐"></a>IO设备分类 ⭐</h3><ul><li>块设备 (Block device)<ul><li>储存于固定大小的块中, 每块都有自己的地址</li><li>每个块都可以可以独立于其他块进行读写</li><li>例如: 磁盘</li></ul></li><li>字符设备 ( Character device )<ul><li>使用字符流进行传递</li><li>不可寻址, 没有任何查找功能</li><li>例如: 打印机, 键鼠</li></ul></li><li>其他<ul><li>时钟</li></ul></li></ul><p><em>我们接下来的讨论一般是针对块设备</em></p><h3 id="IO-设备部组成"><a href="#IO-设备部组成" class="headerlink" title="IO 设备部组成"></a>IO 设备部组成</h3><ul><li>机械部件(即普遍意义上的设备)</li><li>电子部件</li></ul><p>其中电子部件是用于控制管理机械部件的, 我们将电子部件称为 <strong>设备控制器</strong> .它的主要功能是: </p><p><em><u>知道作用</u></em></p><ul><li><p>Convert the serial bit stream into a block of bytes </p><p>将串行字节流转化未字节块</p></li><li><p>Perform any error correction necessary </p><p>对于运行时可能的出错进行纠正</p></li><li><p>Copy it to main memory</p><p>将字节复制到主存</p></li></ul><p><em>注: 一个设备控制器可能同时负责多个机械设备</em></p><p>此外每个设备控制器都拥有一些寄存器用于与OS通信:</p><ul><li>OS通过写入寄存器来命令设备执行操作等</li><li>OS通过读取寄存器来获取设备的状态</li></ul><p>除了寄存器外, 许多设备还有OS可以读取/写入的数据缓冲区</p><h3 id="与OS的通信方式"><a href="#与OS的通信方式" class="headerlink" title="与OS的通信方式"></a>与OS的通信方式</h3><p>OS和控制器的通信可以分为三种方式 ⭐</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/mmio.png" alt=""></p><ol><li><p>独立空间</p><p>每个控制寄存器器都分配有一个单独的IO端口号</p><p>内存的地址空间和IO的地址空间完全独立</p></li><li><p>内存映射 </p><p>将所有的控制寄存器映射到内存空间.</p><p>这些被映射的内存空间不会被其他内存映射, 只能由控制寄存器使用</p><p><strong>优点</strong></p><ol><li>, a I/O device driver can be written entirely in C. Otherwise, some assembly code is needed</li><li>No special protection mechanism is needed to keep user processes from performing I/O.</li><li>Every instructions that can reference memory can also reference control registers.</li></ol></li><li><p>混合</p><p>IO数据缓冲区采用内存映射, 寄存器采用独立空间</p></li></ol><p>IO软件层次: 驱动</p><p>需要实现:</p><ul><li>设备独立性, 设备在接入前不需要任何特殊处理</li><li>统一命名</li><li>纠错(贴近硬件层, 不需要OS费心)</li><li>异步传输</li><li>缓冲区</li><li>共享设备&amp;专业设备</li></ul><h3 id="IO控制方式-⭐"><a href="#IO控制方式-⭐" class="headerlink" title="IO控制方式 ⭐"></a>IO控制方式 ⭐</h3><ol><li><p>程序控制IO  Programmed I/O </p><p>使用程序不断查询设备以了解是否就绪, 忙等待, 低效 浪费CPU</p></li><li><p>中断控制IO  Interrupt-Driven I/O </p><p>允许CPU在IO工作时干其他时, 当IO完毕时发出中断.</p><p>问题在于IO每次只能传输一个字符, 中断频率过高</p></li><li><p>DMA控制IO⭐  I/O Using DMA </p><p>DMA控制器Direct Memory Access 是一个能够独立于CPU访问系统总线的控制器, 相当于一个字符缓冲池, 当缓冲池满了再向CPU发出中断信号.</p><blockquote><p>DMA controller <strong>has access to the system bus independent of the CPU</strong>. It contains several registers that can be written and read by the CPU</p></blockquote><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/dmA.png" alt=""></p><ol><li>CPU向DMA发出指令(而后CPU继续运行其他进程)</li><li>DMA向IO控制器发送传输指令</li><li>IO控制器与存储单元传输数据</li><li>传输控制器回应DMA</li><li>DMA向CPU发出IO中断信号(CPU处理)</li></ol></li></ol><h3 id="IO软件层次"><a href="#IO软件层次" class="headerlink" title="IO软件层次"></a>IO软件层次</h3><p>中断处理</p><p>最好是隐藏的, 不被感知. </p><p>一般需要大量时间, 负责设备与设备驱动之间的通信.</p><p>设备驱动器</p><p>设备独立性 : 设备在接入前不需要任何特殊处理</p><p>统一接口</p><p>缓冲区</p><p>​    双BUFFER区(乒乓机制)</p><h2 id="盘"><a href="#盘" class="headerlink" title="盘"></a>盘</h2><ol><li><p>每个byte由 14个bits构成</p></li><li><p>每42个byte构成1个帧(frame)</p><p>但是每frame种只有24byte用于记录数据, 剩下的用于校验和控制</p></li><li><p>98个帧构成扇区sector </p><p>每个扇区有16byte的引导符preamble, 后面又有288byte的ECC(纠错)</p></li></ol><p>柱面斜进, 每圈的零扇区在磁盘上不是位于同一条直线上.</p><p>磁盘交错. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/DISK%20FORMAT.png" alt=""></p><ol><li>无交错, 每个扇区顺序排列</li><li>单交错</li><li>双交错</li></ol><p><em>(以上了解)</em></p><h3 id="磁盘臂调度算法⭐"><a href="#磁盘臂调度算法⭐" class="headerlink" title="磁盘臂调度算法⭐"></a>磁盘臂调度算法⭐</h3><p>磁盘在读写过程种有三个时间决定: </p><ul><li><p>寻道时间Seek Time </p><p>将磁盘臂移动到适当的柱面上需要的时间</p></li><li><p>旋转延迟Rotational delay</p><p>等待适当的扇区旋转到磁头下的时间</p></li><li><p>数据传输时间Actual data trasfer time.</p><p>相比前面两个来说非常小</p></li></ul><p>传输时间相对忽略不计, 旋转延迟由机械决定, 讨论寻道时间</p><h4 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h4><p>按照柱面访问顺序进行访问. </p><h4 id="Shortest-Seek-Frist-最近柱面优先"><a href="#Shortest-Seek-Frist-最近柱面优先" class="headerlink" title="Shortest Seek Frist 最近柱面优先"></a>Shortest Seek Frist 最近柱面优先</h4><p>每次都访问离当前最近的</p><h4 id="The-elevator-algorithm-电梯调度"><a href="#The-elevator-algorithm-电梯调度" class="headerlink" title="The elevator algorithm 电梯调度"></a>The elevator algorithm 电梯调度</h4><p>每次都从头到尾,再从尾到头</p><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>作用⭐</p><ol><li><p>Maintaining the time of day  维持一天中的时间。 </p></li><li><p>Preventing pro running longer  防止进程运行超出允许的时间</p><p>在启动进程时设定一个计数器, 每个时钟中断处将计数器—, When it gets to zero, the clock driver calls the scheduler to set up another process.</p></li><li><p>Accounting for CPU usage  计算CPU使用率</p><p>每当启动进程时，启动一个不同于主系统计时器的第二个计时器。当该过程停止时，可以读出计时器以告知该过程已运行了多长时间。</p></li><li><p>Handling the alarm system call  处理用户进程发出的警报系统调用</p></li><li><p>Providing watchdog timers  为系统本身的各个部分提供监视定时器</p><p>例如: 在一定时间间隔内未确认的数据包必须重新发送</p></li></ol><p><em><u>其他了解即可</u></em></p><h2 id="Network-terminals-网络终端"><a href="#Network-terminals-网络终端" class="headerlink" title="Network terminals                    网络终端"></a>Network terminals                    网络终端</h2><h3 id="两类终端"><a href="#两类终端" class="headerlink" title="两类终端"></a>两类终端</h3><ul><li><p>胖终端  X Windows</p><p>终端具有大量的计算能力和内存，以便运行复杂的协议来压缩通过网络发送的数据量。 </p></li><li><p>瘦终端 SLIM</p><p>终端非常简单，基本上是显示像素，并且为了使其便宜而没有做太多的复杂设计</p></li></ul><p><em><u>其他了解即可</u></em></p><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>操作系统之IO管理  (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将涉及: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IO设备&lt;/li&gt;
&lt;li&gt;盘&lt;/li&gt;
&lt;li&gt;时钟&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;本文匆匆赶制, 内容粗糙简陋  &lt;del&gt;背就完事了&lt;/del&gt;&lt;/em&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>山与水-漫步秦岭之子午古道</title>
    <link href="http://yoursite.com/2020/08/05/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%AD%90%E5%8D%88%E5%8F%A4%E9%81%93/"/>
    <id>http://yoursite.com/2020/08/05/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%AD%90%E5%8D%88%E5%8F%A4%E9%81%93/</id>
    <published>2020-08-05T03:08:22.000Z</published>
    <updated>2020-08-05T04:27:28.427Z</updated>
    
    <content type="html"><![CDATA[<p>2020年8月2日    海拔1564</p><p>子午古道: 拐儿崖-金仙观-土地梁-尖山 (原路返回)</p><a id="more"></a><p>正儿八经的第一篇徒步记录. 其实是第二次徒步了, 上一篇见2020-07-2的周记. 前两天斥资五百大洋购买了正经装备, 拿这次热热身😄</p><p>学校还在因为疫情继续封闭, 大清早通过某种不可言说的手段溜了出来, 自行打车前往峪口. (大清早在省体集合真的对郊区不友好啊) 打车钱都快赶上参团费用了😭. 约八点二十抵达子午口保护总站, 大部队还没来. 琢磨了下子午峪的简介, 不感冒的看官可跳过~</p><blockquote><p>秦岭七十二峪之一，位于陕西省西安市境内。峪长六百六十里，北口曰子，在西安府南百里；南口曰午，在汉中府洋县东一百六十里。</p><p>子午古道始于战国，范睢相秦“栈道千里，通于蜀汉”，使天下畏秦。“子午”之名谢于西汉，西汉修建.长安城时中轴线其南端起于子午谷口。</p><p>子午至唐代变是通畅，巴蜀荔枝由此道直送长安，故又称荔枝道。该递在朝晚期左宗梁任扶甘总替时全线整修，现谷口的石拱桥即为当时所修。</p><p>——- 选自入口处石碑</p></blockquote><p>确实是从西安城里的子午大道正南方. <strong>“一骑红尘妃子笑，无人知是荔枝来”</strong>.自四川涪州置专驿直通长安。每年“飞骑驰进，七日七夜至京，人马多毙于路，百姓苦之”.</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BF%9D%E6%8A%A4%E7%AB%99.jpg" alt=""></p><p>入山需要刷身份证, 各位别忘了! 先乘摆渡车至金仙观, 领队带着简单热身之后便开始徒步, 最初一公里依旧是观光道, 虽有坡度但不算难走, 行走约一公里抵达第一个休息点(七里坪村) , 经人家, 过小河, 正式进入山道, 攀升二百余米, 抵达休息点二, 期间一路伴水, 两侧环山, 山泉潺潺, 草木环绕. 昨夜的夜雨夹杂着晨雾带来的露水打湿着蛛网与衣角, 倘若登山杖不小心打在什么树枝丫上, 水滴更是直直簌簌地落在身上, 引起同行者一片惊叫. 烦心的是山路混合着宿雨, 有几处略有湿滑. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E6%99%A8%E9%9C%B2.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E5%B1%B1%E8%B7%AF.jpg" alt=""></p><p>从休息点二继续沿着山路行走, 不多时见着土地梁, 其实是路边一个小土地庙, 同行有人还去拜了拜, 这时领队芃芃喊我们看路边的小野瓜, 大家稍作休整,这才进入更陡峭的野道.此时已经约中午十一点, 日出而林霏开, 同行的小姐姐们发现路边的野蘑菇忽地冒了出来, 在大家不经意间身边就多了好些或白或黄的小蘑菇(当然我们也没作死去挑战), 值得一说的是, 我们下山再次路过它们的时候发现它们已经完全张开了, 此间对比的惊奇非亲历者不可察. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E8%98%91%E8%8F%87.jpg" alt=""></p><p>一路攀登, 不少陡峭湿滑的路段大家互相帮助着都过来了. 到海拔1350左右的最后一个休息区. 领队瑞子说就在这里午餐休整, 想登顶的可以继续. 那我们肯定是继续冲呀哈哈. 最后这段山路我依旧打头, 比较难走, 两旁丛林茂密, 脚下山路难以辨认, 常常有巨石横于路中, 非得手脚并用才可以爬过去, 好在一路上不断有前人留下的引路标, 有时爬累了抬头看看不远处的尖山顶, 互相鼓励说就一点了, 已经望见山顶了 . 最后这两百米硬是爬了一个小时. 终于登顶! </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E5%B2%A9%E7%9F%B3.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E7%99%BB%E9%A1%B6.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E5%90%88%E7%85%A7.jpg" alt=""></p><p>不巧是此时山顶依旧云里雾里, 只能模糊看见近处山体. 返回休息区的路上云雾散去, 芃芃帮着大家拍了好些照片, 大感谢. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BA%91%E6%B5%B71.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BA%91%E6%B5%B72.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BA%91%E6%B5%B73.jpg" alt=""></p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E7%85%A7%E7%89%87.jpg" alt=""></p><p>回到休息区, 领队带着食材整了个火锅. (山上一把火真的大丈夫?) 丸子火腿方便面真香. 还有同行的小姐姐前一天准备了好多吃的, 鸭脖鸡翅蛋挞水果…相比之下我是个蹭吃蹭喝的小废物😭</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E7%81%AB%E9%94%85.jpg" alt=""></p><p>大家还惊奇地发现不知道从哪儿冒出了一直贼乖巧的猫, 一直绕着你脚边伸懒腰———而且太乖巧好看以至于大家一致认为这不是野猫, 那怎么会有游客带着猫爬山呢? 还是说是附近农家养的猫, 已经习惯来找游客骗吃骗喝? 被骗的心甘情愿www</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E6%92%B8%E7%8C%AB.jpg" alt=""></p><p>小憩半小时, 原路返回. </p><p>回去路上发现原来大巴是过大学城的!!!!!! 那我直接在大学城等车不就好了为什么直接打车到峪口!!!! 贵死了都!!!!</p><p>写于 2020年8月5日</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E8%AE%B0%E5%BD%95.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年8月2日    海拔1564&lt;/p&gt;
&lt;p&gt;子午古道: 拐儿崖-金仙观-土地梁-尖山 (原路返回)&lt;/p&gt;
    
    </summary>
    
    
      <category term="山与水" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/"/>
    
      <category term="不积硅步" scheme="http://yoursite.com/categories/%E5%B1%B1%E4%B8%8E%E6%B0%B4/%E4%B8%8D%E7%A7%AF%E7%A1%85%E6%AD%A5/"/>
    
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="漫步秦岭" scheme="http://yoursite.com/tags/%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之死锁</title>
    <link href="http://yoursite.com/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%AD%BB%E9%94%81/"/>
    <id>http://yoursite.com/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%AD%BB%E9%94%81/</id>
    <published>2020-08-04T11:23:09.000Z</published>
    <updated>2020-08-15T11:06:21.777Z</updated>
    
    <content type="html"><![CDATA[<p>本章包括以下内容:</p><ol><li>资源与死锁</li><li>处理死锁<ol><li>冷处理: 鸵鸟算法</li><li>热处理: 死锁的检测与恢复</li></ol></li><li>防范死锁<ol><li>避免死锁</li><li>死锁预防</li></ol></li><li>其他策略</li></ol><a id="more"></a><h2 id="资源与死锁"><a href="#资源与死锁" class="headerlink" title="资源与死锁"></a>资源与死锁</h2><h3 id="资源定义与分类"><a href="#资源定义与分类" class="headerlink" title="资源定义与分类"></a>资源定义与分类</h3><p>计算机中具有 <strong>排他性使用</strong> 的对象称为 <strong><u>资源</u></strong> . (即每次只允许一个进程访问). 资源可以是硬件(设备)或软件(信息). 资源随着时间推移必须能<u>获得, 使用, 以及释放</u>.</p><ul><li>可抢占式资源: B进程可以将资源R从进程A出抢占<strong>而不会产生任何副作用</strong>. 例如储存器.</li><li>不可抢占式资源: 在不引起相关失败的情况下, 无法将资源从占有它的进程处抢占过来.例如打印机.</li></ul><p><u>死锁仅可能出现在不可抢占式资源上.</u></p><p>资源的使用流程:</p><ol><li>申请资源</li><li>使用资源</li><li>释放资源</li></ol><p><em>当资源申请失败时,不同系统会采取不同反应: 阻塞申请(等待唤醒) 或 返回错误 (用户决定)</em> </p><h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h3><blockquote><p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件, 那么称这个进程集合的 <strong><u>死锁</u></strong> 的.</p><p><em>A set of processes is deadlocked if each process in the set is waiting for an event that only another process in the set can cause</em> </p></blockquote><p><del>显然这个定义太正经了大家都知道死锁是什么.</del></p><p>当发生死锁时, 任何一个进程都无法: 运行 / 释放资源 / 被唤醒</p><h3 id="死锁的四个必要条件⭐"><a href="#死锁的四个必要条件⭐" class="headerlink" title="死锁的四个必要条件⭐"></a>死锁的四个必要条件⭐</h3><ul><li><p>互斥条件 <strong>Mutual exclusion</strong> condition</p><p>每个资源要么被分给了一个进程, 要么是可用的</p></li><li><p>占有并等待  <strong>Hold and wait</strong> condition </p><p>进程可以在占有资源A的同时等待资源B的分配</p></li><li><p>不可抢占  <strong>No preemption</strong> condition </p><p>已经被分配的资源不可抢占, 只能等待占有它的进程主动释放</p></li><li><p>环路等待  <strong>Circular wait</strong> condition</p><p>系统中有多于一个的进程, 每个进程都在等待下一个进程占有的资源</p></li></ul><p><u>死锁发生时四个条件必须同时满足, 只要使任一条件不被满足即可预防死锁.</u></p><h3 id="死锁建模"><a href="#死锁建模" class="headerlink" title="死锁建模"></a>死锁建模</h3><p>圆形表示进程; 方形表示资源; </p><p>资源指向进程: 该资源已被进程占用;</p><p>进程指向资源: 该进程正在等待资源;</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E6%AD%BB%E9%94%81%E5%BB%BA%E6%A8%A1.png" alt=""></p><p>例如, 上图中进程C在等待被进程D占有的资源T, 进程D在等待被进程C占有的资源U.</p><p><em>如果模型中有闭合有向环, 表明存在死锁.</em></p><hr><h2 id="处理死锁⭐"><a href="#处理死锁⭐" class="headerlink" title="处理死锁⭐"></a>处理死锁⭐</h2><h3 id="冷处理-鸵鸟算法"><a href="#冷处理-鸵鸟算法" class="headerlink" title="冷处理: 鸵鸟算法"></a>冷处理: 鸵鸟算法</h3><p>假装没有问题, 如果进程执行时间过长就重启一下…</p><p>这是由于死锁的产生是取决于进程执行的精确时序, 在同一进程集合的多次运行中可能死锁的出现是非常偶然的; 此外处理死锁的开销往往非常高昂.</p><p>实际中本算法效果较好</p><h3 id="热处理-检测并恢复"><a href="#热处理-检测并恢复" class="headerlink" title="热处理: 检测并恢复"></a>热处理: 检测并恢复</h3><p>系统并不会防范死锁的产生, 而是在死锁发生之后再进行死锁的检测与恢复.</p><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p><strong>DFS算法</strong>: (了解)</p><p>依次将每一个节点作为一棵树的根节点, 并进行深度优先搜索, 如果再次遇到该节点表明找到了环.</p><p><strong>剪枝算法</strong>: </p><p>如果某进程只申请不占有, 将该节点剪去;如果某资源只被占有不被申请, 将该节点剪去;重复这两步直到无法剪去, 存在环.</p><p><strong>矩阵检测</strong>: (了解)</p><p>E 矩阵: 所有资源的总数; A矩阵: 所有资源当前空余量;</p><p>C矩阵: $C_{ij}$ 表示进程 $ i $  当前使用资源 $j$ 的数目;</p><p>R矩阵: $R_{ij}$ 表示进程 $ i $  当前需要资源 $j$ 的数目;</p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E7%9F%A9%E9%98%B5%E6%A3%80%E6%B5%8B.png" alt=""></p><p>必定存在以下公式:</p><script type="math/tex; mode=display">\sum^n_{i=1}C_{ij} +A_j=E_j</script><p>如果当前的A矩阵可以使R矩阵按照一定顺序退出, 说明未形成死锁.</p><p>但死锁检测本身即浪费时间, 又需要定期检测, 所以热处理本身效果不佳.</p><h4 id="死锁的恢复"><a href="#死锁的恢复" class="headerlink" title="死锁的恢复"></a>死锁的恢复</h4><ul><li><p>资源抢占</p><p>将资源强制抢占(例如人工干预)</p></li><li><p>状态回滚</p><p>从之前某个状态重新加载, 重新跑未必发生死锁</p></li><li><p>杀死进程</p><p>杀死一个或若干个进程, 直到打破死锁.</p></li></ul><hr><h2 id="防范死锁⭐"><a href="#防范死锁⭐" class="headerlink" title="防范死锁⭐"></a>防范死锁⭐</h2><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><h4 id="资源轨迹图"><a href="#资源轨迹图" class="headerlink" title="资源轨迹图"></a>资源轨迹图</h4><p>当走向轨迹穿越阴影重叠区时<strong>有可能</strong>发生死锁. </p><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E8%B5%84%E6%BA%90%E5%9B%BE.png" alt=""></p><h4 id="安全态"><a href="#安全态" class="headerlink" title="安全态"></a>安全态</h4><p>安全态: 如果没有死锁发生,即使所有进程突然请求最大的资源需求, 也存在某种调度次序使得每一个进程都运行完毕.</p><p>不安全态: 如果没有死锁发生,若所有进程突然请求最大的资源需求, 不存在某种调度次序使得每一个进程都运行完毕.</p><p><u>注意: 不安全态不代表一定发生死锁, 但死锁发生一定经过不安全态.</u></p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E9%93%B6%E8%A1%8C%E5%AE%B6.png" alt=""></p><p>如果A向量能够使用某种次序分配能够使所有进程安全退出就处于安全状态;</p><p>如果一直使其处于安全状态则可以避免死锁.</p><blockquote><p>实际上银行家算法缺少使用价值, 很少有进程在运行前知道需要多少资源, 而且进程数也在随时变化(新任务产生), 而且资源的状态也随时可能变化(例如打印机坏了).</p></blockquote><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>从理论上完全避免死锁的不可能的(因为需要获知未来的请求) , 但是我们可以通过对死锁的四个必要条件的破坏来预防死锁的产生.</p><p><del>其实我觉得预防和避免这种文字游戏没啥意义,但是确实不知道怎么区分</del></p><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>如果资源不被一个进程独占, 则不会产生死锁. </p><p>具体做法是将打印机使用假脱机, 即IO输出实际上是将文件发送至打印机的磁盘中, 再由打印机的控制程序慢慢打印磁盘的内容. 而多个进程可以同时对磁盘输出, 破坏了互斥条件.</p><p>但如果在某些情况下磁盘本身成为了互斥的资源, 这种方法就失效了</p><h4 id="破坏占有并等待"><a href="#破坏占有并等待" class="headerlink" title="破坏占有并等待"></a>破坏占有并等待</h4><p>禁止已持有资源的进程再申请其他资源.</p><p>一种实现方式是在进程开始时申请好全部资源. 但是这是无法实现的 (如果能实现为什么不用银行家呢?) 此外一次性分配资源也是巨大的浪费.</p><p>另一种实现方式是在申请新资源的时候先释放本来占有的资源. 但是开销大也不佳.</p><h4 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h4><p>通过将资源(主要指硬件设备)虚拟化可以使其能够抢占. 但是并不是所有资源都能够虚拟化的. 而且消除了打印机的死锁也可能带来硬盘的死锁.</p><h4 id="破坏环路等待条件"><a href="#破坏环路等待条件" class="headerlink" title="破坏环路等待条件"></a>破坏环路等待条件</h4><p>一种实现方式是每次只允许占据一个资源, 但是这显然不能接受的.</p><p>另一种方式是对所有资源进行编号, 某进程每次请求的资源不能是比自己占有的资源序号低的资源. 这样资源分配图中肯定不会出现环 (而是一条链).这种方式也几乎不能找到一个令人满意的编号次序.</p><hr><h2 id="其他策略"><a href="#其他策略" class="headerlink" title="其他策略"></a>其他策略</h2><ul><li>Two-Phase Locking</li><li>Non-resource Deadlocks</li><li>Starvation</li><li>….</li></ul><hr><p><strong>操作系统系列</strong></p><ol><li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li><li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a> (本文)</li><li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li><li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章包括以下内容:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;资源与死锁&lt;/li&gt;
&lt;li&gt;处理死锁&lt;ol&gt;
&lt;li&gt;冷处理: 鸵鸟算法&lt;/li&gt;
&lt;li&gt;热处理: 死锁的检测与恢复&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;防范死锁&lt;ol&gt;
&lt;li&gt;避免死锁&lt;/li&gt;
&lt;li&gt;死锁预防&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;其他策略&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="专业课" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
